/**
 * Code Annotation System
 * 
 * This module manages traceability annotations in code comments and documentation.
 * It provides automatic annotation suggestion, validation, and synchronization
 * capabilities to maintain traceability links directly in source code.
 */

import { readFile, writeFile } from 'fs/promises';
import { extname, basename, dirname } from 'path';
import type {
  Artifact,
  TraceabilityLink,
  AnnotationPattern,
  LinkType,
  Location,
  TraceabilityConfig
} from './types.js';
import { TraceabilityGraphManager } from './graph.js';

/**
 * Annotation format for different programming languages
 */
export interface AnnotationFormat {
  /** Language identifier */
  language: string;
  /** Single line comment prefix */
  singleLineComment: string;
  /** Multi-line comment start */
  multiLineStart: string;
  /** Multi-line comment end */
  multiLineEnd: string;
  /** Documentation comment format (e.g., JSDoc, docstring) */
  docComment: {
    start: string;
    prefix: string;
    end: string;
  };
}

/**
 * Annotation content structure
 */
export interface Annotation {
  /** Annotation type */
  type: 'implements' | 'tests' | 'validates' | 'requires' | 'references';
  /** Target artifact ID */
  targetId: string;
  /** Optional description */
  description?: string;
  /** Confidence level (0-1) */
  confidence: number;
  /** Location in file */
  location: Location;
  /** Whether annotation is auto-generated */
  isAutoGenerated: boolean;
  /** Timestamp when annotation was created/updated */
  timestamp: Date;
}

/**
 * Annotation suggestion from analysis
 */
export interface AnnotationSuggestion {
  /** Suggested annotation */
  annotation: Annotation;
  /** Reason for suggestion */
  reason: string;
  /** Suggested location to insert annotation */
  insertLocation: Location;
  /** Code context where annotation would be added */
  context: string;
  /** Priority of the suggestion */
  priority: 'high' | 'medium' | 'low';
}

/**
 * Annotation validation result
 */
export interface AnnotationValidation {
  /** Whether annotation is valid */
  isValid: boolean;
  /** Validation errors */
  errors: string[];
  /** Validation warnings */
  warnings: string[];
  /** Whether target artifact exists */
  targetExists: boolean;
  /** Whether annotation format is correct */
  formatValid: boolean;
}

/**
 * Manages traceability annotations in source code
 */
export class CodeAnnotator {
  private graphManager: TraceabilityGraphManager;
  private config: TraceabilityConfig;
  private formats: Map<string, AnnotationFormat>;
  private patterns: Map<string, AnnotationPattern[]>;

  constructor(graphManager: TraceabilityGraphManager, config: TraceabilityConfig) {
    this.graphManager = graphManager;
    this.config = config;
    this.formats = new Map();
    this.patterns = new Map();

    this.initializeFormats();
    this.initializePatterns();
  }

  /**
   * Extracts existing annotations from a file
   */
  async extractAnnotations(filePath: string): Promise<Annotation[]> {
    try {
      const content = await readFile(filePath, 'utf-8');
      const extension = extname(filePath).toLowerCase();
      const patterns = this.patterns.get(extension) || [];
      const annotations: Annotation[] = [];

      for (const pattern of patterns) {
        const regex = typeof pattern.pattern === 'string' 
          ? new RegExp(pattern.pattern, 'gm') 
          : pattern.pattern;

        let match;
        while ((match = regex.exec(content)) !== null) {
          const annotation = this.parseAnnotationMatch(match, pattern, content, filePath);
          if (annotation) {
            annotations.push(annotation);
          }
        }
      }

      return annotations;
    } catch (error) {
      console.error(`Failed to extract annotations from ${filePath}:`, error);
      return [];
    }
  }

  /**
   * Suggests annotations based on code analysis
   */
  async suggestAnnotations(filePath: string, artifact: Artifact): Promise<AnnotationSuggestion[]> {
    const suggestions: AnnotationSuggestion[] = [];
    const content = await readFile(filePath, 'utf-8');
    const graph = this.graphManager.getGraph();

    // Suggest annotations based on naming conventions
    const namingBasedSuggestions = this.suggestFromNaming(artifact, content, graph);
    suggestions.push(...namingBasedSuggestions);

    // Suggest annotations based on imports/dependencies
    const dependencyBasedSuggestions = this.suggestFromDependencies(artifact, content, graph);
    suggestions.push(...dependencyBasedSuggestions);

    // Suggest annotations for test files
    if (this.isTestFile(filePath)) {
      const testBasedSuggestions = this.suggestForTestFile(artifact, content, graph);
      suggestions.push(...testBasedSuggestions);
    }

    // Suggest annotations based on existing graph relationships
    const graphBasedSuggestions = this.suggestFromGraph(artifact, content, graph);
    suggestions.push(...graphBasedSuggestions);

    return suggestions.sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
  }

  /**
   * Validates an annotation
   */
  async validateAnnotation(annotation: Annotation, filePath: string): Promise<AnnotationValidation> {
    const errors: string[] = [];
    const warnings: string[] = [];
    const graph = this.graphManager.getGraph();

    // Check if target artifact exists
    const targetExists = graph.artifacts.has(annotation.targetId);
    if (!targetExists) {
      errors.push(`Target artifact ${annotation.targetId} does not exist`);
    }

    // Check annotation format
    const extension = extname(filePath).toLowerCase();
    const format = this.formats.get(extension);
    const formatValid = format !== undefined;
    
    if (!formatValid) {
      warnings.push(`No annotation format defined for ${extension} files`);
    }

    // Check annotation type validity
    if (!this.isValidAnnotationType(annotation.type)) {
      errors.push(`Invalid annotation type: ${annotation.type}`);
    }

    // Check confidence level
    if (annotation.confidence < 0 || annotation.confidence > 1) {
      errors.push('Confidence must be between 0 and 1');
    }

    // Check for duplicate annotations
    const existingAnnotations = await this.extractAnnotations(filePath);
    const duplicates = existingAnnotations.filter(a => 
      a.targetId === annotation.targetId && 
      a.type === annotation.type &&
      Math.abs(a.location.startLine - annotation.location.startLine) < 3
    );

    if (duplicates.length > 0) {
      warnings.push('Similar annotation already exists nearby');
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      targetExists,
      formatValid
    };
  }

  /**
   * Adds an annotation to a file
   */
  async addAnnotation(
    filePath: string, 
    annotation: Annotation, 
    insertLocation?: Location
  ): Promise<void> {
    const content = await readFile(filePath, 'utf-8');
    const lines = content.split('\n');
    const extension = extname(filePath).toLowerCase();
    const format = this.formats.get(extension);

    if (!format) {
      throw new Error(`No annotation format available for ${extension} files`);
    }

    const location = insertLocation || this.findBestInsertionPoint(content, annotation);
    const annotationText = this.formatAnnotation(annotation, format);

    // Insert annotation at specified location
    lines.splice(location.startLine - 1, 0, annotationText);

    await writeFile(filePath, lines.join('\n'), 'utf-8');
  }

  /**
   * Updates an existing annotation
   */
  async updateAnnotation(
    filePath: string, 
    oldAnnotation: Annotation, 
    newAnnotation: Annotation
  ): Promise<void> {
    await this.removeAnnotation(filePath, oldAnnotation);
    await this.addAnnotation(filePath, newAnnotation, oldAnnotation.location);
  }

  /**
   * Removes an annotation from a file
   */
  async removeAnnotation(filePath: string, annotation: Annotation): Promise<void> {
    const content = await readFile(filePath, 'utf-8');
    const lines = content.split('\n');

    // Remove lines containing the annotation
    const startLine = annotation.location.startLine - 1;
    const endLine = annotation.location.endLine || startLine;
    const linesToRemove = endLine - startLine + 1;

    lines.splice(startLine, linesToRemove);

    await writeFile(filePath, lines.join('\n'), 'utf-8');
  }

  /**
   * Synchronizes annotations with graph links
   */
  async synchronizeAnnotations(filePath: string): Promise<{
    added: number;
    updated: number;
    removed: number;
  }> {
    const graph = this.graphManager.getGraph();
    const existingAnnotations = await this.extractAnnotations(filePath);
    const artifactsInFile = Array.from(graph.artifacts.values())
      .filter(a => a.filePath === filePath);

    let added = 0;
    let updated = 0;
    let removed = 0;

    // Find links that should have annotations but don't
    for (const artifact of artifactsInFile) {
      const outgoingLinks = graph.linksBySource.get(artifact.id) || new Set();
      
      for (const linkId of outgoingLinks) {
        const link = graph.links.get(linkId);
        if (!link || link.isAutomatic) continue;

        const hasAnnotation = existingAnnotations.some(a => 
          a.targetId === link.targetId && a.type === link.linkType
        );

        if (!hasAnnotation) {
          const annotation: Annotation = {
            type: link.linkType as any,
            targetId: link.targetId,
            description: link.context,
            confidence: link.strength,
            location: artifact.location,
            isAutoGenerated: true,
            timestamp: new Date()
          };

          try {
            await this.addAnnotation(filePath, annotation);
            added++;
          } catch (error) {
            console.error(`Failed to add annotation: ${error}`);
          }
        }
      }
    }

    // Remove annotations for non-existent links
    for (const annotation of existingAnnotations) {
      if (annotation.isAutoGenerated) {
        const linkExists = Array.from(graph.links.values()).some(link =>
          link.targetId === annotation.targetId && 
          link.linkType === annotation.type &&
          artifactsInFile.some(a => link.sourceId === a.id)
        );

        if (!linkExists) {
          try {
            await this.removeAnnotation(filePath, annotation);
            removed++;
          } catch (error) {
            console.error(`Failed to remove annotation: ${error}`);
          }
        }
      }
    }

    return { added, updated, removed };
  }

  /**
   * Gets annotation statistics for a file or project
   */
  async getAnnotationStatistics(filePaths?: string[]): Promise<{
    totalAnnotations: number;
    annotationsByType: Record<string, number>;
    autoGenerated: number;
    manual: number;
    averageConfidence: number;
    mostRecentUpdate: Date | null;
  }> {
    const pathsToAnalyze = filePaths || this.getAllSourceFiles();
    let totalAnnotations = 0;
    const annotationsByType: Record<string, number> = {};
    let autoGenerated = 0;
    let manual = 0;
    const confidences: number[] = [];
    let mostRecentUpdate: Date | null = null;

    for (const filePath of pathsToAnalyze) {
      try {
        const annotations = await this.extractAnnotations(filePath);
        
        for (const annotation of annotations) {
          totalAnnotations++;
          
          annotationsByType[annotation.type] = 
            (annotationsByType[annotation.type] || 0) + 1;
          
          if (annotation.isAutoGenerated) {
            autoGenerated++;
          } else {
            manual++;
          }
          
          confidences.push(annotation.confidence);
          
          if (!mostRecentUpdate || annotation.timestamp > mostRecentUpdate) {
            mostRecentUpdate = annotation.timestamp;
          }
        }
      } catch (error) {
        console.error(`Failed to analyze ${filePath}: ${error}`);
      }
    }

    const averageConfidence = confidences.length > 0 
      ? confidences.reduce((sum, conf) => sum + conf, 0) / confidences.length
      : 0;

    return {
      totalAnnotations,
      annotationsByType,
      autoGenerated,
      manual,
      averageConfidence,
      mostRecentUpdate
    };
  }

  // Private helper methods

  private initializeFormats(): void {
    // TypeScript/JavaScript format
    this.formats.set('.ts', {
      language: 'typescript',
      singleLineComment: '//',
      multiLineStart: '/*',
      multiLineEnd: '*/',
      docComment: {
        start: '/**',
        prefix: ' * ',
        end: ' */'
      }
    });

    this.formats.set('.tsx', this.formats.get('.ts')!);
    this.formats.set('.js', this.formats.get('.ts')!);
    this.formats.set('.jsx', this.formats.get('.ts')!);

    // Python format
    this.formats.set('.py', {
      language: 'python',
      singleLineComment: '#',
      multiLineStart: '"""',
      multiLineEnd: '"""',
      docComment: {
        start: '"""',
        prefix: '',
        end: '"""'
      }
    });

    // CUE format
    this.formats.set('.cue', {
      language: 'cue',
      singleLineComment: '//',
      multiLineStart: '/*',
      multiLineEnd: '*/',
      docComment: {
        start: '/*',
        prefix: ' * ',
        end: ' */'
      }
    });

    // Markdown format (for comments in code blocks)
    this.formats.set('.md', {
      language: 'markdown',
      singleLineComment: '<!-- ',
      multiLineStart: '<!--',
      multiLineEnd: '-->',
      docComment: {
        start: '<!--',
        prefix: '',
        end: '-->'
      }
    });
  }

  private initializePatterns(): void {
    // TypeScript/JavaScript patterns
    const tsPatterns: AnnotationPattern[] = [
      {
        id: 'jsdoc_annotation',
        language: 'typescript',
        pattern: /\/\*\*[^*]*\*+(?:[^/*][^*]*\*+)*\/\s*@(implements|tests|validates|requires|references)\s+([^\s\n]+)(?:\s+(.+?))?$/gm,
        captureGroups: { type: 1, targetId: 2, description: 3 },
        defaultLinkType: 'implements'
      },
      {
        id: 'single_line_annotation',
        language: 'typescript',
        pattern: /\/\/\s*@(implements|tests|validates|requires|references)\s+([^\s\n]+)(?:\s+(.+?))?$/gm,
        captureGroups: { type: 1, targetId: 2, description: 3 },
        defaultLinkType: 'implements'
      }
    ];

    this.patterns.set('.ts', tsPatterns);
    this.patterns.set('.tsx', tsPatterns);
    this.patterns.set('.js', tsPatterns);
    this.patterns.set('.jsx', tsPatterns);

    // Python patterns
    const pyPatterns: AnnotationPattern[] = [
      {
        id: 'docstring_annotation',
        language: 'python',
        pattern: /"""[^"]*@(implements|tests|validates|requires|references)\s+([^\s\n]+)(?:\s+(.+?))?[^"]*"""/gm,
        captureGroups: { type: 1, targetId: 2, description: 3 },
        defaultLinkType: 'implements'
      },
      {
        id: 'hash_annotation',
        language: 'python',
        pattern: /#\s*@(implements|tests|validates|requires|references)\s+([^\s\n]+)(?:\s+(.+?))?$/gm,
        captureGroups: { type: 1, targetId: 2, description: 3 },
        defaultLinkType: 'implements'
      }
    ];

    this.patterns.set('.py', pyPatterns);

    // CUE patterns
    const cuePatterns: AnnotationPattern[] = [
      {
        id: 'cue_annotation',
        language: 'cue',
        pattern: /\/\/\s*@(implements|tests|validates|requires|references)\s+([^\s\n]+)(?:\s+(.+?))?$/gm,
        captureGroups: { type: 1, targetId: 2, description: 3 },
        defaultLinkType: 'implements'
      }
    ];

    this.patterns.set('.cue', cuePatterns);
  }

  private parseAnnotationMatch(
    match: RegExpMatchArray,
    pattern: AnnotationPattern,
    content: string,
    filePath: string
  ): Annotation | null {
    try {
      const typeGroup = pattern.captureGroups.type;
      const targetIdGroup = pattern.captureGroups.targetId;
      const descriptionGroup = pattern.captureGroups.description;

      const type = match[typeGroup] as any;
      const targetId = match[targetIdGroup];
      const description = descriptionGroup ? match[descriptionGroup] : undefined;

      if (!type || !targetId) {
        return null;
      }

      const startLine = this.getLineNumber(content, match.index || 0);
      
      return {
        type,
        targetId,
        description,
        confidence: 0.9, // High confidence for manual annotations
        location: { startLine, endLine: startLine },
        isAutoGenerated: false,
        timestamp: new Date()
      };
    } catch (error) {
      console.error(`Failed to parse annotation match: ${error}`);
      return null;
    }
  }

  private suggestFromNaming(
    artifact: Artifact,
    content: string,
    graph: TraceabilityGraph
  ): AnnotationSuggestion[] {
    const suggestions: AnnotationSuggestion[] = [];

    // Suggest based on artifact names mentioned in code
    for (const [, otherArtifact] of graph.artifacts) {
      if (otherArtifact.id === artifact.id) continue;

      const namePattern = new RegExp(`\\b${this.escapeRegExp(otherArtifact.name)}\\b`, 'i');
      if (namePattern.test(content)) {
        const suggestion: AnnotationSuggestion = {
          annotation: {
            type: this.suggestLinkType(artifact.type, otherArtifact.type),
            targetId: otherArtifact.id,
            description: `References ${otherArtifact.name}`,
            confidence: 0.6,
            location: artifact.location,
            isAutoGenerated: true,
            timestamp: new Date()
          },
          reason: `Artifact name "${otherArtifact.name}" mentioned in code`,
          insertLocation: this.findBestInsertionPoint(content, {} as Annotation),
          context: this.extractContextAroundArtifact(content, artifact),
          priority: 'medium'
        };

        suggestions.push(suggestion);
      }
    }

    return suggestions;
  }

  private suggestFromDependencies(
    artifact: Artifact,
    content: string,
    graph: TraceabilityGraph
  ): AnnotationSuggestion[] {
    const suggestions: AnnotationSuggestion[] = [];

    // Extract import statements or similar dependencies
    const importPatterns = [
      /import\s+.*from\s+['"]([^'"]+)['"]/g,
      /require\s*\(\s*['"]([^'"]+)['"]\s*\)/g,
      /#include\s+[<"]([^>"]+)[>"]/g
    ];

    for (const pattern of importPatterns) {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        const dependency = match[1];
        
        // Find artifacts in the same project that might match this dependency
        for (const [, otherArtifact] of graph.artifacts) {
          if (otherArtifact.filePath.includes(dependency) || 
              otherArtifact.name.toLowerCase().includes(dependency.toLowerCase())) {
            
            suggestions.push({
              annotation: {
                type: 'references',
                targetId: otherArtifact.id,
                description: `Depends on ${otherArtifact.name}`,
                confidence: 0.7,
                location: artifact.location,
                isAutoGenerated: true,
                timestamp: new Date()
              },
              reason: `Imports/requires ${dependency}`,
              insertLocation: this.findBestInsertionPoint(content, {} as Annotation),
              context: match[0],
              priority: 'medium'
            });
          }
        }
      }
    }

    return suggestions;
  }

  private suggestForTestFile(
    artifact: Artifact,
    content: string,
    graph: TraceabilityGraph
  ): AnnotationSuggestion[] {
    const suggestions: AnnotationSuggestion[] = [];

    // Look for describe/test blocks and suggest linking to tested code
    const testPatterns = [
      /describe\s*\(\s*['"`]([^'"`]+)['"`]/g,
      /test\s*\(\s*['"`]([^'"`]+)['"`]/g,
      /it\s*\(\s*['"`]([^'"`]+)['"`]/g
    ];

    for (const pattern of testPatterns) {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        const testName = match[1];
        
        // Find code artifacts that might be tested by this test
        for (const [, codeArtifact] of graph.artifacts) {
          if (codeArtifact.type === 'code' && 
              (testName.toLowerCase().includes(codeArtifact.name.toLowerCase()) ||
               codeArtifact.name.toLowerCase().includes(testName.toLowerCase()))) {
            
            suggestions.push({
              annotation: {
                type: 'tests',
                targetId: codeArtifact.id,
                description: `Tests ${codeArtifact.name}`,
                confidence: 0.8,
                location: {
                  startLine: this.getLineNumber(content, match.index || 0),
                  endLine: this.getLineNumber(content, match.index || 0)
                },
                isAutoGenerated: true,
                timestamp: new Date()
              },
              reason: `Test name suggests it tests ${codeArtifact.name}`,
              insertLocation: {
                startLine: this.getLineNumber(content, match.index || 0) - 1,
                endLine: this.getLineNumber(content, match.index || 0) - 1
              },
              context: match[0],
              priority: 'high'
            });
          }
        }
      }
    }

    return suggestions;
  }

  private suggestFromGraph(
    artifact: Artifact,
    content: string,
    graph: TraceabilityGraph
  ): AnnotationSuggestion[] {
    const suggestions: AnnotationSuggestion[] = [];

    // Suggest annotations for existing graph relationships that lack annotations
    const outgoingLinks = graph.linksBySource.get(artifact.id) || new Set();
    
    for (const linkId of outgoingLinks) {
      const link = graph.links.get(linkId);
      if (!link || link.isAutomatic) continue;

      const target = graph.artifacts.get(link.targetId);
      if (!target) continue;

      suggestions.push({
        annotation: {
          type: link.linkType as any,
          targetId: link.targetId,
          description: link.context,
          confidence: link.strength,
          location: artifact.location,
          isAutoGenerated: true,
          timestamp: new Date()
        },
        reason: 'Existing graph relationship without annotation',
        insertLocation: this.findBestInsertionPoint(content, {} as Annotation),
        context: this.extractContextAroundArtifact(content, artifact),
        priority: 'high'
      });
    }

    return suggestions;
  }

  private suggestLinkType(sourceType: string, targetType: string): any {
    if (sourceType === 'test' && targetType === 'code') return 'tests';
    if (sourceType === 'code' && targetType === 'requirement') return 'implements';
    if (sourceType === 'scenario' && targetType === 'requirement') return 'validates';
    return 'references';
  }

  private isTestFile(filePath: string): boolean {
    const fileName = basename(filePath);
    return /\.(test|spec)\.(ts|tsx|js|jsx|py)$/.test(fileName) ||
           fileName.includes('test') || 
           fileName.includes('spec');
  }

  private isValidAnnotationType(type: string): boolean {
    return ['implements', 'tests', 'validates', 'requires', 'references'].includes(type);
  }

  private findBestInsertionPoint(content: string, annotation: Annotation): Location {
    const lines = content.split('\n');
    
    // For now, insert at the beginning of the file or before the first non-comment line
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line && !line.startsWith('//') && !line.startsWith('/*') && !line.startsWith('#')) {
        return { startLine: Math.max(1, i), endLine: Math.max(1, i) };
      }
    }
    
    return { startLine: 1, endLine: 1 };
  }

  private formatAnnotation(annotation: Annotation, format: AnnotationFormat): string {
    const description = annotation.description ? ` ${annotation.description}` : '';
    return `${format.singleLineComment} @${annotation.type} ${annotation.targetId}${description}`;
  }

  private extractContextAroundArtifact(content: string, artifact: Artifact): string {
    const lines = content.split('\n');
    const startLine = Math.max(0, artifact.location.startLine - 3);
    const endLine = Math.min(lines.length, artifact.location.endLine + 3);
    
    return lines.slice(startLine, endLine).join('\n');
  }

  private getLineNumber(content: string, index: number): number {
    return content.substring(0, index).split('\n').length;
  }

  private escapeRegExp(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  private getAllSourceFiles(): string[] {
    // This would typically be implemented to return all source files in the project
    // For now, return an empty array as a placeholder
    return [];
  }
}