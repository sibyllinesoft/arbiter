#!/bin/bash
# Arbiter Pre-Commit Hook - Rails & Guarantees Enforcement
# Automatically verifies stamps and prevents direct CUE edits

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
ARBITER_CLI="${ARBITER_CLI:-arbiter}"
ARBITER_API_URL="${ARBITER_API_URL:-http://localhost:4001}"

echo -e "${BLUE}üîç Verifying Arbiter stamps...${NC}"

# Function to check if arbiter CLI is available
check_arbiter_available() {
    if ! command -v "$ARBITER_CLI" &> /dev/null; then
        echo -e "${RED}‚ùå Arbiter CLI not found at: $ARBITER_CLI${NC}"
        echo -e "${YELLOW}Install Arbiter CLI or set ARBITER_CLI environment variable${NC}"
        return 1
    fi
    
    # Check if API server is reachable
    if ! curl -s --max-time 2 "$ARBITER_API_URL/health" > /dev/null 2>&1; then
        echo -e "${YELLOW}‚ö†Ô∏è Arbiter API server unreachable at: $ARBITER_API_URL${NC}"
        echo -e "${YELLOW}Starting in offline mode - basic checks only${NC}"
        return 2
    fi
    
    return 0
}

# Function to check for direct CUE edits without stamps
check_direct_cue_edits() {
    local has_violations=false
    
    # Get all staged CUE files
    mapfile -t cue_files < <(git diff --cached --name-only | grep '\.cue$' || true)
    
    if [[ ${#cue_files[@]} -eq 0 ]]; then
        return 0
    fi
    
    echo -e "${BLUE}üìã Checking ${#cue_files[@]} CUE file(s) for proper stamping...${NC}"
    
    for file in "${cue_files[@]}"; do
        if [[ ! -f "$file" ]]; then
            continue  # File was deleted
        fi
        
        # Check if file contains Arbiter stamps
        if ! grep -q "// ARBITER:BEGIN" "$file" 2>/dev/null; then
            echo -e "${RED}‚ùå Direct CUE edit detected: $file${NC}"
            echo -e "${RED}   All CUE modifications must be stamped with valid tickets${NC}"
            echo -e "${YELLOW}   Use: arbiter ticket --scope <plan-hash>${NC}"
            echo -e "${YELLOW}   Then: use proper mutation endpoints${NC}"
            has_violations=true
        else
            # Verify stamp format
            if ! grep -E "// ARBITER:BEGIN [a-zA-Z0-9]{8} stamp=[A-Za-z0-9+/=]+$" "$file" > /dev/null; then
                echo -e "${RED}‚ùå Invalid stamp format in: $file${NC}"
                echo -e "${YELLOW}   Stamps must follow format: // ARBITER:BEGIN <id> stamp=<base64>${NC}"
                has_violations=true
            else
                echo -e "${GREEN}‚úÖ Valid stamp found in: $file${NC}"
            fi
        fi
    done
    
    if $has_violations; then
        return 1
    fi
    
    return 0
}

# Function to verify stamps with API server
verify_stamps_with_api() {
    local has_failures=false
    
    # Get all files with stamps
    mapfile -t stamped_files < <(git diff --cached --name-only | xargs grep -l "// ARBITER:BEGIN" 2>/dev/null || true)
    
    if [[ ${#stamped_files[@]} -eq 0 ]]; then
        return 0
    fi
    
    echo -e "${BLUE}üîê Verifying ${#stamped_files[@]} stamp(s) with API server...${NC}"
    
    for file in "${stamped_files[@]}"; do
        # Extract stamp information
        local stamp_line
        stamp_line=$(grep "// ARBITER:BEGIN" "$file" | head -1)
        
        if [[ $stamp_line =~ //\ ARBITER:BEGIN\ ([a-zA-Z0-9]{8})\ stamp=([A-Za-z0-9+/=]+) ]]; then
            local stamp_id="${BASH_REMATCH[1]}"
            local stamp_value="${BASH_REMATCH[2]}"
            
            # Get current repo SHA
            local repo_sha
            repo_sha=$(git rev-parse HEAD)
            
            # For this demo, we'll use a mock plan hash
            # In real implementation, this would be extracted from the file or context
            local plan_hash="abcd1234567890abcd1234567890abcd1234567890abcd1234567890abcd1234"
            
            # Mock ticket ID - would be extracted from git trailer or stamp metadata
            local ticket_id="tkn_mock1234567890"
            
            # Verify stamp via API (mock implementation)
            echo -e "${YELLOW}üîç Verifying stamp $stamp_id in $file...${NC}"
            
            # In real implementation, this would make actual API call:
            # if ! "$ARBITER_CLI" verify --stamp "$stamp_value" --repo-sha "$repo_sha" --plan-hash "$plan_hash" --ticket-id "$ticket_id"; then
            #     echo -e "${RED}‚ùå Stamp verification failed for: $file${NC}"
            #     has_failures=true
            # else
            #     echo -e "${GREEN}‚úÖ Stamp verified for: $file${NC}"
            # fi
            
            # Mock verification - always pass for now
            echo -e "${GREEN}‚úÖ Stamp verified for: $file${NC}"
        else
            echo -e "${RED}‚ùå Cannot parse stamp in: $file${NC}"
            has_failures=true
        fi
    done
    
    if $has_failures; then
        return 1
    fi
    
    return 0
}

# Function to check commit trailer requirement
check_commit_trailer() {
    local commit_msg_file=".git/COMMIT_EDITMSG"
    
    if [[ ! -f "$commit_msg_file" ]]; then
        return 0  # No commit message yet
    fi
    
    # Check if commit message has Arbiter-Ticket trailer
    if grep -q "^Arbiter-Ticket: tkn_[a-zA-Z0-9]{16}$" "$commit_msg_file"; then
        local ticket_id
        ticket_id=$(grep "^Arbiter-Ticket:" "$commit_msg_file" | cut -d' ' -f2)
        echo -e "${GREEN}‚úÖ Valid Arbiter-Ticket trailer found: $ticket_id${NC}"
        return 0
    else
        # Check if there are any CUE changes that require a trailer
        if git diff --cached --name-only | grep -q '\.cue$'; then
            echo -e "${RED}‚ùå Missing required Arbiter-Ticket trailer in commit message${NC}"
            echo -e "${YELLOW}   Add: Arbiter-Ticket: <your-ticket-id>${NC}"
            echo -e "${YELLOW}   Format: Arbiter-Ticket: tkn_xxxxxxxxxxxxxxxx${NC}"
            return 1
        fi
    fi
    
    return 0
}

# Function to run additional validation
run_additional_validation() {
    echo -e "${BLUE}üß™ Running additional validations...${NC}"
    
    # Check for common anti-patterns
    local has_issues=false
    
    # Check for hardcoded secrets (basic check)
    if git diff --cached | grep -iE "(password|secret|key|token)\s*[:=]\s*['\"][^'\"]*['\"]" > /dev/null; then
        echo -e "${YELLOW}‚ö†Ô∏è Potential hardcoded secrets detected${NC}"
        echo -e "${YELLOW}   Review staged changes for sensitive data${NC}"
    fi
    
    # Check for TODO/FIXME comments in production files
    if git diff --cached | grep -E "(TODO|FIXME|HACK)" > /dev/null; then
        echo -e "${YELLOW}‚ö†Ô∏è TODO/FIXME comments found in staged changes${NC}"
        echo -e "${YELLOW}   Consider resolving before committing${NC}"
    fi
    
    # Validate CUE syntax on staged files
    mapfile -t cue_files < <(git diff --cached --name-only | grep '\.cue$' || true)
    
    for file in "${cue_files[@]}"; do
        if [[ -f "$file" ]]; then
            if ! cue vet "$file" 2>/dev/null; then
                echo -e "${RED}‚ùå CUE syntax error in: $file${NC}"
                has_issues=true
            fi
        fi
    done
    
    if $has_issues; then
        return 1
    fi
    
    return 0
}

# Main execution
main() {
    local exit_code=0
    
    # Check if this is a merge commit (skip hook for merges)
    if [[ -f .git/MERGE_HEAD ]]; then
        echo -e "${YELLOW}üîÑ Merge commit detected - skipping Arbiter verification${NC}"
        exit 0
    fi
    
    # Check arbiter availability
    local arbiter_status=0
    check_arbiter_available || arbiter_status=$?
    
    # Always run direct edit checks (offline mode)
    if ! check_direct_cue_edits; then
        exit_code=1
    fi
    
    # Check commit trailer requirement
    if ! check_commit_trailer; then
        exit_code=1
    fi
    
    # Run additional validations
    if ! run_additional_validation; then
        exit_code=1
    fi
    
    # Only run API verification if server is available
    if [[ $arbiter_status -eq 0 ]]; then
        if ! verify_stamps_with_api; then
            exit_code=1
        fi
    fi
    
    if [[ $exit_code -eq 0 ]]; then
        echo -e "${GREEN}‚úÖ All Arbiter verifications passed${NC}"
        echo -e "${GREEN}üöÄ Commit approved - Rails & Guarantees maintained${NC}"
    else
        echo -e "${RED}‚ùå Arbiter verification failed${NC}"
        echo -e "${RED}üí• Commit blocked - Rails & Guarantees violated${NC}"
        echo ""
        echo -e "${YELLOW}Fix the issues above and try again${NC}"
        echo -e "${YELLOW}For help: arbiter --help${NC}"
    fi
    
    exit $exit_code
}

# Execute main function
main "$@"