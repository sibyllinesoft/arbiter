# Template Development Guide

This guide covers how to create, customize, and maintain templates for Arbiter's code generation system.

## Table of Contents

- [Template System Overview](#template-system-overview)
- [Creating Custom Templates](#creating-custom-templates)
- [Template Syntax and Variables](#template-syntax-and-variables)
- [Template Organization](#template-organization)
- [Context Data Reference](#context-data-reference)
- [Template Inheritance](#template-inheritance)
- [Testing Templates](#testing-templates)
- [Best Practices](#best-practices)

## Template System Overview

Arbiter's template system is designed to transform CUE specifications into production-ready code across multiple languages and frameworks. The system supports:

- **Multiple Template Engines** - Handlebars, Liquid, and custom engines
- **Override Hierarchies** - Custom templates override defaults
- **Rich Context Data** - Comprehensive data from CUE specifications
- **Template Inheritance** - Shared partials and layouts
- **Dynamic Resolution** - Runtime template selection

The “engine” abstraction is simply a command invocation. When Arbiter needs to render a template it serializes the context to JSON and pipes it into the engine command you registered. The command can be anything you want—`bunx handlebars`, `python render.py`, `cookiecutter`, or a compiled binary. Whatever the command writes to stdout becomes the generated artifact, so you can bring virtually any templating technology without writing TypeScript.

Built-in helpers (like the cookiecutter integrations used by some stock templates) consume the same interface internally. They call the underlying library directly for speed, but they still accept the `{command, args, context}` shape that external engines see. That means the alias you register for a first-party template is structurally identical to the alias you would register for your own engine.

Example `.arbiter/templates.json` entry that shells out to a local script:

```json
{
  "engines": {
    "my-templates": {
      "command": "python",
      "defaultArgs": ["templates/render.py"],
      "timeout": 120000
    }
  },
  "aliases": {
    "orders-fastapi": {
      "engine": "my-templates",
      "source": "./templates/orders"
    }
  }
}
```

Every call to `orders-fastapi` now receives the Arbiter context on stdin, and your script can emit any content it likes.

### Template Architecture

```
Template Resolution Flow:

CUE Spec → Context Extraction → Template Selection → Template Processing → Generated Code
    ↓              ↓                    ↓                    ↓               ↓
Assembly.cue   Variables &         Override Dir      Handlebars/Liquid   Source Files
               Metadata           → Default Dir       Processing         → Config Files
                                                                        → Documentation
```

## Creating Custom Templates

### Directory Structure

Create a template directory structure that mirrors your target project layout:

```
templates/
├── typescript/                 # Language-specific templates
│   ├── service/               # Service generation templates
│   │   ├── main.ts.hbs       # Main service file
│   │   ├── routes/           # Route templates
│   │   │   └── {{routeName}}.ts.hbs
│   │   ├── models/           # Model templates
│   │   │   └── {{modelName}}.ts.hbs
│   │   └── tests/            # Test templates
│   │       └── {{serviceName}}.spec.ts.hbs
│   ├── component/            # Component templates
│   │   ├── {{componentName}}.tsx.hbs
│   │   ├── {{componentName}}.module.css.hbs
│   │   └── {{componentName}}.stories.tsx.hbs
│   ├── common/               # Shared templates
│   │   ├── package.json.hbs
│   │   ├── tsconfig.json.hbs
│   │   └── README.md.hbs
│   └── partials/             # Reusable template fragments
│       ├── import-statements.hbs
│       ├── type-definitions.hbs
│       └── error-handling.hbs
├── python/                   # Python templates
│   ├── service/
│   │   ├── main.py.hbs
│   │   ├── routers/
│   │   └── models/
│   └── common/
└── docker/                   # Docker templates
    ├── Dockerfile.hbs
    └── compose.yml.hbs
```

### Template File Naming

Template files use the following naming conventions:

- **Static Names**: `main.ts.hbs` → generates `main.ts`
- **Dynamic Names**: `{{serviceName}}.ts.hbs` → generates `user-service.ts`
- **Nested Variables**: `{{service.name}}-{{service.version}}.ts.hbs`

### Basic Template Creation

#### 1. Create a Service Template

```handlebars
{{!-- templates/typescript/service/main.ts.hbs --}}
/**
 * {{ serviceName }} Service
 * {{ description }}
 * 
 * Generated by Arbiter on {{ generatedAt }}
 */

import express from 'express';
{{#if database}}
import { {{ database.driver }} } from '{{ database.package }}';
{{/if}}
{{#if auth}}
import { authenticate } from './middleware/auth';
{{/if}}

const app = express();
const PORT = process.env.PORT || {{ port }};

{{#if middleware}}
// Middleware
{{#each middleware}}
app.use({{ this }});
{{/each}}
{{/if}}

{{#if database}}
// Database connection
const db = new {{ database.driver }}({
  {{#each database.config}}
  {{ @key }}: {{ this }},
  {{/each}}
});
{{/if}}

{{#each endpoints}}
// {{ this.method }} {{ this.path }} - {{ this.description }}
app.{{ this.method }}('{{ this.path }}', 
  {{#if ../auth}}authenticate, {{/if}}
  async (req, res) => {
    try {
      {{#if this.validation}}
      // Validate request
      {{>validation-middleware this.validation}}
      {{/if}}
      
      {{#if this.database}}
      // Database operation
      {{>database-operation this.database}}
      {{/if}}
      
      res.status({{ this.successStatus | default 200 }}).json({
        {{#each this.responseFields}}
        {{ @key }}: {{ this }},
        {{/each}}
      });
    } catch (error) {
      {{>error-handler error}}
    }
  }
);
{{/each}}

app.listen(PORT, () => {
  console.log(`{{ serviceName }} listening on port ${PORT}`);
});

export default app;
```

#### 2. Create a Component Template

```handlebars
{{!-- templates/typescript/component/{{componentName}}.tsx.hbs --}}
import React{{#if hooks}}, { {{#each hooks}}{{ this }}{{#unless @last}}, {{/unless}}{{/each}} }{{/if}} from 'react';
{{#if styling}}
import styles from './{{ componentName }}.module.css';
{{/if}}
{{#if testId}}
import { testIds } from '../test-utils';
{{/if}}

{{#if props}}
interface {{ componentName }}Props {
{{#each props}}
  {{ this.name }}{{#unless this.required}}?{{/unless}}: {{ this.type }};
{{/each}}
}
{{/if}}

/**
 * {{ componentName }} Component
 * {{ description }}
 */
export const {{ componentName }}: React.FC<{{#if props}}{{ componentName }}Props{{/if}}> = ({{#if props}}{
{{#each props}}
  {{ this.name }}{{#if this.default}} = {{ this.default }}{{/if}},
{{/each}}
}{{/if}}) => {
{{#each hooks}}
  {{#if this.useState}}
  const [{{ this.state.name }}, set{{ this.state.name | capitalize }}] = useState{{#if this.state.type}}<{{ this.state.type }}>{{/if}}({{ this.state.initial }});
  {{/if}}
  {{#if this.useEffect}}
  useEffect(() => {
    {{ this.effect.code }}
  }, [{{ this.effect.dependencies }}]);
  {{/if}}
{{/each}}

{{#if handlers}}
{{#each handlers}}
  const {{ this.name }} = {{#if this.async}}async {{/if}}({{ this.parameters }}) => {
    {{ this.implementation }}
  };
{{/each}}
{{/if}}

  return (
    <div 
      {{#if styling}}className={styles.{{ componentName | lowercase }}}{{/if}}
      {{#if testId}}data-testid={testIds.{{ componentName | lowercase }}}{{/if}}
    >
      {{#if children}}
      {children}
      {{else}}
      <h1>{{ title | default componentName }}</h1>
      {{#each elements}}
      <{{ this.tag }}{{#if this.props}} {{#each this.props}}{{ @key }}="{{ this }}"{{/each}}{{/if}}>
        {{ this.content }}
      </{{ this.tag }}>
      {{/each}}
      {{/if}}
    </div>
  );
};

export default {{ componentName }};
```

## Template Syntax and Variables

### Variable Interpolation

Arbiter templates support two types of variable interpolation:

#### Simple Variables
```handlebars
{{ serviceName }}        <!-- Outputs: user-service -->
{{ port }}              <!-- Outputs: 3000 -->
{{ description }}       <!-- Outputs: User management service -->
```

#### Complex Variables (Object Serialization)
```handlebars
{{{ databaseConfig }}}  <!-- Outputs formatted JSON -->
{{{ environmentVars }}} <!-- Outputs structured object -->
```

### Conditionals

```handlebars
{{#if authentication}}
import { authenticate } from './auth';
{{/if}}

{{#unless testing}}
app.listen(PORT);
{{/unless}}

{{#if database}}
// Database configuration
{{else}}
// No database configuration required
{{/if}}
```

### Loops and Iteration

```handlebars
{{#each endpoints}}
// Route: {{ this.method }} {{ this.path }}
app.{{ this.method }}('{{ this.path }}', (req, res) => {
  {{#each this.middleware}}
  {{ this }}(req, res);
  {{/each}}
});
{{/each}}
```

### Built-in Helpers

#### String Manipulation
```handlebars
{{ serviceName | uppercase }}     <!-- USER-SERVICE -->
{{ serviceName | lowercase }}     <!-- user-service -->
{{ serviceName | capitalize }}    <!-- User-service -->
{{ serviceName | camelCase }}     <!-- userService -->
{{ serviceName | pascalCase }}    <!-- UserService -->
{{ serviceName | kebabCase }}     <!-- user-service -->
{{ serviceName | snakeCase }}     <!-- user_service -->
```

#### Default Values
```handlebars
{{ port | default 3000 }}
{{ description | default "No description provided" }}
```

#### Type Checks
```handlebars
{{#isString variable}}
String value: {{ variable }}
{{/isString}}

{{#isArray endpoints}}
Found {{ endpoints.length }} endpoints
{{/isArray}}
```

## Template Organization

### Partials System

Create reusable template fragments as partials:

#### Error Handler Partial
```handlebars
{{!-- templates/typescript/partials/error-handler.hbs --}}
console.error('Error in {{ @root.serviceName }}:', error);
res.status({{ statusCode | default 500 }}).json({
  error: {
    message: error.message,
    code: '{{ errorCode | default "INTERNAL_ERROR" }}',
    timestamp: new Date().toISOString()
    {{#if @root.development}}
    ,stack: error.stack
    {{/if}}
  }
});
```

#### Database Operation Partial
```handlebars
{{!-- templates/typescript/partials/database-operation.hbs --}}
{{#if operation.type === "create"}}
const result = await db.{{ entity.name }}.create({
  {{#each operation.fields}}
  {{ @key }}: req.body.{{ this }},
  {{/each}}
});
{{else if operation.type === "read"}}
const result = await db.{{ entity.name }}.findMany({
  {{#if operation.where}}
  where: {
    {{#each operation.where}}
    {{ @key }}: {{ this }},
    {{/each}}
  },
  {{/if}}
  {{#if operation.include}}
  include: {
    {{#each operation.include}}
    {{ this }}: true,
    {{/each}}
  },
  {{/if}}
});
{{/if}}
```

### Using Partials

```handlebars
{{!-- Include a partial --}}
{{>error-handler statusCode=400 errorCode="VALIDATION_ERROR"}}

{{!-- Include with context --}}
{{#each operations}}
{{>database-operation operation=this entity=../entity}}
{{/each}}

{{!-- Include with inline context --}}
{{>validation-middleware validation=(object required=true schema="user")}}
```

### Template Layouts

Create base layouts for consistent structure:

```handlebars
{{!-- templates/typescript/layouts/service-layout.hbs --}}
/**
 * {{ serviceName }}
 * {{ description }}
 * 
 * Generated by Arbiter
 */

{{>file-header}}

{{>imports}}

{{>configuration}}

{{{body}}}

{{>exports}}
```

Use layouts in templates:
```handlebars
{{!-- Extend layout --}}
{{#extend "service-layout"}}

{{#content "imports"}}
import express from 'express';
import cors from 'cors';
{{/content}}

{{#content "configuration"}}
const app = express();
app.use(cors());
{{/content}}

{{#content "body"}}
// Main service logic here
{{/content}}

{{/extend}}
```

## Context Data Reference

Templates receive rich context data extracted from CUE specifications:

### Core Context Structure

```typescript
interface GenerationContext {
  // Project metadata
  projectName: string;           // "my-awesome-app"
  description?: string;          // "Full-stack web application"
  version?: string;              // "1.0.0"
  
  // Service information (for service templates)
  serviceName?: string;          // "user-service"
  serviceType?: string;          // "api", "worker", "frontend"
  language?: string;             // "typescript", "python", "rust"
  
  // Infrastructure
  ports?: number[];              // [3000, 3001]
  environment?: Record<string, string>;
  
  // Database configuration
  database?: {
    type: string;                // "postgres", "mysql", "mongodb"
    name: string;                // "app_db"
    host?: string;               // "localhost"
    port?: number;               // 5432
    config?: Record<string, any>;
  };
  
  // API endpoints
  endpoints?: EndpointContext[];
  
  // Authentication
  auth?: {
    type: string;                // "oauth2", "jwt", "session"
    provider?: string;           // "auth0", "firebase"
    config?: Record<string, any>;
  };
  
  // Testing configuration
  testing?: {
    framework: string;           // "vitest", "jest", "pytest"
    coverage: boolean;
    types: string[];             // ["unit", "integration", "e2e"]
  };
  
  // Build metadata
  generatedAt: string;           // ISO timestamp
  generator: {
    name: string;                // "arbiter"
    version: string;             // "1.0.0"
  };
}
```

### Endpoint Context

```typescript
interface EndpointContext {
  method: string;                // "GET", "POST", "PUT", "DELETE"
  path: string;                  // "/api/users"
  description?: string;          // "Get all users"
  
  // Request handling
  parameters?: Parameter[];      // Path and query parameters
  requestBody?: {
    type: string;                // "json", "form", "multipart"
    schema?: any;                // Request body schema
    required: boolean;
  };
  
  // Response handling
  responses: Response[];         // Possible responses
  successStatus: number;         // 200, 201, etc.
  
  // Security and validation
  auth?: boolean;                // Requires authentication
  roles?: string[];              // Required roles
  validation?: ValidationRule[];
  
  // Middleware
  middleware?: string[];         // Middleware to apply
  
  // Database operations
  database?: {
    operation: string;           // "create", "read", "update", "delete"
    entity: string;              // "User", "Post", etc.
    fields?: Record<string, any>;
  };
}
```

### Component Context

For frontend components:

```typescript
interface ComponentContext {
  componentName: string;         // "UserProfile"
  type: string;                  // "page", "component", "layout"
  
  // Props and state
  props?: ComponentProp[];
  state?: StateVariable[];
  hooks?: HookUsage[];
  
  // Styling
  styling?: {
    type: string;                // "css", "scss", "styled-components"
    classes?: string[];
    theme?: Record<string, any>;
  };
  
  // Testing
  testId?: string;               // "user-profile"
  tests?: TestCase[];
  
  // Dependencies
  dependencies?: string[];       // External dependencies
  imports?: Import[];            // Import statements
}
```

### Accessing Nested Data

```handlebars
{{!-- Access nested object properties --}}
{{ database.config.host }}
{{ auth.provider.settings.clientId }}

{{!-- Array access --}}
{{ endpoints.0.path }}          <!-- First endpoint path -->
{{ endpoints.[0].method }}      <!-- Alternative syntax -->

{{!-- Loop with context --}}
{{#each endpoints}}
  {{!-- this = current endpoint --}}
  {{!-- @root = original context --}}
  {{!-- @index = current index --}}
  {{!-- @key = current key (for objects) --}}
  Route {{ @index }}: {{ this.method }} {{ this.path }}
  Service: {{ @root.serviceName }}
{{/each}}
```

## Template Inheritance

### Creating Base Templates

```handlebars
{{!-- templates/base/typescript-service.hbs --}}
<!DOCTYPE typescript-service>
/**
 * {{ serviceName }}
 * Generated by Arbiter
 */

{{#block "imports"}}
import express from 'express';
{{/block}}

{{#block "configuration"}}
const app = express();
const PORT = process.env.PORT || {{ port }};
{{/block}}

{{#block "middleware"}}
app.use(express.json());
{{/block}}

{{#block "routes"}}
// Routes go here
{{/block}}

{{#block "startup"}}
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
{{/block}}

{{#block "exports"}}
export default app;
{{/block}}
```

### Extending Base Templates

```handlebars
{{!-- templates/typescript/service/api-service.hbs --}}
{{#extend "base/typescript-service"}}

{{#block "imports"}}
{{#parent}}{{/parent}}
import cors from 'cors';
import helmet from 'helmet';
{{#if database}}
import { {{ database.driver }} } from '{{ database.package }}';
{{/if}}
{{/block}}

{{#block "middleware"}}
{{#parent}}{{/parent}}
app.use(cors());
app.use(helmet());
{{/block}}

{{#block "routes"}}
{{#each endpoints}}
app.{{ this.method }}('{{ this.path }}', async (req, res) => {
  // Implementation for {{ this.description }}
});
{{/each}}
{{/block}}

{{/extend}}
```

## Testing Templates

### Template Test Structure

Create test files alongside templates:

```
templates/
├── typescript/
│   ├── service/
│   │   ├── main.ts.hbs
│   │   └── __tests__/
│   │       ├── main.spec.ts
│   │       └── fixtures/
│   │           ├── basic-service.json
│   │           └── complex-service.json
```

### Writing Template Tests

```typescript
// templates/typescript/service/__tests__/main.spec.ts
import { TemplateResolver } from '@arbiter/cli';
import { describe, test, expect } from 'vitest';

describe('TypeScript Service Template', () => {
  const resolver = new TemplateResolver({
    language: 'typescript',
    defaultDirectories: ['./templates/typescript']
  });

  test('generates basic service', async () => {
    const context = {
      serviceName: 'userService',
      port: 3000,
      endpoints: [
        {
          method: 'get',
          path: '/users',
          description: 'Get all users'
        }
      ]
    };

    const result = await resolver.renderTemplate(
      'service/main.ts.hbs',
      context,
      ''
    );

    expect(result).toContain('userService');
    expect(result).toContain('app.get(\'/users\'');
    expect(result).toContain('PORT || 3000');
  });

  test('includes database configuration when specified', async () => {
    const context = {
      serviceName: 'userService',
      database: {
        type: 'postgres',
        driver: 'pg',
        package: 'pg'
      }
    };

    const result = await resolver.renderTemplate(
      'service/main.ts.hbs', 
      context,
      ''
    );

    expect(result).toContain('import { pg } from \'pg\'');
    expect(result).toContain('new pg({');
  });

  test('handles authentication middleware', async () => {
    const context = {
      serviceName: 'userService',
      auth: true,
      endpoints: [
        {
          method: 'post',
          path: '/users',
          auth: true
        }
      ]
    };

    const result = await resolver.renderTemplate(
      'service/main.ts.hbs',
      context, 
      ''
    );

    expect(result).toContain('authenticate,');
  });
});
```

### Integration Testing

Test templates with real CUE specifications:

```typescript
// templates/__tests__/integration.spec.ts
import { generateCommand } from '@arbiter/cli';
import fs from 'fs-extra';
import { describe, test, beforeEach, afterEach } from 'vitest';

describe('Template Integration', () => {
  const testDir = '/tmp/arbiter-template-test';
  
  beforeEach(async () => {
    await fs.ensureDir(testDir);
  });
  
  afterEach(async () => {
    await fs.remove(testDir);
  });

  test('generates complete project from CUE spec', async () => {
    // Create test CUE specification
    const cueSpec = `
      package testapp
      
      {
        product: {
          name: "Test App"
        }
        services: {
          api: {
            language: "typescript"
            ports: [3000]
          }
        }
      }
    `;
    
    await fs.writeFile(`${testDir}/.arbiter/assembly.cue`, cueSpec);
    
    // Run generation
    const result = await generateCommand(
      {
        outputDir: testDir,
        dryRun: false
      },
      {
        projectDir: testDir
      }
    );
    
    expect(result).toBe(0);
    expect(await fs.pathExists(`${testDir}/services/api/main.ts`)).toBe(true);
  });
});
```

## Best Practices

### Template Design Principles

1. **Keep Templates Simple**
   - Focus on single responsibility
   - Avoid complex logic in templates
   - Use helpers for complex transformations

2. **Use Meaningful Names**
   ```handlebars
   {{!-- Good --}}
   {{ userService.endpoints.authentication.method }}
   
   {{!-- Avoid --}}
   {{ data.items.0.config.auth }}
   ```

3. **Provide Fallbacks**
   ```handlebars
   {{ port | default 3000 }}
   {{ description | default "No description provided" }}
   ```

4. **Document Template Context**
   ```handlebars
   {{!--
   Template: TypeScript Service
   
   Required context:
   - serviceName: string
   - endpoints: EndpointContext[]
   
   Optional context:
   - database: DatabaseConfig
   - auth: AuthConfig
   - port: number (default: 3000)
   --}}
   ```

### Performance Optimization

1. **Minimize Template Complexity**
   - Move complex logic to context preparation
   - Use partials for repeated code blocks
   - Cache compiled templates when possible

2. **Optimize Context Data**
   - Prepare computed values in context
   - Avoid deep object traversals in templates
   - Pre-format data when possible

3. **Use Efficient Helpers**
   ```handlebars
   {{!-- Efficient --}}
   {{ precomputedValue }}
   
   {{!-- Less efficient --}}
   {{ complex.nested.calculation | transform | format }}
   ```

### Maintainability

1. **Version Templates**
   - Tag template versions
   - Maintain backward compatibility
   - Document breaking changes

2. **Test Coverage**
   - Unit test individual templates
   - Integration test complete workflows
   - Test edge cases and error conditions

3. **Documentation**
   - Document required context variables
   - Provide usage examples
   - Maintain template changelogs

### Error Handling

1. **Graceful Degradation**
   ```handlebars
   {{#if complexFeature}}
     {{>complex-implementation}}
   {{else}}
     {{>simple-fallback}}
   {{/if}}
   ```

2. **Validation in Templates**
   ```handlebars
   {{#unless serviceName}}
     {{#error "serviceName is required"}}{{/error}}
   {{/unless}}
   ```

3. **Helpful Error Messages**
   ```handlebars
   {{!-- Include context in error messages --}}
   {{#unless endpoints}}
     {{#error "No endpoints defined for service: " serviceName}}{{/error}}
   {{/unless}}
   ```

This comprehensive guide provides everything needed to create, customize, and maintain templates for Arbiter's code generation system.
