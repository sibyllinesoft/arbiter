<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Repository Analysis: Scribe Analysis</title>
    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2a2a2a;
            --bg-tertiary: #3a3a3a;
            --text-primary: #e5e5e5;
            --text-secondary: #b5b5b5;
            --text-muted: #888;
            --accent-primary: #4f9cf9;
            --accent-secondary: #7c3aed;
            --border-color: #404040;
            --hover-color: #333333;
            --code-bg: #252525;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .header {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-bottom: 1px solid rgba(255, 255, 255, 0.02);
            color: white;
            padding: 32px;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.02) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 255, 255, 0.01) 0%, transparent 50%);
            pointer-events: none;
        }
        
        .header::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3e%3cg fill='none' fill-rule='evenodd'%3e%3cg fill='%23ffffff' fill-opacity='0.02'%3e%3ccircle cx='20' cy='20' r='1'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e");
            pointer-events: none;
        }
        
        .header h1 {
            margin: 0;
            font-size: 32px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
            z-index: 1;
        }
        
        .header .meta {
            margin-top: 20px;
            opacity: 0.9;
            font-size: 13px;
            position: relative;
            z-index: 1;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 16px;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255, 255, 255, 0.08);
            padding: 8px 12px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .meta-item:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-1px);
        }
        
        .stats {
            background: var(--bg-tertiary);
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 24px;
        }
        
        .stat {
            text-align: center;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }
        
        .stat:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .stat-label {
            font-size: 12px;
            text-transform: uppercase;
            color: var(--text-muted);
            letter-spacing: 0.5px;
            font-weight: 500;
        }
        
        .toc {
            background: var(--bg-tertiary);
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .toc h3 {
            margin: 0 0 20px 0;
            font-size: 18px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }
        
        .file-list {
            max-height: 400px;
            overflow-y: auto;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }
        
        .file-item {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }
        
        .file-item:hover {
            background-color: var(--hover-color);
        }
        
        .file-item:last-child {
            border-bottom: none;
        }
        
        .file-name {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-meta {
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .content {
            padding: 24px;
            background: var(--bg-secondary);
        }
        
        .file-section {
            margin-bottom: 32px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-primary);
        }
        
        .file-header {
            background: var(--bg-tertiary);
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-content {
            max-height: 600px;
            overflow-y: auto;
            position: relative;
        }
        
        .file-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .file-content::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        
        .file-content::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        .file-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        pre {
            margin: 0;
            padding: 24px;
            background: var(--code-bg);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: var(--text-primary);
        }
        
        .icon {
            width: 16px;
            height: 16px;
        }
        
        .icon-lg {
            width: 20px;
            height: 20px;
        }

        /* React Tree Component Styles */
        .tree-container {
            height: 400px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow-y: auto;
            padding: 8px;
        }

        .tree-node {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            cursor: pointer;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            color: var(--text-secondary);
            transition: all 0.2s ease;
            user-select: none;
            border-radius: 4px;
            margin: 1px 0;
        }

        .tree-node:hover {
            background: var(--hover-color);
            color: var(--accent-primary);
        }

        .tree-node.selected {
            background: var(--accent-primary);
            color: white;
        }

        .tree-node-content {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            width: 100%;
        }

        .tree-arrow {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 4px;
            transition: transform 0.2s ease;
            flex-shrink: 0;
            opacity: 0.6;
        }

        .tree-arrow.expanded {
            transform: rotate(90deg);
        }

        .tree-arrow.hidden {
            opacity: 0;
        }

        .tree-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        .tree-label {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .folder-icon {
            color: var(--accent-secondary);
        }

        .file-icon {
            color: var(--text-secondary);
        }

        /* Scrollbar styling for tree */
        .tree-container::-webkit-scrollbar {
            width: 8px;
        }

        .tree-container::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        .tree-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .tree-container::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        @media (max-width: 768px) {
            body {
                padding: 12px;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 24px;
            }
            
            .header .meta {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .meta-item {
                justify-content: center;
            }
            
            .stats {
                grid-template-columns: 1fr;
                gap: 16px;
                padding: 16px;
            }
            
            .content {
                padding: 16px;
            }
        }
        
        .control-bar {
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 16px 32px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }
        
        .control-buttons {
            display: flex;
            gap: 12px;
        }
        
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-primary {
            background: var(--accent-primary);
            color: white;
        }
        
        .btn-primary:hover {
            background: #3d8bfd;
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover {
            background: var(--hover-color);
            transform: translateY(-1px);
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .status-dot.online {
            background: #10b981;
        }
        
        .status-dot.offline {
            background: #ef4444;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @media (max-width: 768px) {
            .control-bar {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
                padding: 16px;
            }
            
            .control-buttons {
                justify-content: center;
            }
            
            .status-indicator {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                ğŸ” Repository Analysis
            </h1>
            <div class="meta">
                <div class="meta-item">
                    <span>ğŸ“Š <strong>Algorithm:</strong> v5-integrated</span>
                </div>
                <div class="meta-item">
                    <span>ğŸ•’ <strong>Generated:</strong> 2025-09-20 03:33:46 UTC</span>
                </div>
                <div class="meta-item">
                    <span>âš¡ <strong>Selection Time:</strong> 1766ms</span>
                </div>
            </div>
        </div>
        
        <div class="control-bar">
            <div class="control-buttons">
                <button id="save-btn" class="btn btn-primary">
                    ğŸ’¾ Save Bundle
                </button>
                <button id="shutdown-btn" class="btn btn-secondary">
                    ğŸ›‘ Shutdown Server
                </button>
            </div>
            <div class="status-indicator">
                <span id="connection-status" class="status-dot online"></span>
                <span id="status-text">Connected</span>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-value">
                    ğŸ“„ 174
                </div>
                <div class="stat-label">Files Selected</div>
            </div>
            <div class="stat">
                <div class="stat-value">
                    ğŸ”¢ 366,397
                </div>
                <div class="stat-label">Estimated Tokens</div>
            </div>
            <div class="stat">
                <div class="stat-value">
                    ğŸ’¾ 1.64 MB
                </div>
                <div class="stat-label">Total Size</div>
            </div>
            <div class="stat">
                <div class="stat-value">
                    ğŸ¯ 48.1%
                </div>
                <div class="stat-label">Coverage</div>
            </div>
        </div>
        
        <div class="toc">
            <h3>
                ğŸ“ File Explorer
            </h3>
            <div id="file-tree-container" class="tree-container"></div>
        </div>
        
        <div class="file-list">
            <div class="file-item">
                <span class="file-name">ğŸ“„ DIRECTORY_MAP.txt</span>
                <span class="file-meta">47.84 KB â€¢ ~16,408 tokens â€¢ Score: 1.00</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/validation/warnings.ts</span>
                <span class="file-meta">18.86 KB â€¢ ~3,783 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/ir.ts</span>
                <span class="file-meta">14.62 KB â€¢ ~3,035 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/constraints/core.ts</span>
                <span class="file-meta">12.57 KB â€¢ ~2,602 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/db.ts</span>
                <span class="file-meta">16.22 KB â€¢ ~3,489 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/config.ts</span>
                <span class="file-meta">9.80 KB â€¢ ~2,142 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/sharded-storage.ts</span>
                <span class="file-meta">19.21 KB â€¢ ~4,465 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/events.ts</span>
                <span class="file-meta">14.14 KB â€¢ ~2,849 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/nats.ts</span>
                <span class="file-meta">6.97 KB â€¢ ~1,453 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/api-client.ts</span>
                <span class="file-meta">15.07 KB â€¢ ~3,184 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/handlers/services.ts</span>
                <span class="file-meta">17.12 KB â€¢ ~3,730 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/language-plugins/python.ts</span>
                <span class="file-meta">37.27 KB â€¢ ~8,346 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/language-plugins/typescript.ts</span>
                <span class="file-meta">15.26 KB â€¢ ~3,445 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/handlers/discovery.ts</span>
                <span class="file-meta">11.29 KB â€¢ ~2,274 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/language-plugins/go.ts</span>
                <span class="file-meta">37.99 KB â€¢ ~9,242 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/constraints/sandbox.ts</span>
                <span class="file-meta">10.66 KB â€¢ ~2,176 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/github-template-config.ts</span>
                <span class="file-meta">25.06 KB â€¢ ~5,647 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/language-plugins/rust.ts</span>
                <span class="file-meta">47.03 KB â€¢ ~10,663 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/shared/src/utils.ts</span>
                <span class="file-meta">2.54 KB â€¢ ~538 tokens â€¢ Score: 0.72</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/constraints/filesystem.ts</span>
                <span class="file-meta">13.71 KB â€¢ ~2,736 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/surface.ts</span>
                <span class="file-meta">8.21 KB â€¢ ~1,628 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/connection-validator.ts</span>
                <span class="file-meta">5.21 KB â€¢ ~1,045 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/diff.ts</span>
                <span class="file-meta">16.96 KB â€¢ ~3,800 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/constraints/idempotency.ts</span>
                <span class="file-meta">19.95 KB â€¢ ~4,326 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/auth.ts</span>
                <span class="file-meta">7.25 KB â€¢ ~1,461 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/sync.ts</span>
                <span class="file-meta">26.66 KB â€¢ ~5,979 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/handlers/executor.ts</span>
                <span class="file-meta">17.50 KB â€¢ ~3,477 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/handlers/manager.ts</span>
                <span class="file-meta">16.35 KB â€¢ ~3,366 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/github-templates.ts</span>
                <span class="file-meta">15.74 KB â€¢ ~3,678 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/constraints/monitoring.ts</span>
                <span class="file-meta">19.37 KB â€¢ ~4,172 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/constraints/schema.ts</span>
                <span class="file-meta">14.62 KB â€¢ ~2,921 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/git-detection.ts</span>
                <span class="file-meta">8.91 KB â€¢ ~1,943 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/file-based-template-manager.ts</span>
                <span class="file-meta">21.88 KB â€¢ ~4,541 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/smart-naming.ts</span>
                <span class="file-meta">12.93 KB â€¢ ~2,805 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/shared/src/types.ts</span>
                <span class="file-meta">43.00 B â€¢ ~10 tokens â€¢ Score: 0.60</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/server.ts</span>
                <span class="file-meta">11.48 KB â€¢ ~2,450 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/template.ts</span>
                <span class="file-meta">9.26 KB â€¢ ~1,939 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/handlers/api.ts</span>
                <span class="file-meta">10.47 KB â€¢ ~2,168 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/import.ts</span>
                <span class="file-meta">16.43 KB â€¢ ~3,466 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/types/architecture.ts</span>
                <span class="file-meta">5.52 KB â€¢ ~1,289 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/design-system/tokens.ts</span>
                <span class="file-meta">7.32 KB â€¢ ~2,732 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/generate.ts</span>
                <span class="file-meta">116.29 KB â€¢ ~26,032 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/check.ts</span>
                <span class="file-meta">9.63 KB â€¢ ~2,065 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/create.ts</span>
                <span class="file-meta">17.73 KB â€¢ ~3,863 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/utils.ts</span>
                <span class="file-meta">8.85 KB â€¢ ~1,987 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/services/api.ts</span>
                <span class="file-meta">9.21 KB â€¢ ~2,035 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/ux-polish.ts</span>
                <span class="file-meta">12.54 KB â€¢ ~2,712 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/docs.ts</span>
                <span class="file-meta">23.71 KB â€¢ ~6,055 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/init.ts</span>
                <span class="file-meta">8.00 KB â€¢ ~1,873 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/handlers/examples/slack-notification.ts</span>
                <span class="file-meta">8.53 KB â€¢ ~1,701 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/webhooks.ts</span>
                <span class="file-meta">13.22 KB â€¢ ~2,629 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/progress.ts</span>
                <span class="file-meta">13.85 KB â€¢ ~3,039 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/cue/index.ts</span>
                <span class="file-meta">19.15 KB â€¢ ~4,353 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ examples/external-agent.ts</span>
                <span class="file-meta">7.35 KB â€¢ ~1,555 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/templates.ts</span>
                <span class="file-meta">10.65 KB â€¢ ~2,219 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/github-template.ts</span>
                <span class="file-meta">20.29 KB â€¢ ~4,133 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/performance.ts</span>
                <span class="file-meta">7.62 KB â€¢ ~1,747 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/types.ts</span>
                <span class="file-meta">6.93 KB â€¢ ~1,602 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/github-templates.ts</span>
                <span class="file-meta">21.60 KB â€¢ ~4,555 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/types.ts</span>
                <span class="file-meta">17.26 KB â€¢ ~3,614 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/.storybook/preview.ts</span>
                <span class="file-meta">6.89 KB â€¢ ~1,583 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/epic.ts</span>
                <span class="file-meta">33.22 KB â€¢ ~7,735 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/utils/diagramLayout.ts</span>
                <span class="file-meta">11.60 KB â€¢ ~2,470 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/execute.ts</span>
                <span class="file-meta">33.55 KB â€¢ ~7,273 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/types/api.ts</span>
                <span class="file-meta">6.87 KB â€¢ ~1,620 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/webhook.ts</span>
                <span class="file-meta">13.09 KB â€¢ ~2,822 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/platform-detection.ts</span>
                <span class="file-meta">8.63 KB â€¢ ~1,895 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/utils/logger.ts</span>
                <span class="file-meta">5.72 KB â€¢ ~1,381 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/validate.ts</span>
                <span class="file-meta">8.92 KB â€¢ ~1,881 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/file-watcher.ts</span>
                <span class="file-meta">6.29 KB â€¢ ~1,349 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/formatting.ts</span>
                <span class="file-meta">6.52 KB â€¢ ~1,583 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/add.ts</span>
                <span class="file-meta">39.56 KB â€¢ ~8,434 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/watch.ts</span>
                <span class="file-meta">10.79 KB â€¢ ~2,416 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/ide.ts</span>
                <span class="file-meta">22.15 KB â€¢ ~5,100 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/migrations/run.ts</span>
                <span class="file-meta">8.41 KB â€¢ ~1,751 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/debounce.ts</span>
                <span class="file-meta">1.31 KB â€¢ ~301 tokens â€¢ Score: 0.66</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/.storybook/main.ts</span>
                <span class="file-meta">478.00 B â€¢ ~124 tokens â€¢ Score: 0.62</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/vite-env.d.ts</span>
                <span class="file-meta">38.00 B â€¢ ~10 tokens â€¢ Score: 0.60</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/specEngine.ts</span>
                <span class="file-meta">26.89 KB â€¢ ~5,388 tokens â€¢ Score: 0.17</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ tests/e2e-docker-compose/src/index.ts</span>
                <span class="file-meta">246.00 B â€¢ ~63 tokens â€¢ Score: 0.17</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/check-connection.ts</span>
                <span class="file-meta">4.57 KB â€¢ ~861 tokens â€¢ Score: 0.82</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/language-plugins/index.ts</span>
                <span class="file-meta">5.10 KB â€¢ ~1,026 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/handlers/examples/push-handler.ts</span>
                <span class="file-meta">3.94 KB â€¢ ~808 tokens â€¢ Score: 0.79</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ scripts/update-version.js</span>
                <span class="file-meta">2.75 KB â€¢ ~668 tokens â€¢ Score: 0.73</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/shared/src/version.ts</span>
                <span class="file-meta">2.44 KB â€¢ ~553 tokens â€¢ Score: 0.72</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ scripts/sync-versions.ts</span>
                <span class="file-meta">4.12 KB â€¢ ~909 tokens â€¢ Score: 0.80</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/design-system/index.ts</span>
                <span class="file-meta">2.11 KB â€¢ ~426 tokens â€¢ Score: 0.70</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/playwright.config.ts</span>
                <span class="file-meta">1.95 KB â€¢ ~477 tokens â€¢ Score: 0.69</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/tailwind.config.js</span>
                <span class="file-meta">1.77 KB â€¢ ~479 tokens â€¢ Score: 0.68</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/rename.ts</span>
                <span class="file-meta">5.44 KB â€¢ ~1,167 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/diagrams/CueShowcase.stories.tsx</span>
                <span class="file-meta">3.11 KB â€¢ ~643 tokens â€¢ Score: 0.67</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/diagrams/index.ts</span>
                <span class="file-meta">1.30 KB â€¢ ~264 tokens â€¢ Score: 0.66</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ docs/webhooks.md</span>
                <span class="file-meta">12.63 KB â€¢ ~2,100 tokens â€¢ Score: 0.26</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/design-system/components/Button.tsx</span>
                <span class="file-meta">2.77 KB â€¢ ~633 tokens â€¢ Score: 0.65</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/vite.config.ts</span>
                <span class="file-meta">911.00 B â€¢ ~241 tokens â€¢ Score: 0.64</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/shared/src/migration.ts</span>
                <span class="file-meta">877.00 B â€¢ ~212 tokens â€¢ Score: 0.64</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/Handlers/Handlers.tsx</span>
                <span class="file-meta">2.51 KB â€¢ ~522 tokens â€¢ Score: 0.64</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/index.ts</span>
                <span class="file-meta">703.00 B â€¢ ~149 tokens â€¢ Score: 0.63</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/eslint.config.js</span>
                <span class="file-meta">617.00 B â€¢ ~143 tokens â€¢ Score: 0.63</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ demo-project/src/App.tsx</span>
                <span class="file-meta">179.00 B â€¢ ~50 tokens â€¢ Score: 0.52</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/diagrams/DataViewer.tsx</span>
                <span class="file-meta">2.28 KB â€¢ ~544 tokens â€¢ Score: 0.62</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/Handlers/index.ts</span>
                <span class="file-meta">342.00 B â€¢ ~65 tokens â€¢ Score: 0.61</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/Layout/Tabs.tsx</span>
                <span class="file-meta">2.04 KB â€¢ ~503 tokens â€¢ Score: 0.61</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ demo-project/vite.config.ts</span>
                <span class="file-meta">329.00 B â€¢ ~90 tokens â€¢ Score: 0.61</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/diagrams/SplitViewShowcase.tsx</span>
                <span class="file-meta">1.94 KB â€¢ ~490 tokens â€¢ Score: 0.61</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/shared/src/index.ts</span>
                <span class="file-meta">202.00 B â€¢ ~42 tokens â€¢ Score: 0.61</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/handlers/types.ts</span>
                <span class="file-meta">5.68 KB â€¢ ~1,227 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/charts/index.ts</span>
                <span class="file-meta">171.00 B â€¢ ~36 tokens â€¢ Score: 0.60</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/api-types/src/index.ts</span>
                <span class="file-meta">122.00 B â€¢ ~26 tokens â€¢ Score: 0.60</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/postcss.config.js</span>
                <span class="file-meta">81.00 B â€¢ ~20 tokens â€¢ Score: 0.60</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ demo-project/src/vite-env.d.ts</span>
                <span class="file-meta">38.00 B â€¢ ~10 tokens â€¢ Score: 0.60</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/Layout/TopBar.stories.tsx</span>
                <span class="file-meta">3.17 KB â€¢ ~757 tokens â€¢ Score: 0.67</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/Handlers/HandlersErrorBoundary.tsx</span>
                <span class="file-meta">4.08 KB â€¢ ~867 tokens â€¢ Score: 0.71</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ scripts/local-ci.sh</span>
                <span class="file-meta">1.12 KB â€¢ ~309 tokens â€¢ Score: 0.57</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/.storybook/decorators.tsx</span>
                <span class="file-meta">867.00 B â€¢ ~209 tokens â€¢ Score: 0.55</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/tsconfig.json</span>
                <span class="file-meta">119.00 B â€¢ ~31 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/shared/package.json</span>
                <span class="file-meta">748.00 B â€¢ ~201 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ biome.json</span>
                <span class="file-meta">1.82 KB â€¢ ~412 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/tsconfig.node.json</span>
                <span class="file-meta">630.00 B â€¢ ~145 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/api-types/package.json</span>
                <span class="file-meta">740.00 B â€¢ ~197 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/tsconfig.json</span>
                <span class="file-meta">1.57 KB â€¢ ~348 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/tsconfig.app.json</span>
                <span class="file-meta">811.00 B â€¢ ~185 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/api-types/tsconfig.json</span>
                <span class="file-meta">366.00 B â€¢ ~88 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ .prettierrc.json</span>
                <span class="file-meta">657.00 B â€¢ ~176 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ tsconfig.json</span>
                <span class="file-meta">1.32 KB â€¢ ~283 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/example-templates.json</span>
                <span class="file-meta">2.16 KB â€¢ ~470 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ demo-project/package.json</span>
                <span class="file-meta">519.00 B â€¢ ~136 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/tsconfig.json</span>
                <span class="file-meta">980.00 B â€¢ ~205 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ docker-compose.yml</span>
                <span class="file-meta">1.60 KB â€¢ ~375 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/shared/tsconfig.json</span>
                <span class="file-meta">384.00 B â€¢ ~93 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ .arbiter/skald-config.json</span>
                <span class="file-meta">316.00 B â€¢ ~87 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ .lintstagedrc.json</span>
                <span class="file-meta">143.00 B â€¢ ~54 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ demo-project/tsconfig.json</span>
                <span class="file-meta">543.00 B â€¢ ~133 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/App.css</span>
                <span class="file-meta">606.00 B â€¢ ~203 tokens â€¢ Score: 0.54</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ examples/sample-tasks.json</span>
                <span class="file-meta">2.69 KB â€¢ ~521 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ demo-project/src/main.tsx</span>
                <span class="file-meta">236.00 B â€¢ ~53 tokens â€¢ Score: 0.52</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/types/ui.ts</span>
                <span class="file-meta">6.07 KB â€¢ ~1,462 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/Layout/SplitPane.tsx</span>
                <span class="file-meta">4.16 KB â€¢ ~979 tokens â€¢ Score: 0.72</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/diagrams/MermaidRenderer.tsx</span>
                <span class="file-meta">3.83 KB â€¢ ~934 tokens â€¢ Score: 0.70</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/constraints/index.ts</span>
                <span class="file-meta">18.32 KB â€¢ ~3,749 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/diagrams/NetworkDiagram.tsx</span>
                <span class="file-meta">3.87 KB â€¢ ~947 tokens â€¢ Score: 0.70</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/validation/__tests__/debug-spec.test.ts</span>
                <span class="file-meta">2.04 KB â€¢ ~449 tokens â€¢ Score: 0.17</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/example-script-template.sh</span>
                <span class="file-meta">3.94 KB â€¢ ~1,016 tokens â€¢ Score: 0.71</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/design-system/components/StatusBadge.tsx</span>
                <span class="file-meta">4.01 KB â€¢ ~1,110 tokens â€¢ Score: 0.71</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/export.ts</span>
                <span class="file-meta">11.26 KB â€¢ ~2,422 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/package.json</span>
                <span class="file-meta">2.52 KB â€¢ ~616 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/index.css</span>
                <span class="file-meta">4.62 KB â€¢ ~1,278 tokens â€¢ Score: 0.74</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/check-constrained.ts</span>
                <span class="file-meta">12.86 KB â€¢ ~2,605 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/design-system/variants.ts</span>
                <span class="file-meta">7.35 KB â€¢ ~1,949 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/github-sync.ts</span>
                <span class="file-meta">30.92 KB â€¢ ~6,346 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/design-system/components/Sidebar.tsx</span>
                <span class="file-meta">6.28 KB â€¢ ~1,505 tokens â€¢ Score: 0.77</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/services/websocket.ts</span>
                <span class="file-meta">10.39 KB â€¢ ~2,133 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/package.json</span>
                <span class="file-meta">2.36 KB â€¢ ~665 tokens â€¢ Score: 0.51</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/minimal.css</span>
                <span class="file-meta">3.89 KB â€¢ ~1,241 tokens â€¢ Score: 0.70</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/App.tsx</span>
                <span class="file-meta">7.24 KB â€¢ ~1,660 tokens â€¢ Score: 0.77</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/tests/integration/nats.test.ts</span>
                <span class="file-meta">5.42 KB â€¢ ~1,169 tokens â€¢ Score: 0.17</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/design-system/components/NavItem.tsx</span>
                <span class="file-meta">7.43 KB â€¢ ~1,745 tokens â€¢ Score: 0.77</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/design-system/components/Breadcrumbs.tsx</span>
                <span class="file-meta">7.23 KB â€¢ ~1,762 tokens â€¢ Score: 0.77</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/diagrams/FlowDiagram.tsx</span>
                <span class="file-meta">7.00 KB â€¢ ~1,776 tokens â€¢ Score: 0.77</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/preview.ts</span>
                <span class="file-meta">12.97 KB â€¢ ~3,172 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/design-system/components/Input.tsx</span>
                <span class="file-meta">8.06 KB â€¢ ~1,809 tokens â€¢ Score: 0.77</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/components/diagrams/PlotsDiagram.tsx</span>
                <span class="file-meta">8.22 KB â€¢ ~1,818 tokens â€¢ Score: 0.77</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/design-system/components/Card.tsx</span>
                <span class="file-meta">8.29 KB â€¢ ~1,823 tokens â€¢ Score: 0.77</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/utils/__tests__/git-detection.test.ts</span>
                <span class="file-meta">7.43 KB â€¢ ~1,627 tokens â€¢ Score: 0.17</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/templates/index.ts</span>
                <span class="file-meta">13.03 KB â€¢ ~2,791 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/cli/src/commands/compat.ts</span>
                <span class="file-meta">13.81 KB â€¢ ~2,838 tokens â€¢ Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/design-system/components/Checkbox.tsx</span>
                <span class="file-meta">8.44 KB â€¢ ~1,896 tokens â€¢ Score: 0.77</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ packages/shared/src/__tests__/issue-schema.test.ts</span>
                <span class="file-meta">5.45 KB â€¢ ~1,199 tokens â€¢ Score: 0.17</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/api/src/handlers/examples/spec-validator.ts</span>
                <span class="file-meta">6.23 KB â€¢ ~1,245 tokens â€¢ Score: 0.17</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ README.md</span>
                <span class="file-meta">844.00 B â€¢ ~143 tokens â€¢ Score: 0.26</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ docs/CLEANUP_BASELINE.md</span>
                <span class="file-meta">73.00 B â€¢ ~19 tokens â€¢ Score: 0.26</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ demo-project/index.html</span>
                <span class="file-meta">361.00 B â€¢ ~125 tokens â€¢ Score: 0.26</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ apps/web/frontend/src/App.test.tsx</span>
                <span class="file-meta">219.00 B â€¢ ~48 tokens â€¢ Score: 0.17</span>
            </div>
            <div class="file-item">
                <span class="file-name">ğŸ“„ tests/e2e-docker-compose/app/package.json</span>
                <span class="file-meta">172.00 B â€¢ ~53 tokens â€¢ Score: 0.17</span>
            </div>
        </div>
        
        <div class="content">
            <div class="file-section" id="file-1">
                <div class="file-header">ğŸ“„ DIRECTORY_MAP.txt</div>
                <div class="file-content">
                    <pre>Repository Inventory
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
Path                                                         Type       Size Modified
------------------------------------------------------------ ---- ---------- -------------------
.                                                            dir     4.80 MB 2025-09-19 23:24:43
/                                                            dir     4.10 KB 2025-09-07 18:08:55
/home                                                        dir     32.00 B 2025-07-05 13:25:42
/home/nathan                                                 dir     1.88 KB 2025-09-19 23:26:13
/home/nathan/Projects                                        dir    822.00 B 2025-09-19 15:22:52
/home/nathan/Projects/arbiter                                dir    692.00 B 2025-09-19 23:08:02
/home/nathan/Projects/arbiter/.arbiter                       dir     34.00 B 2025-09-19 16:03:24
/home/nathan/Projects/arbiter/.arbiter/skald-config.json     file   316.00 B 2025-09-19 16:03:24
/home/nathan/Projects/arbiter/.github                        dir     60.00 B 2025-09-02 18:22:30
/home/nathan/Projects/arbiter/.github/PULL_REQUEST_TEMPLATE  dir     76.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/.github/PULL_REQUEST_TEMPLATE/cli-feature.md file    2.24 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/.github/PULL_REQUEST_TEMPLATE/default.md file    1.78 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/.github/PULL_REQUEST_TEMPLATE/refactoring.md file    2.47 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/.github/workflows              dir    264.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/.github/workflows/ci.yml       file   16.12 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/.github/workflows/dependency-update.yml file   12.66 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/.github/workflows/docs-update.yml file    9.67 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/.github/workflows/e2e-docker-compose.yml file    7.25 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/.github/workflows/performance-monitoring.yml file   16.91 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/.github/workflows/pre-release.yml file   15.97 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/.github/workflows/release.yml  file   13.47 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/.github/workflows/version-bump.yml file   12.44 KB 2025-09-13 02:16:15
/home/nathan/Projects/arbiter/.lintstagedrc.json             file   143.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/.prettierrc.json               file   657.00 B 2025-09-19 18:45:04
/home/nathan/Projects/arbiter/CLAUDE.md                      file   29.68 KB 2025-09-19 19:30:29
/home/nathan/Projects/arbiter/README.md                      file   844.00 B 2025-09-19 19:02:29
/home/nathan/Projects/arbiter/apps                           dir     12.00 B 2025-08-30 16:18:53
/home/nathan/Projects/arbiter/apps/api                       dir    156.00 B 2025-09-19 20:24:19
/home/nathan/Projects/arbiter/apps/api/package.json          file    2.36 KB 2025-09-19 23:07:57
/home/nathan/Projects/arbiter/apps/api/src                   dir    394.00 B 2025-09-19 22:50:55
/home/nathan/Projects/arbiter/apps/api/src/__tests__         dir     84.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/api/src/__tests__/db-coverage.test.ts file   12.84 KB 2025-09-19 19:12:23
/home/nathan/Projects/arbiter/apps/api/src/__tests__/revision-system.test.ts file   11.44 KB 2025-09-19 19:12:23
/home/nathan/Projects/arbiter/apps/api/src/auth.ts           file    7.25 KB 2025-09-19 19:12:23
/home/nathan/Projects/arbiter/apps/api/src/db.ts             file   16.22 KB 2025-09-19 19:12:23
/home/nathan/Projects/arbiter/apps/api/src/events.ts         file   14.14 KB 2025-09-19 19:12:23
/home/nathan/Projects/arbiter/apps/api/src/handlers          dir    188.00 B 2025-09-19 22:04:01
/home/nathan/Projects/arbiter/apps/api/src/handlers/README.md file   12.73 KB 2025-09-19 23:08:27
/home/nathan/Projects/arbiter/apps/api/src/handlers/api.ts   file   10.47 KB 2025-09-19 23:18:59
/home/nathan/Projects/arbiter/apps/api/src/handlers/discovery.ts file   11.29 KB 2025-09-19 23:11:11
/home/nathan/Projects/arbiter/apps/api/src/handlers/examples dir    106.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/api/src/handlers/examples/push-handler.ts file    3.94 KB 2025-09-19 19:12:23
/home/nathan/Projects/arbiter/apps/api/src/handlers/examples/slack-notification.ts file    8.53 KB 2025-09-19 19:12:24
/home/nathan/Projects/arbiter/apps/api/src/handlers/examples/spec-validator.ts file    6.23 KB 2025-09-19 19:12:24
/home/nathan/Projects/arbiter/apps/api/src/handlers/executor.ts file   17.50 KB 2025-09-19 23:09:09
/home/nathan/Projects/arbiter/apps/api/src/handlers/manager.ts file   16.35 KB 2025-09-19 23:24:43
/home/nathan/Projects/arbiter/apps/api/src/handlers/services.ts file   17.12 KB 2025-09-19 23:07:53
/home/nathan/Projects/arbiter/apps/api/src/handlers/types.ts file    5.68 KB 2025-09-19 23:11:36
/home/nathan/Projects/arbiter/apps/api/src/ir.ts             file   14.62 KB 2025-09-19 19:12:24
/home/nathan/Projects/arbiter/apps/api/src/migrations        dir     12.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/api/src/migrations/run.ts file    8.41 KB 2025-09-19 19:12:24
/home/nathan/Projects/arbiter/apps/api/src/nats.ts           file    6.97 KB 2025-09-19 19:12:24
/home/nathan/Projects/arbiter/apps/api/src/server.test.ts    file    2.35 KB 2025-09-18 16:28:52
/home/nathan/Projects/arbiter/apps/api/src/server.ts         file   11.48 KB 2025-09-19 22:49:29
/home/nathan/Projects/arbiter/apps/api/src/specEngine.ts     file   26.89 KB 2025-09-19 21:32:44
/home/nathan/Projects/arbiter/apps/api/src/tests             dir     86.00 B 2025-09-01 15:06:11
/home/nathan/Projects/arbiter/apps/api/src/tests/concurrency dir     44.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/api/src/tests/concurrency/raceConditions.test.ts file   22.01 KB 2025-09-19 22:54:01
/home/nathan/Projects/arbiter/apps/api/src/tests/golden      dir     38.00 B 2025-09-01 15:06:11
/home/nathan/Projects/arbiter/apps/api/src/tests/golden/goldenFiles.test.ts file   18.09 KB 2025-09-19 22:57:43
/home/nathan/Projects/arbiter/apps/api/src/tests/integration dir     80.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/api/src/tests/integration/api.test.ts file   23.24 KB 2025-09-19 22:59:38
/home/nathan/Projects/arbiter/apps/api/src/tests/integration/nats.test.ts file    5.42 KB 2025-09-19 23:01:14
/home/nathan/Projects/arbiter/apps/api/src/tests/integration/websocket.test.ts file   18.05 KB 2025-09-19 23:02:05
/home/nathan/Projects/arbiter/apps/api/src/tests/performance dir     36.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/api/src/tests/performance/benchmarks.test.ts file   26.36 KB 2025-09-19 23:02:38
/home/nathan/Projects/arbiter/apps/api/src/tests/unit        dir    124.00 B 2025-09-19 23:20:21
/home/nathan/Projects/arbiter/apps/api/src/tests/unit/db.test.ts file   19.29 KB 2025-09-18 16:28:52
/home/nathan/Projects/arbiter/apps/api/src/tests/unit/ir.test.ts file   22.98 KB 2025-09-18 16:28:52
/home/nathan/Projects/arbiter/apps/api/src/tests/unit/specEngine.test.ts file   21.25 KB 2025-09-18 16:28:52
/home/nathan/Projects/arbiter/apps/api/src/types.ts          file    6.93 KB 2025-09-19 23:09:31
/home/nathan/Projects/arbiter/apps/api/src/utils.ts          file    8.85 KB 2025-09-19 19:12:24
/home/nathan/Projects/arbiter/apps/api/src/webhooks.ts       file   13.22 KB 2025-09-19 19:12:24
/home/nathan/Projects/arbiter/apps/api/tsconfig.json         file   980.00 B 2025-09-19 19:37:54
/home/nathan/Projects/arbiter/apps/web                       dir     42.00 B 2025-09-19 19:38:42
/home/nathan/Projects/arbiter/apps/web/frontend              dir    690.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/.storybook   dir     62.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/.storybook/decorators.tsx file   867.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/.storybook/main.ts file   478.00 B 2025-09-18 16:28:52
/home/nathan/Projects/arbiter/apps/web/frontend/.storybook/preview.ts file    6.89 KB 2025-09-18 16:28:52
/home/nathan/Projects/arbiter/apps/web/frontend/DIAGRAM_SHOWCASE_README.md file    7.05 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/README.md    file    8.85 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/TESTING_GUIDE.md file    7.52 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/eslint.config.js file   617.00 B 2025-09-19 19:12:25
/home/nathan/Projects/arbiter/apps/web/frontend/index.html   file   411.00 B 2025-09-09 15:05:55
/home/nathan/Projects/arbiter/apps/web/frontend/package-lock.json file  407.34 KB 2025-09-04 11:38:37
/home/nathan/Projects/arbiter/apps/web/frontend/package.json file    3.12 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/playwright.config.ts file    1.95 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/apps/web/frontend/postcss.config.js file    81.00 B 2025-09-02 18:06:42
/home/nathan/Projects/arbiter/apps/web/frontend/src          dir    282.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/App.css  file   606.00 B 2025-09-01 15:06:11
/home/nathan/Projects/arbiter/apps/web/frontend/src/App.test.tsx file   219.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/App.tsx  file    7.24 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/MonacoTest.tsx file    9.36 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/__tests__ dir     50.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/__tests__/App.test.tsx file   14.30 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/__tests__/main.test.tsx file    5.38 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components dir    122.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Editor dir    330.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Editor/EditorPane.stories.tsx file   18.20 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Editor/EditorPane.test.tsx file   21.30 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Editor/EditorPane.tsx file    9.22 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Editor/FileTree.stories.tsx file   17.34 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Editor/FileTree.test.tsx file   24.15 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Editor/FileTree.tsx file   17.71 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Editor/MonacoEditor.stories.tsx file   15.75 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Editor/MonacoEditor.test.tsx file   13.71 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Editor/MonacoEditor.tsx file   14.92 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Handlers dir    248.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Handlers/HandlerEditor.tsx file   18.79 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Handlers/HandlerStats.tsx file   15.16 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Handlers/Handlers.tsx file    2.51 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Handlers/HandlersErrorBoundary.tsx file    4.08 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Handlers/HandlersList.test.tsx file    8.96 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Handlers/HandlersList.tsx file   14.71 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Handlers/README.md file    6.71 KB 2025-09-19 19:02:32
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Handlers/index.ts file   342.00 B 2025-09-19 19:12:25
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Layout dir    398.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Layout/ProjectBrowser.stories.tsx file   16.65 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Layout/ProjectBrowser.test.tsx file   23.04 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Layout/ProjectBrowser.tsx file   14.34 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Layout/SplitPane.stories.tsx file   10.01 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Layout/SplitPane.test.tsx file   16.61 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Layout/SplitPane.tsx file    4.16 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Layout/Tabs.stories.tsx file   14.01 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Layout/Tabs.test.tsx file   14.87 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Layout/Tabs.tsx file    2.04 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Layout/TopBar.stories.tsx file    3.17 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Layout/TopBar.test.tsx file   24.28 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/Layout/TopBar.tsx file   16.40 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/ProjectShowcase.stories.tsx file   25.27 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/charts dir     68.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/charts/Chart.tsx file    9.38 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/charts/CuePlotViewer.tsx file    8.41 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/charts/index.ts file   171.00 B 2025-09-19 19:12:26
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams dir     1.25 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/ArchitectureDiagram.tsx file   19.42 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/CueDrivenArchitectureDiagram.stories.tsx file   11.42 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/CueDrivenArchitectureDiagram.tsx file   21.91 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/CueDrivenArchitectureIntegration.tsx file    9.73 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/CueShowcase.stories.tsx file    3.11 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/CueShowcase.tsx file   11.08 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/CueViewer.stories.tsx file    8.60 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/CueViewer.tsx file   10.54 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/CueVisualizationOverview.stories.tsx file   15.29 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/DataViewer.stories.tsx file    9.80 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/DataViewer.tsx file    2.28 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/DiagramShowcase.stories.tsx file   15.55 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/FlowDiagram.stories.tsx file   22.68 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/FlowDiagram.tsx file    7.00 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/FriendlyDiagram.tsx file   15.66 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/FsmDiagram.stories.tsx file   22.45 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/FsmDiagram.tsx file   10.30 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/GapAnalysis.stories.tsx file   28.35 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/GapsChecklist.tsx file   12.86 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/MermaidRenderer.tsx file    3.83 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/NetworkDiagram.tsx file    3.87 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/PlotsDiagram.tsx file    8.22 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/PrettyCueDiagram.tsx file   10.43 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/ResolvedViewer.tsx file   12.49 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/SiteDiagram.stories.tsx file   28.25 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/SiteDiagram.tsx file    9.44 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/SourceDiagram.tsx file   10.62 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/SplitViewShowcase.tsx file    1.94 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/ViewDiagram.tsx file   13.69 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/components/diagrams/index.ts file    1.30 KB 2025-09-19 19:12:27
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system dir    194.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/DesignSystemOverview.stories.tsx file   33.22 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/README.md file    6.80 KB 2025-09-19 19:02:33
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components dir     1.29 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Breadcrumbs.stories.tsx file    9.92 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Breadcrumbs.test.tsx file   20.42 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Breadcrumbs.tsx file    7.23 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Button.stories.tsx file   10.26 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Button.test.tsx file   10.32 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Button.tsx file    2.77 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Card.stories.tsx file   22.32 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Card.test.tsx file   17.68 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Card.tsx file    8.29 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Checkbox.stories.tsx file   14.73 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Checkbox.test.tsx file   18.97 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Checkbox.tsx file    8.44 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/DesignTokens.stories.tsx file   18.92 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Dialog.stories.tsx file   16.44 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Dialog.test.tsx file   15.84 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Dialog.tsx file    8.95 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Input.stories.tsx file   19.45 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Input.test.tsx file   17.45 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Input.tsx file    8.06 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Modal.stories.tsx file   19.54 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Modal.test.tsx file   16.63 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Modal.tsx file    9.66 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/NavItem.stories.tsx file   12.78 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/NavItem.test.tsx file   24.89 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/NavItem.tsx file    7.43 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Radio.stories.tsx file   20.46 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Radio.test.tsx file   26.66 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Radio.tsx file   12.06 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Select.stories.tsx file   19.95 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Select.test.tsx file   30.84 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Select.tsx file   18.24 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Sidebar.stories.tsx file   12.48 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Sidebar.test.tsx file   21.53 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Sidebar.tsx file    6.28 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/StatusBadge.stories.tsx file   20.09 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/StatusBadge.test.tsx file   19.19 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/StatusBadge.tsx file    4.01 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Tabs.stories.tsx file   25.07 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Tabs.test.tsx file   20.95 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Tabs.tsx file   11.71 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Toast.stories.tsx file   20.03 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Toast.test.tsx file   11.64 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/components/Toast.tsx file   12.45 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/index.ts file    2.11 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/tokens.stories.tsx file   26.02 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/tokens.ts file    7.32 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/apps/web/frontend/src/design-system/variants.ts file    7.35 KB 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/src/index.css file    4.62 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/main.tsx file   274.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/minimal.css file    3.89 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/services dir     54.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/services/__tests__ dir     64.00 B 2025-09-03 13:48:46
/home/nathan/Projects/arbiter/apps/web/frontend/src/services/__tests__/api.test.ts file   33.00 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/apps/web/frontend/src/services/__tests__/websocket-new.test.ts file   24.53 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/apps/web/frontend/src/services/api.ts file    9.21 KB 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/src/services/websocket.ts file   10.39 KB 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/src/test     dir     96.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/test/cue-samples.ts file   30.59 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/apps/web/frontend/src/test/setup.ts file    1.42 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/apps/web/frontend/src/test/storybook-data.ts file   27.39 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/apps/web/frontend/src/test/utils.tsx file    1.21 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/types    dir     52.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/types/api.ts file    6.87 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/apps/web/frontend/src/types/architecture.ts file    5.52 KB 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/src/types/ui.ts file    6.07 KB 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/src/utils    dir     98.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/src/utils/cueArchitectureParser.ts file   15.74 KB 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/src/utils/diagramLayout.ts file   11.60 KB 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/src/utils/logger.ts file    5.72 KB 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/src/vite-env.d.ts file    38.00 B 2025-09-01 15:06:11
/home/nathan/Projects/arbiter/apps/web/frontend/tailwind.config.js file    1.77 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/apps/web/frontend/test-cue-dropdown.md file    3.21 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/tests        dir    188.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/tests/README.md file    8.40 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/web/frontend/tests/basic-navigation.spec.ts file   15.28 KB 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/tests/diagrams.spec.ts file   20.76 KB 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/tests/editor.spec.ts file   17.23 KB 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/tests/responsive.spec.ts file   19.89 KB 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/tests/test-utils.ts file   15.00 KB 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/tsconfig.app.json file   811.00 B 2025-09-01 15:06:11
/home/nathan/Projects/arbiter/apps/web/frontend/tsconfig.json file   119.00 B 2025-09-01 15:06:11
/home/nathan/Projects/arbiter/apps/web/frontend/tsconfig.node.json file   630.00 B 2025-09-01 15:06:11
/home/nathan/Projects/arbiter/apps/web/frontend/vite.config.ts file   911.00 B 2025-09-19 19:12:29
/home/nathan/Projects/arbiter/apps/web/frontend/vitest.config.ts file    1.08 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/biome.json                     file    1.82 KB 2025-09-19 19:30:38
/home/nathan/Projects/arbiter/demo-project                   dir    196.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/demo-project/README.md         file    3.92 KB 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/demo-project/index.html        file   361.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/demo-project/package.json      file   519.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/demo-project/src               dir     76.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/demo-project/src/App.tsx       file   179.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/demo-project/src/main.tsx      file   236.00 B 2025-09-08 00:48:35
/home/nathan/Projects/arbiter/demo-project/src/test-utils    dir     22.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/demo-project/src/test-utils/locators.ts file   504.00 B 2025-09-19 19:02:36
/home/nathan/Projects/arbiter/demo-project/src/vite-env.d.ts file    38.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/demo-project/tsconfig.json     file   543.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/demo-project/vite.config.ts    file   329.00 B 2025-09-19 19:12:30
/home/nathan/Projects/arbiter/docker-compose.yml             file    1.60 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/docs                           dir    488.00 B 2025-09-19 21:18:09
/home/nathan/Projects/arbiter/docs/ARBITER_CUE_SCHEMA.md     file   20.35 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/docs/BENCHMARKING.md           file    4.46 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/docs/CLEANUP_BASELINE.md       file    73.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/docs/CLI_REFERENCE.md          file   34.28 KB 2025-09-19 21:18:02
/home/nathan/Projects/arbiter/docs/INCEPTION_EXAMPLE.md      file    1.61 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/docs/MONOREPO_TRANSFORMATION_STATUS.md file    7.33 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/docs/RELEASE_PLAN.md           file    4.43 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/docs/cli-reference.md          file   14.72 KB 2025-09-19 21:17:59
/home/nathan/Projects/arbiter/docs/core-concepts.md          file   10.37 KB 2025-09-19 19:26:13
/home/nathan/Projects/arbiter/docs/github-sync.md            file    5.73 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/docs/known-issues.md           file    7.84 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/docs/webhooks.md               file   12.63 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/examples                       dir    248.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/examples/epic-task-workflow.md file    7.72 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/examples/external-agent.ts     file    7.35 KB 2025-09-19 19:12:32
/home/nathan/Projects/arbiter/examples/sample-tasks.json     file    2.69 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/package.json                   file    3.95 KB 2025-09-19 21:36:08
/home/nathan/Projects/arbiter/packages                       dir    110.00 B 2025-09-19 21:30:47
/home/nathan/Projects/arbiter/packages/api-types             dir     64.00 B 2025-09-19 20:24:19
/home/nathan/Projects/arbiter/packages/api-types/package.json file   740.00 B 2025-09-19 20:18:56
/home/nathan/Projects/arbiter/packages/api-types/src         dir     16.00 B 2025-09-19 20:18:19
/home/nathan/Projects/arbiter/packages/api-types/src/index.ts file   122.00 B 2025-09-19 20:18:19
/home/nathan/Projects/arbiter/packages/api-types/tsconfig.json file   366.00 B 2025-09-19 20:19:40
/home/nathan/Projects/arbiter/packages/cli                   dir    392.00 B 2025-09-19 21:11:35
/home/nathan/Projects/arbiter/packages/cli/GITHUB_TEMPLATES_CONFIG.md file    9.43 KB 2025-09-18 17:54:51
/home/nathan/Projects/arbiter/packages/cli/TEMPLATE_SYSTEM.md file    8.28 KB 2025-09-18 17:54:51
/home/nathan/Projects/arbiter/packages/cli/example-github-templates.json file    5.59 KB 2025-09-18 17:54:51
/home/nathan/Projects/arbiter/packages/cli/example-script-template.sh file    3.94 KB 2025-09-06 10:32:45
/home/nathan/Projects/arbiter/packages/cli/example-templates.json file    2.16 KB 2025-09-18 17:54:51
/home/nathan/Projects/arbiter/packages/cli/package.json      file    2.52 KB 2025-09-19 21:35:22
/home/nathan/Projects/arbiter/packages/cli/src               dir    396.00 B 2025-09-19 21:08:04
/home/nathan/Projects/arbiter/packages/cli/src/__tests__     dir    158.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/packages/cli/src/__tests__/api-client.test.ts file   20.05 KB 2025-09-19 21:38:27
/home/nathan/Projects/arbiter/packages/cli/src/__tests__/ecosystem.test.ts file   18.88 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/packages/cli/src/__tests__/epic.test.ts file   10.63 KB 2025-09-19 19:12:32
/home/nathan/Projects/arbiter/packages/cli/src/__tests__/github-sync-simple.test.ts file   11.70 KB 2025-09-19 19:12:32
/home/nathan/Projects/arbiter/packages/cli/src/__tests__/golden dir    442.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/packages/cli/src/__tests__/golden/check-no-files.json file    38.00 B 2025-09-19 18:51:57
/home/nathan/Projects/arbiter/packages/cli/src/api-client.ts file   15.07 KB 2025-09-19 19:12:32
/home/nathan/Projects/arbiter/packages/cli/src/cli.ts        file   88.68 KB 2025-09-19 21:17:46
/home/nathan/Projects/arbiter/packages/cli/src/commands      dir    692.00 B 2025-09-19 21:09:07
/home/nathan/Projects/arbiter/packages/cli/src/commands/add.ts file   39.56 KB 2025-09-19 19:12:32
/home/nathan/Projects/arbiter/packages/cli/src/commands/check-connection.ts file    4.57 KB 2025-09-19 19:12:32
/home/nathan/Projects/arbiter/packages/cli/src/commands/check-constrained.ts file   12.86 KB 2025-09-19 19:12:32
/home/nathan/Projects/arbiter/packages/cli/src/commands/check.ts file    9.63 KB 2025-09-19 19:12:32
/home/nathan/Projects/arbiter/packages/cli/src/commands/compat.ts file   13.81 KB 2025-09-19 19:12:33
/home/nathan/Projects/arbiter/packages/cli/src/commands/create.ts file   17.73 KB 2025-09-19 19:12:33
/home/nathan/Projects/arbiter/packages/cli/src/commands/diff.ts file   16.96 KB 2025-09-19 19:12:33
/home/nathan/Projects/arbiter/packages/cli/src/commands/docs.ts file   23.71 KB 2025-09-19 19:12:33
/home/nathan/Projects/arbiter/packages/cli/src/commands/epic.ts file   33.22 KB 2025-09-19 19:12:33
/home/nathan/Projects/arbiter/packages/cli/src/commands/examples.ts file   31.35 KB 2025-09-19 19:12:33
/home/nathan/Projects/arbiter/packages/cli/src/commands/execute.ts file   33.55 KB 2025-09-19 19:12:33
/home/nathan/Projects/arbiter/packages/cli/src/commands/explain.ts file   26.32 KB 2025-09-19 19:12:33
/home/nathan/Projects/arbiter/packages/cli/src/commands/export.ts file   11.26 KB 2025-09-19 19:12:33
/home/nathan/Projects/arbiter/packages/cli/src/commands/generate.ts file  116.29 KB 2025-09-19 19:12:33
/home/nathan/Projects/arbiter/packages/cli/src/commands/github-template.ts file   20.29 KB 2025-09-19 19:12:33
/home/nathan/Projects/arbiter/packages/cli/src/commands/github-templates.ts file   21.60 KB 2025-09-19 19:12:34
/home/nathan/Projects/arbiter/packages/cli/src/commands/ide.ts file   22.15 KB 2025-09-19 19:12:34
/home/nathan/Projects/arbiter/packages/cli/src/commands/import.ts file   16.43 KB 2025-09-19 19:12:34
/home/nathan/Projects/arbiter/packages/cli/src/commands/init.ts file    8.00 KB 2025-09-19 21:08:30
/home/nathan/Projects/arbiter/packages/cli/src/commands/integrate.ts file   24.36 KB 2025-09-19 19:12:34
/home/nathan/Projects/arbiter/packages/cli/src/commands/onboard.ts file   36.92 KB 2025-09-19 19:12:34
/home/nathan/Projects/arbiter/packages/cli/src/commands/preview.ts file   12.97 KB 2025-09-19 19:12:34
/home/nathan/Projects/arbiter/packages/cli/src/commands/rename.ts file    5.44 KB 2025-09-19 19:12:34
/home/nathan/Projects/arbiter/packages/cli/src/commands/surface.ts file    8.21 KB 2025-09-19 20:22:46
/home/nathan/Projects/arbiter/packages/cli/src/commands/sync.ts file   26.66 KB 2025-09-19 19:12:34
/home/nathan/Projects/arbiter/packages/cli/src/commands/template.ts file    9.26 KB 2025-09-18 16:28:54
/home/nathan/Projects/arbiter/packages/cli/src/commands/templates.ts file   10.65 KB 2025-09-19 19:12:34
/home/nathan/Projects/arbiter/packages/cli/src/commands/test.ts file   26.58 KB 2025-09-19 19:12:34
/home/nathan/Projects/arbiter/packages/cli/src/commands/tests.ts file   32.82 KB 2025-09-19 19:12:34
/home/nathan/Projects/arbiter/packages/cli/src/commands/validate.ts file    8.92 KB 2025-09-19 19:12:34
/home/nathan/Projects/arbiter/packages/cli/src/commands/version.ts file   47.37 KB 2025-09-19 19:12:34
/home/nathan/Projects/arbiter/packages/cli/src/commands/watch.ts file   10.79 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/commands/webhook.ts file   13.09 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/config.ts     file    9.80 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/connection-validator.ts file    5.21 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/constraints   dir    202.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/packages/cli/src/constraints/README.md file   12.88 KB 2025-09-18 17:54:51
/home/nathan/Projects/arbiter/packages/cli/src/constraints/cli-integration.ts file   12.15 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/constraints/core.ts file   12.57 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/constraints/filesystem.ts file   13.71 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/packages/cli/src/constraints/idempotency.ts file   19.95 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/constraints/index.ts file   18.32 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/constraints/monitoring.ts file   19.37 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/constraints/sandbox.ts file   10.66 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/packages/cli/src/constraints/schema.ts file   14.62 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/cue           dir     16.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/packages/cli/src/cue/index.ts  file   19.15 KB 2025-09-19 21:37:26
/home/nathan/Projects/arbiter/packages/cli/src/index.ts      file   703.00 B 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/packages/cli/src/language-plugins dir    102.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/packages/cli/src/language-plugins/__tests__ dir     48.00 B 2025-09-19 18:45:04
/home/nathan/Projects/arbiter/packages/cli/src/language-plugins/__tests__/language-plugins.test.ts file   17.02 KB 2025-09-19 18:45:32
/home/nathan/Projects/arbiter/packages/cli/src/language-plugins/go.ts file   37.99 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/language-plugins/index.ts file    5.10 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/language-plugins/python.ts file   37.27 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/language-plugins/rust.ts file   47.03 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/language-plugins/typescript.ts file   15.26 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/performance-test.ts file    8.95 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/templates     dir     16.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/packages/cli/src/templates/index.ts file   13.03 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/test-template-system.ts file    4.48 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/types.ts      file   17.26 KB 2025-09-19 21:13:06
/home/nathan/Projects/arbiter/packages/cli/src/utils         dir    570.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/packages/cli/src/utils/__tests__ dir     42.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/packages/cli/src/utils/__tests__/git-detection.test.ts file    7.43 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/utils/debounce.ts file    1.31 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/packages/cli/src/utils/file-based-template-manager.ts file   21.88 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/utils/file-watcher.ts file    6.29 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/packages/cli/src/utils/formatting.ts file    6.52 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/utils/git-detection.ts file    8.91 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/utils/github-sync.ts file   30.92 KB 2025-09-19 19:12:35
/home/nathan/Projects/arbiter/packages/cli/src/utils/github-template-config.ts file   25.06 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/cli/src/utils/github-templates.ts file   15.74 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/cli/src/utils/performance.ts file    7.62 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/cli/src/utils/platform-detection.ts file    8.63 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/cli/src/utils/progress.ts file   13.85 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/cli/src/utils/sharded-storage.ts file   19.21 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/cli/src/utils/smart-naming.test.ts file    6.58 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/cli/src/utils/smart-naming.ts file   12.93 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/cli/src/utils/standardized-output.ts file   12.75 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/cli/src/utils/ux-polish.ts file   12.54 KB 2025-09-18 16:28:53
/home/nathan/Projects/arbiter/packages/cli/src/validation    dir     40.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/packages/cli/src/validation/__tests__ dir    118.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/packages/cli/src/validation/__tests__/debug-spec.test.ts file    2.04 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/cli/src/validation/__tests__/warnings-property.test.ts file   19.69 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/cli/src/validation/__tests__/warnings.test.ts file   33.14 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/cli/src/validation/warnings.ts file   18.86 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/cli/tsconfig.json     file    1.57 KB 2025-09-19 19:37:41
/home/nathan/Projects/arbiter/packages/shared                dir     64.00 B 2025-09-19 20:24:19
/home/nathan/Projects/arbiter/packages/shared/package.json   file   748.00 B 2025-09-19 20:18:48
/home/nathan/Projects/arbiter/packages/shared/src            dir    314.00 B 2025-09-19 20:24:09
/home/nathan/Projects/arbiter/packages/shared/src/__tests__  dir     72.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/packages/shared/src/__tests__/issue-schema.test.ts file    5.45 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/shared/src/__tests__/types-v2.test.ts file   18.29 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/shared/src/index.ts   file   202.00 B 2025-09-19 20:21:42
/home/nathan/Projects/arbiter/packages/shared/src/migration.ts file   877.00 B 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/shared/src/types.ts   file    43.00 B 2025-09-19 20:17:46
/home/nathan/Projects/arbiter/packages/shared/src/utils.ts   file    2.54 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/shared/src/version.ts file    2.44 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/packages/shared/tsconfig.json  file   384.00 B 2025-09-19 20:19:32
/home/nathan/Projects/arbiter/scripts                        dir    184.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/scripts/cloudflare-tunnel.sh   file   19.26 KB 2025-09-14 12:43:13
/home/nathan/Projects/arbiter/scripts/local-ci.sh            file    1.12 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/scripts/sync-versions.ts       file    4.12 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/scripts/test-nats.ts           file    4.78 KB 2025-09-18 16:28:52
/home/nathan/Projects/arbiter/scripts/test-webhooks.sh       file   11.91 KB 2025-09-14 12:21:25
/home/nathan/Projects/arbiter/scripts/update-version.js      file    2.75 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/tests                          dir     36.00 B 2025-09-05 22:36:39
/home/nathan/Projects/arbiter/tests/e2e-docker-compose       dir    312.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/README.md file    5.83 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/app   dir     60.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/app/index.js file    1.10 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/app/package.json file   172.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/docker-compose-e2e.test.ts file    9.32 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/docker-compose.yml file    1.45 KB 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/package.json file   315.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/run-e2e-tests.sh file    7.45 KB 2025-09-05 22:59:42
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/services dir     26.00 B 2025-09-05 22:53:21
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/services/node-app dir     62.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/services/node-app/package.json file   356.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/services/node-app/server.js file    3.97 KB 2025-09-19 19:12:36
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/src   dir     16.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/src/index.ts file   246.00 B 2025-09-19 19:02:42
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/test-e2e.sh file    3.54 KB 2025-09-05 23:22:06
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/tests dir     46.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/tests/composition_report.json file   238.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/tests/e2e-docker-compose/tsconfig.json file   357.00 B 2025-09-19 19:02:00
/home/nathan/Projects/arbiter/tsconfig.json                  file    1.32 KB 2025-09-19 21:32:39
</pre>
                </div>
            </div>
            <div class="file-section" id="file-2">
                <div class="file-header">ğŸ“„ packages/cli/src/validation/warnings.ts</div>
                <div class="file-content">
                    <pre>/**
 * Validation Warning System
 *
 * This module provides a comprehensive warning system that checks CUE specifications
 * for completeness and forces agents to create detailed, production-ready specs.
 *
 * Warnings block generation unless --force flag is used.
 */

import chalk from &amp;#39;chalk&amp;#39;;

// Normalized spec interface for validation
interface NormalizedSpec {
  product?: { name?: string; goals?: string[] };
  metadata?: { name?: string; version?: string; description?: string };
  services?: Record&amp;lt;string, any&amp;gt;;
  ui?: { routes?: any[] };
  tests?: any[];
  epics?: any[];
  security?: any;
  performance?: any;
  observability?: any;
  environments?: any;
  locators?: any;
  data?: any;
  docs?: any;
}

export interface ValidationWarning {
  category: string;
  severity: &amp;#39;warning&amp;#39; | &amp;#39;error&amp;#39;;
  message: string;
  suggestion: string;
  path?: string;
}

export interface ValidationResult {
  hasWarnings: boolean;
  hasErrors: boolean;
  warnings: ValidationWarning[];
  errors: ValidationWarning[];
}

/**
 * Main validation function - checks all warning categories
 */
export function validateSpecification(spec: any): ValidationResult {
  const warnings: ValidationWarning[] &#x3D; [];

  // Normalize spec to ensure we have a consistent interface
  const normalizedSpec &#x3D; normalizeSpec(spec);

  // Run all validators
  warnings.push(...validateTestDefinitions(normalizedSpec));
  warnings.push(...validateEpicsAndTasks(normalizedSpec));
  warnings.push(...validateServiceCompleteness(normalizedSpec));
  warnings.push(...validateDocumentation(normalizedSpec));
  warnings.push(...validateSecurity(normalizedSpec));
  warnings.push(...validatePerformanceSpecs(normalizedSpec));
  warnings.push(...validateUICompleteness(normalizedSpec));
  warnings.push(...validateDataManagement(normalizedSpec));
  warnings.push(...validateObservability(normalizedSpec));
  warnings.push(...validateEnvironmentConfig(normalizedSpec));

  const errors &#x3D; warnings.filter(w &#x3D;&amp;gt; w.severity &#x3D;&#x3D;&#x3D; &amp;#39;error&amp;#39;);
  const warningList &#x3D; warnings.filter(w &#x3D;&amp;gt; w.severity &#x3D;&#x3D;&#x3D; &amp;#39;warning&amp;#39;);

  return {
    hasWarnings: warningList.length &amp;gt; 0,
    hasErrors: errors.length &amp;gt; 0,
    warnings: warningList,
    errors,
  };
}

/**
 * Normalize any spec format to a consistent interface
 */
function normalizeSpec(spec: any): NormalizedSpec {
  if (!spec) return {};

  return {
    product: spec.product,
    metadata: spec.metadata,
    services: spec.services,
    ui: spec.ui,
    tests: spec.tests,
    epics: spec.epics,
    security: spec.security,
    performance: spec.performance,
    observability: spec.observability,
    environments: spec.environments,
    locators: spec.locators,
    data: spec.data,
    docs: spec.docs,
  };
}

/**
 * Check if specification has comprehensive test definitions
 */
function validateTestDefinitions(spec: NormalizedSpec): ValidationWarning[] {
  const warnings: ValidationWarning[] &#x3D; [];

  // Check for missing test suites
  if (!spec.tests || spec.tests.length &#x3D;&#x3D;&#x3D; 0) {
    warnings.push({
      category: &amp;#39;Testing&amp;#39;,
      severity: &amp;#39;warning&amp;#39;,
      message: &amp;#39;No test suites defined&amp;#39;,
      suggestion: &amp;#39;Add comprehensive test coverage with unit, integration, and e2e tests&amp;#39;,
      path: &amp;#39;tests&amp;#39;,
    });
  } else {
    // Check for test coverage completeness
    const hasUnit &#x3D; spec.tests.some(t &#x3D;&amp;gt; t.type &#x3D;&#x3D;&#x3D; &amp;#39;unit&amp;#39;);
    const hasIntegration &#x3D; spec.tests.some(t &#x3D;&amp;gt; t.type &#x3D;&#x3D;&#x3D; &amp;#39;integration&amp;#39;);
    const hasE2E &#x3D; spec.tests.some(t &#x3D;&amp;gt; t.type &#x3D;&#x3D;&#x3D; &amp;#39;e2e&amp;#39;);

    if (!hasUnit) {
      warnings.push({
        category: &amp;#39;Testing&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &amp;#39;Missing unit tests&amp;#39;,
        suggestion: &amp;#39;Add unit test suite to validate individual components&amp;#39;,
        path: &amp;#39;tests&amp;#39;,
      });
    }

    if (!hasIntegration) {
      warnings.push({
        category: &amp;#39;Testing&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &amp;#39;Missing integration tests&amp;#39;,
        suggestion: &amp;#39;Add integration test suite to validate service interactions&amp;#39;,
        path: &amp;#39;tests&amp;#39;,
      });
    }

    if (!hasE2E) {
      warnings.push({
        category: &amp;#39;Testing&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &amp;#39;Missing end-to-end tests&amp;#39;,
        suggestion: &amp;#39;Add e2e test suite to validate complete user workflows&amp;#39;,
        path: &amp;#39;tests&amp;#39;,
      });
    }

    // Check for test cases without assertions
    spec.tests.forEach((testSuite, idx) &#x3D;&amp;gt; {
      if (!testSuite.cases || testSuite.cases.length &#x3D;&#x3D;&#x3D; 0) {
        warnings.push({
          category: &amp;#39;Testing&amp;#39;,
          severity: &amp;#39;warning&amp;#39;,
          message: &#x60;Test suite &amp;#39;${testSuite.name}&amp;#39; has no test cases&#x60;,
          suggestion: &amp;#39;Add specific test cases with clear assertions&amp;#39;,
          path: &#x60;tests[${idx}].cases&#x60;,
        });
      }
    });
  }

  return warnings;
}

/**
 * Check for missing epics and tasks for source services
 */
function validateEpicsAndTasks(spec: NormalizedSpec): ValidationWarning[] {
  const warnings: ValidationWarning[] &#x3D; [];

  // Check if epics/tasks are defined
  const hasEpics &#x3D; spec.epics &amp;amp;&amp;amp; spec.epics.length &amp;gt; 0;
  const hasTasks &#x3D; spec.epics?.some(epic &#x3D;&amp;gt; epic.tasks &amp;amp;&amp;amp; epic.tasks.length &amp;gt; 0);

  // Find source services (not pre-existing containers)
  const sourceServices &#x3D; Object.entries(spec.services || {}).filter(
    ([_, service]) &#x3D;&amp;gt;
      service.type &#x3D;&#x3D;&#x3D; &amp;#39;deployment&amp;#39; &amp;amp;&amp;amp; service.serviceType &#x3D;&#x3D;&#x3D; &amp;#39;bespoke&amp;#39; &amp;amp;&amp;amp; !service.image // No pre-built image &#x3D; source code
  );

  if (sourceServices.length &amp;gt; 0) {
    if (!hasEpics) {
      warnings.push({
        category: &amp;#39;Project Management&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &amp;#39;Source services found but no epics defined&amp;#39;,
        suggestion: &#x60;Add epics to track implementation of custom services: ${sourceServices.map(([name]) &#x3D;&amp;gt; name).join(&amp;#39;, &amp;#39;)}&#x60;,
        path: &amp;#39;epics&amp;#39;,
      });
    }

    if (!hasTasks) {
      warnings.push({
        category: &amp;#39;Project Management&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &amp;#39;Source services found but no implementation tasks defined&amp;#39;,
        suggestion: &#x60;Add detailed tasks with dependencies for implementing: ${sourceServices.map(([name]) &#x3D;&amp;gt; name).join(&amp;#39;, &amp;#39;)}&#x60;,
        path: &amp;#39;epics[].tasks&amp;#39;,
      });
    }

    // Check each source service has corresponding epic/tasks
    sourceServices.forEach(([serviceName, service]) &#x3D;&amp;gt; {
      const hasServiceEpic &#x3D; spec.epics?.some(
        epic &#x3D;&amp;gt;
          epic.name.toLowerCase().includes(serviceName.toLowerCase()) ||
          epic.description?.toLowerCase().includes(serviceName.toLowerCase())
      );

      if (!hasServiceEpic) {
        warnings.push({
          category: &amp;#39;Project Management&amp;#39;,
          severity: &amp;#39;warning&amp;#39;,
          message: &#x60;Source service &amp;#39;${serviceName}&amp;#39; has no corresponding epic&#x60;,
          suggestion: &#x60;Add epic for implementing ${serviceName} service with detailed tasks&#x60;,
          path: &#x60;services.${serviceName}&#x60;,
        });
      }
    });
  }

  return warnings;
}

/**
 * Check service definitions for completeness
 */
function validateServiceCompleteness(spec: NormalizedSpec): ValidationWarning[] {
  const warnings: ValidationWarning[] &#x3D; [];

  Object.entries(spec.services || {}).forEach(([serviceName, service]) &#x3D;&amp;gt; {
    const basePath &#x3D; &#x60;services.${serviceName}&#x60;;

    // Check for missing essential service properties
    if (!service.language) {
      warnings.push({
        category: &amp;#39;Service Definition&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &#x60;Service &amp;#39;${serviceName}&amp;#39; missing language specification&#x60;,
        suggestion: &amp;#39;Specify the programming language (typescript, python, rust, go, etc.)&amp;#39;,
        path: &#x60;${basePath}.language&#x60;,
      });
    }

    if (!service.ports || service.ports.length &#x3D;&#x3D;&#x3D; 0) {
      warnings.push({
        category: &amp;#39;Service Definition&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &#x60;Service &amp;#39;${serviceName}&amp;#39; has no port definitions&#x60;,
        suggestion: &amp;#39;Define exposed ports with protocol and target port&amp;#39;,
        path: &#x60;${basePath}.ports&#x60;,
      });
    }

    // Check for missing health checks on source services
    if (service.serviceType &#x3D;&#x3D;&#x3D; &amp;#39;bespoke&amp;#39; &amp;amp;&amp;amp; !service.healthCheck) {
      warnings.push({
        category: &amp;#39;Service Definition&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &#x60;Source service &amp;#39;${serviceName}&amp;#39; missing health check configuration&#x60;,
        suggestion: &amp;#39;Add health check endpoint and configuration for monitoring&amp;#39;,
        path: &#x60;${basePath}.healthCheck&#x60;,
      });
    }

    // Check for missing resource limits
    if (!service.resources) {
      warnings.push({
        category: &amp;#39;Service Definition&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &#x60;Service &amp;#39;${serviceName}&amp;#39; missing resource specifications&#x60;,
        suggestion: &amp;#39;Define CPU and memory limits for proper resource management&amp;#39;,
        path: &#x60;${basePath}.resources&#x60;,
      });
    }

    // Check for missing environment configuration
    if (
      service.serviceType &#x3D;&#x3D;&#x3D; &amp;#39;bespoke&amp;#39; &amp;amp;&amp;amp;
      (!service.env || Object.keys(service.env).length &#x3D;&#x3D;&#x3D; 0)
    ) {
      warnings.push({
        category: &amp;#39;Service Definition&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &#x60;Source service &amp;#39;${serviceName}&amp;#39; missing environment configuration&#x60;,
        suggestion: &amp;#39;Define environment variables for configuration management&amp;#39;,
        path: &#x60;${basePath}.env&#x60;,
      });
    }
  });

  return warnings;
}

/**
 * Check for missing documentation
 */
function validateDocumentation(spec: NormalizedSpec): ValidationWarning[] {
  const warnings: ValidationWarning[] &#x3D; [];

  if (!spec.product?.goals || spec.product.goals.length &#x3D;&#x3D;&#x3D; 0) {
    warnings.push({
      category: &amp;#39;Documentation&amp;#39;,
      severity: &amp;#39;warning&amp;#39;,
      message: &amp;#39;Missing product goals and objectives&amp;#39;,
      suggestion: &amp;#39;Define clear product goals to guide development decisions&amp;#39;,
      path: &amp;#39;product.goals&amp;#39;,
    });
  }

  if (!spec.metadata?.description) {
    warnings.push({
      category: &amp;#39;Documentation&amp;#39;,
      severity: &amp;#39;warning&amp;#39;,
      message: &amp;#39;Missing project description&amp;#39;,
      suggestion: &amp;#39;Add comprehensive project description in metadata&amp;#39;,
      path: &amp;#39;metadata.description&amp;#39;,
    });
  }

  // Check for missing API documentation
  const hasApiServices &#x3D; Object.values(spec.services || {}).some(s &#x3D;&amp;gt;
    s.ports?.some(p &#x3D;&amp;gt; p.name?.includes(&amp;#39;http&amp;#39;) || p.name?.includes(&amp;#39;api&amp;#39;))
  );

  if (hasApiServices &amp;amp;&amp;amp; (!spec.docs || !spec.docs.api)) {
    warnings.push({
      category: &amp;#39;Documentation&amp;#39;,
      severity: &amp;#39;warning&amp;#39;,
      message: &amp;#39;API services found but no API documentation specified&amp;#39;,
      suggestion: &amp;#39;Add API documentation configuration (OpenAPI, endpoints, etc.)&amp;#39;,
      path: &amp;#39;docs.api&amp;#39;,
    });
  }

  return warnings;
}

/**
 * Check for security configurations
 */
function validateSecurity(spec: NormalizedSpec): ValidationWarning[] {
  const warnings: ValidationWarning[] &#x3D; [];

  // Check for missing authentication on UI routes
  if (spec.ui?.routes &amp;amp;&amp;amp; spec.ui.routes.length &amp;gt; 0) {
    const unprotectedRoutes &#x3D; spec.ui.routes.filter(
      route &#x3D;&amp;gt; route.capabilities?.includes(&amp;#39;admin&amp;#39;) &amp;amp;&amp;amp; !route.requiresAuth
    );

    if (unprotectedRoutes.length &amp;gt; 0) {
      warnings.push({
        category: &amp;#39;Security&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &amp;#39;Admin routes found without authentication requirements&amp;#39;,
        suggestion: &#x60;Add requiresAuth: true to admin routes: ${unprotectedRoutes.map(r &#x3D;&amp;gt; r.path).join(&amp;#39;, &amp;#39;)}&#x60;,
        path: &amp;#39;ui.routes&amp;#39;,
      });
    }
  }

  // Check for missing security configuration
  if (!spec.security) {
    warnings.push({
      category: &amp;#39;Security&amp;#39;,
      severity: &amp;#39;warning&amp;#39;,
      message: &amp;#39;Missing security configuration&amp;#39;,
      suggestion: &amp;#39;Define authentication, authorization, and security policies&amp;#39;,
      path: &amp;#39;security&amp;#39;,
    });
  }

  return warnings;
}

/**
 * Check for performance specifications
 */
function validatePerformanceSpecs(spec: NormalizedSpec): ValidationWarning[] {
  const warnings: ValidationWarning[] &#x3D; [];

  if (!spec.performance) {
    warnings.push({
      category: &amp;#39;Performance&amp;#39;,
      severity: &amp;#39;warning&amp;#39;,
      message: &amp;#39;Missing performance specifications&amp;#39;,
      suggestion: &amp;#39;Define SLAs, response time targets, and throughput requirements&amp;#39;,
      path: &amp;#39;performance&amp;#39;,
    });
  }

  // Check services for missing performance configuration
  Object.entries(spec.services || {}).forEach(([serviceName, service]) &#x3D;&amp;gt; {
    if (service.serviceType &#x3D;&#x3D;&#x3D; &amp;#39;bespoke&amp;#39; &amp;amp;&amp;amp; !service.resources?.limits) {
      warnings.push({
        category: &amp;#39;Performance&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &#x60;Service &amp;#39;${serviceName}&amp;#39; missing resource limits&#x60;,
        suggestion: &amp;#39;Define CPU and memory limits for performance predictability&amp;#39;,
        path: &#x60;services.${serviceName}.resources.limits&#x60;,
      });
    }
  });

  return warnings;
}

/**
 * Check UI completeness
 */
function validateUICompleteness(spec: NormalizedSpec): ValidationWarning[] {
  const warnings: ValidationWarning[] &#x3D; [];

  if (spec.ui?.routes &amp;amp;&amp;amp; spec.ui.routes.length &amp;gt; 0) {
    spec.ui.routes.forEach((route, idx) &#x3D;&amp;gt; {
      const basePath &#x3D; &#x60;ui.routes[${idx}]&#x60;;

      if (!route.components || route.components.length &#x3D;&#x3D;&#x3D; 0) {
        warnings.push({
          category: &amp;#39;UI Design&amp;#39;,
          severity: &amp;#39;warning&amp;#39;,
          message: &#x60;Route &amp;#39;${route.path}&amp;#39; missing component specifications&#x60;,
          suggestion: &amp;#39;Define UI components needed for this route&amp;#39;,
          path: &#x60;${basePath}.components&#x60;,
        });
      }

      if (!route.capabilities || route.capabilities.length &#x3D;&#x3D;&#x3D; 0) {
        warnings.push({
          category: &amp;#39;UI Design&amp;#39;,
          severity: &amp;#39;warning&amp;#39;,
          message: &#x60;Route &amp;#39;${route.path}&amp;#39; missing capability definitions&#x60;,
          suggestion: &amp;#39;Define user capabilities/permissions for this route&amp;#39;,
          path: &#x60;${basePath}.capabilities&#x60;,
        });
      }
    });

    // Check for missing locators (test automation)
    if (!spec.locators || Object.keys(spec.locators).length &#x3D;&#x3D;&#x3D; 0) {
      warnings.push({
        category: &amp;#39;UI Design&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &amp;#39;UI routes defined but no test locators specified&amp;#39;,
        suggestion: &amp;#39;Add CSS selectors/test IDs for automated testing&amp;#39;,
        path: &amp;#39;locators&amp;#39;,
      });
    }
  }

  return warnings;
}

/**
 * Check data management completeness
 */
function validateDataManagement(spec: NormalizedSpec): ValidationWarning[] {
  const warnings: ValidationWarning[] &#x3D; [];

  // Check for database usage without proper configuration
  const hasDatabaseServices &#x3D; Object.values(spec.services || {}).some(
    s &#x3D;&amp;gt;
      s.image?.includes(&amp;#39;postgres&amp;#39;) ||
      s.image?.includes(&amp;#39;mysql&amp;#39;) ||
      s.image?.includes(&amp;#39;mongo&amp;#39;) ||
      s.serviceType &#x3D;&#x3D;&#x3D; &amp;#39;database&amp;#39;
  );

  if (hasDatabaseServices) {
    if (!spec.data) {
      warnings.push({
        category: &amp;#39;Data Management&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &amp;#39;Database services found but no data schema defined&amp;#39;,
        suggestion: &amp;#39;Add data models, migrations, and backup strategies&amp;#39;,
        path: &amp;#39;data&amp;#39;,
      });
    }

    // Check for missing migration strategy
    if (!spec.data?.migrations) {
      warnings.push({
        category: &amp;#39;Data Management&amp;#39;,
        severity: &amp;#39;warning&amp;#39;,
        message: &amp;#39;Database services found but no migration strategy defined&amp;#39;,
        suggestion: &amp;#39;Define database migration and versioning approach&amp;#39;,
        path: &amp;#39;data.migrations&amp;#39;,
      });
    }
  }

  return warnings;
}

/**
 * Check observability configuration
 */
function validateObservability(spec: NormalizedSpec): ValidationWarning[] {
  const warnings: ValidationWarning[] &#x3D; [];

  const hasServices &#x3D; Object.keys(spec.services || {}).length &amp;gt; 0;

  if (hasServices &amp;amp;&amp;amp; !spec.observability) {
    warnings.push({
      category: &amp;#39;Observability&amp;#39;,
      severity: &amp;#39;warning&amp;#39;,
      message: &amp;#39;Services defined but no observability configuration&amp;#39;,
      suggestion: &amp;#39;Add logging, monitoring, and alerting configuration&amp;#39;,
      path: &amp;#39;observability&amp;#39;,
    });
  }

  if (hasServices &amp;amp;&amp;amp; !spec.observability?.logging) {
    warnings.push({
      category: &amp;#39;Observability&amp;#39;,
      severity: &amp;#39;warning&amp;#39;,
      message: &amp;#39;Missing logging configuration&amp;#39;,
      suggestion: &amp;#39;Define log levels, formats, and aggregation strategy&amp;#39;,
      path: &amp;#39;observability.logging&amp;#39;,
    });
  }

  if (hasServices &amp;amp;&amp;amp; !spec.observability?.monitoring) {
    warnings.push({
      category: &amp;#39;Observability&amp;#39;,
      severity: &amp;#39;warning&amp;#39;,
      message: &amp;#39;Missing monitoring configuration&amp;#39;,
      suggestion: &amp;#39;Define metrics collection and health monitoring&amp;#39;,
      path: &amp;#39;observability.monitoring&amp;#39;,
    });
  }

  return warnings;
}

/**
 * Check environment configuration
 */
function validateEnvironmentConfig(spec: NormalizedSpec): ValidationWarning[] {
  const warnings: ValidationWarning[] &#x3D; [];

  // Check for missing environment definitions
  if (!spec.environments || Object.keys(spec.environments).length &#x3D;&#x3D;&#x3D; 0) {
    warnings.push({
      category: &amp;#39;Environment Config&amp;#39;,
      severity: &amp;#39;warning&amp;#39;,
      message: &amp;#39;Missing environment configurations&amp;#39;,
      suggestion: &amp;#39;Define development, staging, and production environments&amp;#39;,
      path: &amp;#39;environments&amp;#39;,
    });
  } else {
    const requiredEnvs &#x3D; [&amp;#39;development&amp;#39;, &amp;#39;production&amp;#39;];
    const definedEnvs &#x3D; Object.keys(spec.environments);

    requiredEnvs.forEach(env &#x3D;&amp;gt; {
      if (!definedEnvs.includes(env)) {
        warnings.push({
          category: &amp;#39;Environment Config&amp;#39;,
          severity: &amp;#39;warning&amp;#39;,
          message: &#x60;Missing ${env} environment configuration&#x60;,
          suggestion: &#x60;Add ${env} environment with proper configuration&#x60;,
          path: &#x60;environments.${env}&#x60;,
        });
      }
    });
  }

  return warnings;
}

/**
 * Format warnings for CLI output
 */
export function formatWarnings(result: ValidationResult): string {
  const lines: string[] &#x3D; [];

  if (result.hasErrors) {
    lines.push(chalk.red.bold(&amp;#39;\nâŒ ERRORS (must fix):&amp;#39;));
    result.errors.forEach(error &#x3D;&amp;gt; {
      lines.push(chalk.red(&#x60;  â€¢ ${error.category}: ${error.message}&#x60;));
      lines.push(chalk.gray(&#x60;    ${error.suggestion}&#x60;));
      if (error.path) lines.push(chalk.gray(&#x60;    Path: ${error.path}&#x60;));
    });
  }

  if (result.hasWarnings) {
    lines.push(chalk.yellow.bold(&amp;#39;\nâš ï¸  WARNINGS (recommend fixing):&amp;#39;));
    result.warnings.forEach(warning &#x3D;&amp;gt; {
      lines.push(chalk.yellow(&#x60;  â€¢ ${warning.category}: ${warning.message}&#x60;));
      lines.push(chalk.gray(&#x60;    ${warning.suggestion}&#x60;));
      if (warning.path) lines.push(chalk.gray(&#x60;    Path: ${warning.path}&#x60;));
    });
  }

  if (result.hasWarnings || result.hasErrors) {
    lines.push(chalk.blue.bold(&amp;#39;\nğŸ’¡ Use --force to generate anyway&amp;#39;));
    lines.push(chalk.red.bold(&amp;#39;\nğŸš¨ IMPORTANT FOR AI AGENTS:&amp;#39;));
    lines.push(
      chalk.yellow(
        &amp;#39;IF YOU NEED INFORMATION TO COMPLETE THE SPEC, ASK THE PRODUCT OWNER (USER) FOR IT.&amp;#39;
      )
    );
    lines.push(chalk.yellow(&amp;#39;YOU MUST REQUEST APPROVAL FROM THE USER BEFORE USING &#x60;--force&#x60;.&amp;#39;));
  }

  return lines.join(&amp;#39;\n&amp;#39;);
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-3">
                <div class="file-header">ğŸ“„ apps/api/src/ir.ts</div>
                <div class="file-content">
                    <pre>/**
 * Intermediate Representation (IR) generator for diagrams and visualizations
 */
import type { IRKind, IRResponse } from &amp;#39;./types.ts&amp;#39;;
import { getCurrentTimestamp, logger } from &amp;#39;./utils.ts&amp;#39;;

export class IRGenerator {
  /**
   * Generate IR for different diagram types
   */
  async generateIR(kind: IRKind, resolved: Record&amp;lt;string, unknown&amp;gt;): Promise&amp;lt;IRResponse&amp;gt; {
    const startTime &#x3D; Date.now();

    try {
      let data: Record&amp;lt;string, unknown&amp;gt;;

      switch (kind) {
        case &amp;#39;flow&amp;#39;:
          data &#x3D; this.generateFlowIR(resolved);
          break;
        case &amp;#39;fsm&amp;#39;:
          data &#x3D; this.generateFsmIR(resolved);
          break;
        case &amp;#39;view&amp;#39;:
          data &#x3D; this.generateViewIR(resolved);
          break;
        case &amp;#39;site&amp;#39;:
          data &#x3D; this.generateSiteIR(resolved);
          break;
        case &amp;#39;capabilities&amp;#39;:
          data &#x3D; this.generateCapabilitiesIR(resolved);
          break;
        case &amp;#39;flows&amp;#39;:
          data &#x3D; this.generateFlowsIR(resolved);
          break;
        case &amp;#39;dependencies&amp;#39;:
          data &#x3D; this.generateDependenciesIR(resolved);
          break;
        case &amp;#39;coverage&amp;#39;:
          data &#x3D; this.generateCoverageIR(resolved);
          break;
        default:
          throw new Error(&#x60;Unknown IR kind: ${kind}&#x60;);
      }

      const duration &#x3D; Date.now() - startTime;

      // Reduced logging - only log for debug level when enabled
      // logger.debug(&amp;quot;Generated IR&amp;quot;, {
      //   kind,
      //   nodeCount: this.getNodeCount(data),
      //   duration,
      // });

      return {
        kind,
        data,
        generated_at: getCurrentTimestamp(),
      };
    } catch (error) {
      logger.error(&amp;#39;IR generation failed&amp;#39;, error instanceof Error ? error : undefined, { kind });

      throw new Error(
        &#x60;Failed to generate ${kind} IR: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;
      );
    }
  }

  /**
   * Generate flow IR for Mermaid (flowchart/sequence) - from TODO.md specification
   */
  private generateFlowIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    const flows &#x3D; this.extractFlows(resolved);
    const flowIRs: any[] &#x3D; [];

    Object.entries(flows).forEach(([flowId, flow]) &#x3D;&amp;gt; {
      const nodes: any[] &#x3D; [];
      const edges: any[] &#x3D; [];

      if (Array.isArray(flow.steps)) {
        flow.steps.forEach((step: any, index: number) &#x3D;&amp;gt; {
          const nodeId &#x3D; step.id || &#x60;${index}&#x60;;
          const kind &#x3D; this.getFlowStepKind(step);
          const label &#x3D; this.getFlowStepLabel(step, index);

          nodes.push({
            id: nodeId,
            kind,
            label,
          });

          // Create edges based on dependsOn relationships
          if (step.dependsOn &amp;amp;&amp;amp; Array.isArray(step.dependsOn)) {
            step.dependsOn.forEach((depId: string) &#x3D;&amp;gt; {
              edges.push({
                from: depId,
                to: nodeId,
                label: step.transition || &amp;#39;&amp;#39;,
              });
            });
          }
        });
      }

      flowIRs.push({
        id: flowId,
        nodes,
        edges,
      });
    });

    return {
      specHash: this.computeSpecHash(resolved),
      flows: flowIRs,
    };
  }

  /**
   * Generate FSM IR for XState - from TODO.md specification
   */
  private generateFsmIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    // Handle both CUE format (states) and legacy format (stateModels)
    const stateModels &#x3D;
      (resolved.states as Record&amp;lt;string, any&amp;gt;) ||
      (resolved.stateModels as Record&amp;lt;string, any&amp;gt;) ||
      {};
    const fsms: any[] &#x3D; [];

    Object.entries(stateModels).forEach(([fsmId, model]) &#x3D;&amp;gt; {
      const states: Record&amp;lt;string, any&amp;gt; &#x3D; {};

      if (model.states &amp;amp;&amp;amp; typeof model.states &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39;) {
        Object.entries(model.states).forEach(([stateId, state]: [string, any]) &#x3D;&amp;gt; {
          states[stateId] &#x3D; {
            actions: state.actions || [],
            transitions: state.transitions || state.on || {},
          };
        });
      }

      fsms.push({
        id: fsmId,
        name: model.name || fsmId,
        initial: model.initialState || model.initial || &amp;#39;idle&amp;#39;,
        states,
      });
    });

    return {
      specHash: this.computeSpecHash(resolved),
      fsms,
    };
  }

  /**
   * Generate view IR for wireframes - from TODO.md specification
   */
  private generateViewIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    // Handle both CUE format (routes) and legacy format (ui.routes)
    const routes &#x3D; (resolved.routes as Record&amp;lt;string, any&amp;gt;) || (resolved.ui as any)?.routes || {};
    const locators &#x3D; (resolved.locators as Record&amp;lt;string, string&amp;gt;) || {};
    const views: any[] &#x3D; [];

    Object.entries(routes).forEach(([path, route]: [string, any]) &#x3D;&amp;gt; {
      const widgets: any[] &#x3D; [];

      // Extract widgets from route components and map with locators
      if (route.components &amp;amp;&amp;amp; Array.isArray(route.components)) {
        route.components.forEach((component: any) &#x3D;&amp;gt; {
          if (component.type &#x3D;&#x3D;&#x3D; &amp;#39;button&amp;#39; &amp;amp;&amp;amp; component.token) {
            widgets.push({
              type: &amp;#39;button&amp;#39;,
              token: component.token,
              text: component.text || component.token,
            });
          } else if (component.type &#x3D;&#x3D;&#x3D; &amp;#39;input&amp;#39; &amp;amp;&amp;amp; component.token) {
            widgets.push({
              type: &amp;#39;input&amp;#39;,
              token: component.token,
              label: component.label || component.token,
            });
          } else if (component.type &#x3D;&#x3D;&#x3D; &amp;#39;table&amp;#39; &amp;amp;&amp;amp; component.token) {
            widgets.push({
              type: &amp;#39;table&amp;#39;,
              token: component.token,
              columns: component.columns || [],
            });
          }
        });
      }

      // Also extract widgets from referenced locators
      Object.entries(locators).forEach(([token, _selector]) &#x3D;&amp;gt; {
        if (token.startsWith(&amp;#39;btn:&amp;#39;)) {
          widgets.push({
            type: &amp;#39;button&amp;#39;,
            token,
            text: token.replace(&amp;#39;btn:&amp;#39;, &amp;#39;&amp;#39;),
          });
        } else if (token.startsWith(&amp;#39;input:&amp;#39;)) {
          widgets.push({
            type: &amp;#39;input&amp;#39;,
            token,
            label: token.replace(&amp;#39;input:&amp;#39;, &amp;#39;&amp;#39;),
          });
        }
      });

      // Create view for each route (even without widgets for navigation structure)
      views.push({
        id: path,
        name: route.name || path,
        component: route.component,
        layout: route.layout,
        requiresAuth: route.requiresAuth || false,
        widgets,
      });
    });

    return {
      specHash: this.computeSpecHash(resolved),
      views,
    };
  }

  /**
   * Generate site IR (DAG of routes) for Graphviz - from TODO.md specification
   */
  private generateSiteIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    const routes &#x3D; (resolved.ui as any)?.routes || [];
    const nodes: any[] &#x3D; [];
    const edges: any[] &#x3D; [];

    // Create nodes for each route
    routes.forEach((route: any) &#x3D;&amp;gt; {
      nodes.push({
        id: route.id || route.path,
        label: route.name || route.path,
        path: route.path,
        capabilities: route.capabilities || [],
      });
    });

    // Create edges based on route relationships and navigation patterns
    routes.forEach((route: any, index: number) &#x3D;&amp;gt; {
      const routeId &#x3D; route.id || route.path;

      // Connect routes that share capabilities (simplified relationship detection)
      routes.forEach((otherRoute: any, otherIndex: number) &#x3D;&amp;gt; {
        if (index !&#x3D;&#x3D; otherIndex &amp;amp;&amp;amp; route.capabilities &amp;amp;&amp;amp; otherRoute.capabilities) {
          const sharedCaps &#x3D; route.capabilities.filter((cap: string) &#x3D;&amp;gt;
            otherRoute.capabilities.includes(cap)
          );

          if (sharedCaps.length &amp;gt; 0) {
            const otherRouteId &#x3D; otherRoute.id || otherRoute.path;
            edges.push({
              from: routeId,
              to: otherRouteId,
              label: sharedCaps.join(&amp;#39;, &amp;#39;),
              type: &amp;#39;capability&amp;#39;,
            });
          }
        }
      });
    });

    return {
      specHash: this.computeSpecHash(resolved),
      routes: {
        nodes,
        edges,
      },
    };
  }

  private extractFlows(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, any&amp;gt; {
    return (resolved.flows as Record&amp;lt;string, any&amp;gt;) || {};
  }

  private getNodeCount(data: Record&amp;lt;string, unknown&amp;gt;): number {
    const nodes &#x3D; data.nodes;
    return Array.isArray(nodes) ? nodes.length : 0;
  }

  // New helper methods for TODO.md specification compliance
  private getFlowStepKind(step: any): string {
    // Handle CUE specification format
    if (step.type) return step.type;

    // Fallback to legacy test format
    if (step.visit) return &amp;#39;visit&amp;#39;;
    if (step.click) return &amp;#39;click&amp;#39;;
    if (step.fill) return &amp;#39;fill&amp;#39;;
    if (step.expect) return &amp;#39;expect&amp;#39;;
    if (step.expect_api) return &amp;#39;expect_api&amp;#39;;
    return &amp;#39;process&amp;#39;;
  }

  private getFlowStepLabel(step: any, index: number): string {
    // Handle CUE specification format
    if (step.name) return step.name;

    // Fallback to legacy test format
    if (step.visit) return &#x60;Visit: ${step.visit}&#x60;;
    if (step.click) return &#x60;Click: ${step.click}&#x60;;
    if (step.fill) return &#x60;Fill: ${step.fill}&#x60;;
    if (step.expect) return &#x60;Expect: ${step.expect.locator || step.expect}&#x60;;
    if (step.expect_api) return &#x60;API: ${step.expect_api.method} ${step.expect_api.path}&#x60;;
    return &#x60;Step ${index + 1}&#x60;;
  }

  private computeSpecHash(resolved: Record&amp;lt;string, unknown&amp;gt;): string {
    // Simple hash computation - in production you&amp;#39;d want a proper hash like SHA-256
    return &#x60;sha256-${JSON.stringify(resolved).length.toString(16)}&#x60;;
  }

  /**
   * Generate capabilities IR for dependency graph visualization
   */
  private generateCapabilitiesIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    const capabilities &#x3D; (resolved.capabilities as Record&amp;lt;string, any&amp;gt;) || {};
    const nodes: any[] &#x3D; [];
    const edges: any[] &#x3D; [];
    const groups: any[] &#x3D; [];
    const domains &#x3D; new Set&amp;lt;string&amp;gt;();

    // Process capabilities into nodes
    Object.entries(capabilities).forEach(([capId, capability]) &#x3D;&amp;gt; {
      const domain &#x3D; capId.split(&amp;#39;.&amp;#39;)[0];
      domains.add(domain);

      nodes.push({
        id: capId,
        label: capability.name || capId,
        type: &amp;#39;capability&amp;#39;,
        domain: domain,
        properties: {
          complexity: capability.complexity || &amp;#39;medium&amp;#39;,
          priority: capability.priority || &amp;#39;medium&amp;#39;,
          owner: capability.owner || &amp;#39;unknown&amp;#39;,
        },
      });

      // Create dependency edges
      if (capability.depends_on &amp;amp;&amp;amp; Array.isArray(capability.depends_on)) {
        capability.depends_on.forEach((depId: string) &#x3D;&amp;gt; {
          edges.push({
            source: depId,
            target: capId,
            type: &amp;#39;dependency&amp;#39;,
          });
        });
      }
    });

    // Create domain groups
    domains.forEach(domain &#x3D;&amp;gt; {
      const domainNodes &#x3D; nodes.filter(n &#x3D;&amp;gt; n.domain &#x3D;&#x3D;&#x3D; domain);
      groups.push({
        id: domain,
        label: domain.charAt(0).toUpperCase() + domain.slice(1),
        nodeIds: domainNodes.map(n &#x3D;&amp;gt; n.id),
      });
    });

    return {
      type: &amp;#39;directed_graph&amp;#39;,
      nodes,
      edges,
      groups,
      metadata: {
        totalCapabilities: nodes.length,
        dependencies: edges.length,
        domains: domains.size,
      },
    };
  }

  /**
   * Generate flows IR for flowchart visualization (alias for flow)
   */
  private generateFlowsIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    const flows &#x3D; (resolved.flows as Record&amp;lt;string, any&amp;gt;) || {};
    const flowList: any[] &#x3D; [];

    Object.entries(flows).forEach(([flowId, flow]) &#x3D;&amp;gt; {
      flowList.push({
        id: flowId,
        name: flow.name || flowId,
        steps: flow.steps || [],
      });
    });

    return {
      type: &amp;#39;flowchart&amp;#39;,
      flows: flowList,
    };
  }

  /**
   * Generate dependencies IR for layered graph visualization
   */
  private generateDependenciesIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    const capabilities &#x3D; (resolved.capabilities as Record&amp;lt;string, any&amp;gt;) || {};
    const layers: any[] &#x3D; [];
    const processed &#x3D; new Set&amp;lt;string&amp;gt;();
    let layerIndex &#x3D; 0;

    // Build dependency layers (topological sort)
    while (processed.size &amp;lt; Object.keys(capabilities).length &amp;amp;&amp;amp; layerIndex &amp;lt; 10) {
      const currentLayer: any[] &#x3D; [];

      Object.entries(capabilities).forEach(([capId, capability]) &#x3D;&amp;gt; {
        if (processed.has(capId)) return;

        const dependencies &#x3D; capability.depends_on || [];
        const allDepsProcessed &#x3D; dependencies.every((dep: string) &#x3D;&amp;gt; processed.has(dep));

        if (allDepsProcessed) {
          currentLayer.push({
            id: capId,
            label: capability.name || capId,
            dependencies: dependencies,
          });
          processed.add(capId);
        }
      });

      if (currentLayer.length &amp;gt; 0) {
        layers.push({
          level: layerIndex,
          nodes: currentLayer,
        });
      }

      layerIndex++;
    }

    return {
      type: &amp;#39;layered_graph&amp;#39;,
      layers,
    };
  }

  /**
   * Generate coverage IR for test coverage visualization
   */
  private generateCoverageIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    const capabilities &#x3D; (resolved.capabilities as Record&amp;lt;string, any&amp;gt;) || {};
    const tests &#x3D; (resolved.tests as Record&amp;lt;string, any&amp;gt;) || {};

    const totalCapabilities &#x3D; Object.keys(capabilities).length;
    let coveredCapabilities &#x3D; 0;
    const coverage: Record&amp;lt;string, any&amp;gt; &#x3D; {};

    // Calculate coverage for each capability
    Object.entries(capabilities).forEach(([capId, capability]) &#x3D;&amp;gt; {
      const coveringTests &#x3D; Object.entries(tests).filter(([_, test]) &#x3D;&amp;gt; {
        const covers &#x3D; test.covers || [];
        return covers.includes(capId);
      });

      const isCovered &#x3D; coveringTests.length &amp;gt; 0;
      if (isCovered) coveredCapabilities++;

      coverage[capId] &#x3D; {
        covered: isCovered,
        testCount: coveringTests.length,
        tests: coveringTests.map(([testId, _]) &#x3D;&amp;gt; testId),
      };
    });

    const overallCoverage &#x3D;
      totalCapabilities &amp;gt; 0 ? (coveredCapabilities / totalCapabilities) * 100 : 0;

    return {
      type: &amp;#39;coverage_graph&amp;#39;,
      coverage: {
        overall: Math.round(overallCoverage),
        capabilities: coverage,
        summary: {
          total: totalCapabilities,
          covered: coveredCapabilities,
          uncovered: totalCapabilities - coveredCapabilities,
        },
      },
    };
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-4">
                <div class="file-header">ğŸ“„ packages/cli/src/constraints/core.ts</div>
                <div class="file-content">
                    <pre>import { EventEmitter } from &amp;#39;node:events&amp;#39;;
import { performance } from &amp;#39;node:perf_hooks&amp;#39;;

/**
 * Constraint violation error with specific failure details
 */
export class ConstraintViolationError extends Error {
  constructor(
    public readonly constraint: string,
    public readonly actual: unknown,
    public readonly expected: unknown,
    public readonly details?: Record&amp;lt;string, unknown&amp;gt;
  ) {
    super(&#x60;Constraint violation: ${constraint} - Expected ${expected}, got ${actual}&#x60;);
    this.name &#x3D; &amp;#39;ConstraintViolationError&amp;#39;;
  }
}

/**
 * Core constraint types that must be enforced across all operations
 */
export interface Constraints {
  /** Maximum payload size in bytes (â‰¤64 KB) */
  maxPayloadSize: number;
  /** Maximum operation duration in milliseconds (â‰¤750 ms) */
  maxOperationTime: number;
  /** Rate limit in requests per second (~1 rps) */
  rateLimit: {
    requests: number;
    windowMs: number;
  };
  /** API version for schema validation */
  apiVersion: string;
  /** Maximum symlink depth (0 &#x3D; no symlinks allowed) */
  maxSymlinkDepth: number;
}

/**
 * Default constraint values from TODO.md section 13
 */
export const DEFAULT_CONSTRAINTS: Constraints &#x3D; {
  maxPayloadSize: 64 * 1024, // 64 KB
  maxOperationTime: 750, // 750 ms
  rateLimit: {
    requests: 1,
    windowMs: 1000, // 1 second window for ~1 rps
  },
  apiVersion: &amp;#39;2024-12-26&amp;#39;, // Latest as of implementation
  maxSymlinkDepth: 0, // No symlinks allowed
};

/**
 * Operation context for tracking constraint violations
 */
export interface OperationContext {
  operation: string;
  startTime: number;
  payloadSize?: number;
  apiVersion?: string;
  metadata?: Record&amp;lt;string, unknown&amp;gt;;
}

/**
 * Rate limiting state tracker
 */
interface RateLimitState {
  requests: number;
  windowStart: number;
}

/**
 * Constraint monitoring and enforcement system
 * Implements fail-fast behavior with real-time violation detection
 */
export class ConstraintEnforcer extends EventEmitter {
  private readonly constraints: Constraints;
  private readonly rateLimitState: RateLimitState;
  private readonly operations &#x3D; new Map&amp;lt;string, OperationContext&amp;gt;();

  constructor(constraints: Partial&amp;lt;Constraints&amp;gt; &#x3D; {}) {
    super();
    this.constraints &#x3D; { ...DEFAULT_CONSTRAINTS, ...constraints };
    this.rateLimitState &#x3D; {
      requests: 0,
      windowStart: Date.now(),
    };
  }

  /**
   * Start tracking an operation for constraint enforcement
   */
  startOperation(operation: string, metadata?: Record&amp;lt;string, unknown&amp;gt;): string {
    const operationId &#x3D; &#x60;${operation}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}&#x60;;
    const context: OperationContext &#x3D; {
      operation,
      startTime: performance.now(),
      metadata,
    };

    this.operations.set(operationId, context);

    // Check rate limiting before operation starts
    this.enforceRateLimit();

    this.emit(&amp;#39;operation:start&amp;#39;, { operationId, context });
    return operationId;
  }

  /**
   * End tracking an operation and enforce time constraints
   */
  endOperation(operationId: string): void {
    const context &#x3D; this.operations.get(operationId);
    if (!context) {
      throw new Error(&#x60;Operation ${operationId} not found&#x60;);
    }

    const duration &#x3D; performance.now() - context.startTime;

    // Enforce maximum operation time
    if (duration &amp;gt; this.constraints.maxOperationTime) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;maxOperationTime&amp;#39;,
        &#x60;${Math.round(duration)}ms&#x60;,
        &#x60;â‰¤${this.constraints.maxOperationTime}ms&#x60;,
        {
          operationId,
          operation: context.operation,
          duration,
          metadata: context.metadata,
        }
      );

      this.emit(&amp;#39;constraint:violation&amp;#39;, {
        constraint: &amp;#39;maxOperationTime&amp;#39;,
        violation,
        context,
      });

      throw violation;
    }

    this.operations.delete(operationId);
    this.emit(&amp;#39;operation:end&amp;#39;, { operationId, duration, context });
  }

  /**
   * Validate payload size constraint
   */
  validatePayloadSize(data: unknown, operationId?: string): void {
    const payloadSize &#x3D; this.calculatePayloadSize(data);

    if (payloadSize &amp;gt; this.constraints.maxPayloadSize) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;maxPayloadSize&amp;#39;,
        &#x60;${this.formatBytes(payloadSize)}&#x60;,
        &#x60;â‰¤${this.formatBytes(this.constraints.maxPayloadSize)}&#x60;,
        {
          operationId,
          payloadSize,
          dataType: typeof data,
        }
      );

      this.emit(&amp;#39;constraint:violation&amp;#39;, {
        constraint: &amp;#39;maxPayloadSize&amp;#39;,
        violation,
        payloadSize,
      });

      throw violation;
    }

    // Update operation context with payload size
    if (operationId) {
      const context &#x3D; this.operations.get(operationId);
      if (context) {
        context.payloadSize &#x3D; payloadSize;
      }
    }

    this.emit(&amp;#39;payload:validated&amp;#39;, { operationId, payloadSize });
  }

  /**
   * Validate API version constraint (must use latest)
   */
  validateApiVersion(version: string, operationId?: string): void {
    if (version !&#x3D;&#x3D; this.constraints.apiVersion) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;apiVersion&amp;#39;,
        version,
        this.constraints.apiVersion,
        {
          operationId,
          message: &amp;#39;Must use latest API version in envelope schema&amp;#39;,
        }
      );

      this.emit(&amp;#39;constraint:violation&amp;#39;, {
        constraint: &amp;#39;apiVersion&amp;#39;,
        violation,
        providedVersion: version,
      });

      throw violation;
    }

    // Update operation context with API version
    if (operationId) {
      const context &#x3D; this.operations.get(operationId);
      if (context) {
        context.apiVersion &#x3D; version;
      }
    }

    this.emit(&amp;#39;apiVersion:validated&amp;#39;, { operationId, version });
  }

  /**
   * Validate that operation uses server endpoints (sandbox constraint)
   */
  validateSandboxCompliance(
    operationType: string,
    isDirectToolExecution: boolean,
    operationId?: string
  ): void {
    if (isDirectToolExecution) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;sandboxCompliance&amp;#39;,
        &amp;#39;direct tool execution&amp;#39;,
        &amp;#39;server endpoint usage&amp;#39;,
        {
          operationId,
          operationType,
          message: &amp;#39;All analyze/validate operations must use server endpoints&amp;#39;,
        }
      );

      this.emit(&amp;#39;constraint:violation&amp;#39;, {
        constraint: &amp;#39;sandboxCompliance&amp;#39;,
        violation,
        operationType,
      });

      throw violation;
    }

    this.emit(&amp;#39;sandbox:validated&amp;#39;, { operationId, operationType });
  }

  /**
   * Validate idempotent operation constraint
   */
  validateIdempotency(
    operation: string,
    inputs: unknown,
    expectedOutput: unknown,
    actualOutput: unknown,
    operationId?: string
  ): void {
    if (!this.deepEqual(expectedOutput, actualOutput)) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;idempotency&amp;#39;,
        &amp;#39;non-deterministic output&amp;#39;,
        &amp;#39;identical output for identical inputs&amp;#39;,
        {
          operationId,
          operation,
          inputs,
          expectedOutput,
          actualOutput,
        }
      );

      this.emit(&amp;#39;constraint:violation&amp;#39;, {
        constraint: &amp;#39;idempotency&amp;#39;,
        violation,
        operation,
      });

      throw violation;
    }

    this.emit(&amp;#39;idempotency:validated&amp;#39;, { operationId, operation });
  }

  /**
   * Get current constraint status and metrics
   */
  getConstraintStatus(): {
    constraints: Constraints;
    activeOperations: number;
    rateLimitStatus: {
      current: number;
      limit: number;
      windowStart: number;
      windowEnd: number;
    };
    violations: {
      total: number;
      byType: Record&amp;lt;string, number&amp;gt;;
    };
  } {
    return {
      constraints: { ...this.constraints },
      activeOperations: this.operations.size,
      rateLimitStatus: {
        current: this.rateLimitState.requests,
        limit: this.constraints.rateLimit.requests,
        windowStart: this.rateLimitState.windowStart,
        windowEnd: this.rateLimitState.windowStart + this.constraints.rateLimit.windowMs,
      },
      violations: {
        total: this.listenerCount(&amp;#39;constraint:violation&amp;#39;),
        byType: {}, // Would be populated by violation tracking
      },
    };
  }

  /**
   * Enforce rate limiting constraint
   */
  private enforceRateLimit(): void {
    const now &#x3D; Date.now();

    // Reset window if expired
    if (now - this.rateLimitState.windowStart &amp;gt;&#x3D; this.constraints.rateLimit.windowMs) {
      this.rateLimitState.requests &#x3D; 0;
      this.rateLimitState.windowStart &#x3D; now;
    }

    // Check if rate limit exceeded
    if (this.rateLimitState.requests &amp;gt;&#x3D; this.constraints.rateLimit.requests) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;rateLimit&amp;#39;,
        &#x60;${this.rateLimitState.requests + 1} requests&#x60;,
        &#x60;â‰¤${this.constraints.rateLimit.requests} requests per ${this.constraints.rateLimit.windowMs}ms&#x60;,
        {
          windowStart: this.rateLimitState.windowStart,
          windowEnd: this.rateLimitState.windowStart + this.constraints.rateLimit.windowMs,
          currentRequests: this.rateLimitState.requests,
        }
      );

      this.emit(&amp;#39;constraint:violation&amp;#39;, {
        constraint: &amp;#39;rateLimit&amp;#39;,
        violation,
        rateLimitState: { ...this.rateLimitState },
      });

      throw violation;
    }

    // Increment request count
    this.rateLimitState.requests++;
    this.emit(&amp;#39;rateLimit:checked&amp;#39;, {
      requests: this.rateLimitState.requests,
      limit: this.constraints.rateLimit.requests,
    });
  }

  /**
   * Calculate payload size in bytes
   */
  private calculatePayloadSize(data: unknown): number {
    if (typeof data &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39;) {
      return Buffer.byteLength(data, &amp;#39;utf8&amp;#39;);
    }

    if (Buffer.isBuffer(data)) {
      return data.length;
    }

    // For objects, serialize to JSON and calculate size
    const serialized &#x3D; JSON.stringify(data);
    return Buffer.byteLength(serialized, &amp;#39;utf8&amp;#39;);
  }

  /**
   * Format bytes in human-readable format
   */
  private formatBytes(bytes: number): string {
    if (bytes &#x3D;&#x3D;&#x3D; 0) return &amp;#39;0 B&amp;#39;;

    const k &#x3D; 1024;
    const sizes &#x3D; [&amp;#39;B&amp;#39;, &amp;#39;KB&amp;#39;, &amp;#39;MB&amp;#39;, &amp;#39;GB&amp;#39;];
    const i &#x3D; Math.floor(Math.log(bytes) / Math.log(k));

    return &#x60;${Number.parseFloat((bytes / k ** i).toFixed(2))} ${sizes[i]}&#x60;;
  }

  /**
   * Deep equality comparison for idempotency validation
   */
  private deepEqual(a: unknown, b: unknown): boolean {
    if (a &#x3D;&#x3D;&#x3D; b) return true;

    if (a &#x3D;&#x3D; null || b &#x3D;&#x3D; null) return a &#x3D;&#x3D;&#x3D; b;

    if (typeof a !&#x3D;&#x3D; typeof b) return false;

    if (typeof a !&#x3D;&#x3D; &amp;#39;object&amp;#39;) return false;

    const aObj &#x3D; a as Record&amp;lt;string, unknown&amp;gt;;
    const bObj &#x3D; b as Record&amp;lt;string, unknown&amp;gt;;

    const keysA &#x3D; Object.keys(aObj);
    const keysB &#x3D; Object.keys(bObj);

    if (keysA.length !&#x3D;&#x3D; keysB.length) return false;

    for (const key of keysA) {
      if (!keysB.includes(key)) return false;
      if (!this.deepEqual(aObj[key], bObj[key])) return false;
    }

    return true;
  }
}

/**
 * Global constraint enforcer instance
 */
export const globalConstraintEnforcer &#x3D; new ConstraintEnforcer();

/**
 * Decorator for automatic constraint enforcement on async functions
 */
export function withConstraints(operation: string) {
  return &amp;lt;T extends (...args: any[]) &#x3D;&amp;gt; Promise&amp;lt;any&amp;gt;&amp;gt;(
    _target: any,
    propertyName: string,
    descriptor: TypedPropertyDescriptor&amp;lt;T&amp;gt;
  ) &#x3D;&amp;gt; {
    const method &#x3D; descriptor.value!;

    descriptor.value &#x3D; async function (this: any, ...args: any[]) {
      const operationId &#x3D; globalConstraintEnforcer.startOperation(operation, {
        method: propertyName,
        args: args.length,
      });

      try {
        const result &#x3D; await method.apply(this, args);
        globalConstraintEnforcer.endOperation(operationId);
        return result;
      } catch (error) {
        globalConstraintEnforcer.endOperation(operationId);
        throw error;
      }
    } as T;

    return descriptor;
  };
}

/**
 * Utility function to wrap any async operation with constraints
 */
export async function constrainedOperation&amp;lt;T&amp;gt;(
  operation: string,
  fn: () &#x3D;&amp;gt; Promise&amp;lt;T&amp;gt;,
  metadata?: Record&amp;lt;string, unknown&amp;gt;
): Promise&amp;lt;T&amp;gt; {
  const operationId &#x3D; globalConstraintEnforcer.startOperation(operation, metadata);

  try {
    const result &#x3D; await fn();
    globalConstraintEnforcer.endOperation(operationId);
    return result;
  } catch (error) {
    globalConstraintEnforcer.endOperation(operationId);
    throw error;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-5">
                <div class="file-header">ğŸ“„ apps/api/src/db.ts</div>
                <div class="file-content">
                    <pre>/**
 * SQLite database layer using Bun&amp;#39;s native sqlite driver
 */
import { Database } from &amp;#39;bun:sqlite&amp;#39;;
import { createHash, randomUUID } from &amp;#39;node:crypto&amp;#39;;
import type {
  Event,
  EventType,
  Fragment,
  FragmentRevision,
  Project,
  ServerConfig,
  Version,
} from &amp;#39;./types.ts&amp;#39;;

export class SpecWorkbenchDB {
  private db: Database;

  constructor(config: ServerConfig) {
    this.db &#x3D; new Database(config.database_path, { create: true });
    this.initializeSchema();
  }

  /**
   * Configure SQLite pragmas for optimal performance
   */
  private configurePragmas(): void {
    // Enable WAL mode for better concurrent access
    this.db.exec(&amp;#39;PRAGMA journal_mode &#x3D; WAL&amp;#39;);
    this.db.exec(&amp;#39;PRAGMA synchronous &#x3D; NORMAL&amp;#39;);
    this.db.exec(&amp;#39;PRAGMA cache_size &#x3D; 1000&amp;#39;);
    this.db.exec(&amp;#39;PRAGMA temp_store &#x3D; memory&amp;#39;);
  }

  /**
   * Handle schema migrations (add columns if needed)
   */
  private handleSchemaMigrations(): void {
    // Schema migration - add head_revision_id column if it doesn&amp;#39;t exist
    try {
      this.db.exec(&amp;#39;ALTER TABLE fragments ADD COLUMN head_revision_id TEXT&amp;#39;);
    } catch (error) {
      // Column already exists or table doesn&amp;#39;t exist yet, ignore
    }
  }

  /**
   * Create the projects table
   */
  private createProjectsTable(): void {
    this.db.exec(&#x60;
      CREATE TABLE IF NOT EXISTS projects (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        updated_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;))
      )
    &#x60;);
  }

  /**
   * Create the fragments table
   */
  private createFragmentsTable(): void {
    this.db.exec(&#x60;
      CREATE TABLE IF NOT EXISTS fragments (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        path TEXT NOT NULL,
        content TEXT NOT NULL,
        head_revision_id TEXT,
        created_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        updated_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        FOREIGN KEY (project_id) REFERENCES projects (id) ON DELETE CASCADE,
        UNIQUE (project_id, path)
      )
    &#x60;);
  }

  /**
   * Create the fragment_revisions table
   */
  private createFragmentRevisionsTable(): void {
    this.db.exec(&#x60;
      CREATE TABLE IF NOT EXISTS fragment_revisions (
        id TEXT PRIMARY KEY,
        fragment_id TEXT NOT NULL,
        revision_number INTEGER NOT NULL,
        content TEXT NOT NULL,
        content_hash TEXT NOT NULL,
        author TEXT,
        message TEXT,
        created_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        FOREIGN KEY (fragment_id) REFERENCES fragments (id) ON DELETE CASCADE,
        UNIQUE (fragment_id, revision_number)
      )
    &#x60;);
  }

  /**
   * Create the versions table
   */
  private createVersionsTable(): void {
    this.db.exec(&#x60;
      CREATE TABLE IF NOT EXISTS versions (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        spec_hash TEXT NOT NULL,
        resolved_json TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        FOREIGN KEY (project_id) REFERENCES projects (id) ON DELETE CASCADE,
        UNIQUE (project_id, spec_hash)
      )
    &#x60;);
  }

  /**
   * Create the events table
   */
  private createEventsTable(): void {
    this.db.exec(&#x60;
      CREATE TABLE IF NOT EXISTS events (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        event_type TEXT NOT NULL,
        data TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        FOREIGN KEY (project_id) REFERENCES projects (id) ON DELETE CASCADE
      )
    &#x60;);
  }

  /**
   * Create all database tables
   */
  private createTables(): void {
    this.createProjectsTable();
    this.createFragmentsTable();
    this.createFragmentRevisionsTable();
    this.createVersionsTable();
    this.createEventsTable();
  }

  /**
   * Create performance indices for tables
   */
  private createIndices(): void {
    // Fragment indices
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_fragments_project_id ON fragments (project_id)&amp;#39;);
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_fragments_path ON fragments (project_id, path)&amp;#39;);

    // Fragment revision indices
    this.db.exec(
      &amp;#39;CREATE INDEX IF NOT EXISTS idx_fragment_revisions_fragment_id ON fragment_revisions (fragment_id)&amp;#39;
    );
    this.db.exec(
      &amp;#39;CREATE INDEX IF NOT EXISTS idx_fragment_revisions_revision_number ON fragment_revisions (fragment_id, revision_number)&amp;#39;
    );
    this.db.exec(
      &amp;#39;CREATE INDEX IF NOT EXISTS idx_fragment_revisions_content_hash ON fragment_revisions (content_hash)&amp;#39;
    );

    // Version indices
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_versions_project_id ON versions (project_id)&amp;#39;);
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_versions_hash ON versions (spec_hash)&amp;#39;);

    // Event indices
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_events_project_id ON events (project_id)&amp;#39;);
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_events_created_at ON events (created_at DESC)&amp;#39;);
  }

  /**
   * Create database triggers for automatic timestamp updates
   */
  private createTriggers(): void {
    // Trigger to update updated_at on projects
    this.db.exec(&#x60;
      CREATE TRIGGER IF NOT EXISTS update_projects_updated_at
      AFTER UPDATE ON projects
      FOR EACH ROW
      BEGIN
        UPDATE projects SET updated_at &#x3D; datetime(&amp;#39;now&amp;#39;) WHERE id &#x3D; NEW.id;
      END
    &#x60;);

    // Trigger to update updated_at on fragments
    this.db.exec(&#x60;
      CREATE TRIGGER IF NOT EXISTS update_fragments_updated_at
      AFTER UPDATE ON fragments
      FOR EACH ROW
      BEGIN
        UPDATE fragments SET updated_at &#x3D; datetime(&amp;#39;now&amp;#39;) WHERE id &#x3D; NEW.id;
      END
    &#x60;);
  }

  /**
   * Initialize database schema with proper indices
   */
  private initializeSchema(): void {
    this.configurePragmas();
    this.handleSchemaMigrations();
    this.createTables();
    this.createIndices();
    this.createTriggers();
  }

  // Project operations
  async createProject(id: string, name: string): Promise&amp;lt;Project&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      INSERT INTO projects (id, name) VALUES (?, ?)
      RETURNING id, name, created_at, updated_at
    &#x60;);

    const result &#x3D; stmt.get(id, name) as Project;
    if (!result) {
      throw new Error(&amp;#39;Failed to create project&amp;#39;);
    }
    return result;
  }

  async getProject(id: string): Promise&amp;lt;Project | null&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM projects WHERE id &#x3D; ?&amp;#39;);
    return stmt.get(id) as Project | null;
  }

  async listProjects(): Promise&amp;lt;Project[]&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM projects ORDER BY created_at DESC&amp;#39;);
    return stmt.all() as Project[];
  }

  async deleteProject(id: string): Promise&amp;lt;void&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;DELETE FROM projects WHERE id &#x3D; ?&amp;#39;);
    const result &#x3D; stmt.run(id);
    if (result.changes &#x3D;&#x3D;&#x3D; 0) {
      throw new Error(&amp;#39;Project not found&amp;#39;);
    }
  }

  // Fragment operations
  async createFragment(
    id: string,
    projectId: string,
    path: string,
    content: string,
    author?: string,
    message?: string
  ): Promise&amp;lt;Fragment&amp;gt; {
    return this.transaction(() &#x3D;&amp;gt; {
      // Create fragment
      const stmt &#x3D; this.db.prepare(&#x60;
        INSERT INTO fragments (id, project_id, path, content) 
        VALUES (?, ?, ?, ?)
        RETURNING id, project_id, path, content, head_revision_id, created_at, updated_at
      &#x60;);

      const fragment &#x3D; stmt.get(id, projectId, path, content) as Fragment;
      if (!fragment) {
        throw new Error(&amp;#39;Failed to create fragment&amp;#39;);
      }

      // Create initial revision
      const revisionId &#x3D; this.generateId();
      const contentHash &#x3D; createHash(&amp;#39;sha256&amp;#39;).update(content).digest(&amp;#39;hex&amp;#39;);

      this.createFragmentRevision(
        revisionId,
        id,
        1, // Initial revision number
        content,
        contentHash,
        author,
        message || &amp;#39;Initial fragment creation&amp;#39;
      );

      // Update fragment with head revision pointer
      const updateStmt &#x3D; this.db.prepare(&#x60;
        UPDATE fragments SET head_revision_id &#x3D; ? WHERE id &#x3D; ?
      &#x60;);
      updateStmt.run(revisionId, id);

      // Return updated fragment
      const getStmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM fragments WHERE id &#x3D; ?&amp;#39;);
      return getStmt.get(id) as Fragment;
    });
  }

  async updateFragment(
    projectId: string,
    path: string,
    content: string,
    author?: string,
    message?: string
  ): Promise&amp;lt;Fragment&amp;gt; {
    return this.transaction(() &#x3D;&amp;gt; {
      // Get existing fragment
      const existingFragment &#x3D; this.getFragment(projectId, path);
      if (!existingFragment) {
        throw new Error(&amp;#39;Fragment not found&amp;#39;);
      }

      // Create content hash for deduplication
      const contentHash &#x3D; createHash(&amp;#39;sha256&amp;#39;).update(content).digest(&amp;#39;hex&amp;#39;);

      // Check if content has actually changed
      if (existingFragment.content &#x3D;&#x3D;&#x3D; content) {
        return existingFragment; // No change, return existing
      }

      // Get next revision number
      const nextRevisionNumber &#x3D; this.getNextRevisionNumber(existingFragment.id);

      // Create new revision
      const revisionId &#x3D; this.generateId();
      const revision &#x3D; this.createFragmentRevision(
        revisionId,
        existingFragment.id,
        nextRevisionNumber,
        content,
        contentHash,
        author,
        message
      );

      // Update fragment with new content and head revision pointer
      const stmt &#x3D; this.db.prepare(&#x60;
        UPDATE fragments 
        SET content &#x3D; ?, head_revision_id &#x3D; ?
        WHERE project_id &#x3D; ? AND path &#x3D; ?
        RETURNING id, project_id, path, content, head_revision_id, created_at, updated_at
      &#x60;);

      const result &#x3D; stmt.get(content, revisionId, projectId, path) as Fragment | undefined;
      if (!result) {
        throw new Error(&amp;#39;Failed to update fragment&amp;#39;);
      }
      return result;
    });
  }

  getFragment(projectId: string, path: string): Fragment | null {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM fragments WHERE project_id &#x3D; ? AND path &#x3D; ?&amp;#39;);
    return stmt.get(projectId, path) as Fragment | null;
  }

  async getFragmentById(id: string): Promise&amp;lt;Fragment | null&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM fragments WHERE id &#x3D; ?&amp;#39;);
    return stmt.get(id) as Fragment | null;
  }

  async listFragments(projectId: string): Promise&amp;lt;Fragment[]&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM fragments WHERE project_id &#x3D; ? ORDER BY path&amp;#39;);
    return stmt.all(projectId) as Fragment[];
  }

  async deleteFragment(projectId: string, path: string): Promise&amp;lt;void&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;DELETE FROM fragments WHERE project_id &#x3D; ? AND path &#x3D; ?&amp;#39;);
    const result &#x3D; stmt.run(projectId, path);
    if (result.changes &#x3D;&#x3D;&#x3D; 0) {
      throw new Error(&amp;#39;Fragment not found&amp;#39;);
    }
  }

  // Fragment revision operations
  private generateId(): string {
    return randomUUID();
  }

  private getNextRevisionNumber(fragmentId: string): number {
    const stmt &#x3D; this.db.prepare(&#x60;
      SELECT COALESCE(MAX(revision_number), 0) + 1 as next_revision
      FROM fragment_revisions 
      WHERE fragment_id &#x3D; ?
    &#x60;);
    const result &#x3D; stmt.get(fragmentId) as { next_revision: number };
    return result.next_revision;
  }

  async createFragmentRevision(
    id: string,
    fragmentId: string,
    revisionNumber: number,
    content: string,
    contentHash: string,
    author?: string,
    message?: string
  ): Promise&amp;lt;FragmentRevision&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      INSERT INTO fragment_revisions (id, fragment_id, revision_number, content, content_hash, author, message)
      VALUES (?, ?, ?, ?, ?, ?, ?)
      RETURNING id, fragment_id, revision_number, content, content_hash, author, message, created_at
    &#x60;);

    const result &#x3D; stmt.get(
      id,
      fragmentId,
      revisionNumber,
      content,
      contentHash,
      author,
      message
    ) as FragmentRevision;
    if (!result) {
      throw new Error(&amp;#39;Failed to create fragment revision&amp;#39;);
    }
    return result;
  }

  async getFragmentRevision(
    fragmentId: string,
    revisionNumber: number
  ): Promise&amp;lt;FragmentRevision | null&amp;gt; {
    const stmt &#x3D; this.db.prepare(
      &amp;#39;SELECT * FROM fragment_revisions WHERE fragment_id &#x3D; ? AND revision_number &#x3D; ?&amp;#39;
    );
    return stmt.get(fragmentId, revisionNumber) as FragmentRevision | null;
  }

  async listFragmentRevisions(fragmentId: string): Promise&amp;lt;FragmentRevision[]&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      SELECT * FROM fragment_revisions 
      WHERE fragment_id &#x3D; ? 
      ORDER BY revision_number DESC
    &#x60;);
    return stmt.all(fragmentId) as FragmentRevision[];
  }

  async getLatestFragmentRevision(fragmentId: string): Promise&amp;lt;FragmentRevision | null&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      SELECT * FROM fragment_revisions 
      WHERE fragment_id &#x3D; ? 
      ORDER BY revision_number DESC 
      LIMIT 1
    &#x60;);
    return stmt.get(fragmentId) as FragmentRevision | null;
  }

  // Version operations
  async createVersion(
    id: string,
    projectId: string,
    specHash: string,
    resolvedJson: string
  ): Promise&amp;lt;Version&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      INSERT INTO versions (id, project_id, spec_hash, resolved_json)
      VALUES (?, ?, ?, ?)
      RETURNING id, project_id, spec_hash, resolved_json, created_at
    &#x60;);

    const result &#x3D; stmt.get(id, projectId, specHash, resolvedJson) as Version;
    if (!result) {
      throw new Error(&amp;#39;Failed to create version&amp;#39;);
    }
    return result;
  }

  async getVersionByHash(projectId: string, specHash: string): Promise&amp;lt;Version | null&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM versions WHERE project_id &#x3D; ? AND spec_hash &#x3D; ?&amp;#39;);
    return stmt.get(projectId, specHash) as Version | null;
  }

  async getLatestVersion(projectId: string): Promise&amp;lt;Version | null&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      SELECT * FROM versions 
      WHERE project_id &#x3D; ? 
      ORDER BY created_at DESC 
      LIMIT 1
    &#x60;);
    return stmt.get(projectId) as Version | null;
  }

  async listVersions(projectId: string): Promise&amp;lt;Version[]&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      SELECT * FROM versions 
      WHERE project_id &#x3D; ? 
      ORDER BY created_at DESC
    &#x60;);
    return stmt.all(projectId) as Version[];
  }

  // Event operations
  async createEvent(
    id: string,
    projectId: string,
    eventType: EventType,
    data: Record&amp;lt;string, unknown&amp;gt;
  ): Promise&amp;lt;Event&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      INSERT INTO events (id, project_id, event_type, data)
      VALUES (?, ?, ?, ?)
      RETURNING id, project_id, event_type, data, created_at
    &#x60;);

    const result &#x3D; stmt.get(id, projectId, eventType, JSON.stringify(data)) as Event &amp;amp; {
      data: string;
    };

    if (!result) {
      throw new Error(&amp;#39;Failed to create event&amp;#39;);
    }

    return {
      ...result,
      data: JSON.parse(result.data),
    };
  }

  async getEvents(projectId: string, limit &#x3D; 100, since?: string): Promise&amp;lt;Event[]&amp;gt; {
    let query &#x3D; &#x60;
      SELECT * FROM events 
      WHERE project_id &#x3D; ?
    &#x60;;
    const params: any[] &#x3D; [projectId];

    if (since) {
      query +&#x3D; &amp;#39; AND created_at &amp;gt; ?&amp;#39;;
      // Convert ISO timestamp to SQLite datetime format
      const sqliteTimestamp &#x3D; new Date(since)
        .toISOString()
        .replace(&amp;#39;T&amp;#39;, &amp;#39; &amp;#39;)
        .replace(&amp;#39;Z&amp;#39;, &amp;#39;&amp;#39;)
        .split(&amp;#39;.&amp;#39;)[0];
      params.push(sqliteTimestamp);
    }

    query +&#x3D; &amp;#39; ORDER BY created_at DESC LIMIT ?&amp;#39;;
    params.push(limit);

    const stmt &#x3D; this.db.prepare(query);
    const results &#x3D; stmt.all(...params) as (Event &amp;amp; { data: string })[];

    return results.map(event &#x3D;&amp;gt; ({
      ...event,
      data: JSON.parse(event.data),
    }));
  }

  // Transaction support
  transaction&amp;lt;T&amp;gt;(fn: () &#x3D;&amp;gt; T): T {
    return this.db.transaction(fn)();
  }

  // Cleanup and maintenance
  async vacuum(): Promise&amp;lt;void&amp;gt; {
    this.db.exec(&amp;#39;VACUUM&amp;#39;);
  }

  close(): void {
    this.db.close();
  }

  // Health check
  async healthCheck(): Promise&amp;lt;boolean&amp;gt; {
    try {
      const result &#x3D; this.db.prepare(&amp;#39;SELECT 1 as ok&amp;#39;).get();
      return (result as any)?.ok &#x3D;&#x3D;&#x3D; 1;
    } catch {
      return false;
    }
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-6">
                <div class="file-header">ğŸ“„ packages/cli/src/config.ts</div>
                <div class="file-content">
                    <pre>import path from &amp;#39;node:path&amp;#39;;
import { fileURLToPath } from &amp;#39;node:url&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import yaml from &amp;#39;yaml&amp;#39;;
import { z } from &amp;#39;zod&amp;#39;;
import type { CLIConfig } from &amp;#39;./types.js&amp;#39;;

const __filename &#x3D; fileURLToPath(import.meta.url);
const __dirname &#x3D; path.dirname(__filename);

/**
 * Default CLI configuration
 * Updated to match Arbiter specification constraints
 */
export const DEFAULT_CONFIG: CLIConfig &#x3D; {
  apiUrl: &amp;#39;http://localhost:5050&amp;#39;, // Standardized to match server default
  timeout: 750, // Enforce spec maximum (â‰¤750ms)
  format: &amp;#39;table&amp;#39;,
  color: true,
  projectDir: process.cwd(),
};

/**
 * Common ports to try for server auto-discovery
 * Listed in order of preference
 */
export const COMMON_PORTS &#x3D; [5050, 3000, 4000, 8080] as const;

/**
 * Configuration file schema for validation
 * Enforces Arbiter specification constraints
 */
const gitHubRepoSchema &#x3D; z.object({
  owner: z.string().optional(), // Made optional for auto-detection
  repo: z.string().optional(), // Made optional for auto-detection
  token: z.string().optional(),
  baseUrl: z.string().url().optional(),
  tokenEnv: z.string().optional(),
});

const gitHubTemplateFieldSchema &#x3D; z.object({
  name: z.string(),
  label: z.string(),
  required: z.boolean().optional(),
  type: z.enum([&amp;#39;text&amp;#39;, &amp;#39;number&amp;#39;, &amp;#39;date&amp;#39;, &amp;#39;select&amp;#39;, &amp;#39;boolean&amp;#39;]).optional(),
  default: z.string().optional(),
  pattern: z.string().optional(),
  help: z.string().optional(),
});

const gitHubFieldValidationSchema &#x3D; z.object({
  field: z.string(),
  required: z.boolean().optional(),
  minLength: z.number().optional(),
  maxLength: z.number().optional(),
  pattern: z.string().optional(),
  enum: z.array(z.string()).optional(),
  validator: z.string().optional(),
  errorMessage: z.string().optional(),
});

const gitHubTemplateSectionsSchema &#x3D; z.object({
  description: z.string(),
  details: z.array(gitHubTemplateFieldSchema).optional(),
  acceptanceCriteria: z.string().optional(),
  dependencies: z.string().optional(),
  additional: z.record(z.string()).optional(),
});

const gitHubTemplateValidationSchema &#x3D; z.object({
  fields: z.array(gitHubFieldValidationSchema).optional(),
  custom: z.array(z.string()).optional(),
});

const gitHubTemplateSetSchema &#x3D; z.object({
  name: z.string(),
  description: z.string().optional(),
  sections: gitHubTemplateSectionsSchema,
  labels: z.array(z.string()).optional(),
  validation: gitHubTemplateValidationSchema.optional(),
});

const gitHubTemplateOptionsSchema &#x3D; z.object({
  includeMetadata: z.boolean().optional(),
  includeArbiterIds: z.boolean().optional(),
  includeAcceptanceCriteria: z.boolean().optional(),
  includeDependencies: z.boolean().optional(),
  includeEstimations: z.boolean().optional(),
  customFields: z.record(z.string()).optional(),
});

const gitHubTemplateConfigSchema &#x3D; z.object({
  inherits: z.string().optional(),
  name: z.string().optional(),
  title: z.string().optional(),
  description: z.string().optional(),
  sections: gitHubTemplateSectionsSchema.partial().optional(),
  labels: z.array(z.string()).optional(),
  assignees: z.array(z.string()).optional(),
  validation: gitHubTemplateValidationSchema.optional(),
  options: gitHubTemplateOptionsSchema.optional(),
});

const gitHubLabelSchema &#x3D; z.object({
  name: z.string(),
  color: z.string(),
  description: z.string().optional(),
});

const gitHubRepoConfigSchema &#x3D; z.object({
  issueConfig: z
    .object({
      blankIssuesEnabled: z.boolean().optional(),
      contactLinks: z
        .array(
          z.object({
            name: z.string(),
            url: z.string().url(),
            about: z.string(),
          })
        )
        .optional(),
    })
    .optional(),
  labels: z.array(gitHubLabelSchema).optional(),
  pullRequestTemplate: z.string().optional(),
});

const gitHubTemplatesConfigSchema &#x3D; z.object({
  base: gitHubTemplateSetSchema.optional(),
  epic: gitHubTemplateConfigSchema.optional(),
  task: gitHubTemplateConfigSchema.optional(),
  bugReport: gitHubTemplateConfigSchema.optional(),
  featureRequest: gitHubTemplateConfigSchema.optional(),
  repositoryConfig: gitHubRepoConfigSchema.optional(),
});

const gitHubSyncSchema &#x3D; z.object({
  repository: gitHubRepoSchema,
  mapping: z
    .object({
      epicLabels: z.record(z.array(z.string())).optional(),
      taskLabels: z.record(z.array(z.string())).optional(),
      defaultLabels: z.array(z.string()).optional(),
      epicPrefix: z.string().optional(),
      taskPrefix: z.string().optional(),
    })
    .optional(),
  behavior: z
    .object({
      createMilestones: z.boolean().optional(),
      autoClose: z.boolean().optional(),
      syncAcceptanceCriteria: z.boolean().optional(),
      syncAssignees: z.boolean().optional(),
    })
    .optional(),
  templates: gitHubTemplatesConfigSchema.optional(),
});

const configSchema &#x3D; z.object({
  apiUrl: z.string().url().optional(),
  timeout: z.number().min(100).max(750).optional(), // Enforce spec maximum (â‰¤750ms)
  format: z.enum([&amp;#39;table&amp;#39;, &amp;#39;json&amp;#39;, &amp;#39;yaml&amp;#39;]).optional(),
  color: z.boolean().optional(),
  projectDir: z.string().optional(),
  github: gitHubSyncSchema.optional(),
});

/**
 * Possible configuration file names
 */
const CONFIG_FILES &#x3D; [
  &amp;#39;.arbiter/config.json&amp;#39;,
  &amp;#39;.arbiter/config.yaml&amp;#39;,
  &amp;#39;.arbiter/config.yml&amp;#39;,
  // Legacy paths for backward compatibility
  &amp;#39;.arbiter.json&amp;#39;,
  &amp;#39;.arbiter.yaml&amp;#39;,
  &amp;#39;.arbiter.yml&amp;#39;,
  &amp;#39;arbiter.json&amp;#39;,
  &amp;#39;arbiter.yaml&amp;#39;,
  &amp;#39;arbiter.yml&amp;#39;,
];

/**
 * Load CLI configuration from file or use defaults
 */
export async function loadConfig(configPath?: string): Promise&amp;lt;CLIConfig&amp;gt; {
  const baseConfig &#x3D; { ...DEFAULT_CONFIG };

  if (configPath) {
    return await loadSpecificConfigFile(configPath, baseConfig);
  }

  return await searchForConfigFile(baseConfig);
}

/**
 * Load configuration with Git auto-detection integration
 * This is called after the initial config load to enhance with Git info
 */
export async function loadConfigWithGitDetection(
  baseConfig: CLIConfig,
  options: {
    useConfig?: boolean;
    useGitRemote?: boolean;
    verbose?: boolean;
  } &#x3D; {}
): Promise&amp;lt;CLIConfig&amp;gt; {
  const { getSmartRepositoryConfig } &#x3D; await import(&amp;#39;./utils/git-detection.js&amp;#39;);

  // Always try to get smart repository config, which handles conflicts
  const smartRepoConfig &#x3D; getSmartRepositoryConfig(baseConfig.github?.repository, options);

  if (smartRepoConfig) {
    // Merge detected repository info into config
    const enhancedConfig: CLIConfig &#x3D; {
      ...baseConfig,
      github: {
        ...baseConfig.github,
        repository: {
          ...baseConfig.github?.repository,
          owner: smartRepoConfig.repo.owner,
          repo: smartRepoConfig.repo.repo,
        },
      },
    };

    if (options.verbose) {
      console.log(
        chalk.green(
          &#x60;âœ… Enhanced config with ${smartRepoConfig.source} repository: ${smartRepoConfig.repo.owner}/${smartRepoConfig.repo.repo}&#x60;
        )
      );
    }

    return enhancedConfig;
  }

  // If no smart config found, return original
  return baseConfig;
}

/**
 * Load a specific configuration file
 */
async function loadSpecificConfigFile(
  configPath: string,
  baseConfig: CLIConfig
): Promise&amp;lt;CLIConfig&amp;gt; {
  if (!(await fs.pathExists(configPath))) {
    throw new Error(&#x60;Configuration file not found: ${configPath}&#x60;);
  }

  const userConfig &#x3D; await loadConfigFile(configPath);
  return { ...baseConfig, ...userConfig };
}

/**
 * Search for configuration files up the directory tree
 */
async function searchForConfigFile(baseConfig: CLIConfig): Promise&amp;lt;CLIConfig&amp;gt; {
  let currentDir &#x3D; process.cwd();
  const root &#x3D; path.parse(currentDir).root;

  while (currentDir !&#x3D;&#x3D; root) {
    const foundConfig &#x3D; await findConfigInDirectory(currentDir);
    if (foundConfig) {
      return { ...baseConfig, ...foundConfig };
    }
    currentDir &#x3D; path.dirname(currentDir);
  }

  return baseConfig;
}

/**
 * Find configuration file in a specific directory
 */
async function findConfigInDirectory(directory: string): Promise&amp;lt;Partial&amp;lt;CLIConfig&amp;gt; | null&amp;gt; {
  for (const fileName of CONFIG_FILES) {
    const configFile &#x3D; path.join(directory, fileName);
    if (await fs.pathExists(configFile)) {
      return await loadConfigFile(configFile);
    }
  }
  return null;
}

/**
 * Load and parse a configuration file
 */
async function loadConfigFile(filePath: string): Promise&amp;lt;Partial&amp;lt;CLIConfig&amp;gt;&amp;gt; {
  const content &#x3D; await fs.readFile(filePath, &amp;#39;utf-8&amp;#39;);
  const ext &#x3D; path.extname(filePath).toLowerCase();

  let parsed: unknown;

  if (ext &#x3D;&#x3D;&#x3D; &amp;#39;.json&amp;#39;) {
    parsed &#x3D; JSON.parse(content);
  } else if (ext &#x3D;&#x3D;&#x3D; &amp;#39;.yaml&amp;#39; || ext &#x3D;&#x3D;&#x3D; &amp;#39;.yml&amp;#39;) {
    parsed &#x3D; yaml.parse(content);
  } else {
    throw new Error(&#x60;Unsupported configuration file format: ${ext}&#x60;);
  }

  // Validate configuration
  const result &#x3D; configSchema.safeParse(parsed);
  if (!result.success) {
    throw new Error(&#x60;Invalid configuration: ${result.error.message}&#x60;);
  }

  return result.data as unknown as Partial&amp;lt;CLIConfig&amp;gt;;
}

/**
 * Save configuration to file
 */
export async function saveConfig(config: Partial&amp;lt;CLIConfig&amp;gt;, filePath: string): Promise&amp;lt;void&amp;gt; {
  const ext &#x3D; path.extname(filePath).toLowerCase();
  let content: string;

  if (ext &#x3D;&#x3D;&#x3D; &amp;#39;.json&amp;#39;) {
    content &#x3D; JSON.stringify(config, null, 2);
  } else if (ext &#x3D;&#x3D;&#x3D; &amp;#39;.yaml&amp;#39; || ext &#x3D;&#x3D;&#x3D; &amp;#39;.yml&amp;#39;) {
    content &#x3D; yaml.stringify(config);
  } else {
    throw new Error(&#x60;Unsupported configuration file format: ${ext}&#x60;);
  }

  // Ensure the directory exists
  await fs.ensureDir(path.dirname(filePath));
  await fs.writeFile(filePath, content, &amp;#39;utf-8&amp;#39;);
}

/**
 * Get default configuration file path
 */
export function getDefaultConfigPath(): string {
  return path.join(process.cwd(), &amp;#39;.arbiter&amp;#39;, &amp;#39;config.json&amp;#39;);
}

export type Config &#x3D; CLIConfig;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-7">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/sharded-storage.ts</div>
                <div class="file-content">
                    <pre>/**
 * Sharded CUE Storage Implementation
 *
 * Manages CUE files across multiple shards for better organization and performance.
 * Each shard contains a subset of epics and their tasks, with ordering preserved.
 */

import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import { createCUEManipulator, formatCUE, validateCUE } from &amp;#39;../cue/index.js&amp;#39;;

// Types for sharded storage management
export interface ShardManifest {
  shardId: string;
  fileName: string;
  epics: Array&amp;lt;{
    id: string;
    status: string;
    lastModified: string;
  }&amp;gt;;
  size: number;
  totalTasks: number;
  created: string;
  lastModified: string;
}

export interface Epic {
  id: string;
  name: string;
  description?: string;
  priority: &amp;#39;critical&amp;#39; | &amp;#39;high&amp;#39; | &amp;#39;medium&amp;#39; | &amp;#39;low&amp;#39;;
  status: &amp;#39;planning&amp;#39; | &amp;#39;in_progress&amp;#39; | &amp;#39;completed&amp;#39; | &amp;#39;cancelled&amp;#39;;
  owner?: string;
  assignee?: string;
  estimatedHours?: number;
  actualHours?: number;
  startDate?: string;
  dueDate?: string;
  completedDate?: string;
  tasks: Task[];
  dependencies?: string[];
  labels?: string[];
  tags?: string[];
  config?: {
    allowParallelTasks?: boolean;
    autoProgress?: boolean;
    requireAllTasks?: boolean;
  };
  arbiter?: {
    shard?: string;
    generatedFrom?: string;
    cuePackage?: string;
  };
}

export interface Task {
  id: string;
  name: string;
  description?: string;
  type: &amp;#39;feature&amp;#39; | &amp;#39;bug&amp;#39; | &amp;#39;refactor&amp;#39; | &amp;#39;test&amp;#39; | &amp;#39;docs&amp;#39; | &amp;#39;devops&amp;#39; | &amp;#39;research&amp;#39;;
  priority: &amp;#39;critical&amp;#39; | &amp;#39;high&amp;#39; | &amp;#39;medium&amp;#39; | &amp;#39;low&amp;#39;;
  status: &amp;#39;todo&amp;#39; | &amp;#39;in_progress&amp;#39; | &amp;#39;review&amp;#39; | &amp;#39;testing&amp;#39; | &amp;#39;completed&amp;#39; | &amp;#39;cancelled&amp;#39;;
  assignee?: string;
  reviewer?: string;
  estimatedHours?: number;
  actualHours?: number;
  dependsOn?: string[];
  acceptanceCriteria?: string[];
  order?: number;
  config?: {
    canRunInParallel?: boolean;
    requiresReview?: boolean;
    requiresTesting?: boolean;
    blocksOtherTasks?: boolean;
  };
  arbiter?: {
    cueManipulation?: {
      operation: string;
      target?: string;
      parameters?: Record&amp;lt;string, any&amp;gt;;
    };
    generatedCode?: {
      language?: string;
      outputPath?: string;
      template?: string;
    };
    testing?: {
      testTypes?: string[];
      coverage?: number;
    };
  };
}

export interface ShardedStorageConfig {
  baseDir: string;
  manifestFile: string;
  shardPrefix: string;
  maxEpicsPerShard: number;
  autoCreateShards: boolean;
  cuePackage: string;
}

/**
 * Manages sharded CUE storage for epics and tasks
 */
export class ShardedCUEStorage {
  private config: ShardedStorageConfig;
  private manifests: Map&amp;lt;string, ShardManifest&amp;gt; &#x3D; new Map();
  private cueManipulator: any;

  constructor(config: Partial&amp;lt;ShardedStorageConfig&amp;gt; &#x3D; {}) {
    this.config &#x3D; {
      baseDir: &amp;#39;.arbiter/epics&amp;#39;,
      manifestFile: &amp;#39;.arbiter/shard-manifest.cue&amp;#39;,
      shardPrefix: &amp;#39;epic-shard&amp;#39;,
      maxEpicsPerShard: 10,
      autoCreateShards: true,
      cuePackage: &amp;#39;epics&amp;#39;,
      ...config,
    };

    this.cueManipulator &#x3D; createCUEManipulator();
  }

  /**
   * Initialize sharded storage directory structure
   */
  async initialize(): Promise&amp;lt;void&amp;gt; {
    await fs.ensureDir(this.config.baseDir);

    // Create initial manifest if it doesn&amp;#39;t exist
    if (!fs.existsSync(this.config.manifestFile)) {
      await this.createInitialManifest();
    }

    // Load existing manifests
    await this.loadManifests();
  }

  /**
   * Create initial manifest file
   */
  private async createInitialManifest(): Promise&amp;lt;void&amp;gt; {
    const initialManifest &#x3D; &#x60;package ${this.config.cuePackage}

// Shard manifest tracking epic distribution across CUE files
shardManifests: []

// Project configuration
project: {
  name: &amp;quot;Project Epics&amp;quot;
  version: &amp;quot;1.0.0&amp;quot;
  description: &amp;quot;Sharded epic and task storage&amp;quot;
}

config: {
  defaultEpicShard: &amp;quot;epic-shard-1&amp;quot;
  maxEpicsPerShard: ${this.config.maxEpicsPerShard}
  autoCreateShards: ${this.config.autoCreateShards}
}&#x60;;

    const formatted &#x3D; await formatCUE(initialManifest);
    await fs.writeFile(this.config.manifestFile, formatted);
  }

  /**
   * Load all shard manifests from the manifest file
   */
  private async loadManifests(): Promise&amp;lt;void&amp;gt; {
    try {
      const manifestContent &#x3D; await fs.readFile(this.config.manifestFile, &amp;#39;utf-8&amp;#39;);
      const ast &#x3D; await this.cueManipulator.parse(manifestContent);

      if (ast.shardManifests) {
        for (const manifest of ast.shardManifests) {
          this.manifests.set(manifest.shardId, manifest);
        }
      }
    } catch (error) {
      console.warn(chalk.yellow(&#x60;Warning: Could not load shard manifests: ${error}&#x60;));
    }
  }

  /**
   * Save manifest changes back to file
   */
  private async saveManifests(): Promise&amp;lt;void&amp;gt; {
    try {
      const manifestContent &#x3D; await fs.readFile(this.config.manifestFile, &amp;#39;utf-8&amp;#39;);
      const manifestArray &#x3D; Array.from(this.manifests.values());

      const updatedContent &#x3D; await this.cueManipulator.addToSection(
        manifestContent,
        &amp;#39;shardManifests&amp;#39;,
        &amp;#39;&amp;#39;,
        manifestArray
      );

      const formatted &#x3D; await formatCUE(updatedContent);
      await fs.writeFile(this.config.manifestFile, formatted);
    } catch (error) {
      throw new Error(&#x60;Failed to save shard manifests: ${error}&#x60;);
    }
  }

  /**
   * Find the appropriate shard for a new epic
   */
  private findAvailableShard(): string | null {
    // Find a shard with space
    for (const [shardId, manifest] of this.manifests) {
      if (manifest.size &amp;lt; this.config.maxEpicsPerShard) {
        return shardId;
      }
    }

    // No available shard found
    return null;
  }

  /**
   * Create a new shard
   */
  private async createNewShard(): Promise&amp;lt;string&amp;gt; {
    const shardNumber &#x3D; this.manifests.size + 1;
    const shardId &#x3D; &#x60;${this.config.shardPrefix}-${shardNumber}&#x60;;
    const fileName &#x3D; &#x60;${shardId}.cue&#x60;;
    const filePath &#x3D; path.join(this.config.baseDir, fileName);

    // Create the shard file
    const shardContent &#x3D; &#x60;package ${this.config.cuePackage}

// Epic Shard ${shardNumber}
// This file contains a subset of epics for better organization

epics: {
  // Epics in this shard will be added here
}&#x60;;

    const formatted &#x3D; await formatCUE(shardContent);
    await fs.writeFile(filePath, formatted);

    // Create manifest entry
    const manifest: ShardManifest &#x3D; {
      shardId,
      fileName,
      epics: [],
      size: 0,
      totalTasks: 0,
      created: new Date().toISOString(),
      lastModified: new Date().toISOString(),
    };

    this.manifests.set(shardId, manifest);
    await this.saveManifests();

    console.log(chalk.green(&#x60;âœ… Created new shard: ${shardId}&#x60;));
    return shardId;
  }

  /**
   * Add an epic to the appropriate shard
   */
  async addEpic(epic: Epic): Promise&amp;lt;string&amp;gt; {
    // Find available shard or create new one
    let targetShard &#x3D; epic.arbiter?.shard || this.findAvailableShard();

    if (!targetShard) {
      if (this.config.autoCreateShards) {
        targetShard &#x3D; await this.createNewShard();
      } else {
        throw new Error(&amp;#39;No available shards and auto-creation is disabled&amp;#39;);
      }
    }

    const manifest &#x3D; this.manifests.get(targetShard);
    if (!manifest) {
      throw new Error(&#x60;Shard ${targetShard} not found in manifests&#x60;);
    }

    // Ensure epic has shard information
    epic.arbiter &#x3D; {
      ...epic.arbiter,
      shard: targetShard,
      cuePackage: this.config.cuePackage,
    };

    // Validate task dependencies
    this.validateTaskDependencies(epic.tasks);

    // Sort tasks by dependency order
    epic.tasks &#x3D; this.sortTasksByDependencies(epic.tasks);

    // Load shard file and add epic
    const shardPath &#x3D; path.join(this.config.baseDir, manifest.fileName);
    let shardContent &#x3D; &amp;#39;&amp;#39;;

    if (fs.existsSync(shardPath)) {
      shardContent &#x3D; await fs.readFile(shardPath, &amp;#39;utf-8&amp;#39;);
    } else {
      // Create shard file if it doesn&amp;#39;t exist
      shardContent &#x3D; &#x60;package ${this.config.cuePackage}\n\nepics: {}&#x60;;
    }

    // Add epic using CUE manipulation
    const updatedContent &#x3D; await this.cueManipulator.addToSection(
      shardContent,
      &amp;#39;epics&amp;#39;,
      epic.id,
      epic
    );

    // Validate and save
    const validationResult &#x3D; await validateCUE(updatedContent);
    if (!validationResult.valid) {
      throw new Error(&#x60;CUE validation failed: ${validationResult.errors.join(&amp;#39;, &amp;#39;)}&#x60;);
    }

    const formatted &#x3D; await formatCUE(updatedContent);
    await fs.writeFile(shardPath, formatted);

    // Update manifest
    manifest.epics.push({
      id: epic.id,
      status: epic.status,
      lastModified: new Date().toISOString(),
    });
    manifest.size &#x3D; manifest.epics.length;
    manifest.totalTasks &#x3D; manifest.epics.reduce((sum, e) &#x3D;&amp;gt; sum + (epic.tasks?.length || 0), 0);
    manifest.lastModified &#x3D; new Date().toISOString();

    await this.saveManifests();

    console.log(chalk.green(&#x60;âœ… Added epic &amp;quot;${epic.name}&amp;quot; to shard ${targetShard}&#x60;));
    return targetShard;
  }

  /**
   * Get an epic from its shard
   */
  async getEpic(epicId: string): Promise&amp;lt;Epic | null&amp;gt; {
    // Find which shard contains the epic
    let targetShard: string | null &#x3D; null;

    for (const [shardId, manifest] of this.manifests) {
      if (manifest.epics.some(e &#x3D;&amp;gt; e.id &#x3D;&#x3D;&#x3D; epicId)) {
        targetShard &#x3D; shardId;
        break;
      }
    }

    if (!targetShard) {
      return null;
    }

    const manifest &#x3D; this.manifests.get(targetShard)!;
    const shardPath &#x3D; path.join(this.config.baseDir, manifest.fileName);

    if (!fs.existsSync(shardPath)) {
      throw new Error(&#x60;Shard file ${manifest.fileName} not found&#x60;);
    }

    const shardContent &#x3D; await fs.readFile(shardPath, &amp;#39;utf-8&amp;#39;);
    const ast &#x3D; await this.cueManipulator.parse(shardContent);

    return ast.epics?.[epicId] || null;
  }

  /**
   * Update an epic in its shard
   */
  async updateEpic(epic: Epic): Promise&amp;lt;void&amp;gt; {
    const existingEpic &#x3D; await this.getEpic(epic.id);
    if (!existingEpic) {
      throw new Error(&#x60;Epic ${epic.id} not found&#x60;);
    }

    const targetShard &#x3D; existingEpic.arbiter?.shard;
    if (!targetShard) {
      throw new Error(&#x60;Epic ${epic.id} has no shard information&#x60;);
    }

    // Validate task dependencies and sort by dependency order
    this.validateTaskDependencies(epic.tasks);
    epic.tasks &#x3D; this.sortTasksByDependencies(epic.tasks);

    const manifest &#x3D; this.manifests.get(targetShard)!;
    const shardPath &#x3D; path.join(this.config.baseDir, manifest.fileName);

    const shardContent &#x3D; await fs.readFile(shardPath, &amp;#39;utf-8&amp;#39;);
    const updatedContent &#x3D; await this.cueManipulator.addToSection(
      shardContent,
      &amp;#39;epics&amp;#39;,
      epic.id,
      epic
    );

    // Validate and save
    const validationResult &#x3D; await validateCUE(updatedContent);
    if (!validationResult.valid) {
      throw new Error(&#x60;CUE validation failed: ${validationResult.errors.join(&amp;#39;, &amp;#39;)}&#x60;);
    }

    const formatted &#x3D; await formatCUE(updatedContent);
    await fs.writeFile(shardPath, formatted);

    // Update manifest
    const epicManifest &#x3D; manifest.epics.find(e &#x3D;&amp;gt; e.id &#x3D;&#x3D;&#x3D; epic.id);
    if (epicManifest) {
      epicManifest.status &#x3D; epic.status;
      epicManifest.lastModified &#x3D; new Date().toISOString();
    }

    manifest.lastModified &#x3D; new Date().toISOString();
    await this.saveManifests();

    console.log(chalk.green(&#x60;âœ… Updated epic &amp;quot;${epic.name}&amp;quot; in shard ${targetShard}&#x60;));
  }

  /**
   * List all epics across all shards
   */
  async listEpics(status?: string): Promise&amp;lt;Epic[]&amp;gt; {
    const epics: Epic[] &#x3D; [];

    for (const [shardId, manifest] of this.manifests) {
      const shardPath &#x3D; path.join(this.config.baseDir, manifest.fileName);

      if (!fs.existsSync(shardPath)) {
        console.warn(chalk.yellow(&#x60;Warning: Shard file ${manifest.fileName} not found&#x60;));
        continue;
      }

      try {
        const shardContent &#x3D; await fs.readFile(shardPath, &amp;#39;utf-8&amp;#39;);
        const ast &#x3D; await this.cueManipulator.parse(shardContent);

        if (ast.epics) {
          for (const epicId of Object.keys(ast.epics)) {
            const epic &#x3D; ast.epics[epicId];
            if (!status || epic.status &#x3D;&#x3D;&#x3D; status) {
              // Sort tasks by dependency order
              if (epic.tasks) {
                epic.tasks &#x3D; this.sortTasksByDependencies(epic.tasks);
              }
              epics.push(epic);
            }
          }
        }
      } catch (error) {
        console.warn(chalk.yellow(&#x60;Warning: Could not parse shard ${shardId}: ${error}&#x60;));
      }
    }

    return epics;
  }

  /**
   * Get dependency-ordered tasks across all epics
   */
  async getOrderedTasks(epicId?: string): Promise&amp;lt;Task[]&amp;gt; {
    if (epicId) {
      const epic &#x3D; await this.getEpic(epicId);
      return epic?.tasks ? this.sortTasksByDependencies(epic.tasks) : [];
    }

    const allEpics &#x3D; await this.listEpics();
    const allTasks: Task[] &#x3D; [];

    for (const epic of allEpics) {
      if (epic.tasks) {
        // Add epic context to tasks for cross-epic dependencies
        const tasksWithEpicContext &#x3D; epic.tasks.map(task &#x3D;&amp;gt; ({
          ...task,
          epicId: epic.id,
        }));
        allTasks.push(...tasksWithEpicContext);
      }
    }

    // Sort by dependencies within each epic, then by epic priority
    return this.sortTasksByDependencies(allTasks);
  }

  /**
   * Get storage statistics
   */
  async getStats(): Promise&amp;lt;{
    totalShards: number;
    totalEpics: number;
    totalTasks: number;
    avgEpicsPerShard: number;
    shardUtilization: number;
  }&amp;gt; {
    const totalShards &#x3D; this.manifests.size;
    let totalEpics &#x3D; 0;
    let totalTasks &#x3D; 0;

    for (const manifest of this.manifests.values()) {
      totalEpics +&#x3D; manifest.size;
      totalTasks +&#x3D; manifest.totalTasks;
    }

    const avgEpicsPerShard &#x3D; totalShards &amp;gt; 0 ? totalEpics / totalShards : 0;
    const shardUtilization &#x3D;
      totalShards &amp;gt; 0 ? (totalEpics / (totalShards * this.config.maxEpicsPerShard)) * 100 : 0;

    return {
      totalShards,
      totalEpics,
      totalTasks,
      avgEpicsPerShard,
      shardUtilization,
    };
  }

  /**
   * Validate task dependencies for cycles and missing references
   */
  private validateTaskDependencies(tasks: Task[]): void {
    const taskIds &#x3D; new Set(tasks.map(t &#x3D;&amp;gt; t.id));

    // Check for missing dependencies
    for (const task of tasks) {
      if (task.dependsOn) {
        for (const depId of task.dependsOn) {
          if (!taskIds.has(depId)) {
            throw new Error(&#x60;Task &amp;quot;${task.id}&amp;quot; depends on non-existent task &amp;quot;${depId}&amp;quot;&#x60;);
          }
        }
      }
    }

    // Check for circular dependencies using DFS
    const visited &#x3D; new Set&amp;lt;string&amp;gt;();
    const recursionStack &#x3D; new Set&amp;lt;string&amp;gt;();

    const hasCycle &#x3D; (taskId: string): boolean &#x3D;&amp;gt; {
      if (recursionStack.has(taskId)) {
        return true; // Found cycle
      }

      if (visited.has(taskId)) {
        return false; // Already processed
      }

      visited.add(taskId);
      recursionStack.add(taskId);

      const task &#x3D; tasks.find(t &#x3D;&amp;gt; t.id &#x3D;&#x3D;&#x3D; taskId);
      if (task?.dependsOn) {
        for (const depId of task.dependsOn) {
          if (hasCycle(depId)) {
            return true;
          }
        }
      }

      recursionStack.delete(taskId);
      return false;
    };

    for (const task of tasks) {
      if (!visited.has(task.id) &amp;amp;&amp;amp; hasCycle(task.id)) {
        throw new Error(&#x60;Circular dependency detected involving task &amp;quot;${task.id}&amp;quot;&#x60;);
      }
    }
  }

  /**
   * Sort tasks by dependencies using topological sorting
   */
  private sortTasksByDependencies(tasks: Task[]): Task[] {
    if (tasks.length &#x3D;&#x3D;&#x3D; 0) return [];

    // Create adjacency list and in-degree count
    const adjList &#x3D; new Map&amp;lt;string, string[]&amp;gt;();
    const inDegree &#x3D; new Map&amp;lt;string, number&amp;gt;();

    // Initialize
    for (const task of tasks) {
      adjList.set(task.id, []);
      inDegree.set(task.id, 0);
    }

    // Build graph
    for (const task of tasks) {
      if (task.dependsOn) {
        for (const depId of task.dependsOn) {
          // Only consider dependencies within this task set
          if (adjList.has(depId)) {
            adjList.get(depId)?.push(task.id);
            inDegree.set(task.id, inDegree.get(task.id)! + 1);
          }
        }
      }
    }

    // Kahn&amp;#39;s algorithm for topological sorting
    const queue: string[] &#x3D; [];
    const result: Task[] &#x3D; [];

    // Find all tasks with no dependencies
    for (const [taskId, degree] of inDegree) {
      if (degree &#x3D;&#x3D;&#x3D; 0) {
        queue.push(taskId);
      }
    }

    while (queue.length &amp;gt; 0) {
      const currentId &#x3D; queue.shift()!;
      const currentTask &#x3D; tasks.find(t &#x3D;&amp;gt; t.id &#x3D;&#x3D;&#x3D; currentId)!;
      result.push(currentTask);

      // Process dependents
      for (const dependentId of adjList.get(currentId)!) {
        inDegree.set(dependentId, inDegree.get(dependentId)! - 1);
        if (inDegree.get(dependentId) &#x3D;&#x3D;&#x3D; 0) {
          queue.push(dependentId);
        }
      }
    }

    // If result doesn&amp;#39;t contain all tasks, there was a cycle (shouldn&amp;#39;t happen due to validation)
    if (result.length !&#x3D;&#x3D; tasks.length) {
      throw new Error(&amp;#39;Unable to sort tasks - circular dependency detected&amp;#39;);
    }

    return result;
  }

  /**
   * Get dependency graph for visualization
   */
  getDependencyGraph(tasks: Task[]): {
    nodes: Array&amp;lt;{ id: string; name: string; type: string; status: string }&amp;gt;;
    edges: Array&amp;lt;{ from: string; to: string }&amp;gt;;
  } {
    const nodes &#x3D; tasks.map(task &#x3D;&amp;gt; ({
      id: task.id,
      name: task.name,
      type: task.type,
      status: task.status,
    }));

    const edges: Array&amp;lt;{ from: string; to: string }&amp;gt; &#x3D; [];

    for (const task of tasks) {
      if (task.dependsOn) {
        for (const depId of task.dependsOn) {
          edges.push({ from: depId, to: task.id });
        }
      }
    }

    return { nodes, edges };
  }

  /**
   * Get tasks that can be started (no incomplete dependencies)
   */
  getReadyTasks(tasks: Task[]): Task[] {
    return tasks.filter(task &#x3D;&amp;gt; {
      if (task.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39; || task.status &#x3D;&#x3D;&#x3D; &amp;#39;cancelled&amp;#39;) {
        return false;
      }

      if (!task.dependsOn || task.dependsOn.length &#x3D;&#x3D;&#x3D; 0) {
        return true;
      }

      // Check if all dependencies are completed
      return task.dependsOn.every(depId &#x3D;&amp;gt; {
        const depTask &#x3D; tasks.find(t &#x3D;&amp;gt; t.id &#x3D;&#x3D;&#x3D; depId);
        return depTask?.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39;;
      });
    });
  }

  /**
   * Get blocked tasks (have incomplete dependencies)
   */
  getBlockedTasks(tasks: Task[]): Task[] {
    return tasks.filter(task &#x3D;&amp;gt; {
      if (task.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39; || task.status &#x3D;&#x3D;&#x3D; &amp;#39;cancelled&amp;#39;) {
        return false;
      }

      if (!task.dependsOn || task.dependsOn.length &#x3D;&#x3D;&#x3D; 0) {
        return false;
      }

      // Check if any dependencies are not completed
      return task.dependsOn.some(depId &#x3D;&amp;gt; {
        const depTask &#x3D; tasks.find(t &#x3D;&amp;gt; t.id &#x3D;&#x3D;&#x3D; depId);
        return depTask?.status !&#x3D;&#x3D; &amp;#39;completed&amp;#39;;
      });
    });
  }

  /**
   * Cleanup and close storage
   */
  async close(): Promise&amp;lt;void&amp;gt; {
    await this.cueManipulator.cleanup?.();
  }
}

// Export default instance with standard configuration
export const shardedStorage &#x3D; new ShardedCUEStorage();
</pre>
                </div>
            </div>
            <div class="file-section" id="file-8">
                <div class="file-header">ğŸ“„ apps/api/src/events.ts</div>
                <div class="file-content">
                    <pre>/**
 * Real-time events and WebSocket management
 */
import type { ServerWebSocket } from &amp;#39;bun&amp;#39;;
import { NatsService } from &amp;#39;./nats.ts&amp;#39;;
import type { AuthContext, Event, ServerConfig, WebSocketMessage } from &amp;#39;./types.ts&amp;#39;;
import { generateId, getCurrentTimestamp, logger } from &amp;#39;./utils.ts&amp;#39;;

interface WebSocketConnection {
  id: string;
  ws: ServerWebSocket&amp;lt;{ connectionId: string; authContext: AuthContext }&amp;gt;;
  authContext: AuthContext;
  projectSubscriptions: Set&amp;lt;string&amp;gt;;
  lastPing: number;
}

export class EventService {
  private connections &#x3D; new Map&amp;lt;string, WebSocketConnection&amp;gt;();
  private projectSubscriptions &#x3D; new Map&amp;lt;string, Set&amp;lt;string&amp;gt;&amp;gt;(); // projectId -&amp;gt; Set&amp;lt;connectionId&amp;gt;
  private pingInterval?: Timer;
  private nats: NatsService;

  constructor(private config: ServerConfig) {
    this.nats &#x3D; new NatsService(config.nats);
    this.startPingInterval();
  }

  /**
   * Start WebSocket ping interval to keep connections alive
   */
  private startPingInterval(): void {
    this.pingInterval &#x3D; setInterval(() &#x3D;&amp;gt; {
      this.pingAllConnections();
    }, this.config.websocket.ping_interval_ms);
  }

  /**
   * Handle new WebSocket connection
   */
  handleConnection(
    ws: ServerWebSocket&amp;lt;{ connectionId: string; authContext: AuthContext }&amp;gt;,
    authContext: AuthContext
  ): string {
    const connectionId &#x3D; generateId();

    const connection: WebSocketConnection &#x3D; {
      id: connectionId,
      ws,
      authContext,
      projectSubscriptions: new Set(),
      lastPing: Date.now(),
    };

    this.connections.set(connectionId, connection);

    // Set connection data for WebSocket
    ws.data &#x3D; { connectionId, authContext };

    // Reduced logging - only log if debug level enabled
    // logger.info(&amp;quot;WebSocket connection established&amp;quot;, {
    //   connectionId,
    //   userId: authContext.user_id,
    //   totalConnections: this.connections.size,
    // });

    // Send welcome message
    this.sendToConnection(connectionId, {
      type: &amp;#39;event&amp;#39;,
      data: {
        event_type: &amp;#39;connection_established&amp;#39;,
        connection_id: connectionId,
        timestamp: getCurrentTimestamp(),
      },
    });

    return connectionId;
  }

  /**
   * Handle WebSocket disconnection
   */
  handleDisconnection(connectionId: string): void {
    const connection &#x3D; this.connections.get(connectionId);

    if (connection) {
      // Remove from all project subscriptions
      for (const projectId of connection.projectSubscriptions) {
        this.unsubscribeFromProject(connectionId, projectId);
      }

      this.connections.delete(connectionId);

      // Reduced logging - only log if debug level enabled
      // logger.info(&amp;quot;WebSocket connection closed&amp;quot;, {
      //   connectionId,
      //   userId: connection.authContext.user_id,
      //   totalConnections: this.connections.size,
      // });
    }
  }

  /**
   * Handle incoming WebSocket message
   */
  async handleMessage(connectionId: string, message: WebSocketMessage): Promise&amp;lt;void&amp;gt; {
    const connection &#x3D; this.connections.get(connectionId);

    if (!connection) {
      logger.warn(&amp;#39;Message from unknown connection&amp;#39;, { connectionId });
      return;
    }

    try {
      switch (message.type) {
        case &amp;#39;ping&amp;#39;:
          this.handlePing(connectionId);
          break;

        case &amp;#39;event&amp;#39;:
          await this.handleEventMessage(connectionId, message);
          break;

        default:
          logger.warn(&amp;#39;Unknown message type&amp;#39;, {
            connectionId,
            messageType: message.type,
          });
      }
    } catch (error) {
      logger.error(&amp;#39;Error handling WebSocket message&amp;#39;, error instanceof Error ? error : undefined, {
        connectionId,
        messageType: message.type,
      });

      this.sendToConnection(connectionId, {
        type: &amp;#39;error&amp;#39;,
        data: {
          error: &amp;#39;Failed to process message&amp;#39;,
          originalMessage: message,
        },
      });
    }
  }

  /**
   * Handle ping message
   */
  private handlePing(connectionId: string): void {
    const connection &#x3D; this.connections.get(connectionId);

    if (connection) {
      connection.lastPing &#x3D; Date.now();

      this.sendToConnection(connectionId, {
        type: &amp;#39;pong&amp;#39;,
        data: { timestamp: getCurrentTimestamp() },
      });
    }
  }

  /**
   * Handle event-type message (subscribe/unsubscribe)
   */
  private async handleEventMessage(connectionId: string, message: WebSocketMessage): Promise&amp;lt;void&amp;gt; {
    const connection &#x3D; this.connections.get(connectionId);
    if (!connection) return;

    const { data } &#x3D; message;
    const action &#x3D; data.action as string;
    const projectId &#x3D; data.project_id as string;

    switch (action) {
      case &amp;#39;subscribe&amp;#39;:
        if (projectId) {
          await this.subscribeToProject(connectionId, projectId);
        }
        break;

      case &amp;#39;unsubscribe&amp;#39;:
        if (projectId) {
          this.unsubscribeFromProject(connectionId, projectId);
        }
        break;

      default:
        logger.warn(&amp;#39;Unknown event action&amp;#39;, { connectionId, action });
    }
  }

  /**
   * Subscribe connection to project events
   */
  private async subscribeToProject(connectionId: string, projectId: string): Promise&amp;lt;void&amp;gt; {
    const connection &#x3D; this.connections.get(connectionId);

    if (!connection) {
      return;
    }

    // Check if user has access to project
    if (
      !connection.authContext.project_access.includes(&amp;#39;*&amp;#39;) &amp;amp;&amp;amp;
      !connection.authContext.project_access.includes(projectId)
    ) {
      this.sendToConnection(connectionId, {
        type: &amp;#39;error&amp;#39;,
        data: {
          error: &amp;#39;Access denied&amp;#39;,
          project_id: projectId,
        },
      });
      return;
    }

    // Add to project subscriptions
    connection.projectSubscriptions.add(projectId);

    if (!this.projectSubscriptions.has(projectId)) {
      this.projectSubscriptions.set(projectId, new Set());
    }
    this.projectSubscriptions.get(projectId)?.add(connectionId);

    logger.info(&amp;#39;Subscribed to project&amp;#39;, {
      connectionId,
      projectId,
      userId: connection.authContext.user_id,
    });

    // Acknowledge subscription
    this.sendToConnection(connectionId, {
      type: &amp;#39;event&amp;#39;,
      project_id: projectId,
      data: {
        event_type: &amp;#39;subscription_confirmed&amp;#39;,
        project_id: projectId,
        timestamp: getCurrentTimestamp(),
      },
    });
  }

  /**
   * Unsubscribe connection from project events
   */
  private unsubscribeFromProject(connectionId: string, projectId: string): void {
    const connection &#x3D; this.connections.get(connectionId);

    if (connection) {
      connection.projectSubscriptions.delete(projectId);
    }

    const projectConnections &#x3D; this.projectSubscriptions.get(projectId);
    if (projectConnections) {
      projectConnections.delete(connectionId);

      // Clean up empty project subscriptions
      if (projectConnections.size &#x3D;&#x3D;&#x3D; 0) {
        this.projectSubscriptions.delete(projectId);
      }
    }

    logger.debug(&amp;#39;Unsubscribed from project&amp;#39;, { connectionId, projectId });
  }

  /**
   * Broadcast event to all subscribers of a project
   */
  /**
   * Create WebSocket message from event
   */
  private createWebSocketMessage(
    projectId: string,
    event: Omit&amp;lt;Event, &amp;#39;id&amp;#39; | &amp;#39;created_at&amp;#39;&amp;gt;
  ): WebSocketMessage {
    return {
      type: &amp;#39;event&amp;#39;,
      project_id: projectId,
      data: {
        ...event,
        id: generateId(),
        created_at: getCurrentTimestamp(),
      },
    };
  }

  /**
   * Publish event to NATS (non-blocking)
   */
  private async publishToNats(
    projectId: string,
    event: Omit&amp;lt;Event, &amp;#39;id&amp;#39; | &amp;#39;created_at&amp;#39;&amp;gt;,
    specHash?: string
  ): Promise&amp;lt;void&amp;gt; {
    this.nats.publishEvent(projectId, event, specHash).catch(_error &#x3D;&amp;gt; {
      // Already logged in NatsService, but ensure it doesn&amp;#39;t affect WebSocket flow
      logger.debug(&amp;#39;NATS publish completed with potential error&amp;#39;, {
        projectId,
        eventType: event.event_type,
      });
    });
  }

  /**
   * Check if there are subscribers for the project
   */
  private hasProjectSubscribers(projectId: string): boolean {
    const subscribers &#x3D; this.projectSubscriptions.get(projectId);
    return !!(subscribers &amp;amp;&amp;amp; subscribers.size &amp;gt; 0);
  }

  /**
   * Get project subscribers
   */
  private getProjectSubscribers(projectId: string): Set&amp;lt;string&amp;gt; | undefined {
    return this.projectSubscriptions.get(projectId);
  }

  /**
   * Send message to individual connection with error handling
   */
  private async sendToConnectionSafe(
    connectionId: string,
    message: WebSocketMessage,
    projectId: string
  ): Promise&amp;lt;{ success: boolean }&amp;gt; {
    try {
      await this.sendToConnection(connectionId, message);
      return { success: true };
    } catch (error) {
      logger.error(
        &amp;#39;Failed to send message to connection&amp;#39;,
        error instanceof Error ? error : undefined,
        {
          connectionId,
          projectId,
        }
      );
      return { success: false };
    }
  }

  /**
   * Broadcast message to all WebSocket subscribers
   */
  private async broadcastToSubscribers(
    subscribers: Set&amp;lt;string&amp;gt;,
    message: WebSocketMessage,
    projectId: string
  ): Promise&amp;lt;{ successCount: number; errorCount: number }&amp;gt; {
    const promises &#x3D; Array.from(subscribers).map(connectionId &#x3D;&amp;gt;
      this.sendToConnectionSafe(connectionId, message, projectId)
    );

    const results &#x3D; await Promise.all(promises);
    const successCount &#x3D; results.filter(r &#x3D;&amp;gt; r.success).length;
    const errorCount &#x3D; results.length - successCount;

    return { successCount, errorCount };
  }

  /**
   * Log broadcast results and performance
   */
  private logBroadcastResults(
    projectId: string,
    event: Omit&amp;lt;Event, &amp;#39;id&amp;#39; | &amp;#39;created_at&amp;#39;&amp;gt;,
    subscriberCount: number,
    successCount: number,
    errorCount: number,
    duration: number
  ): void {
    logger.info(&amp;#39;Broadcasted event to project&amp;#39;, {
      projectId,
      eventType: event.event_type,
      subscriberCount,
      successCount,
      errorCount,
      duration,
    });
  }

  /**
   * Check and warn about broadcast performance
   */
  private checkBroadcastPerformance(projectId: string, duration: number, targetMs &#x3D; 100): void {
    if (duration &amp;gt; targetMs) {
      logger.warn(&amp;#39;Broadcast exceeded target time&amp;#39;, {
        projectId,
        duration,
        target: targetMs,
      });
    }
  }

  async broadcastToProject(
    projectId: string,
    event: Omit&amp;lt;Event, &amp;#39;id&amp;#39; | &amp;#39;created_at&amp;#39;&amp;gt;,
    specHash?: string
  ): Promise&amp;lt;void&amp;gt; {
    const startTime &#x3D; Date.now();

    // Create WebSocket message
    const message &#x3D; this.createWebSocketMessage(projectId, event);

    // Publish to NATS (async, non-blocking)
    await this.publishToNats(projectId, event, specHash);

    // Check for WebSocket subscribers
    if (!this.hasProjectSubscribers(projectId)) {
      logger.debug(&amp;#39;No WebSocket subscribers for project&amp;#39;, { projectId });
      return;
    }

    const subscribers &#x3D; this.getProjectSubscribers(projectId)!;

    // Broadcast to all WebSocket subscribers
    const { successCount, errorCount } &#x3D; await this.broadcastToSubscribers(
      subscribers,
      message,
      projectId
    );

    // Log results and check performance
    const duration &#x3D; Date.now() - startTime;
    this.logBroadcastResults(
      projectId,
      event,
      subscribers.size,
      successCount,
      errorCount,
      duration
    );
    this.checkBroadcastPerformance(projectId, duration);
  }

  /**
   * Send message to specific connection
   */
  private async sendToConnection(connectionId: string, message: WebSocketMessage): Promise&amp;lt;void&amp;gt; {
    const connection &#x3D; this.connections.get(connectionId);

    if (!connection) {
      throw new Error(&#x60;Connection ${connectionId} not found&#x60;);
    }

    try {
      const messageStr &#x3D; JSON.stringify(message);
      connection.ws.send(messageStr);
    } catch (error) {
      // Connection might be closed, remove it
      this.handleDisconnection(connectionId);
      throw error;
    }
  }

  /**
   * Ping all connections to keep them alive
   */
  private pingAllConnections(): void {
    const now &#x3D; Date.now();
    const timeout &#x3D; this.config.websocket.ping_interval_ms * 2;
    const staleConnections: string[] &#x3D; [];

    for (const [connectionId, connection] of this.connections.entries()) {
      if (now - connection.lastPing &amp;gt; timeout) {
        staleConnections.push(connectionId);
      } else {
        this.sendToConnection(connectionId, {
          type: &amp;#39;ping&amp;#39;,
          data: { timestamp: getCurrentTimestamp() },
        }).catch(() &#x3D;&amp;gt; {
          // Connection error, mark for removal
          staleConnections.push(connectionId);
        });
      }
    }

    // Clean up stale connections
    staleConnections.forEach(connectionId &#x3D;&amp;gt; {
      logger.info(&amp;#39;Removing stale connection&amp;#39;, { connectionId });
      this.handleDisconnection(connectionId);
    });
  }

  /**
   * Get connection statistics
   */
  getStats(): {
    totalConnections: number;
    totalProjects: number;
    connectionsByProject: Record&amp;lt;string, number&amp;gt;;
    nats: {
      enabled: boolean;
      connected: boolean;
      eventsPublished: number;
    };
  } {
    const connectionsByProject: Record&amp;lt;string, number&amp;gt; &#x3D; {};

    for (const [projectId, connections] of this.projectSubscriptions.entries()) {
      connectionsByProject[projectId] &#x3D; connections.size;
    }

    return {
      totalConnections: this.connections.size,
      totalProjects: this.projectSubscriptions.size,
      connectionsByProject,
      nats: this.nats.getStats(),
    };
  }

  /**
   * Close all connections and cleanup
   */
  async cleanup(): Promise&amp;lt;void&amp;gt; {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
    }

    // Close all connections
    for (const connection of this.connections.values()) {
      try {
        connection.ws.close();
      } catch {
        // Ignore close errors
      }
    }

    this.connections.clear();
    this.projectSubscriptions.clear();

    // Cleanup NATS connection
    await this.nats.cleanup();

    logger.info(&amp;#39;EventService cleanup completed&amp;#39;);
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-9">
                <div class="file-header">ğŸ“„ apps/api/src/nats.ts</div>
                <div class="file-content">
                    <pre>/**
 * NATS integration service for external agent communication
 * Publishes spec events to NATS topics for external AI agents to consume
 */
import { type ConnectionOptions, type NatsConnection, connect } from &amp;#39;nats&amp;#39;;
import type { Event, NatsConfig, NatsSpecEvent } from &amp;#39;./types.ts&amp;#39;;
import { getCurrentTimestamp, logger } from &amp;#39;./utils.ts&amp;#39;;

export class NatsService {
  private connection: NatsConnection | null &#x3D; null;
  private config: NatsConfig;
  private isConnected &#x3D; false;
  private reconnectAttempts &#x3D; 0;
  private eventSequence &#x3D; 0;
  private reconnectTimer?: Timer;

  constructor(config?: NatsConfig) {
    this.config &#x3D; {
      url: process.env.NATS_URL || &amp;#39;nats://localhost:4222&amp;#39;,
      enabled: !!process.env.NATS_URL || false,
      reconnectTimeWait: 2000, // Start with 2 seconds
      maxReconnectAttempts: 10,
      topicPrefix: &amp;#39;spec&amp;#39;,
      ...config,
    };

    if (this.config.enabled) {
      this.initialize();
    } else {
      logger.info(&amp;#39;NATS integration disabled - no NATS_URL configured&amp;#39;);
    }
  }

  /**
   * Initialize NATS connection
   */
  private async initialize(): Promise&amp;lt;void&amp;gt; {
    if (!this.config.enabled) {
      return;
    }

    try {
      const connectionOptions: ConnectionOptions &#x3D; {
        servers: [this.config.url!],
        reconnectTimeWait: this.config.reconnectTimeWait,
        maxReconnectAttempts: this.config.maxReconnectAttempts,
        pingInterval: 60000, // 60 seconds
        maxPingOut: 2,
      };

      logger.info(&amp;#39;Connecting to NATS server&amp;#39;, {
        url: this.config.url,
        options: connectionOptions,
      });

      this.connection &#x3D; await connect(connectionOptions);
      this.isConnected &#x3D; true;
      this.reconnectAttempts &#x3D; 0;

      logger.info(&amp;#39;Successfully connected to NATS server&amp;#39;, {
        server: this.connection.getServer(),
      });

      // Set up event listeners
      this.setupConnectionListeners();
    } catch (error) {
      this.isConnected &#x3D; false;

      logger.error(&amp;#39;Failed to connect to NATS server&amp;#39;, error instanceof Error ? error : undefined, {
        url: this.config.url,
        attempts: this.reconnectAttempts,
      });

      this.scheduleReconnect();
    }
  }

  /**
   * Setup connection event listeners
   */
  private setupConnectionListeners(): void {
    if (!this.connection) return;

    // Monitor connection state
    this.connection.closed().then(error &#x3D;&amp;gt; {
      this.isConnected &#x3D; false;

      if (error) {
        logger.error(
          &amp;#39;NATS connection closed with error&amp;#39;,
          error instanceof Error ? error : undefined
        );
        this.scheduleReconnect();
      } else {
        logger.info(&amp;#39;NATS connection closed normally&amp;#39;);
      }
    });
  }

  /**
   * Schedule a reconnection attempt with exponential backoff
   */
  private scheduleReconnect(): void {
    if (this.reconnectAttempts &amp;gt;&#x3D; this.config.maxReconnectAttempts) {
      logger.error(&amp;#39;Max NATS reconnect attempts reached, giving up&amp;#39;, undefined, {
        maxAttempts: this.config.maxReconnectAttempts,
      });
      return;
    }

    const delay &#x3D; Math.min(
      this.config.reconnectTimeWait * 2 ** this.reconnectAttempts,
      30000 // Max 30 seconds
    );

    this.reconnectAttempts++;

    logger.info(&amp;#39;Scheduling NATS reconnect&amp;#39;, {
      attempt: this.reconnectAttempts,
      delay,
      maxAttempts: this.config.maxReconnectAttempts,
    });

    this.reconnectTimer &#x3D; setTimeout(() &#x3D;&amp;gt; {
      this.initialize();
    }, delay);
  }

  /**
   * Publish event to NATS topic for external agents
   */
  async publishEvent(
    projectId: string,
    event: Omit&amp;lt;Event, &amp;#39;id&amp;#39; | &amp;#39;created_at&amp;#39;&amp;gt;,
    specHash?: string
  ): Promise&amp;lt;void&amp;gt; {
    // Always return early if NATS is disabled - no impact on core functionality
    if (!this.config.enabled || !this.connection || !this.isConnected) {
      return;
    }

    try {
      // Map event type to topic suffix
      const topicSuffix &#x3D; this.getTopicSuffix(event.event_type);
      const topic &#x3D; &#x60;${this.config.topicPrefix}.${projectId}.${topicSuffix}.updated&#x60;;

      const natsEvent: NatsSpecEvent &#x3D; {
        topic,
        projectId,
        event,
        metadata: {
          timestamp: getCurrentTimestamp(),
          specHash,
          sequence: ++this.eventSequence,
        },
      };

      // Publish to NATS (fire and forget for performance)
      this.connection.publish(topic, JSON.stringify(natsEvent));

      logger.debug(&amp;#39;Published event to NATS&amp;#39;, {
        topic,
        projectId,
        eventType: event.event_type,
        sequence: this.eventSequence,
      });
    } catch (error) {
      // Log error but don&amp;#39;t throw - NATS failures should never break core functionality
      logger.error(&amp;#39;Failed to publish event to NATS&amp;#39;, error instanceof Error ? error : undefined, {
        projectId,
        eventType: event.event_type,
      });
    }
  }

  /**
   * Map event types to NATS topic suffixes
   */
  private getTopicSuffix(eventType: string): string {
    switch (eventType) {
      case &amp;#39;fragment_created&amp;#39;:
      case &amp;#39;fragment_updated&amp;#39;:
      case &amp;#39;fragment_deleted&amp;#39;:
        return &amp;#39;fragment&amp;#39;;

      case &amp;#39;validation_started&amp;#39;:
      case &amp;#39;validation_completed&amp;#39;:
      case &amp;#39;validation_failed&amp;#39;:
        return &amp;#39;validation&amp;#39;;

      case &amp;#39;version_frozen&amp;#39;:
        return &amp;#39;version&amp;#39;;

      default:
        return &amp;#39;general&amp;#39;;
    }
  }

  /**
   * Health check for NATS connection
   */
  getHealthStatus(): {
    enabled: boolean;
    connected: boolean;
    server?: string;
    reconnectAttempts: number;
    eventsPublished: number;
  } {
    return {
      enabled: this.config.enabled,
      connected: this.isConnected,
      server: this.connection?.getServer(),
      reconnectAttempts: this.reconnectAttempts,
      eventsPublished: this.eventSequence,
    };
  }

  /**
   * Get connection statistics
   */
  getStats(): {
    enabled: boolean;
    connected: boolean;
    eventsPublished: number;
    config: NatsConfig;
  } {
    return {
      enabled: this.config.enabled,
      connected: this.isConnected,
      eventsPublished: this.eventSequence,
      config: this.config,
    };
  }

  /**
   * Manually trigger reconnection (for testing/admin)
   */
  async reconnect(): Promise&amp;lt;void&amp;gt; {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer &#x3D; undefined;
    }

    this.reconnectAttempts &#x3D; 0;
    await this.initialize();
  }

  /**
   * Close NATS connection and cleanup
   */
  async cleanup(): Promise&amp;lt;void&amp;gt; {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer &#x3D; undefined;
    }

    if (this.connection) {
      try {
        await this.connection.close();
        logger.info(&amp;#39;NATS connection closed successfully&amp;#39;);
      } catch (error) {
        logger.error(&amp;#39;Error closing NATS connection&amp;#39;, error instanceof Error ? error : undefined);
      }

      this.connection &#x3D; null;
      this.isConnected &#x3D; false;
    }
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-10">
                <div class="file-header">ğŸ“„ packages/cli/src/api-client.ts</div>
                <div class="file-content">
                    <pre>import type { IRResponse, ValidationRequest, ValidationResponse } from &amp;#39;@arbiter/shared&amp;#39;;
import { COMMON_PORTS } from &amp;#39;./config.js&amp;#39;;
import type { CLIConfig, CommandResult } from &amp;#39;./types.js&amp;#39;;

/**
 * Rate-limited HTTP API client for Arbiter server
 * Implements rate limiting (â‰¤1 RPS), payload size limits (â‰¤64KB), and timeout compliance (â‰¤750ms)
 * according to the Arbiter specification
 */
export class ApiClient {
  private baseUrl: string;
  private timeout: number;
  private lastRequestTime &#x3D; 0;
  private discoveredUrl: string | null &#x3D; null;
  private readonly MAX_PAYLOAD_SIZE &#x3D; 64 * 1024; // 64KB
  private readonly MIN_REQUEST_INTERVAL &#x3D; 1000; // 1 second (1 RPS)
  private readonly MAX_TIMEOUT &#x3D; 750; // 750ms per spec

  constructor(config: CLIConfig) {
    this.baseUrl &#x3D; config.apiUrl.replace(/\/$/, &amp;#39;&amp;#39;); // Remove trailing slash
    // Ensure timeout compliance with spec (â‰¤750ms)
    this.timeout &#x3D; Math.min(config.timeout, this.MAX_TIMEOUT);
  }

  /**
   * Auto-discover server by trying common ports
   */
  async discoverServer(): Promise&amp;lt;{ success: boolean; url?: string; error?: string }&amp;gt; {
    const hostname &#x3D; new URL(this.baseUrl).hostname;
    const protocol &#x3D; new URL(this.baseUrl).protocol;

    for (const port of COMMON_PORTS) {
      const testUrl &#x3D; &#x60;${protocol}//${hostname}:${port}&#x60;;

      try {
        const controller &#x3D; new AbortController();
        const timeoutId &#x3D; setTimeout(() &#x3D;&amp;gt; controller.abort(), 2000); // Quick discovery timeout

        const response &#x3D; await fetch(&#x60;${testUrl}/health&#x60;, {
          signal: controller.signal,
          method: &amp;#39;GET&amp;#39;,
        });

        clearTimeout(timeoutId);

        if (response.ok) {
          this.discoveredUrl &#x3D; testUrl;
          return { success: true, url: testUrl };
        }
      } catch {}
    }

    return {
      success: false,
      error: &#x60;No Arbiter server found on common ports [${COMMON_PORTS.join(&amp;#39;, &amp;#39;)}]. Please ensure the server is running.&#x60;,
    };
  }

  /**
   * Get the effective base URL (discovered or configured)
   */
  private getEffectiveBaseUrl(): string {
    return this.discoveredUrl || this.baseUrl;
  }

  /**
   * Enforce rate limiting (â‰¤1 RPS) with exponential backoff
   */
  private async enforceRateLimit(): Promise&amp;lt;void&amp;gt; {
    const now &#x3D; Date.now();
    const timeSinceLastRequest &#x3D; now - this.lastRequestTime;

    if (timeSinceLastRequest &amp;lt; this.MIN_REQUEST_INTERVAL) {
      const waitTime &#x3D; this.MIN_REQUEST_INTERVAL - timeSinceLastRequest;
      await new Promise(resolve &#x3D;&amp;gt; setTimeout(resolve, waitTime));
    }

    this.lastRequestTime &#x3D; Date.now();
  }

  /**
   * Validate payload size (â‰¤64KB)
   */
  private validatePayloadSize(payload: string): void {
    const size &#x3D; new TextEncoder().encode(payload).length;
    if (size &amp;gt; this.MAX_PAYLOAD_SIZE) {
      throw new Error(
        &#x60;Payload size ${size} bytes exceeds maximum allowed ${this.MAX_PAYLOAD_SIZE} bytes (64KB)&#x60;
      );
    }
  }

  /**
   * Validate CUE content using the /api/validate endpoint
   */
  async validate(
    content: string,
    _options: {
      schema?: string;
      strict?: boolean;
    } &#x3D; {}
  ): Promise&amp;lt;CommandResult&amp;lt;ValidationResponse&amp;gt;&amp;gt; {
    try {
      await this.enforceRateLimit();
      this.validatePayloadSize(content);

      const request: ValidationRequest &#x3D; {
        text: content,
        files: [], // Empty files array for text-based validation
        projectId: &amp;#39;cli-project&amp;#39;, // Use a default project ID for CLI
      };

      const requestPayload &#x3D; JSON.stringify(request);
      this.validatePayloadSize(requestPayload);

      const response &#x3D; await this.fetch(&amp;#39;/api/validate&amp;#39;, {
        method: &amp;#39;POST&amp;#39;,
        body: requestPayload,
        headers: {
          &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;,
        },
      });

      if (!response.ok) {
        const errorText &#x3D; await response.text();
        return {
          success: false,
          error: &#x60;API error: ${response.status} ${errorText}&#x60;,
          exitCode: 1,
        };
      }

      const data: ValidationResponse &#x3D; await response.json();

      return {
        success: data.success,
        data,
        exitCode: data.success ? 0 : 1,
      };
    } catch (error) {
      return {
        success: false,
        error: &#x60;Network error: ${error instanceof Error ? error.message : String(error)}&#x60;,
        exitCode: 2,
      };
    }
  }

  /**
   * Get intermediate representation using the /api/ir endpoint
   */
  async getIR(content: string): Promise&amp;lt;CommandResult&amp;lt;IRResponse&amp;gt;&amp;gt; {
    try {
      await this.enforceRateLimit();
      this.validatePayloadSize(content);

      const requestPayload &#x3D; JSON.stringify({ text: content });
      this.validatePayloadSize(requestPayload);

      const response &#x3D; await this.fetch(&amp;#39;/api/ir&amp;#39;, {
        method: &amp;#39;POST&amp;#39;,
        body: requestPayload,
        headers: {
          &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;,
        },
      });

      if (!response.ok) {
        const errorText &#x3D; await response.text();
        return {
          success: false,
          error: &#x60;API error: ${response.status} ${errorText}&#x60;,
          exitCode: 1,
        };
      }

      const data: IRResponse &#x3D; await response.json();

      return {
        success: true,
        data,
        exitCode: 0,
      };
    } catch (error) {
      return {
        success: false,
        error: &#x60;Network error: ${error instanceof Error ? error.message : String(error)}&#x60;,
        exitCode: 2,
      };
    }
  }

  /**
   * Lightweight helper for ad-hoc API requests
   */
  async request(path: string, init: RequestInit &#x3D; {}): Promise&amp;lt;Response&amp;gt; {
    await this.enforceRateLimit();
    return this.fetch(path, init);
  }

  /**
   * List fragments for a project
   */
  async listFragments(projectId &#x3D; &amp;#39;default&amp;#39;): Promise&amp;lt;CommandResult&amp;lt;any[]&amp;gt;&amp;gt; {
    try {
      await this.enforceRateLimit();

      const response &#x3D; await this.fetch(
        &#x60;/api/fragments?projectId&#x3D;${encodeURIComponent(projectId)}&#x60;
      );

      if (!response.ok) {
        const errorText &#x3D; await response.text();
        return {
          success: false,
          error: &#x60;API error: ${response.status} ${errorText}&#x60;,
          exitCode: 1,
        };
      }

      const data &#x3D; await response.json();

      return {
        success: true,
        data,
        exitCode: 0,
      };
    } catch (error) {
      return {
        success: false,
        error: &#x60;Network error: ${error instanceof Error ? error.message : String(error)}&#x60;,
        exitCode: 2,
      };
    }
  }

  /**
   * Update or create a fragment
   */
  async updateFragment(
    projectId: string,
    path: string,
    content: string,
    options?: { author?: string; message?: string }
  ): Promise&amp;lt;CommandResult&amp;lt;any&amp;gt;&amp;gt; {
    try {
      await this.enforceRateLimit();
      this.validatePayloadSize(content);

      const requestPayload &#x3D; JSON.stringify({
        projectId,
        path,
        content,
        author: options?.author,
        message: options?.message,
      });
      this.validatePayloadSize(requestPayload);

      const response &#x3D; await this.fetch(&amp;#39;/api/fragments&amp;#39;, {
        method: &amp;#39;POST&amp;#39;,
        body: requestPayload,
        headers: {
          &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;,
        },
      });

      if (!response.ok) {
        const errorText &#x3D; await response.text();
        return {
          success: false,
          error: &#x60;API error: ${response.status} ${errorText}&#x60;,
          exitCode: 1,
        };
      }

      const data &#x3D; await response.json();

      return {
        success: true,
        data,
        exitCode: 0,
      };
    } catch (error) {
      return {
        success: false,
        error: &#x60;Network error: ${error instanceof Error ? error.message : String(error)}&#x60;,
        exitCode: 2,
      };
    }
  }

  /**
   * Store CUE specification in service database with sharding support
   */
  async storeSpecification(spec: {
    content: string;
    type: string;
    path: string;
    shard?: string;
  }): Promise&amp;lt;CommandResult&amp;lt;{ success: boolean; id: string; shard?: string }&amp;gt;&amp;gt; {
    await this.enforceRateLimit();

    try {
      const response &#x3D; await this.fetch(&amp;#39;/api/specifications&amp;#39;, {
        method: &amp;#39;POST&amp;#39;,
        headers: { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39; },
        body: JSON.stringify({
          ...spec,
          sharded: true, // Indicate this should use sharded storage
        }),
      });

      if (!response.ok) {
        const error &#x3D; await response.text();
        return {
          success: false,
          data: null,
          error: &#x60;Failed to store specification: ${error}&#x60;,
          exitCode: 1,
        };
      }

      const data &#x3D; await response.json();
      return { success: true, data, error: null, exitCode: 0 };
    } catch (error) {
      return {
        success: false,
        data: null,
        error: &#x60;Network error storing specification: ${error}&#x60;,
        exitCode: 2,
      };
    }
  }

  /**
   * Get CUE specification from service database
   */
  async getSpecification(type: string, path: string): Promise&amp;lt;CommandResult&amp;lt;{ content: string }&amp;gt;&amp;gt; {
    await this.enforceRateLimit();

    try {
      const params &#x3D; new URLSearchParams({ type, path });
      const response &#x3D; await this.fetch(&#x60;/api/specifications?${params}&#x60;);

      if (!response.ok) {
        if (response.status &#x3D;&#x3D;&#x3D; 404) {
          return {
            success: false,
            data: null,
            error: &amp;#39;Specification not found&amp;#39;,
            exitCode: 1,
          };
        }
        const error &#x3D; await response.text();
        return {
          success: false,
          data: null,
          error: &#x60;Failed to get specification: ${error}&#x60;,
          exitCode: 1,
        };
      }

      const data &#x3D; await response.json();
      return { success: true, data, error: null, exitCode: 0 };
    } catch (error) {
      return {
        success: false,
        data: null,
        error: &#x60;Network error getting specification: ${error}&#x60;,
        exitCode: 2,
      };
    }
  }

  /**
   * Check server health using the /health endpoint
   * Automatically attempts discovery if initial connection fails
   */
  async health(): Promise&amp;lt;CommandResult&amp;lt;{ status: string; timestamp: string }&amp;gt;&amp;gt; {
    try {
      await this.enforceRateLimit();

      // First try the configured URL
      let response &#x3D; await this.fetch(&amp;#39;/health&amp;#39;);

      // If it fails, try auto-discovery
      if (!response.ok || response.status &#x3D;&#x3D;&#x3D; 404) {
        console.warn(
          &#x60;Initial connection to ${this.baseUrl} failed. Attempting server discovery...&#x60;
        );
        const discovery &#x3D; await this.discoverServer();

        if (discovery.success &amp;amp;&amp;amp; discovery.url) {
          console.log(&#x60;âœ“ Found server at ${discovery.url}&#x60;);
          // Retry with discovered URL
          response &#x3D; await this.fetch(&amp;#39;/health&amp;#39;);
        } else {
          return {
            success: false,
            error: discovery.error || &#x60;Cannot reach server at ${this.baseUrl}&#x60;,
            exitCode: 2,
          };
        }
      }

      if (!response.ok) {
        return {
          success: false,
          error: &#x60;Server unhealthy: ${response.status}&#x60;,
          exitCode: 1,
        };
      }

      const data &#x3D; await response.json();

      return {
        success: true,
        data,
        exitCode: 0,
      };
    } catch (error) {
      // Try auto-discovery on any connection error
      const discovery &#x3D; await this.discoverServer();

      if (discovery.success) {
        return this.health(); // Retry after discovery
      }

      return {
        success: false,
        error:
          discovery.error ||
          &#x60;Cannot reach server: ${error instanceof Error ? error.message : String(error)}&#x60;,
        exitCode: 2,
      };
    }
  }

  /**
   * Export CUE content to various formats using the dedicated /export endpoint
   */
  async export(
    content: string,
    format: string,
    options: {
      strict?: boolean;
      includeExamples?: boolean;
      outputMode?: &amp;#39;single&amp;#39; | &amp;#39;multiple&amp;#39;;
    } &#x3D; {}
  ): Promise&amp;lt;CommandResult&amp;lt;any&amp;gt;&amp;gt; {
    try {
      const response &#x3D; await this.fetch(&amp;#39;/export&amp;#39;, {
        method: &amp;#39;POST&amp;#39;,
        body: JSON.stringify({
          text: content,
          format,
          strict: options.strict || false,
          includeExamples: options.includeExamples || false,
          outputMode: options.outputMode || &amp;#39;single&amp;#39;,
        }),
        headers: {
          &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;,
        },
      });

      if (!response.ok) {
        const errorData &#x3D; await response.json().catch(() &#x3D;&amp;gt; ({ error: &amp;#39;Unknown error&amp;#39; }));
        return {
          success: false,
          error: errorData.error || &#x60;Export failed: ${response.status}&#x60;,
          exitCode: 1,
        };
      }

      const data &#x3D; await response.json();

      if (!data.success) {
        return {
          success: false,
          error: data.error || &amp;#39;Export failed&amp;#39;,
          exitCode: 1,
        };
      }

      return {
        success: true,
        data,
        exitCode: 0,
      };
    } catch (error) {
      return {
        success: false,
        error: &#x60;Export error: ${error instanceof Error ? error.message : String(error)}&#x60;,
        exitCode: 2,
      };
    }
  }

  /**
   * Get supported export formats from the API
   */
  async getSupportedFormats(): Promise&amp;lt;CommandResult&amp;lt;any&amp;gt;&amp;gt; {
    try {
      const response &#x3D; await this.fetch(&amp;#39;/export/formats&amp;#39;);

      if (!response.ok) {
        return {
          success: false,
          error: &#x60;Failed to get formats: ${response.status}&#x60;,
          exitCode: 1,
        };
      }

      const data &#x3D; await response.json();

      return {
        success: data.success,
        data: data.formats,
        exitCode: data.success ? 0 : 1,
      };
    } catch (error) {
      return {
        success: false,
        error: &#x60;Network error: ${error instanceof Error ? error.message : String(error)}&#x60;,
        exitCode: 2,
      };
    }
  }

  /**
   * Internal fetch wrapper with timeout and error handling
   */
  private async fetch(endpoint: string, options: RequestInit &#x3D; {}): Promise&amp;lt;Response&amp;gt; {
    const baseUrl &#x3D; this.getEffectiveBaseUrl();
    const url &#x3D; &#x60;${baseUrl}${endpoint}&#x60;;

    const controller &#x3D; new AbortController();
    const timeoutId &#x3D; setTimeout(() &#x3D;&amp;gt; controller.abort(), this.timeout);

    try {
      const response &#x3D; await fetch(url, {
        ...options,
        signal: controller.signal,
      });

      clearTimeout(timeoutId);
      return response;
    } catch (error) {
      clearTimeout(timeoutId);

      if (error instanceof Error &amp;amp;&amp;amp; error.name &#x3D;&#x3D;&#x3D; &amp;#39;AbortError&amp;#39;) {
        throw new Error(&#x60;Request timeout after ${this.timeout}ms connecting to ${baseUrl}&#x60;);
      }

      // Enhance error message with connection details
      if (
        error instanceof Error &amp;amp;&amp;amp;
        (error.message.includes(&amp;#39;ECONNREFUSED&amp;#39;) || error.message.includes(&amp;#39;fetch failed&amp;#39;))
      ) {
        throw new Error(&#x60;Connection failed to ${baseUrl}. Is the Arbiter server running?&#x60;);
      }

      throw error;
    }
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-11">
                <div class="file-header">ğŸ“„ apps/api/src/handlers/services.ts</div>
                <div class="file-content">
                    <pre>/**
 * Handler Services - Provide secure, sandboxed services for custom handlers
 */

import { mkdir } from &amp;#39;node:fs/promises&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import nodemailer from &amp;#39;nodemailer&amp;#39;;
import type { Transporter } from &amp;#39;nodemailer&amp;#39;;
import { logger as defaultLogger } from &amp;#39;../utils.js&amp;#39;;
import { HandlerSandbox } from &amp;#39;./sandbox.js&amp;#39;;
import type {
  FileDiff,
  GitService,
  HttpClient,
  HttpResponse,
  Logger,
  NotificationService,
  RequestOptions,
  SlackMessage,
} from &amp;#39;./types.js&amp;#39;;

type EmailMode &#x3D; &amp;#39;disabled&amp;#39; | &amp;#39;log&amp;#39; | &amp;#39;smtp&amp;#39;;

export interface HandlerEmailConfig {
  mode?: EmailMode;
  from?: string;
  smtp?: {
    host?: string;
    port?: number;
    secure?: boolean;
    user?: string;
    pass?: string;
  };
}

/**
 * HTTP Client for handlers with built-in security and rate limiting
 */
export class HandlerHttpClient implements HttpClient {
  private requestCounts &#x3D; new Map&amp;lt;string, { count: number; resetTime: number }&amp;gt;();
  private readonly maxRequestsPerMinute &#x3D; 60;
  private readonly allowedDomains &#x3D; new Set([
    &amp;#39;api.github.com&amp;#39;,
    &amp;#39;gitlab.com&amp;#39;,
    &amp;#39;hooks.slack.com&amp;#39;,
    &amp;#39;api.slack.com&amp;#39;,
    &amp;#39;discord.com&amp;#39;,
    &amp;#39;api.trello.com&amp;#39;,
    &amp;#39;api.atlassian.com&amp;#39;,
  ]);

  constructor(private logger: Logger) {}

  async get(url: string, options: RequestOptions &#x3D; {}): Promise&amp;lt;HttpResponse&amp;gt; {
    return this.makeRequest(&amp;#39;GET&amp;#39;, url, undefined, options);
  }

  async post(url: string, data?: unknown, options: RequestOptions &#x3D; {}): Promise&amp;lt;HttpResponse&amp;gt; {
    return this.makeRequest(&amp;#39;POST&amp;#39;, url, data, options);
  }

  async put(url: string, data?: unknown, options: RequestOptions &#x3D; {}): Promise&amp;lt;HttpResponse&amp;gt; {
    return this.makeRequest(&amp;#39;PUT&amp;#39;, url, data, options);
  }

  async delete(url: string, options: RequestOptions &#x3D; {}): Promise&amp;lt;HttpResponse&amp;gt; {
    return this.makeRequest(&amp;#39;DELETE&amp;#39;, url, undefined, options);
  }

  private async makeRequest(
    method: string,
    url: string,
    data?: unknown,
    options: RequestOptions &#x3D; {}
  ): Promise&amp;lt;HttpResponse&amp;gt; {
    // Validate URL
    this.validateUrl(url);

    // Rate limiting
    this.checkRateLimit();

    const { timeout &#x3D; 10000, retries &#x3D; 0 } &#x3D; options;
    let lastError: Error | undefined;

    for (let attempt &#x3D; 0; attempt &amp;lt;&#x3D; retries; attempt++) {
      try {
        const controller &#x3D; new AbortController();
        const timeoutId &#x3D; setTimeout(() &#x3D;&amp;gt; controller.abort(), timeout);

        const requestOptions: RequestInit &#x3D; {
          method,
          headers: {
            &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;,
            &amp;#39;User-Agent&amp;#39;: &amp;#39;Arbiter-Webhook-Handler/1.0&amp;#39;,
            ...options.headers,
          },
          signal: controller.signal,
        };

        if (data &amp;amp;&amp;amp; (method &#x3D;&#x3D;&#x3D; &amp;#39;POST&amp;#39; || method &#x3D;&#x3D;&#x3D; &amp;#39;PUT&amp;#39;)) {
          requestOptions.body &#x3D; JSON.stringify(data);
        }

        this.logger.debug(&amp;#39;Making HTTP request&amp;#39;, { method, url, attempt });

        const response &#x3D; await fetch(url, requestOptions);
        clearTimeout(timeoutId);

        let responseData: unknown;
        const contentType &#x3D; response.headers.get(&amp;#39;content-type&amp;#39;) || &amp;#39;&amp;#39;;

        if (contentType.includes(&amp;#39;application/json&amp;#39;)) {
          responseData &#x3D; await response.json();
        } else {
          responseData &#x3D; await response.text();
        }

        const result: HttpResponse &#x3D; {
          status: response.status,
          statusText: response.statusText,
          data: responseData,
          headers: Object.fromEntries(response.headers.entries()),
        };

        // Log result
        this.logger.info(&amp;#39;HTTP request completed&amp;#39;, {
          method,
          url: this.sanitizeUrl(url),
          status: response.status,
          attempt,
        });

        return result;
      } catch (error) {
        lastError &#x3D; error as Error;

        if (attempt &#x3D;&#x3D;&#x3D; retries) {
          this.logger.error(&amp;#39;HTTP request failed&amp;#39;, lastError, {
            method,
            url: this.sanitizeUrl(url),
            attempt,
          });
          throw lastError;
        }

        // Exponential backoff for retries
        const delay &#x3D; Math.min(1000 * 2 ** attempt, 5000);
        await new Promise(resolve &#x3D;&amp;gt; setTimeout(resolve, delay));
      }
    }

    throw lastError || new Error(&amp;#39;HTTP request failed&amp;#39;);
  }

  private validateUrl(url: string): void {
    try {
      const parsedUrl &#x3D; new URL(url);

      // Only allow HTTPS (except localhost for development)
      if (parsedUrl.protocol !&#x3D;&#x3D; &amp;#39;https:&amp;#39; &amp;amp;&amp;amp; !parsedUrl.hostname.includes(&amp;#39;localhost&amp;#39;)) {
        throw new Error(&amp;#39;Only HTTPS URLs are allowed&amp;#39;);
      }

      // Check allowed domains
      if (
        !this.allowedDomains.has(parsedUrl.hostname) &amp;amp;&amp;amp;
        !parsedUrl.hostname.includes(&amp;#39;localhost&amp;#39;)
      ) {
        throw new Error(&#x60;Domain not allowed: ${parsedUrl.hostname}&#x60;);
      }

      // Prevent SSRF attacks
      if (parsedUrl.hostname.includes(&amp;#39;metadata&amp;#39;) || parsedUrl.hostname.includes(&amp;#39;169.254&amp;#39;)) {
        throw new Error(&amp;#39;Blocked URL pattern detected&amp;#39;);
      }
    } catch (error) {
      throw new Error(&#x60;Invalid URL: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;);
    }
  }

  private checkRateLimit(): void {
    const now &#x3D; Date.now();
    const minute &#x3D; Math.floor(now / 60000);

    const current &#x3D; this.requestCounts.get(String(minute)) || { count: 0, resetTime: minute };

    if (current.count &amp;gt;&#x3D; this.maxRequestsPerMinute) {
      throw new Error(&amp;#39;Rate limit exceeded: too many HTTP requests&amp;#39;);
    }

    current.count++;
    this.requestCounts.set(String(minute), current);

    // Clean up old entries
    for (const [key, value] of this.requestCounts) {
      if (value.resetTime &amp;lt; minute - 5) {
        // Keep last 5 minutes
        this.requestCounts.delete(key);
      }
    }
  }

  private sanitizeUrl(url: string): string {
    try {
      const parsedUrl &#x3D; new URL(url);
      return &#x60;${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}&#x60;;
    } catch {
      return &amp;#39;[invalid-url]&amp;#39;;
    }
  }
}

/**
 * Notification service for handlers
 */
export class HandlerNotificationService implements NotificationService {
  private emailMode: EmailMode;
  private emailFrom?: string;
  private transporter?: Transporter;

  constructor(private logger: Logger, private emailConfig: HandlerEmailConfig &#x3D; {}) {
    this.emailMode &#x3D; this.resolveEmailMode(emailConfig.mode);
    this.emailFrom &#x3D; emailConfig.from ?? process.env.HANDLER_EMAIL_FROM;

    if (this.emailMode &#x3D;&#x3D;&#x3D; &amp;#39;smtp&amp;#39;) {
      this.configureSmtpTransport(emailConfig.smtp);
    }
  }

  async sendSlack(webhookUrl: string, message: SlackMessage): Promise&amp;lt;void&amp;gt; {
    if (!webhookUrl.includes(&amp;#39;hooks.slack.com&amp;#39;)) {
      throw new Error(&amp;#39;Invalid Slack webhook URL&amp;#39;);
    }

    const payload &#x3D; {
      text: message.text,
      blocks: message.blocks,
      channel: message.channel,
      username: message.username || &amp;#39;Arbiter Webhook&amp;#39;,
      icon_emoji: message.iconEmoji || &amp;#39;:robot_face:&amp;#39;,
    };

    try {
      const response &#x3D; await fetch(webhookUrl, {
        method: &amp;#39;POST&amp;#39;,
        headers: {
          &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;,
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(&#x60;Slack webhook failed: ${response.status} ${response.statusText}&#x60;);
      }

      this.logger.info(&amp;#39;Slack notification sent successfully&amp;#39;);
    } catch (error) {
      this.logger.error(&amp;#39;Failed to send Slack notification&amp;#39;, error as Error);
      throw error;
    }
  }

  async sendEmail(to: string, subject: string, body: string): Promise&amp;lt;void&amp;gt; {
    const sanitizedTo &#x3D; this.sanitizeEmail(to);

    if (this.emailMode &#x3D;&#x3D;&#x3D; &amp;#39;disabled&amp;#39;) {
      const message &#x3D;
        &amp;#39;Email notifications are disabled. Set HANDLER_EMAIL_MODE&#x3D;log or smtp to enable.&amp;#39;;
      this.logger.warn(message, { to: sanitizedTo });
      throw new Error(message);
    }

    if (this.emailMode &#x3D;&#x3D;&#x3D; &amp;#39;log&amp;#39;) {
      this.logger.info(&amp;#39;Email notification logged (log mode)&amp;#39;, {
        to: sanitizedTo,
        subject,
      });
      return;
    }

    if (!this.transporter || !this.emailFrom) {
      const message &#x3D; &amp;#39;Email transporter not configured. Check SMTP credentials and from address.&amp;#39;;
      this.logger.error(message, undefined, { to: sanitizedTo });
      throw new Error(message);
    }

    try {
      await this.transporter.sendMail({
        from: this.emailFrom,
        to,
        subject,
        text: body,
        html: this.renderEmailHtml(subject, body),
      });

      this.logger.info(&amp;#39;Email notification sent successfully&amp;#39;, { to: sanitizedTo, subject });
    } catch (error) {
      this.logger.error(&amp;#39;Failed to send email notification&amp;#39;, error as Error, {
        to: sanitizedTo,
      });
      throw error;
    }
  }

  async sendWebhook(url: string, payload: unknown): Promise&amp;lt;void&amp;gt; {
    try {
      const response &#x3D; await fetch(url, {
        method: &amp;#39;POST&amp;#39;,
        headers: {
          &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;,
          &amp;#39;User-Agent&amp;#39;: &amp;#39;Arbiter-Webhook-Handler/1.0&amp;#39;,
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(&#x60;Webhook failed: ${response.status} ${response.statusText}&#x60;);
      }

      this.logger.info(&amp;#39;Webhook notification sent successfully&amp;#39;, {
        url: this.sanitizeUrl(url),
      });
    } catch (error) {
      this.logger.error(&amp;#39;Failed to send webhook notification&amp;#39;, error as Error, {
        url: this.sanitizeUrl(url),
      });
      throw error;
    }
  }

  private resolveEmailMode(override?: EmailMode): EmailMode {
    if (override) return override;

    const fromEnv &#x3D; (process.env.HANDLER_EMAIL_MODE || &amp;#39;&amp;#39;).toLowerCase();
    if (fromEnv &#x3D;&#x3D;&#x3D; &amp;#39;smtp&amp;#39; || fromEnv &#x3D;&#x3D;&#x3D; &amp;#39;log&amp;#39;) {
      return fromEnv;
    }
    return &amp;#39;disabled&amp;#39;;
  }

  private configureSmtpTransport(smtpConfig?: HandlerEmailConfig[&amp;#39;smtp&amp;#39;]): void {
    const host &#x3D; smtpConfig?.host ?? process.env.HANDLER_EMAIL_SMTP_HOST;
    const port &#x3D; smtpConfig?.port ?? Number(process.env.HANDLER_EMAIL_SMTP_PORT || 587);
    const secure &#x3D; smtpConfig?.secure ?? process.env.HANDLER_EMAIL_SMTP_SECURE &#x3D;&#x3D;&#x3D; &amp;#39;true&amp;#39;;
    const user &#x3D; smtpConfig?.user ?? process.env.HANDLER_EMAIL_SMTP_USER;
    const pass &#x3D; smtpConfig?.pass ?? process.env.HANDLER_EMAIL_SMTP_PASS;

    if (!host || !user || !pass) {
      this.logger.error(&amp;#39;SMTP email mode enabled but configuration is incomplete&amp;#39;, undefined, {
        missing: {
          host: !host,
          user: !user,
          pass: !pass,
        },
      });
      this.emailMode &#x3D; &amp;#39;disabled&amp;#39;;
      return;
    }

    if (!this.emailFrom) {
      this.logger.warn(&amp;#39;SMTP email mode enabled but HANDLER_EMAIL_FROM is not set. Using user.&amp;#39;);
      this.emailFrom &#x3D; user;
    }

    this.transporter &#x3D; nodemailer.createTransport({
      host,
      port,
      secure: secure ?? port &#x3D;&#x3D;&#x3D; 465,
      auth: {
        user,
        pass,
      },
    });
  }

  private renderEmailHtml(subject: string, body: string): string {
    const safeSubject &#x3D; this.escapeHtml(subject);
    const safeBody &#x3D; this.escapeHtml(body);
    return &#x60;&amp;lt;!doctype html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta charset&#x3D;&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;title&amp;gt;${safeSubject}&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;pre style&#x3D;&amp;quot;font-family: monospace; white-space: pre-wrap;&amp;quot;&amp;gt;${safeBody}&amp;lt;/pre&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#x60;;
  }

  private sanitizeEmail(email: string): string {
    const parts &#x3D; email.split(&amp;#39;@&amp;#39;);
    if (parts.length !&#x3D;&#x3D; 2) return &amp;#39;[invalid-email]&amp;#39;;
    return &#x60;${parts[0].substring(0, 2)}***@${parts[1]}&#x60;;
  }

  private sanitizeUrl(url: string): string {
    try {
      const parsedUrl &#x3D; new URL(url);
      return &#x60;${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}&#x60;;
    } catch {
      return &amp;#39;[invalid-url]&amp;#39;;
    }
  }

  private escapeHtml(value: string): string {
    return value.replace(/&amp;amp;/g, &amp;#39;&amp;amp;amp;&amp;#39;).replace(/&amp;lt;/g, &amp;#39;&amp;amp;lt;&amp;#39;).replace(/&amp;gt;/g, &amp;#39;&amp;amp;gt;&amp;#39;);
  }
}

/**
 * Git service for handlers (limited read-only operations)
 */
export class HandlerGitService implements GitService {
  private readonly baseDir: string;

  constructor(private logger: Logger) {
    this.baseDir &#x3D; process.env.HANDLER_GIT_ROOT ?? &amp;#39;/tmp/arbiter-handler-git&amp;#39;;
  }

  async cloneRepository(url: string, target: string): Promise&amp;lt;void&amp;gt; {
    const validatedUrl &#x3D; this.validateRepoUrl(url);
    const targetPath &#x3D; await this.resolveTargetPath(target);

    await this.runGit([&amp;#39;clone&amp;#39;, &amp;#39;--depth&amp;#39;, &amp;#39;1&amp;#39;, validatedUrl, targetPath], process.cwd());
    this.logger.info(&amp;#39;Repository cloned for handler&amp;#39;, {
      url: this.sanitizeUrl(validatedUrl),
      target: targetPath,
    });
  }

  async getCommitDiff(sha: string): Promise&amp;lt;FileDiff[]&amp;gt; {
    const repoPath &#x3D; this.resolveRepoPath();
    const output &#x3D; await this.runGitOutput(
      [&amp;#39;diff&amp;#39;, &#x60;${sha}^&#x60;, sha, &amp;#39;--name-status&amp;#39;, &amp;#39;--stat&amp;#39;],
      repoPath
    );

    return this.parseDiff(output.stdout);
  }

  async getFileContent(path: string, ref &#x3D; &amp;#39;HEAD&amp;#39;): Promise&amp;lt;string&amp;gt; {
    const repoPath &#x3D; this.resolveRepoPath();
    const result &#x3D; await this.runGitOutput([&amp;#39;show&amp;#39;, &#x60;${ref}:${path}&#x60;], repoPath);
    return result.stdout;
  }

  async createBranch(name: string, from &#x3D; &amp;#39;HEAD&amp;#39;): Promise&amp;lt;void&amp;gt; {
    const repoPath &#x3D; this.resolveRepoPath();
    await this.runGit([&amp;#39;branch&amp;#39;, name, from], repoPath);
    this.logger.info(&amp;#39;Created branch for handler&amp;#39;, { name, from });
  }

  async createPullRequest(): Promise&amp;lt;unknown&amp;gt; {
    throw new Error(&amp;#39;Pull request creation requires provider integration&amp;#39;);
  }

  private resolveRepoPath(): string {
    return process.env.HANDLER_GIT_REPO_PATH ?? process.cwd();
  }

  private async resolveTargetPath(target: string): Promise&amp;lt;string&amp;gt; {
    const absolute &#x3D; path.isAbsolute(target) ? target : path.join(this.baseDir, target);
    if (!absolute.startsWith(this.baseDir)) {
      throw new Error(&amp;#39;Target path outside allowed git directory&amp;#39;);
    }
    await mkdir(path.dirname(absolute), { recursive: true });
    return absolute;
  }

  private validateRepoUrl(url: string): string {
    try {
      const parsed &#x3D; new URL(url);
      if (![&amp;#39;https:&amp;#39;, &amp;#39;git:&amp;#39;].includes(parsed.protocol)) {
        throw new Error(&amp;#39;Only HTTPS/GIT URLs are allowed&amp;#39;);
      }
      return parsed.toString();
    } catch (error) {
      throw new Error(&#x60;Invalid repository URL: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;);
    }
  }

  private async runGit(args: string[], cwd: string): Promise&amp;lt;void&amp;gt; {
    const result &#x3D; Bun.spawnSync([&amp;#39;git&amp;#39;, ...args], { cwd, stderr: &amp;#39;pipe&amp;#39;, stdout: &amp;#39;pipe&amp;#39; });
    if (result.exitCode !&#x3D;&#x3D; 0) {
      const error &#x3D; new TextDecoder().decode(result.stderr);
      throw new Error(error || &#x60;git ${args.join(&amp;#39; &amp;#39;)} failed&#x60;);
    }
  }

  private async runGitOutput(args: string[], cwd: string): Promise&amp;lt;{ stdout: string; stderr: string }&amp;gt; {
    const result &#x3D; Bun.spawnSync([&amp;#39;git&amp;#39;, ...args], { cwd, stderr: &amp;#39;pipe&amp;#39;, stdout: &amp;#39;pipe&amp;#39; });
    const stdout &#x3D; new TextDecoder().decode(result.stdout).trim();
    const stderr &#x3D; new TextDecoder().decode(result.stderr).trim();
    if (result.exitCode !&#x3D;&#x3D; 0) {
      throw new Error(stderr || &#x60;git ${args.join(&amp;#39; &amp;#39;)} failed&#x60;);
    }
    return { stdout, stderr };
  }

  private parseDiff(output: string): FileDiff[] {
    const diffs: FileDiff[] &#x3D; [];
    const lines &#x3D; output.split(&amp;#39;\n&amp;#39;);

    for (const line of lines) {
      if (!line || !/^[AMDCRTU]/.test(line)) continue;
      const [status, filePath] &#x3D; line.split(/\s+/);
      diffs.push({
        path: filePath,
        status: this.mapStatus(status),
        additions: 0,
        deletions: 0,
      });
    }

    return diffs;
  }

  private mapStatus(status: string): FileDiff[&amp;#39;status&amp;#39;] {
    switch (status[0]) {
      case &amp;#39;A&amp;#39;:
        return &amp;#39;added&amp;#39;;
      case &amp;#39;D&amp;#39;:
        return &amp;#39;deleted&amp;#39;;
      case &amp;#39;R&amp;#39;:
        return &amp;#39;renamed&amp;#39;;
      default:
        return &amp;#39;modified&amp;#39;;
    }
  }

  private sanitizeUrl(url: string): string {
    try {
      const parsedUrl &#x3D; new URL(url);
      return &#x60;${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}&#x60;;
    } catch {
      return &amp;#39;[invalid-url]&amp;#39;;
    }
  }
}

/**
 * Security validator for handler services
 */
export class HandlerSecurityValidator {
  static validateHandlerCode(code: string, logger: Logger &#x3D; defaultLogger): {
    safe: boolean;
    violations: string[];
  } {
    const sandbox &#x3D; new HandlerSandbox(logger);
    return sandbox.validate(code);
  }

  static sanitizeEnvironment(env: Record&amp;lt;string, string&amp;gt;): Record&amp;lt;string, string&amp;gt; {
    const sanitized: Record&amp;lt;string, string&amp;gt; &#x3D; {};
    const allowedKeys &#x3D; [&amp;#39;NODE_ENV&amp;#39;, &amp;#39;LOG_LEVEL&amp;#39;];

    for (const [key, value] of Object.entries(env)) {
      if (allowedKeys.includes(key) || key.startsWith(&amp;#39;HANDLER_&amp;#39;)) {
        sanitized[key] &#x3D; value;
      }
    }

    return sanitized;
  }

  static validateSecrets(secrets: Record&amp;lt;string, string&amp;gt;): { valid: boolean; errors: string[] } {
    const errors: string[] &#x3D; [];

    for (const [key, value] of Object.entries(secrets)) {
      if (!key.startsWith(&amp;#39;HANDLER_&amp;#39;)) {
        errors.push(&#x60;Secret key must start with &amp;#39;HANDLER_&amp;#39;: ${key}&#x60;);
      }

      if (value.length &amp;lt; 10) {
        errors.push(&#x60;Secret value too short: ${key}&#x60;);
      }
    }

    return {
      valid: errors.length &#x3D;&#x3D;&#x3D; 0,
      errors,
    };
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-12">
                <div class="file-header">ğŸ“„ packages/cli/src/language-plugins/python.ts</div>
                <div class="file-content">
                    <pre>/**
 * Python Language Plugin - FastAPI + SQLAlchemy 2.0+ + Modern Async Stack
 * Supports: FastAPI 0.100+, SQLAlchemy 2.0+, Pydantic v2, asyncio, pytest
 */

import type {
  BuildConfig,
  ComponentConfig,
  GeneratedFile,
  GenerationResult,
  LanguagePlugin,
  ProjectConfig,
  ServiceConfig,
} from &amp;#39;./index.js&amp;#39;;

export class PythonPlugin implements LanguagePlugin {
  readonly name &#x3D; &amp;#39;Python Plugin&amp;#39;;
  readonly language &#x3D; &amp;#39;python&amp;#39;;
  readonly version &#x3D; &amp;#39;1.0.0&amp;#39;;
  readonly description &#x3D; &amp;#39;Modern Python with FastAPI, SQLAlchemy 2.0+, and async best practices&amp;#39;;
  readonly supportedFeatures &#x3D; [
    &amp;#39;api&amp;#39;,
    &amp;#39;async-services&amp;#39;,
    &amp;#39;database-orm&amp;#39;,
    &amp;#39;validation&amp;#39;,
    &amp;#39;authentication&amp;#39;,
    &amp;#39;testing&amp;#39;,
    &amp;#39;dependency-injection&amp;#39;,
    &amp;#39;background-tasks&amp;#39;,
    &amp;#39;websockets&amp;#39;,
  ];
  readonly capabilities &#x3D; {
    services: true,
    api: true,
    testing: true,
  };

  // Python doesn&amp;#39;t have UI components like frontend frameworks
  async generateComponent(config: ComponentConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    throw new Error(&amp;#39;Component generation not supported for Python. Use generateService instead.&amp;#39;);
  }

  async generateService(config: ServiceConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    const files: GeneratedFile[] &#x3D; [];
    const dependencies: string[] &#x3D; [];

    switch (config.type) {
      case &amp;#39;api&amp;#39;:
        files.push({
          path: &#x60;app/routers/${config.name}.py&#x60;,
          content: this.generateAPIRouter(config),
        });
        dependencies.push(&amp;#39;fastapi&amp;#39;, &amp;#39;uvicorn&amp;#39;);
        break;
      case &amp;#39;service&amp;#39;:
        files.push({
          path: &#x60;app/services/${config.name}_service.py&#x60;,
          content: this.generateBusinessService(config),
        });
        break;
      case &amp;#39;model&amp;#39;:
        files.push({
          path: &#x60;app/models/${config.name}.py&#x60;,
          content: this.generateModel(config),
        });
        dependencies.push(&amp;#39;sqlalchemy&amp;#39;);
        break;
      case &amp;#39;handler&amp;#39;:
        files.push({
          path: &#x60;app/handlers/${config.name}_handler.py&#x60;,
          content: this.generateHandler(config),
        });
        break;
    }

    if (config.validation) {
      dependencies.push(&amp;#39;pydantic&amp;#39;);
      files.push({
        path: &#x60;app/schemas/${config.name}_schema.py&#x60;,
        content: this.generatePydanticSchema(config),
      });
    }

    if (config.database) {
      dependencies.push(&amp;#39;sqlalchemy&amp;#39;, &amp;#39;asyncpg&amp;#39;);
    }

    return { files, dependencies };
  }

  async initializeProject(config: ProjectConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    const files: GeneratedFile[] &#x3D; [];
    const dependencies &#x3D; [
      &amp;#39;fastapi&amp;gt;&#x3D;0.100.0&amp;#39;,
      &amp;#39;uvicorn[standard]&amp;gt;&#x3D;0.22.0&amp;#39;,
      &amp;#39;pydantic&amp;gt;&#x3D;2.0.0&amp;#39;,
      &amp;#39;python-multipart&amp;gt;&#x3D;0.0.6&amp;#39;,
    ];

    // Requirements file
    files.push({
      path: &amp;#39;requirements.txt&amp;#39;,
      content: this.generateRequirements(config, dependencies),
    });

    // Development requirements
    files.push({
      path: &amp;#39;requirements-dev.txt&amp;#39;,
      content: this.generateDevRequirements(config),
    });

    // Main application file
    files.push({
      path: &amp;#39;app/main.py&amp;#39;,
      content: this.generateMainApp(config),
    });

    // Application configuration
    files.push({
      path: &amp;#39;app/core/config.py&amp;#39;,
      content: this.generateConfig(config),
    });

    // Core package init
    files.push({
      path: &amp;#39;app/__init__.py&amp;#39;,
      content: &amp;#39;&amp;#39;,
    });

    files.push({
      path: &amp;#39;app/core/__init__.py&amp;#39;,
      content: &amp;#39;&amp;#39;,
    });

    // Database setup (if needed)
    if (config.database) {
      files.push({
        path: &amp;#39;app/core/database.py&amp;#39;,
        content: this.generateDatabase(config),
      });
      files.push({
        path: &amp;#39;app/models/__init__.py&amp;#39;,
        content: &amp;#39;&amp;#39;,
      });
      dependencies.push(&amp;#39;sqlalchemy&amp;gt;&#x3D;2.0.0&amp;#39;, &amp;#39;asyncpg&amp;gt;&#x3D;0.28.0&amp;#39;);
    }

    // Authentication setup (if needed)
    if (config.auth) {
      files.push({
        path: &amp;#39;app/core/security.py&amp;#39;,
        content: this.generateSecurity(config),
      });
      files.push({
        path: &amp;#39;app/core/auth.py&amp;#39;,
        content: this.generateAuth(config),
      });
      dependencies.push(&amp;#39;python-jose[cryptography]&amp;#39;, &amp;#39;passlib[bcrypt]&amp;#39;);
    }

    // Testing setup
    if (config.testing) {
      files.push({
        path: &amp;#39;tests/__init__.py&amp;#39;,
        content: &amp;#39;&amp;#39;,
      });
      files.push({
        path: &amp;#39;tests/conftest.py&amp;#39;,
        content: this.generateTestConfig(config),
      });
      files.push({
        path: &amp;#39;tests/test_main.py&amp;#39;,
        content: this.generateMainTest(config),
      });
    }

    // Docker setup (if requested)
    if (config.docker) {
      files.push({
        path: &amp;#39;Dockerfile&amp;#39;,
        content: this.generateDockerfile(config),
      });
      files.push({
        path: &amp;#39;docker-compose.yml&amp;#39;,
        content: this.generateDockerCompose(config),
      });
    }

    // Project metadata
    files.push({
      path: &amp;#39;pyproject.toml&amp;#39;,
      content: this.generatePyprojectToml(config),
    });

    return {
      files,
      dependencies,
      scripts: {
        dev: &amp;#39;uvicorn app.main:app --reload --host 0.0.0.0 --port 8000&amp;#39;,
        start: &amp;#39;uvicorn app.main:app --host 0.0.0.0 --port 8000&amp;#39;,
        test: &amp;#39;pytest&amp;#39;,
        &amp;#39;test:watch&amp;#39;: &amp;#39;pytest --watch&amp;#39;,
        format: &amp;#39;black . &amp;amp;&amp;amp; isort .&amp;#39;,
        lint: &amp;#39;flake8 app tests&amp;#39;,
        &amp;#39;type-check&amp;#39;: &amp;#39;mypy app&amp;#39;,
      },
    };
  }

  async generateBuildConfig(config: BuildConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    const files: GeneratedFile[] &#x3D; [];

    // Production dockerfile
    if (config.target &#x3D;&#x3D;&#x3D; &amp;#39;production&amp;#39;) {
      files.push({
        path: &amp;#39;Dockerfile.prod&amp;#39;,
        content: this.generateProductionDockerfile(config),
      });
    }

    // CI/CD configuration
    files.push({
      path: &amp;#39;.github/workflows/python-app.yml&amp;#39;,
      content: this.generateGitHubActions(config),
    });

    return { files };
  }

  private generateAPIRouter(config: ServiceConfig): string {
    const endpoints &#x3D; config.endpoints || [
      &amp;#39;GET /&amp;#39;,
      &amp;#39;POST /&amp;#39;,
      &amp;#39;GET /{id}&amp;#39;,
      &amp;#39;PUT /{id}&amp;#39;,
      &amp;#39;DELETE /{id}&amp;#39;,
    ];
    const routerMethods &#x3D; endpoints
      .map(endpoint &#x3D;&amp;gt; {
        const [method, path] &#x3D; endpoint.split(&amp;#39; &amp;#39;);
        const methodName &#x3D; method.toLowerCase();
        const safePath &#x3D; path.replace(&amp;#39;{&amp;#39;, &amp;#39;{&amp;#39;).replace(&amp;#39;}&amp;#39;, &amp;#39;}&amp;#39;); // Ensure proper formatting

        return &#x60;
@router.${methodName}(&amp;quot;${safePath}&amp;quot;)
async def ${methodName}_${config.name}(${path.includes(&amp;#39;{id}&amp;#39;) ? &amp;#39;id: int&amp;#39; : &amp;#39;&amp;#39;}):
    &amp;quot;&amp;quot;&amp;quot;${method} ${path} endpoint for ${config.name}&amp;quot;&amp;quot;&amp;quot;
    # TODO: Implement endpoint logic
    return {&amp;quot;message&amp;quot;: &amp;quot;${method} ${config.name} endpoint&amp;quot;, ${path.includes(&amp;#39;{id}&amp;#39;) ? &amp;#39;&amp;quot;id&amp;quot;: id&amp;#39; : &amp;#39;&amp;#39;}}&#x60;;
      })
      .join(&amp;#39;\n&amp;#39;);

    return &#x60;&amp;quot;&amp;quot;&amp;quot;
${config.name} Router
FastAPI router for ${config.name} endpoints
&amp;quot;&amp;quot;&amp;quot;
from fastapi import APIRouter, HTTPException, Depends
from typing import List, Optional
${config.database ? &amp;#39;from app.core.database import get_db_session&amp;#39; : &amp;#39;&amp;#39;}
${config.validation ? &#x60;from app.schemas.${config.name}_schema import ${config.name}Schema, ${config.name}Create, ${config.name}Update&#x60; : &amp;#39;&amp;#39;}

router &#x3D; APIRouter(
    prefix&#x3D;&amp;quot;/${config.name.toLowerCase()}&amp;quot;,
    tags&#x3D;[&amp;quot;${config.name}&amp;quot;],
    responses&#x3D;{404: {&amp;quot;description&amp;quot;: &amp;quot;Not found&amp;quot;}},
)

${routerMethods}
&#x60;;
  }

  private generateBusinessService(config: ServiceConfig): string {
    return &#x60;&amp;quot;&amp;quot;&amp;quot;
${config.name} Service
Business logic for ${config.name} operations
&amp;quot;&amp;quot;&amp;quot;
from typing import List, Optional, Any
from sqlalchemy.ext.asyncio import AsyncSession
${config.database ? &amp;#39;from app.core.database import get_db_session&amp;#39; : &amp;#39;&amp;#39;}
${config.validation ? &#x60;from app.schemas.${config.name}_schema import ${config.name}Schema, ${config.name}Create, ${config.name}Update&#x60; : &amp;#39;&amp;#39;}
import logging

logger &#x3D; logging.getLogger(__name__)


class ${config.name}Service:
    &amp;quot;&amp;quot;&amp;quot;Service class for ${config.name} business logic&amp;quot;&amp;quot;&amp;quot;

    async def get_all(self${config.database ? &amp;#39;, db: AsyncSession&amp;#39; : &amp;#39;&amp;#39;}) -&amp;gt; List[Any]:
        &amp;quot;&amp;quot;&amp;quot;Get all ${config.name} items&amp;quot;&amp;quot;&amp;quot;
        logger.info(f&amp;quot;Fetching all ${config.name} items&amp;quot;)
        # TODO: Implement get_all logic
        return []

    async def get_by_id(self, item_id: int${config.database ? &amp;#39;, db: AsyncSession&amp;#39; : &amp;#39;&amp;#39;}) -&amp;gt; Optional[Any]:
        &amp;quot;&amp;quot;&amp;quot;Get ${config.name} by ID&amp;quot;&amp;quot;&amp;quot;
        logger.info(f&amp;quot;Fetching ${config.name} with ID: {item_id}&amp;quot;)
        # TODO: Implement get_by_id logic
        return None

    async def create(self, item_data: Any${config.database ? &amp;#39;, db: AsyncSession&amp;#39; : &amp;#39;&amp;#39;}) -&amp;gt; Any:
        &amp;quot;&amp;quot;&amp;quot;Create new ${config.name}&amp;quot;&amp;quot;&amp;quot;
        logger.info(f&amp;quot;Creating new ${config.name}&amp;quot;)
        # TODO: Implement create logic
        return item_data

    async def update(self, item_id: int, item_data: Any${config.database ? &amp;#39;, db: AsyncSession&amp;#39; : &amp;#39;&amp;#39;}) -&amp;gt; Optional[Any]:
        &amp;quot;&amp;quot;&amp;quot;Update ${config.name} by ID&amp;quot;&amp;quot;&amp;quot;
        logger.info(f&amp;quot;Updating ${config.name} with ID: {item_id}&amp;quot;)
        # TODO: Implement update logic
        return item_data

    async def delete(self, item_id: int${config.database ? &amp;#39;, db: AsyncSession&amp;#39; : &amp;#39;&amp;#39;}) -&amp;gt; bool:
        &amp;quot;&amp;quot;&amp;quot;Delete ${config.name} by ID&amp;quot;&amp;quot;&amp;quot;
        logger.info(f&amp;quot;Deleting ${config.name} with ID: {item_id}&amp;quot;)
        # TODO: Implement delete logic
        return True


# Service instance
${config.name.toLowerCase()}_service &#x3D; ${config.name}Service()
&#x60;;
  }

  private generateModel(config: ServiceConfig): string {
    return &#x60;&amp;quot;&amp;quot;&amp;quot;
${config.name} Model
SQLAlchemy 2.0+ async model definition
&amp;quot;&amp;quot;&amp;quot;
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from sqlalchemy.sql import func
from sqlalchemy.ext.declarative import declarative_base

Base &#x3D; declarative_base()


class ${config.name}(Base):
    &amp;quot;&amp;quot;&amp;quot;${config.name} database model&amp;quot;&amp;quot;&amp;quot;
    
    __tablename__ &#x3D; &amp;quot;${config.name.toLowerCase()}s&amp;quot;

    id &#x3D; Column(Integer, primary_key&#x3D;True, index&#x3D;True)
    name &#x3D; Column(String, nullable&#x3D;False, index&#x3D;True)
    description &#x3D; Column(String, nullable&#x3D;True)
    is_active &#x3D; Column(Boolean, default&#x3D;True)
    created_at &#x3D; Column(DateTime(timezone&#x3D;True), server_default&#x3D;func.now())
    updated_at &#x3D; Column(DateTime(timezone&#x3D;True), server_default&#x3D;func.now(), onupdate&#x3D;func.now())

    def __repr__(self) -&amp;gt; str:
        return f&amp;quot;&amp;lt;${config.name}(id&#x3D;{self.id}, name&#x3D;&amp;#39;{self.name}&amp;#39;)&amp;gt;&amp;quot;
&#x60;;
  }

  private generateHandler(config: ServiceConfig): string {
    return &#x60;&amp;quot;&amp;quot;&amp;quot;
${config.name} Handler
HTTP request handlers for ${config.name}
&amp;quot;&amp;quot;&amp;quot;
from fastapi import HTTPException, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List
${config.database ? &amp;#39;from app.core.database import get_db_session&amp;#39; : &amp;#39;&amp;#39;}
${config.validation ? &#x60;from app.schemas.${config.name}_schema import ${config.name}Schema, ${config.name}Create, ${config.name}Update&#x60; : &amp;#39;&amp;#39;}
from app.services.${config.name}_service import ${config.name.toLowerCase()}_service
import logging

logger &#x3D; logging.getLogger(__name__)


class ${config.name}Handler:
    &amp;quot;&amp;quot;&amp;quot;Handler class for ${config.name} HTTP operations&amp;quot;&amp;quot;&amp;quot;

    async def handle_get_all(self${config.database ? &amp;#39;, db: AsyncSession &#x3D; Depends(get_db_session)&amp;#39; : &amp;#39;&amp;#39;}) -&amp;gt; List[Any]:
        &amp;quot;&amp;quot;&amp;quot;Handle GET request for all ${config.name} items&amp;quot;&amp;quot;&amp;quot;
        try:
            return await ${config.name.toLowerCase()}_service.get_all(${config.database ? &amp;#39;db&#x3D;db&amp;#39; : &amp;#39;&amp;#39;})
        except Exception as e:
            logger.error(f&amp;quot;Error fetching all ${config.name}: {e}&amp;quot;)
            raise HTTPException(status_code&#x3D;500, detail&#x3D;&amp;quot;Internal server error&amp;quot;)

    async def handle_get_by_id(self, item_id: int${config.database ? &amp;#39;, db: AsyncSession &#x3D; Depends(get_db_session)&amp;#39; : &amp;#39;&amp;#39;}) -&amp;gt; Any:
        &amp;quot;&amp;quot;&amp;quot;Handle GET request for ${config.name} by ID&amp;quot;&amp;quot;&amp;quot;
        try:
            item &#x3D; await ${config.name.toLowerCase()}_service.get_by_id(item_id${config.database ? &amp;#39;, db&#x3D;db&amp;#39; : &amp;#39;&amp;#39;})
            if not item:
                raise HTTPException(status_code&#x3D;404, detail&#x3D;&amp;quot;${config.name} not found&amp;quot;)
            return item
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f&amp;quot;Error fetching ${config.name} {item_id}: {e}&amp;quot;)
            raise HTTPException(status_code&#x3D;500, detail&#x3D;&amp;quot;Internal server error&amp;quot;)

    async def handle_create(self, item_data: Any${config.database ? &amp;#39;, db: AsyncSession &#x3D; Depends(get_db_session)&amp;#39; : &amp;#39;&amp;#39;}) -&amp;gt; Any:
        &amp;quot;&amp;quot;&amp;quot;Handle POST request to create ${config.name}&amp;quot;&amp;quot;&amp;quot;
        try:
            return await ${config.name.toLowerCase()}_service.create(item_data${config.database ? &amp;#39;, db&#x3D;db&amp;#39; : &amp;#39;&amp;#39;})
        except Exception as e:
            logger.error(f&amp;quot;Error creating ${config.name}: {e}&amp;quot;)
            raise HTTPException(status_code&#x3D;500, detail&#x3D;&amp;quot;Internal server error&amp;quot;)

    async def handle_update(self, item_id: int, item_data: Any${config.database ? &amp;#39;, db: AsyncSession &#x3D; Depends(get_db_session)&amp;#39; : &amp;#39;&amp;#39;}) -&amp;gt; Any:
        &amp;quot;&amp;quot;&amp;quot;Handle PUT request to update ${config.name}&amp;quot;&amp;quot;&amp;quot;
        try:
            item &#x3D; await ${config.name.toLowerCase()}_service.update(item_id, item_data${config.database ? &amp;#39;, db&#x3D;db&amp;#39; : &amp;#39;&amp;#39;})
            if not item:
                raise HTTPException(status_code&#x3D;404, detail&#x3D;&amp;quot;${config.name} not found&amp;quot;)
            return item
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f&amp;quot;Error updating ${config.name} {item_id}: {e}&amp;quot;)
            raise HTTPException(status_code&#x3D;500, detail&#x3D;&amp;quot;Internal server error&amp;quot;)

    async def handle_delete(self, item_id: int${config.database ? &amp;#39;, db: AsyncSession &#x3D; Depends(get_db_session)&amp;#39; : &amp;#39;&amp;#39;}) -&amp;gt; dict:
        &amp;quot;&amp;quot;&amp;quot;Handle DELETE request for ${config.name}&amp;quot;&amp;quot;&amp;quot;
        try:
            success &#x3D; await ${config.name.toLowerCase()}_service.delete(item_id${config.database ? &amp;#39;, db&#x3D;db&amp;#39; : &amp;#39;&amp;#39;})
            if not success:
                raise HTTPException(status_code&#x3D;404, detail&#x3D;&amp;quot;${config.name} not found&amp;quot;)
            return {&amp;quot;message&amp;quot;: &amp;quot;${config.name} deleted successfully&amp;quot;}
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f&amp;quot;Error deleting ${config.name} {item_id}: {e}&amp;quot;)
            raise HTTPException(status_code&#x3D;500, detail&#x3D;&amp;quot;Internal server error&amp;quot;)


# Handler instance
${config.name.toLowerCase()}_handler &#x3D; ${config.name}Handler()
&#x60;;
  }

  private generatePydanticSchema(config: ServiceConfig): string {
    return &#x60;&amp;quot;&amp;quot;&amp;quot;
${config.name} Pydantic Schemas
Data validation and serialization schemas using Pydantic v2
&amp;quot;&amp;quot;&amp;quot;
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional
from datetime import datetime


class ${config.name}Base(BaseModel):
    &amp;quot;&amp;quot;&amp;quot;Base schema for ${config.name}&amp;quot;&amp;quot;&amp;quot;
    name: str &#x3D; Field(..., description&#x3D;&amp;quot;${config.name} name&amp;quot;, min_length&#x3D;1, max_length&#x3D;100)
    description: Optional[str] &#x3D; Field(None, description&#x3D;&amp;quot;${config.name} description&amp;quot;, max_length&#x3D;500)
    is_active: bool &#x3D; Field(True, description&#x3D;&amp;quot;Whether the ${config.name} is active&amp;quot;)


class ${config.name}Create(${config.name}Base):
    &amp;quot;&amp;quot;&amp;quot;Schema for creating ${config.name}&amp;quot;&amp;quot;&amp;quot;
    pass


class ${config.name}Update(${config.name}Base):
    &amp;quot;&amp;quot;&amp;quot;Schema for updating ${config.name}&amp;quot;&amp;quot;&amp;quot;
    name: Optional[str] &#x3D; Field(None, description&#x3D;&amp;quot;${config.name} name&amp;quot;, min_length&#x3D;1, max_length&#x3D;100)
    is_active: Optional[bool] &#x3D; Field(None, description&#x3D;&amp;quot;Whether the ${config.name} is active&amp;quot;)


class ${config.name}Schema(${config.name}Base):
    &amp;quot;&amp;quot;&amp;quot;Schema for ${config.name} responses&amp;quot;&amp;quot;&amp;quot;
    model_config &#x3D; ConfigDict(from_attributes&#x3D;True)
    
    id: int &#x3D; Field(..., description&#x3D;&amp;quot;Unique identifier&amp;quot;)
    created_at: datetime &#x3D; Field(..., description&#x3D;&amp;quot;Creation timestamp&amp;quot;)
    updated_at: datetime &#x3D; Field(..., description&#x3D;&amp;quot;Last update timestamp&amp;quot;)


class ${config.name}InDB(${config.name}Schema):
    &amp;quot;&amp;quot;&amp;quot;Schema for ${config.name} as stored in database&amp;quot;&amp;quot;&amp;quot;
    pass
&#x60;;
  }

  private generateMainApp(config: ProjectConfig): string {
    const corsImport &#x3D; config.features.includes(&amp;#39;cors&amp;#39;)
      ? &amp;#39;from fastapi.middleware.cors import CORSMiddleware&amp;#39;
      : &amp;#39;&amp;#39;;
    const corsSetup &#x3D; config.features.includes(&amp;#39;cors&amp;#39;)
      ? &#x60;
app.add_middleware(
    CORSMiddleware,
    allow_origins&#x3D;[&amp;quot;*&amp;quot;],  # Configure appropriately for production
    allow_credentials&#x3D;True,
    allow_methods&#x3D;[&amp;quot;*&amp;quot;],
    allow_headers&#x3D;[&amp;quot;*&amp;quot;],
)&#x60;
      : &amp;#39;&amp;#39;;

    return &#x60;&amp;quot;&amp;quot;&amp;quot;
${config.name} FastAPI Application
Main application entry point with modern async patterns
&amp;quot;&amp;quot;&amp;quot;
import uvicorn
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
${corsImport}
from contextlib import asynccontextmanager
import logging
import time

from app.core.config import settings
${config.database ? &amp;#39;from app.core.database import init_db&amp;#39; : &amp;#39;&amp;#39;}

# Configure logging
logging.basicConfig(
    level&#x3D;logging.INFO,
    format&#x3D;&amp;quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&amp;quot;
)
logger &#x3D; logging.getLogger(__name__)


@asynccontextmanager
async def lifespan(app: FastAPI):
    &amp;quot;&amp;quot;&amp;quot;Application lifespan manager&amp;quot;&amp;quot;&amp;quot;
    # Startup
    logger.info(&amp;quot;Starting up ${config.name}&amp;quot;)
    ${config.database ? &amp;#39;await init_db()&amp;#39; : &amp;#39;&amp;#39;}
    
    yield
    
    # Shutdown
    logger.info(&amp;quot;Shutting down ${config.name}&amp;quot;)


# Create FastAPI instance
app &#x3D; FastAPI(
    title&#x3D;&amp;quot;${config.name}&amp;quot;,
    description&#x3D;&amp;quot;${config.description || &amp;#39;A modern FastAPI application&amp;#39;}&amp;quot;,
    version&#x3D;&amp;quot;1.0.0&amp;quot;,
    lifespan&#x3D;lifespan,
)

${corsSetup}

# Middleware for request timing
@app.middleware(&amp;quot;http&amp;quot;)
async def add_process_time_header(request: Request, call_next):
    start_time &#x3D; time.time()
    response &#x3D; await call_next(request)
    process_time &#x3D; time.time() - start_time
    response.headers[&amp;quot;X-Process-Time&amp;quot;] &#x3D; str(process_time)
    return response


# Global exception handler
@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    return JSONResponse(
        status_code&#x3D;exc.status_code,
        content&#x3D;{
            &amp;quot;error&amp;quot;: exc.detail,
            &amp;quot;status_code&amp;quot;: exc.status_code,
            &amp;quot;path&amp;quot;: str(request.url.path)
        }
    )


# Health check endpoint
@app.get(&amp;quot;/health&amp;quot;)
async def health_check():
    &amp;quot;&amp;quot;&amp;quot;Health check endpoint&amp;quot;&amp;quot;&amp;quot;
    return {
        &amp;quot;status&amp;quot;: &amp;quot;healthy&amp;quot;,
        &amp;quot;service&amp;quot;: &amp;quot;${config.name}&amp;quot;,
        &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;
    }


# Root endpoint
@app.get(&amp;quot;/&amp;quot;)
async def root():
    &amp;quot;&amp;quot;&amp;quot;Root endpoint&amp;quot;&amp;quot;&amp;quot;
    return {
        &amp;quot;message&amp;quot;: &amp;quot;Welcome to ${config.name} API&amp;quot;,
        &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
        &amp;quot;docs&amp;quot;: &amp;quot;/docs&amp;quot;
    }


# Include routers
# TODO: Add your routers here
# app.include_router(your_router, prefix&#x3D;&amp;quot;/api/v1&amp;quot;)


if __name__ &#x3D;&#x3D; &amp;quot;__main__&amp;quot;:
    uvicorn.run(
        &amp;quot;app.main:app&amp;quot;,
        host&#x3D;settings.HOST,
        port&#x3D;settings.PORT,
        reload&#x3D;settings.DEBUG,
        log_level&#x3D;&amp;quot;info&amp;quot;
    )
&#x60;;
  }

  private generateConfig(config: ProjectConfig): string {
    return &#x60;&amp;quot;&amp;quot;&amp;quot;
Application Configuration
Environment-based configuration using Pydantic Settings
&amp;quot;&amp;quot;&amp;quot;
from pydantic import Field
from pydantic_settings import BaseSettings
from typing import Optional


class Settings(BaseSettings):
    &amp;quot;&amp;quot;&amp;quot;Application settings&amp;quot;&amp;quot;&amp;quot;
    
    # Basic settings
    APP_NAME: str &#x3D; Field(default&#x3D;&amp;quot;${config.name}&amp;quot;, description&#x3D;&amp;quot;Application name&amp;quot;)
    DEBUG: bool &#x3D; Field(default&#x3D;True, description&#x3D;&amp;quot;Debug mode&amp;quot;)
    HOST: str &#x3D; Field(default&#x3D;&amp;quot;0.0.0.0&amp;quot;, description&#x3D;&amp;quot;Host to bind to&amp;quot;)
    PORT: int &#x3D; Field(default&#x3D;8000, description&#x3D;&amp;quot;Port to bind to&amp;quot;)
    
    # Database settings
    ${
      config.database
        ? &#x60;DATABASE_URL: str &#x3D; Field(
        default&#x3D;&amp;quot;postgresql+asyncpg://user:password@localhost:5432/${config.name.toLowerCase()}&amp;quot;,
        description&#x3D;&amp;quot;Database connection URL&amp;quot;
    )&#x60;
        : &amp;#39;# DATABASE_URL: str &#x3D; Field(default&#x3D;&amp;quot;sqlite:///./app.db&amp;quot;)&amp;#39;
    }
    
    # Security settings
    ${
      config.auth &#x3D;&#x3D;&#x3D; &amp;#39;jwt&amp;#39;
        ? &#x60;SECRET_KEY: str &#x3D; Field(default&#x3D;&amp;quot;your-secret-key-change-in-production&amp;quot;, description&#x3D;&amp;quot;JWT secret key&amp;quot;)
    ACCESS_TOKEN_EXPIRE_MINUTES: int &#x3D; Field(default&#x3D;30, description&#x3D;&amp;quot;Access token expiration time&amp;quot;)&#x60;
        : &amp;#39;# SECRET_KEY: str &#x3D; Field(default&#x3D;&amp;quot;your-secret-key&amp;quot;)&amp;#39;
    }
    
    # CORS settings
    CORS_ORIGINS: list[str] &#x3D; Field(default&#x3D;[&amp;quot;http://localhost:3000&amp;quot;], description&#x3D;&amp;quot;CORS allowed origins&amp;quot;)
    
    # Logging
    LOG_LEVEL: str &#x3D; Field(default&#x3D;&amp;quot;INFO&amp;quot;, description&#x3D;&amp;quot;Logging level&amp;quot;)
    
    class Config:
        env_file &#x3D; &amp;quot;.env&amp;quot;
        env_file_encoding &#x3D; &amp;quot;utf-8&amp;quot;


# Global settings instance
settings &#x3D; Settings()
&#x60;;
  }

  private generateDatabase(config: ProjectConfig): string {
    const dbType &#x3D; config.database || &amp;#39;postgres&amp;#39;;

    return &#x60;&amp;quot;&amp;quot;&amp;quot;
Database Configuration
SQLAlchemy 2.0+ async database setup
&amp;quot;&amp;quot;&amp;quot;
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.pool import NullPool
import logging

from app.core.config import settings

logger &#x3D; logging.getLogger(__name__)

# Database engine
engine &#x3D; create_async_engine(
    settings.DATABASE_URL,
    echo&#x3D;settings.DEBUG,
    poolclass&#x3D;NullPool if settings.DEBUG else None,
    pool_pre_ping&#x3D;True,
)

# Session factory
AsyncSessionLocal &#x3D; async_sessionmaker(
    engine,
    class_&#x3D;AsyncSession,
    expire_on_commit&#x3D;False,
)

# Base class for models
Base &#x3D; declarative_base()


async def get_db_session() -&amp;gt; AsyncSession:
    &amp;quot;&amp;quot;&amp;quot;Dependency to get database session&amp;quot;&amp;quot;&amp;quot;
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()


async def init_db() -&amp;gt; None:
    &amp;quot;&amp;quot;&amp;quot;Initialize database tables&amp;quot;&amp;quot;&amp;quot;
    try:
        # Import all models here to ensure they are registered
        # from app.models import user, item  # Example imports
        
        async with engine.begin() as conn:
            # Create all tables
            await conn.run_sync(Base.metadata.create_all)
        
        logger.info(&amp;quot;Database initialized successfully&amp;quot;)
    except Exception as e:
        logger.error(f&amp;quot;Error initializing database: {e}&amp;quot;)
        raise


async def close_db() -&amp;gt; None:
    &amp;quot;&amp;quot;&amp;quot;Close database connections&amp;quot;&amp;quot;&amp;quot;
    await engine.dispose()
    logger.info(&amp;quot;Database connections closed&amp;quot;)
&#x60;;
  }

  private generateSecurity(config: ProjectConfig): string {
    if (config.auth !&#x3D;&#x3D; &amp;#39;jwt&amp;#39;) return &amp;#39;&amp;#39;;

    return &#x60;&amp;quot;&amp;quot;&amp;quot;
Security Utilities
JWT token handling and password hashing
&amp;quot;&amp;quot;&amp;quot;
from datetime import datetime, timedelta
from typing import Optional, Union
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import HTTPException, status

from app.core.config import settings

# Password hashing
pwd_context &#x3D; CryptContext(schemes&#x3D;[&amp;quot;bcrypt&amp;quot;], deprecated&#x3D;&amp;quot;auto&amp;quot;)

# JWT settings
ALGORITHM &#x3D; &amp;quot;HS256&amp;quot;


def create_access_token(data: dict, expires_delta: Optional[timedelta] &#x3D; None) -&amp;gt; str:
    &amp;quot;&amp;quot;&amp;quot;Create JWT access token&amp;quot;&amp;quot;&amp;quot;
    to_encode &#x3D; data.copy()
    if expires_delta:
        expire &#x3D; datetime.utcnow() + expires_delta
    else:
        expire &#x3D; datetime.utcnow() + timedelta(minutes&#x3D;settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({&amp;quot;exp&amp;quot;: expire})
    encoded_jwt &#x3D; jwt.encode(to_encode, settings.SECRET_KEY, algorithm&#x3D;ALGORITHM)
    return encoded_jwt


def verify_token(token: str) -&amp;gt; Optional[dict]:
    &amp;quot;&amp;quot;&amp;quot;Verify JWT token&amp;quot;&amp;quot;&amp;quot;
    try:
        payload &#x3D; jwt.decode(token, settings.SECRET_KEY, algorithms&#x3D;[ALGORITHM])
        return payload
    except JWTError:
        return None


def hash_password(password: str) -&amp;gt; str:
    &amp;quot;&amp;quot;&amp;quot;Hash password&amp;quot;&amp;quot;&amp;quot;
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -&amp;gt; bool:
    &amp;quot;&amp;quot;&amp;quot;Verify password against hash&amp;quot;&amp;quot;&amp;quot;
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -&amp;gt; str:
    &amp;quot;&amp;quot;&amp;quot;Get password hash&amp;quot;&amp;quot;&amp;quot;
    return pwd_context.hash(password)
&#x60;;
  }

  private generateAuth(config: ProjectConfig): string {
    if (config.auth !&#x3D;&#x3D; &amp;#39;jwt&amp;#39;) return &amp;#39;&amp;#39;;

    return &#x60;&amp;quot;&amp;quot;&amp;quot;
Authentication Dependencies
FastAPI dependencies for authentication
&amp;quot;&amp;quot;&amp;quot;
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional

from app.core.database import get_db_session
from app.core.security import verify_token
# from app.models.user import User  # Uncomment and import your User model
# from app.services.user_service import user_service  # Uncomment and import your user service

security &#x3D; HTTPBearer()


async def get_current_user(
    credentials: HTTPAuthorizationCredentials &#x3D; Depends(security),
    db: AsyncSession &#x3D; Depends(get_db_session)
) -&amp;gt; dict:  # Replace with your User type
    &amp;quot;&amp;quot;&amp;quot;Get current authenticated user&amp;quot;&amp;quot;&amp;quot;
    token &#x3D; credentials.credentials
    
    payload &#x3D; verify_token(token)
    if payload is None:
        raise HTTPException(
            status_code&#x3D;status.HTTP_401_UNAUTHORIZED,
            detail&#x3D;&amp;quot;Could not validate credentials&amp;quot;,
            headers&#x3D;{&amp;quot;WWW-Authenticate&amp;quot;: &amp;quot;Bearer&amp;quot;},
        )
    
    # TODO: Implement user lookup
    # user_id &#x3D; payload.get(&amp;quot;sub&amp;quot;)
    # if user_id is None:
    #     raise HTTPException(
    #         status_code&#x3D;status.HTTP_401_UNAUTHORIZED,
    #         detail&#x3D;&amp;quot;Could not validate credentials&amp;quot;,
    #     )
    # 
    # user &#x3D; await user_service.get_by_id(user_id, db&#x3D;db)
    # if user is None:
    #     raise HTTPException(
    #         status_code&#x3D;status.HTTP_401_UNAUTHORIZED,
    #         detail&#x3D;&amp;quot;User not found&amp;quot;,
    #     )
    
    # Return user object or user data
    return {&amp;quot;user_id&amp;quot;: payload.get(&amp;quot;sub&amp;quot;), &amp;quot;username&amp;quot;: payload.get(&amp;quot;username&amp;quot;)}


async def get_current_active_user(
    current_user: dict &#x3D; Depends(get_current_user)  # Replace with your User type
) -&amp;gt; dict:  # Replace with your User type
    &amp;quot;&amp;quot;&amp;quot;Get current active user&amp;quot;&amp;quot;&amp;quot;
    # TODO: Implement active user check
    # if not current_user.is_active:
    #     raise HTTPException(
    #         status_code&#x3D;status.HTTP_400_BAD_REQUEST,
    #         detail&#x3D;&amp;quot;Inactive user&amp;quot;
    #     )
    
    return current_user
&#x60;;
  }

  private generateRequirements(config: ProjectConfig, baseDeps: string[]): string {
    const deps &#x3D; [...baseDeps];

    if (config.database) {
      deps.push(&amp;#39;sqlalchemy&amp;gt;&#x3D;2.0.0&amp;#39;, &amp;#39;asyncpg&amp;gt;&#x3D;0.28.0&amp;#39;);
    }
    if (config.auth &#x3D;&#x3D;&#x3D; &amp;#39;jwt&amp;#39;) {
      deps.push(&amp;#39;python-jose[cryptography]&amp;gt;&#x3D;3.3.0&amp;#39;, &amp;#39;passlib[bcrypt]&amp;gt;&#x3D;1.7.4&amp;#39;);
    }
    if (config.features.includes(&amp;#39;cors&amp;#39;)) {
      // CORS support is built into FastAPI
    }

    return deps.sort().join(&amp;#39;\n&amp;#39;);
  }

  private generateDevRequirements(config: ProjectConfig): string {
    const devDeps &#x3D; [
      &amp;#39;pytest&amp;gt;&#x3D;7.0.0&amp;#39;,
      &amp;#39;pytest-asyncio&amp;gt;&#x3D;0.21.0&amp;#39;,
      &amp;#39;httpx&amp;gt;&#x3D;0.24.0&amp;#39;,
      &amp;#39;black&amp;gt;&#x3D;23.0.0&amp;#39;,
      &amp;#39;isort&amp;gt;&#x3D;5.12.0&amp;#39;,
      &amp;#39;flake8&amp;gt;&#x3D;6.0.0&amp;#39;,
      &amp;#39;mypy&amp;gt;&#x3D;1.0.0&amp;#39;,
    ];

    if (config.testing) {
      devDeps.push(&amp;#39;pytest-cov&amp;gt;&#x3D;4.0.0&amp;#39;, &amp;#39;factory-boy&amp;gt;&#x3D;3.2.0&amp;#39;);
    }

    return devDeps.sort().join(&amp;#39;\n&amp;#39;);
  }

  private generateTestConfig(config: ProjectConfig): string {
    return &#x60;&amp;quot;&amp;quot;&amp;quot;
Pytest Configuration
Test fixtures and configuration
&amp;quot;&amp;quot;&amp;quot;
import pytest
import asyncio
from typing import Generator, AsyncGenerator
from fastapi.testclient import TestClient
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker

from app.main import app
${config.database ? &amp;#39;from app.core.database import get_db_session, Base&amp;#39; : &amp;#39;&amp;#39;}


@pytest.fixture(scope&#x3D;&amp;quot;session&amp;quot;)
def event_loop():
    &amp;quot;&amp;quot;&amp;quot;Create an instance of the default event loop for the test session.&amp;quot;&amp;quot;&amp;quot;
    loop &#x3D; asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


${
  config.database
    ? &#x60;@pytest.fixture(scope&#x3D;&amp;quot;session&amp;quot;)
async def test_db():
    &amp;quot;&amp;quot;&amp;quot;Create test database&amp;quot;&amp;quot;&amp;quot;
    # Use in-memory SQLite for tests
    engine &#x3D; create_async_engine(&amp;quot;sqlite+aiosqlite:///:memory:&amp;quot;, echo&#x3D;True)
    
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    async_session &#x3D; async_sessionmaker(engine, class_&#x3D;AsyncSession, expire_on_commit&#x3D;False)
    
    yield async_session
    
    await engine.dispose()


@pytest.fixture
async def db_session(test_db):
    &amp;quot;&amp;quot;&amp;quot;Get database session for tests&amp;quot;&amp;quot;&amp;quot;
    async with test_db() as session:
        yield session


@pytest.fixture
def override_get_db(db_session):
    &amp;quot;&amp;quot;&amp;quot;Override database dependency&amp;quot;&amp;quot;&amp;quot;
    async def _override_get_db():
        yield db_session
    
    app.dependency_overrides[get_db_session] &#x3D; _override_get_db
    yield
    app.dependency_overrides.clear()&#x60;
    : &amp;#39;&amp;#39;
}


@pytest.fixture
def client() -&amp;gt; Generator[TestClient, None, None]:
    &amp;quot;&amp;quot;&amp;quot;Create test client&amp;quot;&amp;quot;&amp;quot;
    with TestClient(app) as c:
        yield c


@pytest.fixture
async def async_client() -&amp;gt; AsyncGenerator[AsyncClient, None]:
    &amp;quot;&amp;quot;&amp;quot;Create async test client&amp;quot;&amp;quot;&amp;quot;
    async with AsyncClient(app&#x3D;app, base_url&#x3D;&amp;quot;http://test&amp;quot;) as ac:
        yield ac
&#x60;;
  }

  private generateMainTest(config: ProjectConfig): string {
    return &#x60;&amp;quot;&amp;quot;&amp;quot;
Main Application Tests
Basic API endpoint tests
&amp;quot;&amp;quot;&amp;quot;
import pytest
from fastapi.testclient import TestClient
from httpx import AsyncClient


def test_root_endpoint(client: TestClient):
    &amp;quot;&amp;quot;&amp;quot;Test root endpoint&amp;quot;&amp;quot;&amp;quot;
    response &#x3D; client.get(&amp;quot;/&amp;quot;)
    assert response.status_code &#x3D;&#x3D; 200
    data &#x3D; response.json()
    assert &amp;quot;message&amp;quot; in data
    assert &amp;quot;${config.name}&amp;quot; in data[&amp;quot;message&amp;quot;]


def test_health_check(client: TestClient):
    &amp;quot;&amp;quot;&amp;quot;Test health check endpoint&amp;quot;&amp;quot;&amp;quot;
    response &#x3D; client.get(&amp;quot;/health&amp;quot;)
    assert response.status_code &#x3D;&#x3D; 200
    data &#x3D; response.json()
    assert data[&amp;quot;status&amp;quot;] &#x3D;&#x3D; &amp;quot;healthy&amp;quot;
    assert data[&amp;quot;service&amp;quot;] &#x3D;&#x3D; &amp;quot;${config.name}&amp;quot;


@pytest.mark.asyncio
async def test_root_endpoint_async(async_client: AsyncClient):
    &amp;quot;&amp;quot;&amp;quot;Test root endpoint with async client&amp;quot;&amp;quot;&amp;quot;
    response &#x3D; await async_client.get(&amp;quot;/&amp;quot;)
    assert response.status_code &#x3D;&#x3D; 200
    data &#x3D; response.json()
    assert &amp;quot;message&amp;quot; in data


@pytest.mark.asyncio
async def test_health_check_async(async_client: AsyncClient):
    &amp;quot;&amp;quot;&amp;quot;Test health check endpoint with async client&amp;quot;&amp;quot;&amp;quot;
    response &#x3D; await async_client.get(&amp;quot;/health&amp;quot;)
    assert response.status_code &#x3D;&#x3D; 200
    data &#x3D; response.json()
    assert data[&amp;quot;status&amp;quot;] &#x3D;&#x3D; &amp;quot;healthy&amp;quot;
&#x60;;
  }

  private generateDockerfile(config: ProjectConfig): string {
    return &#x60;# Python ${config.name} Dockerfile
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE&#x3D;1 \\
    PYTHONUNBUFFERED&#x3D;1 \\
    PYTHONPATH&#x3D;/app

# Install system dependencies
RUN apt-get update \\
    &amp;amp;&amp;amp; apt-get install -y --no-install-recommends \\
        build-essential \\
        libpq-dev \\
    &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*

# Copy requirements first (for better caching)
COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip \\
    &amp;amp;&amp;amp; pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN adduser --disabled-password --gecos &amp;#39;&amp;#39; --uid 1000 appuser \\
    &amp;amp;&amp;amp; chown -R appuser:appuser /app
USER appuser

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval&#x3D;30s --timeout&#x3D;10s --start-period&#x3D;5s --retries&#x3D;3 \\
    CMD curl -f http://localhost:8000/health || exit 1

# Run application
CMD [&amp;quot;uvicorn&amp;quot;, &amp;quot;app.main:app&amp;quot;, &amp;quot;--host&amp;quot;, &amp;quot;0.0.0.0&amp;quot;, &amp;quot;--port&amp;quot;, &amp;quot;8000&amp;quot;]
&#x60;;
  }

  private generateDockerCompose(config: ProjectConfig): string {
    const dbService &#x3D;
      config.database &#x3D;&#x3D;&#x3D; &amp;#39;postgres&amp;#39;
        ? &#x60;
  database:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: ${config.name.toLowerCase()}
      POSTGRES_PASSWORD: password
      POSTGRES_DB: ${config.name.toLowerCase()}
    ports:
      - &amp;quot;5432:5432&amp;quot;
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: [&amp;quot;CMD-SHELL&amp;quot;, &amp;quot;pg_isready -U ${config.name.toLowerCase()}&amp;quot;]
      interval: 10s
      timeout: 5s
      retries: 5&#x60;
        : &amp;#39;&amp;#39;;

    return &#x60;version: &amp;#39;3.8&amp;#39;

services:
  app:
    build: .
    ports:
      - &amp;quot;8000:8000&amp;quot;
    environment:
      - DEBUG&#x3D;true
      ${config.database ? &#x60;- DATABASE_URL&#x3D;postgresql+asyncpg://${config.name.toLowerCase()}:password@database:5432/${config.name.toLowerCase()}&#x60; : &amp;#39;&amp;#39;}
    ${
      config.database
        ? &#x60;depends_on:
      database:
        condition: service_healthy&#x60;
        : &amp;#39;&amp;#39;
    }
    volumes:
      - .:/app
    restart: unless-stopped
${dbService}

${
  config.database &#x3D;&#x3D;&#x3D; &amp;#39;postgres&amp;#39;
    ? &#x60;volumes:
  postgres_data:&#x60;
    : &amp;#39;&amp;#39;
}
&#x60;;
  }

  private generatePyprojectToml(config: ProjectConfig): string {
    return &#x60;[build-system]
requires &#x3D; [&amp;quot;setuptools&amp;gt;&#x3D;61.0&amp;quot;]
build-backend &#x3D; &amp;quot;setuptools.build_meta&amp;quot;

[project]
name &#x3D; &amp;quot;${config.name.toLowerCase().replace(/[^a-z0-9-]/g, &amp;#39;-&amp;#39;)}&amp;quot;
version &#x3D; &amp;quot;1.0.0&amp;quot;
description &#x3D; &amp;quot;${config.description || &#x60;Modern FastAPI application: ${config.name}&#x60;}&amp;quot;
authors &#x3D; [
    {name &#x3D; &amp;quot;Your Name&amp;quot;, email &#x3D; &amp;quot;your.email@example.com&amp;quot;}
]
dependencies &#x3D; [
    &amp;quot;fastapi&amp;gt;&#x3D;0.100.0&amp;quot;,
    &amp;quot;uvicorn[standard]&amp;gt;&#x3D;0.22.0&amp;quot;,
    &amp;quot;pydantic&amp;gt;&#x3D;2.0.0&amp;quot;,
    &amp;quot;python-multipart&amp;gt;&#x3D;0.0.6&amp;quot;,
]
requires-python &#x3D; &amp;quot;&amp;gt;&#x3D;3.11&amp;quot;

[project.optional-dependencies]
dev &#x3D; [
    &amp;quot;pytest&amp;gt;&#x3D;7.0.0&amp;quot;,
    &amp;quot;pytest-asyncio&amp;gt;&#x3D;0.21.0&amp;quot;,
    &amp;quot;httpx&amp;gt;&#x3D;0.24.0&amp;quot;,
    &amp;quot;black&amp;gt;&#x3D;23.0.0&amp;quot;,
    &amp;quot;isort&amp;gt;&#x3D;5.12.0&amp;quot;,
    &amp;quot;flake8&amp;gt;&#x3D;6.0.0&amp;quot;,
    &amp;quot;mypy&amp;gt;&#x3D;1.0.0&amp;quot;,
]

[tool.black]
line-length &#x3D; 100
target-version &#x3D; [&amp;#39;py311&amp;#39;]
include &#x3D; &amp;#39;\\.pyi?$&amp;#39;

[tool.isort]
profile &#x3D; &amp;quot;black&amp;quot;
multi_line_output &#x3D; 3
line_length &#x3D; 100

[tool.mypy]
python_version &#x3D; &amp;quot;3.11&amp;quot;
warn_return_any &#x3D; true
warn_unused_configs &#x3D; true
disallow_untyped_defs &#x3D; true
check_untyped_defs &#x3D; true

[tool.pytest.ini_options]
testpaths &#x3D; [&amp;quot;tests&amp;quot;]
python_files &#x3D; &amp;quot;test_*.py&amp;quot;
python_classes &#x3D; &amp;quot;Test*&amp;quot;
python_functions &#x3D; &amp;quot;test_*&amp;quot;
addopts &#x3D; &amp;quot;-v --tb&#x3D;short&amp;quot;
asyncio_mode &#x3D; &amp;quot;auto&amp;quot;
&#x60;;
  }

  private generateProductionDockerfile(config: BuildConfig): string {
    return &#x60;# Production Python Dockerfile
FROM python:3.11-slim as builder

WORKDIR /app

# Install build dependencies
RUN apt-get update \\
    &amp;amp;&amp;amp; apt-get install -y --no-install-recommends \\
        build-essential \\
        libpq-dev \\
    &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*

# Copy requirements
COPY requirements.txt .
RUN pip install --user --no-cache-dir --upgrade pip \\
    &amp;amp;&amp;amp; pip install --user --no-cache-dir -r requirements.txt

# Production stage
FROM python:3.11-slim

WORKDIR /app

# Install runtime dependencies
RUN apt-get update \\
    &amp;amp;&amp;amp; apt-get install -y --no-install-recommends \\
        libpq5 \\
        curl \\
    &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*

# Copy installed packages from builder
COPY --from&#x3D;builder /root/.local /root/.local

# Copy application
COPY . .

# Create non-root user
RUN adduser --disabled-password --gecos &amp;#39;&amp;#39; --uid 1000 appuser \\
    &amp;amp;&amp;amp; chown -R appuser:appuser /app
USER appuser

# Make sure scripts in .local are usable
ENV PATH&#x3D;/root/.local/bin:$PATH

EXPOSE 8000

HEALTHCHECK --interval&#x3D;30s --timeout&#x3D;10s --start-period&#x3D;5s --retries&#x3D;3 \\
    CMD curl -f http://localhost:8000/health || exit 1

CMD [&amp;quot;uvicorn&amp;quot;, &amp;quot;app.main:app&amp;quot;, &amp;quot;--host&amp;quot;, &amp;quot;0.0.0.0&amp;quot;, &amp;quot;--port&amp;quot;, &amp;quot;8000&amp;quot;, &amp;quot;--workers&amp;quot;, &amp;quot;4&amp;quot;]
&#x60;;
  }

  private generateGitHubActions(config: BuildConfig): string {
    return &#x60;name: Python Application CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test
        options: &amp;gt;-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: &amp;#39;3.11&amp;#39;
        
    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: \${{ runner.os }}-pip-\${{ hashFiles(&amp;#39;**/requirements*.txt&amp;#39;) }}
        restore-keys: |
          \${{ runner.os }}-pip-
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Lint with flake8
      run: |
        flake8 app tests --count --select&#x3D;E9,F63,F7,F82 --show-source --statistics
        flake8 app tests --count --exit-zero --max-complexity&#x3D;10 --max-line-length&#x3D;100 --statistics
    
    - name: Format check with black
      run: black --check app tests
    
    - name: Import sort check
      run: isort --check-only app tests
    
    - name: Type check with mypy
      run: mypy app
    
    - name: Test with pytest
      env:
        DATABASE_URL: postgresql+asyncpg://postgres:postgres@localhost:5432/test
      run: |
        pytest --cov&#x3D;app --cov-report&#x3D;xml --cov-report&#x3D;term-missing
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

  ${
    config.target &#x3D;&#x3D;&#x3D; &amp;#39;production&amp;#39;
      ? &#x60;deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref &#x3D;&#x3D; &amp;#39;refs/heads/main&amp;#39;
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Build and push Docker image
      env:
        DOCKER_REGISTRY: your-registry.com
      run: |
        docker build -f Dockerfile.prod -t $DOCKER_REGISTRY/your-app:$&#x60; +
        &amp;#39;{{ github.sha }}&amp;#39; +
        &#x60; .
        docker push $DOCKER_REGISTRY/your-app:$&#x60; +
        &amp;#39;{{ github.sha }}&amp;#39;
      : &amp;#39;&amp;#39;
  }
&#x60;;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-13">
                <div class="file-header">ğŸ“„ packages/cli/src/language-plugins/typescript.ts</div>
                <div class="file-content">
                    <pre>/**
 * TypeScript Language Plugin - React + Vite + Modern Stack
 * Supports: React 18+, Vite 5+, TypeScript 5+, Tailwind CSS, Vitest
 */

import type {
  BuildConfig,
  ComponentConfig,
  GeneratedFile,
  GenerationResult,
  LanguagePlugin,
  ProjectConfig,
  ServiceConfig,
} from &amp;#39;./index.js&amp;#39;;

export class TypeScriptPlugin implements LanguagePlugin {
  readonly name &#x3D; &amp;#39;TypeScript Plugin&amp;#39;;
  readonly language &#x3D; &amp;#39;typescript&amp;#39;;
  readonly version &#x3D; &amp;#39;1.0.0&amp;#39;;
  readonly description &#x3D; &amp;#39;Modern TypeScript with React, Vite, and best practices&amp;#39;;
  readonly supportedFeatures &#x3D; [
    &amp;#39;components&amp;#39;,
    &amp;#39;hooks&amp;#39;,
    &amp;#39;api&amp;#39;,
    &amp;#39;routing&amp;#39;,
    &amp;#39;state-management&amp;#39;,
    &amp;#39;testing&amp;#39;,
    &amp;#39;styling&amp;#39;,
    &amp;#39;build-optimization&amp;#39;,
    &amp;#39;type-safety&amp;#39;,
  ];
  readonly capabilities &#x3D; {
    components: true,
    services: true,
    testing: true,
    api: true,
  };

  async generateComponent(config: ComponentConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    const files: GeneratedFile[] &#x3D; [];
    const dependencies: string[] &#x3D; [];

    // Component file
    files.push({
      path: &#x60;src/components/${config.name}/${config.name}.tsx&#x60;,
      content: this.generateComponentContent(config),
    });

    // Props type definition
    files.push({
      path: &#x60;src/components/${config.name}/types.ts&#x60;,
      content: this.generateComponentTypes(config),
    });

    // Styles (if requested)
    if (config.styles) {
      files.push({
        path: &#x60;src/components/${config.name}/${config.name}.module.css&#x60;,
        content: this.generateComponentStyles(config),
      });
    }

    // Tests (if requested)
    if (config.tests) {
      files.push({
        path: &#x60;src/components/${config.name}/${config.name}.test.tsx&#x60;,
        content: this.generateComponentTest(config),
      });
      dependencies.push(&amp;#39;@testing-library/react&amp;#39;, &amp;#39;@testing-library/jest-dom&amp;#39;);
    }

    // Index file for clean imports
    files.push({
      path: &#x60;src/components/${config.name}/index.ts&#x60;,
      content: &#x60;export { ${config.name} } from &amp;#39;./${config.name}&amp;#39;;
export type { ${config.name}Props } from &amp;#39;./types&amp;#39;;&#x60;,
    });

    return {
      files,
      dependencies,
      instructions: [
        &#x60;Component ${config.name} created successfully&#x60;,
        &#x60;Import with: import { ${config.name} } from &amp;quot;./components/${config.name}&amp;quot;;&#x60;,
      ],
    };
  }

  async generateService(config: ServiceConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    const files: GeneratedFile[] &#x3D; [];
    const dependencies: string[] &#x3D; [&amp;#39;express&amp;#39;, &amp;#39;@types/express&amp;#39;];

    switch (config.type) {
      case &amp;#39;api&amp;#39;:
        files.push({
          path: &#x60;src/api/${config.name}.ts&#x60;,
          content: this.generateAPIService(config),
        });
        break;
      case &amp;#39;service&amp;#39;:
        files.push({
          path: &#x60;src/services/${config.name}.service.ts&#x60;,
          content: this.generateBusinessService(config),
        });
        break;
      case &amp;#39;handler&amp;#39;:
        files.push({
          path: &#x60;src/handlers/${config.name}.handler.ts&#x60;,
          content: this.generateHandler(config),
        });
        break;
    }

    if (config.validation) {
      dependencies.push(&amp;#39;zod&amp;#39;);
      files.push({
        path: &#x60;src/schemas/${config.name}.schema.ts&#x60;,
        content: this.generateValidationSchema(config),
      });
    }

    return { files, dependencies };
  }

  async initializeProject(config: ProjectConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    const files: GeneratedFile[] &#x3D; [];
    const dependencies &#x3D; [
      &amp;#39;react&amp;#39;,
      &amp;#39;react-dom&amp;#39;,
      &amp;#39;@types/react&amp;#39;,
      &amp;#39;@types/react-dom&amp;#39;,
      &amp;#39;typescript&amp;#39;,
      &amp;#39;vite&amp;#39;,
      &amp;#39;@vitejs/plugin-react&amp;#39;,
    ];

    // Package.json
    files.push({
      path: &amp;#39;package.json&amp;#39;,
      content: this.generatePackageJson(config),
    });

    // Vite config
    files.push({
      path: &amp;#39;vite.config.ts&amp;#39;,
      content: this.generateViteConfig(config),
    });

    // TypeScript config
    files.push({
      path: &amp;#39;tsconfig.json&amp;#39;,
      content: this.generateTSConfig(),
    });

    // Main App component
    files.push({
      path: &amp;#39;src/App.tsx&amp;#39;,
      content: this.generateMainApp(config),
    });

    // Main entry point
    files.push({
      path: &amp;#39;src/main.tsx&amp;#39;,
      content: this.generateMainEntry(config),
    });

    // Index HTML
    files.push({
      path: &amp;#39;index.html&amp;#39;,
      content: this.generateIndexHTML(config),
    });

    // Environment types
    files.push({
      path: &amp;#39;src/vite-env.d.ts&amp;#39;,
      content: &amp;#39;/// &amp;lt;reference types&#x3D;&amp;quot;vite/client&amp;quot; /&amp;gt;&amp;#39;,
    });

    // Additional features
    if (config.features.includes(&amp;#39;routing&amp;#39;)) {
      dependencies.push(&amp;#39;react-router-dom&amp;#39;, &amp;#39;@types/react-router-dom&amp;#39;);
    }
    if (config.features.includes(&amp;#39;state-management&amp;#39;)) {
      dependencies.push(&amp;#39;@reduxjs/toolkit&amp;#39;, &amp;#39;react-redux&amp;#39;);
    }
    if (config.features.includes(&amp;#39;styling&amp;#39;)) {
      dependencies.push(&amp;#39;tailwindcss&amp;#39;, &amp;#39;autoprefixer&amp;#39;, &amp;#39;postcss&amp;#39;);
    }
    if (config.testing) {
      dependencies.push(&amp;#39;vitest&amp;#39;, &amp;#39;@testing-library/react&amp;#39;, &amp;#39;@testing-library/jest-dom&amp;#39;);
    }

    return {
      files,
      dependencies,
      scripts: {
        dev: &amp;#39;vite&amp;#39;,
        build: &amp;#39;tsc &amp;amp;&amp;amp; vite build&amp;#39;,
        preview: &amp;#39;vite preview&amp;#39;,
        test: &amp;#39;vitest&amp;#39;,
        &amp;#39;test:ui&amp;#39;: &amp;#39;vitest --ui&amp;#39;,
      },
    };
  }

  async generateBuildConfig(config: BuildConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    const files: GeneratedFile[] &#x3D; [];

    files.push({
      path: &amp;#39;vite.config.ts&amp;#39;,
      content: this.generateOptimizedViteConfig(config),
    });

    if (config.target &#x3D;&#x3D;&#x3D; &amp;#39;production&amp;#39;) {
      files.push({
        path: &amp;#39;tsconfig.build.json&amp;#39;,
        content: this.generateBuildTSConfig(),
      });
    }

    return { files };
  }

  private generateComponentContent(config: ComponentConfig): string {
    const hasProps &#x3D; config.props &amp;amp;&amp;amp; config.props.length &amp;gt; 0;
    const propsImport &#x3D; hasProps ? &#x60;import type { ${config.name}Props } from &amp;#39;./types&amp;#39;;&#x60; : &amp;#39;&amp;#39;;
    const propsParam &#x3D; hasProps ? &#x60;props: ${config.name}Props&#x60; : &amp;#39;&amp;#39;;
    const cssImport &#x3D; config.styles ? &#x60;import styles from &amp;#39;./${config.name}.module.css&amp;#39;;&#x60; : &amp;#39;&amp;#39;;

    return &#x60;${propsImport}
${cssImport}

/**
 * ${config.name} Component
 * ${config.type &#x3D;&#x3D;&#x3D; &amp;#39;page&amp;#39; ? &amp;#39;Page component&amp;#39; : &amp;#39;Reusable UI component&amp;#39;}
 */
export function ${config.name}(${propsParam}) {
  return (
    &amp;lt;div${config.styles ? &amp;#39; className&#x3D;{styles.container}&amp;#39; : &amp;#39;&amp;#39;}&amp;gt;
      &amp;lt;h1&amp;gt;${config.name}&amp;lt;/h1&amp;gt;
      {/* Component content */}
    &amp;lt;/div&amp;gt;
  );
}

${config.name}.displayName &#x3D; &amp;#39;${config.name}&amp;#39;;
&#x60;;
  }

  private generateComponentTypes(config: ComponentConfig): string {
    const props &#x3D;
      config.props &amp;amp;&amp;amp; config.props.length &amp;gt; 0
        ? config.props
            .map(prop &#x3D;&amp;gt; &#x60;  ${prop.name}${prop.required ? &amp;#39;&amp;#39; : &amp;#39;?&amp;#39;}: ${prop.type};&#x60;)
            .join(&amp;#39;\n&amp;#39;)
        : &amp;#39;  // No props defined&amp;#39;;

    return &#x60;export interface ${config.name}Props {
${props}
}
&#x60;;
  }

  private generateComponentStyles(config: ComponentConfig): string {
    return &#x60;.container {
  /* ${config.name} component styles */
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
&#x60;;
  }

  private generateComponentTest(config: ComponentConfig): string {
    return &#x60;import { render, screen } from &amp;#39;@testing-library/react&amp;#39;;
import { ${config.name} } from &amp;#39;./${config.name}&amp;#39;;

describe(&amp;#39;${config.name}&amp;#39;, () &#x3D;&amp;gt; {
  it(&amp;#39;renders successfully&amp;#39;, () &#x3D;&amp;gt; {
    render(&amp;lt;${config.name} /&amp;gt;);
    expect(screen.getByText(&amp;#39;${config.name}&amp;#39;)).toBeInTheDocument();
  });

  // Add more tests as needed
});
&#x60;;
  }

  private generateAPIService(config: ServiceConfig): string {
    return &#x60;import express from &amp;#39;express&amp;#39;;
import type { Request, Response, NextFunction } from &amp;#39;express&amp;#39;;

const router &#x3D; express.Router();

/**
 * ${config.name} API Routes
 * Handles all ${config.name} related endpoints
 */

// GET endpoint
router.get(&amp;#39;/&amp;#39;, async (req: Request, res: Response, next: NextFunction) &#x3D;&amp;gt; {
  try {
    // Implementation here
    res.json({ message: &amp;#39;${config.name} API working&amp;#39; });
  } catch (error) {
    next(error);
  }
});

// POST endpoint
router.post(&amp;#39;/&amp;#39;, async (req: Request, res: Response, next: NextFunction) &#x3D;&amp;gt; {
  try {
    // Implementation here
    res.status(201).json({ message: &amp;#39;${config.name} created&amp;#39; });
  } catch (error) {
    next(error);
  }
});

export { router as ${config.name}Router };
&#x60;;
  }

  private generateBusinessService(config: ServiceConfig): string {
    return &#x60;/**
 * ${config.name} Service
 * Business logic for ${config.name} operations
 */

export class ${config.name}Service {
  async findAll(): Promise&amp;lt;any[]&amp;gt; {
    // Implementation here
    throw new Error(&amp;#39;Not implemented&amp;#39;);
  }

  async findById(id: string): Promise&amp;lt;any&amp;gt; {
    // Implementation here
    throw new Error(&amp;#39;Not implemented&amp;#39;);
  }

  async create(data: any): Promise&amp;lt;any&amp;gt; {
    // Implementation here
    throw new Error(&amp;#39;Not implemented&amp;#39;);
  }

  async update(id: string, data: any): Promise&amp;lt;any&amp;gt; {
    // Implementation here
    throw new Error(&amp;#39;Not implemented&amp;#39;);
  }

  async delete(id: string): Promise&amp;lt;void&amp;gt; {
    // Implementation here
    throw new Error(&amp;#39;Not implemented&amp;#39;);
  }
}

export const ${config.name.toLowerCase()}Service &#x3D; new ${config.name}Service();
&#x60;;
  }

  private generateHandler(config: ServiceConfig): string {
    return &#x60;import type { Request, Response, NextFunction } from &amp;#39;express&amp;#39;;

/**
 * ${config.name} Handler
 * HTTP request handlers for ${config.name}
 */

export class ${config.name}Handler {
  async handleGet(req: Request, res: Response, next: NextFunction) {
    try {
      // Implementation here
      res.json({ message: &amp;#39;GET ${config.name}&amp;#39; });
    } catch (error) {
      next(error);
    }
  }

  async handlePost(req: Request, res: Response, next: NextFunction) {
    try {
      // Implementation here
      res.status(201).json({ message: &amp;#39;POST ${config.name}&amp;#39; });
    } catch (error) {
      next(error);
    }
  }

  async handlePut(req: Request, res: Response, next: NextFunction) {
    try {
      // Implementation here
      res.json({ message: &amp;#39;PUT ${config.name}&amp;#39; });
    } catch (error) {
      next(error);
    }
  }

  async handleDelete(req: Request, res: Response, next: NextFunction) {
    try {
      // Implementation here
      res.status(204).send();
    } catch (error) {
      next(error);
    }
  }
}

export const ${config.name.toLowerCase()}Handler &#x3D; new ${config.name}Handler();
&#x60;;
  }

  private generateValidationSchema(config: ServiceConfig): string {
    return &#x60;import { z } from &amp;#39;zod&amp;#39;;

/**
 * ${config.name} Validation Schemas
 */

export const ${config.name}Schema &#x3D; z.object({
  id: z.string().uuid().optional(),
  // Add your schema properties here
});

export const Create${config.name}Schema &#x3D; ${config.name}Schema.omit({ id: true });

export const Update${config.name}Schema &#x3D; ${config.name}Schema.partial();

export type ${config.name} &#x3D; z.infer&amp;lt;typeof ${config.name}Schema&amp;gt;;
export type Create${config.name} &#x3D; z.infer&amp;lt;typeof Create${config.name}Schema&amp;gt;;
export type Update${config.name} &#x3D; z.infer&amp;lt;typeof Update${config.name}Schema&amp;gt;;
&#x60;;
  }

  private generatePackageJson(config: ProjectConfig): string {
    return JSON.stringify(
      {
        name: config.name,
        private: true,
        version: &amp;#39;0.0.0&amp;#39;,
        type: &amp;#39;module&amp;#39;,
        description: config.description || &#x60;A modern TypeScript project: ${config.name}&#x60;,
        scripts: {
          dev: &amp;#39;vite&amp;#39;,
          build: &amp;#39;tsc &amp;amp;&amp;amp; vite build&amp;#39;,
          preview: &amp;#39;vite preview&amp;#39;,
          test: config.testing ? &amp;#39;vitest&amp;#39; : undefined,
          &amp;#39;test:ui&amp;#39;: config.testing ? &amp;#39;vitest --ui&amp;#39; : undefined,
          lint: &amp;#39;eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0&amp;#39;,
          &amp;#39;type-check&amp;#39;: &amp;#39;tsc --noEmit&amp;#39;,
        },
        dependencies: {},
        devDependencies: {},
        engines: {
          node: &amp;#39;&amp;gt;&#x3D;18.0.0&amp;#39;,
        },
      },
      null,
      2
    );
  }

  private generateViteConfig(config: ProjectConfig): string {
    return &#x60;import { defineConfig } from &amp;#39;vite&amp;#39;;
import react from &amp;#39;@vitejs/plugin-react&amp;#39;;

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
  },
  build: {
    target: &amp;#39;es2022&amp;#39;,
    sourcemap: true,
  },
  test: {
    globals: true,
    environment: &amp;#39;jsdom&amp;#39;,
    setupFiles: [&amp;#39;./src/test-setup.ts&amp;#39;],
  },
});
&#x60;;
  }

  private generateOptimizedViteConfig(config: BuildConfig): string {
    const optimizations &#x3D; config.optimization
      ? &#x60;
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: [&amp;#39;react&amp;#39;, &amp;#39;react-dom&amp;#39;],
        },
      },
    },&#x60;
      : &amp;#39;&amp;#39;;

    return &#x60;import { defineConfig } from &amp;#39;vite&amp;#39;;
import react from &amp;#39;@vitejs/plugin-react&amp;#39;;

export default defineConfig({
  plugins: [react()],
  build: {
    target: &amp;#39;es2022&amp;#39;,
    minify: &amp;#39;${config.target &#x3D;&#x3D;&#x3D; &amp;#39;production&amp;#39; ? &amp;#39;terser&amp;#39; : &amp;#39;esbuild&amp;#39;}&amp;#39;,
    sourcemap: ${config.target !&#x3D;&#x3D; &amp;#39;production&amp;#39;},${optimizations}
  },
});
&#x60;;
  }

  private generateTSConfig(): string {
    return JSON.stringify(
      {
        compilerOptions: {
          target: &amp;#39;ES2022&amp;#39;,
          lib: [&amp;#39;ES2023&amp;#39;, &amp;#39;DOM&amp;#39;, &amp;#39;DOM.Iterable&amp;#39;],
          module: &amp;#39;ESNext&amp;#39;,
          skipLibCheck: true,
          moduleResolution: &amp;#39;bundler&amp;#39;,
          allowImportingTsExtensions: true,
          resolveJsonModule: true,
          isolatedModules: true,
          noEmit: true,
          jsx: &amp;#39;react-jsx&amp;#39;,
          strict: true,
          noUnusedLocals: true,
          noUnusedParameters: true,
          noFallthroughCasesInSwitch: true,
        },
        include: [&amp;#39;src&amp;#39;],
        references: [{ path: &amp;#39;./tsconfig.node.json&amp;#39; }],
      },
      null,
      2
    );
  }

  private generateBuildTSConfig(): string {
    return JSON.stringify(
      {
        extends: &amp;#39;./tsconfig.json&amp;#39;,
        compilerOptions: {
          noEmit: false,
          declaration: true,
          outDir: &amp;#39;./dist&amp;#39;,
        },
        exclude: [&amp;#39;src/**/*.test.ts&amp;#39;, &amp;#39;src/**/*.test.tsx&amp;#39;],
      },
      null,
      2
    );
  }

  private generateMainApp(config: ProjectConfig): string {
    const routing &#x3D; config.features.includes(&amp;#39;routing&amp;#39;);
    const routingImport &#x3D; routing
      ? &amp;quot;import { BrowserRouter as Router, Routes, Route } from &amp;#39;react-router-dom&amp;#39;;&amp;quot;
      : &amp;#39;&amp;#39;;
    const routingWrapper &#x3D; routing
      ? &amp;#39;&amp;lt;Router&amp;gt;\n      &amp;lt;Routes&amp;gt;\n        &amp;lt;Route path&#x3D;&amp;quot;/&amp;quot; element&#x3D;{&amp;lt;h1&amp;gt;Welcome to {name}&amp;lt;/h1&amp;gt;} /&amp;gt;\n      &amp;lt;/Routes&amp;gt;\n    &amp;lt;/Router&amp;gt;&amp;#39;
      : &amp;#39;&amp;lt;h1&amp;gt;Welcome to {name}&amp;lt;/h1&amp;gt;&amp;#39;;

    return &#x60;${routingImport}
import &amp;#39;./App.css&amp;#39;;

function App() {
  const name &#x3D; &amp;#39;${config.name}&amp;#39;;

  return (
    &amp;lt;div className&#x3D;&amp;quot;App&amp;quot;&amp;gt;
      ${routingWrapper}
    &amp;lt;/div&amp;gt;
  );
}

export default App;
&#x60;;
  }

  private generateMainEntry(config: ProjectConfig): string {
    return &#x60;import React from &amp;#39;react&amp;#39;;
import ReactDOM from &amp;#39;react-dom/client&amp;#39;;
import App from &amp;#39;./App&amp;#39;;
import &amp;#39;./index.css&amp;#39;;

ReactDOM.createRoot(document.getElementById(&amp;#39;root&amp;#39;)!).render(
  &amp;lt;React.StrictMode&amp;gt;
    &amp;lt;App /&amp;gt;
  &amp;lt;/React.StrictMode&amp;gt;
);
&#x60;;
  }

  private generateIndexHTML(config: ProjectConfig): string {
    return &#x60;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang&#x3D;&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset&#x3D;&amp;quot;UTF-8&amp;quot; /&amp;gt;
    &amp;lt;link rel&#x3D;&amp;quot;icon&amp;quot; type&#x3D;&amp;quot;image/svg+xml&amp;quot; href&#x3D;&amp;quot;/vite.svg&amp;quot; /&amp;gt;
    &amp;lt;meta name&#x3D;&amp;quot;viewport&amp;quot; content&#x3D;&amp;quot;width&#x3D;device-width, initial-scale&#x3D;1.0&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;${config.name}&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id&#x3D;&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script type&#x3D;&amp;quot;module&amp;quot; src&#x3D;&amp;quot;/src/main.tsx&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&#x60;;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-14">
                <div class="file-header">ğŸ“„ apps/api/src/handlers/discovery.ts</div>
                <div class="file-content">
                    <pre>/**
 * Handler discovery and loading system
 * Dynamically discovers and loads custom webhook handlers
 */

import { access, readdir, stat } from &amp;#39;node:fs/promises&amp;#39;;
import { basename, extname, join, relative } from &amp;#39;node:path&amp;#39;;
import { logger as defaultLogger } from &amp;#39;../utils.js&amp;#39;;
import type { HandlerDiscoveryConfig, HandlerModule, Logger, RegisteredHandler } from &amp;#39;./types.js&amp;#39;;
import { HandlerLoader } from &amp;#39;./loader.js&amp;#39;;

export class HandlerDiscovery {
  private handlers &#x3D; new Map&amp;lt;string, RegisteredHandler&amp;gt;();
  private watchers &#x3D; new Map&amp;lt;string, AbortController&amp;gt;();
  private loader: HandlerLoader;

  constructor(
    private config: HandlerDiscoveryConfig,
    private logger: Logger &#x3D; defaultLogger
  ) {
    this.loader &#x3D; new HandlerLoader(this.logger);
  }

  /**
   * Discover all handlers in the configured directory
   */
  async discoverHandlers(): Promise&amp;lt;RegisteredHandler[]&amp;gt; {
    const handlersDir &#x3D; this.config.handlersDirectory;

    try {
      await access(handlersDir);
    } catch {
      this.logger.warn(&amp;#39;Handlers directory not found&amp;#39;, { path: handlersDir });
      return [];
    }

    this.logger.info(&amp;#39;Starting handler discovery&amp;#39;, { directory: handlersDir });

    const handlers: RegisteredHandler[] &#x3D; [];
    const discoveredHandlers &#x3D; new Map&amp;lt;string, RegisteredHandler&amp;gt;();

    // Discover GitHub handlers
    const githubHandlers &#x3D; await this.discoverProviderHandlers(
      join(handlersDir, &amp;#39;github&amp;#39;),
      &amp;#39;github&amp;#39;
    );
    handlers.push(...githubHandlers);

    // Discover GitLab handlers
    const gitlabHandlers &#x3D; await this.discoverProviderHandlers(
      join(handlersDir, &amp;#39;gitlab&amp;#39;),
      &amp;#39;gitlab&amp;#39;
    );
    handlers.push(...gitlabHandlers);

    // Cache discovered handlers
    for (const handler of handlers) {
      discoveredHandlers.set(handler.id, handler);
    }

    this.handlers &#x3D; discoveredHandlers;

    // Set up file watchers if enabled
    if (this.config.enableAutoReload) {
      await this.setupFileWatchers(handlersDir);
    }

    this.logger.info(&amp;#39;Handler discovery completed&amp;#39;, {
      totalHandlers: handlers.length,
      githubHandlers: githubHandlers.length,
      gitlabHandlers: gitlabHandlers.length,
    });

    return handlers;
  }

  /**
   * Discover handlers for a specific provider
   */
  private async discoverProviderHandlers(
    providerDir: string,
    provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;
  ): Promise&amp;lt;RegisteredHandler[]&amp;gt; {
    try {
      await access(providerDir);
    } catch {
      this.logger.debug(&amp;#39;Provider directory not found&amp;#39;, { provider, path: providerDir });
      return [];
    }

    const handlers: RegisteredHandler[] &#x3D; [];
    const entries &#x3D; await readdir(providerDir, { withFileTypes: true });

    for (const entry of entries) {
      if (!entry.isFile()) continue;

      const ext &#x3D; extname(entry.name);
      if (![&amp;#39;.ts&amp;#39;, &amp;#39;.js&amp;#39;, &amp;#39;.mts&amp;#39;, &amp;#39;.mjs&amp;#39;].includes(ext)) continue;

      const handlerPath &#x3D; join(providerDir, entry.name);
      const eventName &#x3D; basename(entry.name, ext);

      try {
        const handlerId &#x3D; this.createHandlerId(provider, eventName, handlerPath);
        const handler &#x3D; await this.loadHandler(handlerPath, provider, eventName, handlerId);
        if (handler) {
          handlers.push(handler);
        }
      } catch (error) {
        this.logger.error(&amp;#39;Failed to load handler&amp;#39;, error as Error, {
          path: handlerPath,
          provider,
          event: eventName,
        });
      }
    }

    return handlers;
  }

  /**
   * Load a single handler file
   */
  private async loadHandler(
    handlerPath: string,
    provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;,
    eventName: string,
    handlerId?: string
  ): Promise&amp;lt;RegisteredHandler | null&amp;gt; {
    try {
      this.logger.debug(&amp;#39;Loading handler&amp;#39;, { path: handlerPath, provider, event: eventName });

      // Security check: validate file path is within handlers directory
      if (!handlerPath.startsWith(this.config.handlersDirectory)) {
        throw new Error(&amp;#39;Handler path outside allowed directory&amp;#39;);
      }

      const handlerModule &#x3D; await this.loader.load({
        id: handlerId ?? this.createHandlerId(provider, eventName, handlerPath),
        provider,
        event: eventName,
        handlerPath,
        enabled: true,
        config: {
          enabled: true,
          timeout: this.config.defaultTimeout,
          retries: this.config.defaultRetries,
          environment: {},
          secrets: {},
        },
        executionCount: 0,
        errorCount: 0,
      } as RegisteredHandler);

      // Validate handler metadata
      this.validateHandlerModule(handlerModule, eventName);

      const registeredHandler: RegisteredHandler &#x3D; {
        id: handlerId ?? this.createHandlerId(provider, eventName, handlerPath),
        provider,
        event: eventName,
        handlerPath,
        enabled: handlerModule.config?.enabled ?? true,
        config: {
          enabled: true,
          timeout: this.config.defaultTimeout,
          retries: this.config.defaultRetries,
          environment: {},
          secrets: {},
          ...handlerModule.config,
        },
        executionCount: 0,
        errorCount: 0,
        metadata: handlerModule.metadata || {
          name: &#x60;${provider} ${eventName} handler&#x60;,
          description: &#x60;Handler for ${provider} ${eventName} events&#x60;,
          version: &amp;#39;1.0.0&amp;#39;,
          supportedEvents: [eventName],
          requiredPermissions: [],
        },
      };

      this.logger.info(&amp;#39;Handler loaded successfully&amp;#39;, {
        id: registeredHandler.id,
        provider,
        event: eventName,
        name: registeredHandler.metadata?.name,
      });

      return registeredHandler;
    } catch (error) {
      this.logger.error(&amp;#39;Handler loading failed&amp;#39;, error as Error, {
        path: handlerPath,
        provider,
        event: eventName,
      });
      return null;
    }
  }

  private createHandlerId(
    provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;,
    eventName: string,
    handlerPath: string
  ): string {
    const relativePath &#x3D; relative(this.config.handlersDirectory, handlerPath);
    return &#x60;${provider}:${eventName}:${relativePath}&#x60;;
  }

  /**
   * Validate handler module structure
   */
  private validateHandlerModule(module: HandlerModule, eventName: string): void {
    if (!module.handler) {
      throw new Error(&amp;#39;Handler module must export a handler function&amp;#39;);
    }

    if (typeof module.handler !&#x3D;&#x3D; &amp;#39;function&amp;#39;) {
      throw new Error(&amp;#39;Handler must be a function&amp;#39;);
    }

    // Validate supported events if specified
    if (module.metadata?.supportedEvents) {
      const supportedEvents &#x3D; module.metadata.supportedEvents;
      if (!supportedEvents.includes(eventName)) {
        this.logger.warn(&amp;#39;Handler event name not in supported events list&amp;#39;, {
          eventName,
          supportedEvents,
        });
      }
    }

    // Validate required permissions format
    if (module.metadata?.requiredPermissions) {
      for (const permission of module.metadata.requiredPermissions) {
        if (typeof permission !&#x3D;&#x3D; &amp;#39;string&amp;#39; || !permission.includes(&amp;#39;:&amp;#39;)) {
          this.logger.warn(&amp;#39;Invalid permission format&amp;#39;, { permission });
        }
      }
    }
  }

  async registerHandlerFromFile(
    handlerPath: string,
    provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;,
    eventName: string
  ): Promise&amp;lt;RegisteredHandler&amp;gt; {
    const handlerId &#x3D; this.createHandlerId(provider, eventName, handlerPath);
    const handler &#x3D; await this.loadHandler(handlerPath, provider, eventName, handlerId);

    if (!handler) {
      throw new Error(&amp;#39;Failed to load handler after creation&amp;#39;);
    }

    this.handlers.set(handler.id, handler);
    return handler;
  }

  /**
   * Set up file watchers for auto-reload
   */
  private async setupFileWatchers(handlersDir: string): Promise&amp;lt;void&amp;gt; {
    try {
      // Note: In a real implementation, you&amp;#39;d use fs.watch or a library like chokidar
      this.logger.info(&amp;#39;File watching not implemented in this example&amp;#39;);

      // Example implementation outline:
      // const watcher &#x3D; fs.watch(handlersDir, { recursive: true });
      // watcher.on(&amp;#39;change&amp;#39;, (eventType, filename) &#x3D;&amp;gt; {
      //   if (filename &amp;amp;&amp;amp; this.isHandlerFile(filename)) {
      //     this.reloadHandler(filename);
      //   }
      // });
    } catch (error) {
      this.logger.error(&amp;#39;Failed to setup file watchers&amp;#39;, error as Error);
    }
  }

  /**
   * Get all registered handlers
   */
  getHandlers(): RegisteredHandler[] {
    return Array.from(this.handlers.values());
  }

  /**
   * Get handlers for a specific provider and event
   */
  getHandlersForEvent(provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;, event: string): RegisteredHandler[] {
    return this.getHandlers().filter(
      h &#x3D;&amp;gt; h.provider &#x3D;&#x3D;&#x3D; provider &amp;amp;&amp;amp; h.event &#x3D;&#x3D;&#x3D; event &amp;amp;&amp;amp; h.enabled
    );
  }

  /**
   * Get a specific handler by ID
   */
  getHandler(id: string): RegisteredHandler | undefined {
    return this.handlers.get(id);
  }

  /**
   * Update handler configuration
   */
  updateHandlerConfig(id: string, updates: Partial&amp;lt;RegisteredHandler&amp;gt;): boolean {
    const handler &#x3D; this.handlers.get(id);
    if (!handler) return false;

    // Merge updates
    Object.assign(handler, updates);
    this.handlers.set(id, handler);

    this.logger.info(&amp;#39;Handler configuration updated&amp;#39;, { id, updates: Object.keys(updates) });
    return true;
  }

  /**
   * Enable or disable a handler
   */
  setHandlerEnabled(id: string, enabled: boolean): boolean {
    const handler &#x3D; this.handlers.get(id);
    if (!handler) return false;

    handler.enabled &#x3D; enabled;
    handler.config.enabled &#x3D; enabled;
    this.handlers.set(id, handler);

    this.logger.info(&amp;#39;Handler state changed&amp;#39;, { id, enabled });
    return true;
  }

  /**
   * Remove a handler from registry
   */
  removeHandler(id: string): boolean {
    const removed &#x3D; this.handlers.delete(id);
    if (removed) {
      this.logger.info(&amp;#39;Handler removed&amp;#39;, { id });
    }
    return removed;
  }

  /**
   * Reload handler from file
   */
  async reloadHandler(id: string): Promise&amp;lt;boolean&amp;gt; {
    const existingHandler &#x3D; this.handlers.get(id);
    if (!existingHandler) return false;

    try {
      // Reload handler
      const reloadedHandler &#x3D; await this.loadHandler(
        existingHandler.handlerPath,
        existingHandler.provider,
        existingHandler.event,
        existingHandler.id
      );

      if (reloadedHandler) {
        // Preserve runtime state
        reloadedHandler.id &#x3D; existingHandler.id;
        reloadedHandler.executionCount &#x3D; existingHandler.executionCount;
        reloadedHandler.errorCount &#x3D; existingHandler.errorCount;
        reloadedHandler.lastExecuted &#x3D; existingHandler.lastExecuted;

        this.handlers.set(id, reloadedHandler);
        this.logger.info(&amp;#39;Handler reloaded&amp;#39;, { id });
        return true;
      }
    } catch (error) {
      this.logger.error(&amp;#39;Handler reload failed&amp;#39;, error as Error, { id });
    }

    return false;
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    // Stop all file watchers
    for (const [path, controller] of this.watchers) {
      controller.abort();
      this.logger.debug(&amp;#39;Stopped file watcher&amp;#39;, { path });
    }
    this.watchers.clear();

    // Clear handler cache
    this.handlers.clear();

    this.logger.info(&amp;#39;Handler discovery disposed&amp;#39;);
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-15">
                <div class="file-header">ğŸ“„ packages/cli/src/language-plugins/go.ts</div>
                <div class="file-content">
                    <pre>/**
 * Go Language Plugin - Gin + GORM + Modern Go Patterns
 * Supports: Go 1.21+, Gin Web Framework, GORM v2, Go modules, structured logging
 */

import type {
  BuildConfig,
  ComponentConfig,
  GeneratedFile,
  GenerationResult,
  LanguagePlugin,
  ProjectConfig,
  ServiceConfig,
} from &amp;#39;./index.js&amp;#39;;

export class GoPlugin implements LanguagePlugin {
  readonly name &#x3D; &amp;#39;Go Plugin&amp;#39;;
  readonly language &#x3D; &amp;#39;go&amp;#39;;
  readonly version &#x3D; &amp;#39;1.0.0&amp;#39;;
  readonly description &#x3D; &amp;#39;Modern Go with Gin, GORM, and idiomatic Go patterns&amp;#39;;
  readonly supportedFeatures &#x3D; [
    &amp;#39;web-server&amp;#39;,
    &amp;#39;api&amp;#39;,
    &amp;#39;database-orm&amp;#39;,
    &amp;#39;middleware&amp;#39;,
    &amp;#39;validation&amp;#39;,
    &amp;#39;testing&amp;#39;,
    &amp;#39;concurrency&amp;#39;,
    &amp;#39;microservices&amp;#39;,
    &amp;#39;grpc&amp;#39;,
  ];
  readonly capabilities &#x3D; {
    services: true,
    api: true,
    testing: true,
  };

  // Go doesn&amp;#39;t have UI components like frontend frameworks
  async generateComponent(config: ComponentConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    throw new Error(&amp;#39;Component generation not supported for Go. Use generateService instead.&amp;#39;);
  }

  async generateService(config: ServiceConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    const files: GeneratedFile[] &#x3D; [];
    const dependencies: string[] &#x3D; [];

    switch (config.type) {
      case &amp;#39;api&amp;#39;:
        files.push({
          path: &#x60;internal/handlers/${config.name.toLowerCase()}_handler.go&#x60;,
          content: this.generateAPIHandler(config),
        });
        files.push({
          path: &#x60;internal/routes/${config.name.toLowerCase()}_routes.go&#x60;,
          content: this.generateRoutes(config),
        });
        dependencies.push(&amp;#39;github.com/gin-gonic/gin&amp;#39;);
        break;
      case &amp;#39;service&amp;#39;:
        files.push({
          path: &#x60;internal/services/${config.name.toLowerCase()}_service.go&#x60;,
          content: this.generateBusinessService(config),
        });
        break;
      case &amp;#39;model&amp;#39;:
        files.push({
          path: &#x60;internal/models/${config.name.toLowerCase()}.go&#x60;,
          content: this.generateModel(config),
        });
        dependencies.push(&amp;#39;gorm.io/gorm&amp;#39;);
        break;
      case &amp;#39;middleware&amp;#39;:
        files.push({
          path: &#x60;internal/middleware/${config.name.toLowerCase()}.go&#x60;,
          content: this.generateMiddleware(config),
        });
        break;
    }

    if (config.validation) {
      dependencies.push(&amp;#39;github.com/go-playground/validator/v10&amp;#39;);
    }

    if (config.database) {
      dependencies.push(&amp;#39;gorm.io/gorm&amp;#39;, &amp;#39;gorm.io/driver/postgres&amp;#39;);
    }

    return { files, dependencies };
  }

  async initializeProject(config: ProjectConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    const files: GeneratedFile[] &#x3D; [];
    const dependencies &#x3D; [
      &amp;#39;github.com/gin-gonic/gin&amp;#39;,
      &amp;#39;github.com/joho/godotenv&amp;#39;,
      &amp;#39;go.uber.org/zap&amp;#39;,
    ];

    // Go module file
    files.push({
      path: &amp;#39;go.mod&amp;#39;,
      content: this.generateGoMod(config),
    });

    // Main application
    files.push({
      path: &amp;#39;cmd/main.go&amp;#39;,
      content: this.generateMainApp(config),
    });

    // Configuration
    files.push({
      path: &amp;#39;internal/config/config.go&amp;#39;,
      content: this.generateConfig(config),
    });

    // Database setup (if needed)
    if (config.database) {
      files.push({
        path: &amp;#39;internal/database/database.go&amp;#39;,
        content: this.generateDatabase(config),
      });
      dependencies.push(&amp;#39;gorm.io/gorm&amp;#39;, &amp;#39;gorm.io/driver/postgres&amp;#39;);
    }

    // Logging setup
    files.push({
      path: &amp;#39;internal/logger/logger.go&amp;#39;,
      content: this.generateLogger(),
    });

    // Server setup
    files.push({
      path: &amp;#39;internal/server/server.go&amp;#39;,
      content: this.generateServer(config),
    });

    // Middleware
    files.push({
      path: &amp;#39;internal/middleware/cors.go&amp;#39;,
      content: this.generateCORSMiddleware(),
    });

    files.push({
      path: &amp;#39;internal/middleware/logger.go&amp;#39;,
      content: this.generateLoggerMiddleware(),
    });

    // Health check
    files.push({
      path: &amp;#39;internal/handlers/health_handler.go&amp;#39;,
      content: this.generateHealthHandler(),
    });

    // Environment file
    files.push({
      path: &amp;#39;.env.example&amp;#39;,
      content: this.generateEnvExample(config),
    });

    // Testing setup
    if (config.testing) {
      files.push({
        path: &amp;#39;internal/testutils/testutils.go&amp;#39;,
        content: this.generateTestUtils(config),
      });
    }

    // Docker setup (if requested)
    if (config.docker) {
      files.push({
        path: &amp;#39;Dockerfile&amp;#39;,
        content: this.generateDockerfile(config),
      });
      files.push({
        path: &amp;#39;docker-compose.yml&amp;#39;,
        content: this.generateDockerCompose(config),
      });
    }

    // Makefile for common tasks
    files.push({
      path: &amp;#39;Makefile&amp;#39;,
      content: this.generateMakefile(config),
    });

    return {
      files,
      dependencies,
      scripts: {
        dev: &amp;#39;go run cmd/main.go&amp;#39;,
        build: &amp;#39;go build -o bin/app cmd/main.go&amp;#39;,
        test: &amp;#39;go test ./...&amp;#39;,
        &amp;#39;test:coverage&amp;#39;:
          &amp;#39;go test -coverprofile&#x3D;coverage.out ./... &amp;amp;&amp;amp; go tool cover -html&#x3D;coverage.out&amp;#39;,
        lint: &amp;#39;golangci-lint run&amp;#39;,
        format: &amp;#39;gofmt -s -w .&amp;#39;,
        &amp;#39;mod:tidy&amp;#39;: &amp;#39;go mod tidy&amp;#39;,
      },
    };
  }

  async generateBuildConfig(config: BuildConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    const files: GeneratedFile[] &#x3D; [];

    // Production dockerfile
    if (config.target &#x3D;&#x3D;&#x3D; &amp;#39;production&amp;#39;) {
      files.push({
        path: &amp;#39;Dockerfile.prod&amp;#39;,
        content: this.generateProductionDockerfile(config),
      });
    }

    // CI/CD configuration
    files.push({
      path: &amp;#39;.github/workflows/go.yml&amp;#39;,
      content: this.generateGitHubActions(config),
    });

    // Build configuration
    files.push({
      path: &amp;#39;.goreleaser.yml&amp;#39;,
      content: this.generateGoReleaser(config),
    });

    return { files };
  }

  private generateAPIHandler(config: ServiceConfig): string {
    const packageName &#x3D; config.name.toLowerCase();
    const structName &#x3D; this.toPascalCase(config.name);

    return &#x60;package handlers

import (
	&amp;quot;net/http&amp;quot;
	&amp;quot;strconv&amp;quot;

	&amp;quot;github.com/gin-gonic/gin&amp;quot;
	&amp;quot;go.uber.org/zap&amp;quot;

	&amp;quot;your-module/internal/models&amp;quot;
	&amp;quot;your-module/internal/services&amp;quot;
)

// ${structName}Handler handles HTTP requests for ${config.name}
type ${structName}Handler struct {
	service *services.${structName}Service
	logger  *zap.Logger
}

// New${structName}Handler creates a new ${config.name} handler
func New${structName}Handler(service *services.${structName}Service, logger *zap.Logger) *${structName}Handler {
	return &amp;amp;${structName}Handler{
		service: service,
		logger:  logger,
	}
}

// GetAll handles GET /${packageName}
func (h *${structName}Handler) GetAll(c *gin.Context) {
	h.logger.Info(&amp;quot;Fetching all ${config.name} items&amp;quot;)

	items, err :&#x3D; h.service.GetAll(c.Request.Context())
	if err !&#x3D; nil {
		h.logger.Error(&amp;quot;Failed to fetch ${config.name} items&amp;quot;, zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{&amp;quot;error&amp;quot;: &amp;quot;Internal server error&amp;quot;})
		return
	}

	c.JSON(http.StatusOK, gin.H{&amp;quot;data&amp;quot;: items})
}

// GetByID handles GET /${packageName}/:id
func (h *${structName}Handler) GetByID(c *gin.Context) {
	idParam :&#x3D; c.Param(&amp;quot;id&amp;quot;)
	id, err :&#x3D; strconv.ParseUint(idParam, 10, 32)
	if err !&#x3D; nil {
		c.JSON(http.StatusBadRequest, gin.H{&amp;quot;error&amp;quot;: &amp;quot;Invalid ID format&amp;quot;})
		return
	}

	h.logger.Info(&amp;quot;Fetching ${config.name} by ID&amp;quot;, zap.Uint64(&amp;quot;id&amp;quot;, id))

	item, err :&#x3D; h.service.GetByID(c.Request.Context(), uint(id))
	if err !&#x3D; nil {
		if err &#x3D;&#x3D; services.ErrNotFound {
			c.JSON(http.StatusNotFound, gin.H{&amp;quot;error&amp;quot;: &amp;quot;${config.name} not found&amp;quot;})
			return
		}
		h.logger.Error(&amp;quot;Failed to fetch ${config.name}&amp;quot;, zap.Error(err), zap.Uint64(&amp;quot;id&amp;quot;, id))
		c.JSON(http.StatusInternalServerError, gin.H{&amp;quot;error&amp;quot;: &amp;quot;Internal server error&amp;quot;})
		return
	}

	c.JSON(http.StatusOK, gin.H{&amp;quot;data&amp;quot;: item})
}

// Create handles POST /${packageName}
func (h *${structName}Handler) Create(c *gin.Context) {
	var req models.Create${structName}Request
	if err :&#x3D; c.ShouldBindJSON(&amp;amp;req); err !&#x3D; nil {
		c.JSON(http.StatusBadRequest, gin.H{&amp;quot;error&amp;quot;: err.Error()})
		return
	}

	h.logger.Info(&amp;quot;Creating new ${config.name}&amp;quot;, zap.String(&amp;quot;name&amp;quot;, req.Name))

	item, err :&#x3D; h.service.Create(c.Request.Context(), &amp;amp;req)
	if err !&#x3D; nil {
		h.logger.Error(&amp;quot;Failed to create ${config.name}&amp;quot;, zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{&amp;quot;error&amp;quot;: &amp;quot;Internal server error&amp;quot;})
		return
	}

	c.JSON(http.StatusCreated, gin.H{&amp;quot;data&amp;quot;: item})
}

// Update handles PUT /${packageName}/:id
func (h *${structName}Handler) Update(c *gin.Context) {
	idParam :&#x3D; c.Param(&amp;quot;id&amp;quot;)
	id, err :&#x3D; strconv.ParseUint(idParam, 10, 32)
	if err !&#x3D; nil {
		c.JSON(http.StatusBadRequest, gin.H{&amp;quot;error&amp;quot;: &amp;quot;Invalid ID format&amp;quot;})
		return
	}

	var req models.Update${structName}Request
	if err :&#x3D; c.ShouldBindJSON(&amp;amp;req); err !&#x3D; nil {
		c.JSON(http.StatusBadRequest, gin.H{&amp;quot;error&amp;quot;: err.Error()})
		return
	}

	h.logger.Info(&amp;quot;Updating ${config.name}&amp;quot;, zap.Uint64(&amp;quot;id&amp;quot;, id))

	item, err :&#x3D; h.service.Update(c.Request.Context(), uint(id), &amp;amp;req)
	if err !&#x3D; nil {
		if err &#x3D;&#x3D; services.ErrNotFound {
			c.JSON(http.StatusNotFound, gin.H{&amp;quot;error&amp;quot;: &amp;quot;${config.name} not found&amp;quot;})
			return
		}
		h.logger.Error(&amp;quot;Failed to update ${config.name}&amp;quot;, zap.Error(err), zap.Uint64(&amp;quot;id&amp;quot;, id))
		c.JSON(http.StatusInternalServerError, gin.H{&amp;quot;error&amp;quot;: &amp;quot;Internal server error&amp;quot;})
		return
	}

	c.JSON(http.StatusOK, gin.H{&amp;quot;data&amp;quot;: item})
}

// Delete handles DELETE /${packageName}/:id
func (h *${structName}Handler) Delete(c *gin.Context) {
	idParam :&#x3D; c.Param(&amp;quot;id&amp;quot;)
	id, err :&#x3D; strconv.ParseUint(idParam, 10, 32)
	if err !&#x3D; nil {
		c.JSON(http.StatusBadRequest, gin.H{&amp;quot;error&amp;quot;: &amp;quot;Invalid ID format&amp;quot;})
		return
	}

	h.logger.Info(&amp;quot;Deleting ${config.name}&amp;quot;, zap.Uint64(&amp;quot;id&amp;quot;, id))

	err &#x3D; h.service.Delete(c.Request.Context(), uint(id))
	if err !&#x3D; nil {
		if err &#x3D;&#x3D; services.ErrNotFound {
			c.JSON(http.StatusNotFound, gin.H{&amp;quot;error&amp;quot;: &amp;quot;${config.name} not found&amp;quot;})
			return
		}
		h.logger.Error(&amp;quot;Failed to delete ${config.name}&amp;quot;, zap.Error(err), zap.Uint64(&amp;quot;id&amp;quot;, id))
		c.JSON(http.StatusInternalServerError, gin.H{&amp;quot;error&amp;quot;: &amp;quot;Internal server error&amp;quot;})
		return
	}

	c.JSON(http.StatusOK, gin.H{&amp;quot;message&amp;quot;: &amp;quot;${config.name} deleted successfully&amp;quot;})
}
&#x60;;
  }

  private generateRoutes(config: ServiceConfig): string {
    const packageName &#x3D; config.name.toLowerCase();
    const structName &#x3D; this.toPascalCase(config.name);

    return &#x60;package routes

import (
	&amp;quot;github.com/gin-gonic/gin&amp;quot;
	&amp;quot;go.uber.org/zap&amp;quot;

	&amp;quot;your-module/internal/handlers&amp;quot;
	&amp;quot;your-module/internal/services&amp;quot;
)

// Setup${structName}Routes configures routes for ${config.name}
func Setup${structName}Routes(router *gin.RouterGroup, service *services.${structName}Service, logger *zap.Logger) {
	handler :&#x3D; handlers.New${structName}Handler(service, logger)

	${packageName}Group :&#x3D; router.Group(&amp;quot;/${packageName}&amp;quot;)
	{
		${packageName}Group.GET(&amp;quot;/&amp;quot;, handler.GetAll)
		${packageName}Group.GET(&amp;quot;/:id&amp;quot;, handler.GetByID)
		${packageName}Group.POST(&amp;quot;/&amp;quot;, handler.Create)
		${packageName}Group.PUT(&amp;quot;/:id&amp;quot;, handler.Update)
		${packageName}Group.DELETE(&amp;quot;/:id&amp;quot;, handler.Delete)
	}
}
&#x60;;
  }

  private generateBusinessService(config: ServiceConfig): string {
    const structName &#x3D; this.toPascalCase(config.name);

    return &#x60;package services

import (
	&amp;quot;context&amp;quot;
	&amp;quot;errors&amp;quot;

	&amp;quot;go.uber.org/zap&amp;quot;
	&amp;quot;gorm.io/gorm&amp;quot;

	&amp;quot;your-module/internal/models&amp;quot;
)

var (
	// ErrNotFound is returned when a resource is not found
	ErrNotFound &#x3D; errors.New(&amp;quot;resource not found&amp;quot;)
	
	// ErrConflict is returned when a resource conflicts with existing data
	ErrConflict &#x3D; errors.New(&amp;quot;resource conflict&amp;quot;)
)

// ${structName}Service provides business logic for ${config.name} operations
type ${structName}Service struct {
	db     *gorm.DB
	logger *zap.Logger
}

// New${structName}Service creates a new ${config.name} service
func New${structName}Service(db *gorm.DB, logger *zap.Logger) *${structName}Service {
	return &amp;amp;${structName}Service{
		db:     db,
		logger: logger,
	}
}

// GetAll retrieves all ${config.name} items
func (s *${structName}Service) GetAll(ctx context.Context) ([]*models.${structName}, error) {
	var items []*models.${structName}
	
	if err :&#x3D; s.db.WithContext(ctx).Find(&amp;amp;items).Error; err !&#x3D; nil {
		s.logger.Error(&amp;quot;Failed to fetch all ${config.name} items&amp;quot;, zap.Error(err))
		return nil, err
	}

	return items, nil
}

// GetByID retrieves a ${config.name} by ID
func (s *${structName}Service) GetByID(ctx context.Context, id uint) (*models.${structName}, error) {
	var item models.${structName}
	
	if err :&#x3D; s.db.WithContext(ctx).First(&amp;amp;item, id).Error; err !&#x3D; nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrNotFound
		}
		s.logger.Error(&amp;quot;Failed to fetch ${config.name}&amp;quot;, zap.Error(err), zap.Uint(&amp;quot;id&amp;quot;, id))
		return nil, err
	}

	return &amp;amp;item, nil
}

// Create creates a new ${config.name}
func (s *${structName}Service) Create(ctx context.Context, req *models.Create${structName}Request) (*models.${structName}, error) {
	item :&#x3D; &amp;amp;models.${structName}{
		Name:        req.Name,
		Description: req.Description,
		IsActive:    true,
	}

	if err :&#x3D; s.db.WithContext(ctx).Create(item).Error; err !&#x3D; nil {
		s.logger.Error(&amp;quot;Failed to create ${config.name}&amp;quot;, zap.Error(err))
		return nil, err
	}

	return item, nil
}

// Update updates an existing ${config.name}
func (s *${structName}Service) Update(ctx context.Context, id uint, req *models.Update${structName}Request) (*models.${structName}, error) {
	var item models.${structName}
	
	if err :&#x3D; s.db.WithContext(ctx).First(&amp;amp;item, id).Error; err !&#x3D; nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrNotFound
		}
		return nil, err
	}

	// Update fields
	if req.Name !&#x3D; &amp;quot;&amp;quot; {
		item.Name &#x3D; req.Name
	}
	if req.Description !&#x3D; nil {
		item.Description &#x3D; req.Description
	}
	if req.IsActive !&#x3D; nil {
		item.IsActive &#x3D; *req.IsActive
	}

	if err :&#x3D; s.db.WithContext(ctx).Save(&amp;amp;item).Error; err !&#x3D; nil {
		s.logger.Error(&amp;quot;Failed to update ${config.name}&amp;quot;, zap.Error(err), zap.Uint(&amp;quot;id&amp;quot;, id))
		return nil, err
	}

	return &amp;amp;item, nil
}

// Delete deletes a ${config.name} by ID
func (s *${structName}Service) Delete(ctx context.Context, id uint) error {
	result :&#x3D; s.db.WithContext(ctx).Delete(&amp;amp;models.${structName}{}, id)
	if result.Error !&#x3D; nil {
		s.logger.Error(&amp;quot;Failed to delete ${config.name}&amp;quot;, zap.Error(result.Error), zap.Uint(&amp;quot;id&amp;quot;, id))
		return result.Error
	}

	if result.RowsAffected &#x3D;&#x3D; 0 {
		return ErrNotFound
	}

	return nil
}
&#x60;;
  }

  private generateModel(config: ServiceConfig): string {
    const structName &#x3D; this.toPascalCase(config.name);

    return &#x60;package models

import (
	&amp;quot;time&amp;quot;

	&amp;quot;gorm.io/gorm&amp;quot;
)

// ${structName} represents the ${config.name} model
type ${structName} struct {
	ID          uint           \&#x60;gorm:&amp;quot;primarykey&amp;quot; json:&amp;quot;id&amp;quot;\&#x60;
	Name        string         \&#x60;gorm:&amp;quot;not null;index&amp;quot; json:&amp;quot;name&amp;quot; validate:&amp;quot;required,min&#x3D;1,max&#x3D;100&amp;quot;\&#x60;
	Description *string        \&#x60;json:&amp;quot;description,omitempty&amp;quot; validate:&amp;quot;omitempty,max&#x3D;500&amp;quot;\&#x60;
	IsActive    bool           \&#x60;gorm:&amp;quot;default:true&amp;quot; json:&amp;quot;is_active&amp;quot;\&#x60;
	CreatedAt   time.Time      \&#x60;json:&amp;quot;created_at&amp;quot;\&#x60;
	UpdatedAt   time.Time      \&#x60;json:&amp;quot;updated_at&amp;quot;\&#x60;
	DeletedAt   gorm.DeletedAt \&#x60;gorm:&amp;quot;index&amp;quot; json:&amp;quot;-&amp;quot;\&#x60;
}

// Create${structName}Request represents the request payload for creating a ${config.name}
type Create${structName}Request struct {
	Name        string  \&#x60;json:&amp;quot;name&amp;quot; validate:&amp;quot;required,min&#x3D;1,max&#x3D;100&amp;quot;\&#x60;
	Description *string \&#x60;json:&amp;quot;description,omitempty&amp;quot; validate:&amp;quot;omitempty,max&#x3D;500&amp;quot;\&#x60;
}

// Update${structName}Request represents the request payload for updating a ${config.name}
type Update${structName}Request struct {
	Name        string  \&#x60;json:&amp;quot;name,omitempty&amp;quot; validate:&amp;quot;omitempty,min&#x3D;1,max&#x3D;100&amp;quot;\&#x60;
	Description *string \&#x60;json:&amp;quot;description,omitempty&amp;quot; validate:&amp;quot;omitempty,max&#x3D;500&amp;quot;\&#x60;
	IsActive    *bool   \&#x60;json:&amp;quot;is_active,omitempty&amp;quot;\&#x60;
}

// ${structName}Response represents the response payload for ${config.name}
type ${structName}Response struct {
	ID          uint      \&#x60;json:&amp;quot;id&amp;quot;\&#x60;
	Name        string    \&#x60;json:&amp;quot;name&amp;quot;\&#x60;
	Description *string   \&#x60;json:&amp;quot;description,omitempty&amp;quot;\&#x60;
	IsActive    bool      \&#x60;json:&amp;quot;is_active&amp;quot;\&#x60;
	CreatedAt   time.Time \&#x60;json:&amp;quot;created_at&amp;quot;\&#x60;
	UpdatedAt   time.Time \&#x60;json:&amp;quot;updated_at&amp;quot;\&#x60;
}

// TableName specifies the table name for GORM
func (${structName}) TableName() string {
	return &amp;quot;${config.name.toLowerCase()}s&amp;quot;
}

// BeforeCreate is a GORM hook that runs before creating a record
func (item *${structName}) BeforeCreate(tx *gorm.DB) (err error) {
	// Add any pre-creation logic here
	return nil
}

// BeforeUpdate is a GORM hook that runs before updating a record
func (item *${structName}) BeforeUpdate(tx *gorm.DB) (err error) {
	// Add any pre-update logic here
	return nil
}
&#x60;;
  }

  private generateMiddleware(config: ServiceConfig): string {
    const middlewareName &#x3D; this.toPascalCase(config.name);

    return &#x60;package middleware

import (
	&amp;quot;github.com/gin-gonic/gin&amp;quot;
	&amp;quot;go.uber.org/zap&amp;quot;
)

// ${middlewareName} creates a new ${config.name} middleware
func ${middlewareName}(logger *zap.Logger) gin.HandlerFunc {
	return gin.HandlerFunc(func(c *gin.Context) {
		// Pre-processing logic
		logger.Info(&amp;quot;${middlewareName} middleware - before request&amp;quot;)

		// Process request
		c.Next()

		// Post-processing logic
		logger.Info(&amp;quot;${middlewareName} middleware - after request&amp;quot;)
	})
}
&#x60;;
  }

  private generateGoMod(config: ProjectConfig): string {
    return &#x60;module ${config.name.toLowerCase()}

go 1.21

require (
	github.com/gin-gonic/gin v1.9.1
	github.com/joho/godotenv v1.5.1
	go.uber.org/zap v1.26.0
)
&#x60;;
  }

  private generateMainApp(config: ProjectConfig): string {
    return &#x60;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;os/signal&amp;quot;
	&amp;quot;syscall&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;go.uber.org/zap&amp;quot;

	&amp;quot;${config.name.toLowerCase()}/internal/config&amp;quot;
	${config.database ? &#x60;&amp;quot;${config.name.toLowerCase()}/internal/database&amp;quot;&#x60; : &amp;#39;&amp;#39;}
	&amp;quot;${config.name.toLowerCase()}/internal/logger&amp;quot;
	&amp;quot;${config.name.toLowerCase()}/internal/server&amp;quot;
)

func main() {
	// Initialize logger
	zapLogger, err :&#x3D; logger.NewLogger()
	if err !&#x3D; nil {
		log.Fatalf(&amp;quot;Failed to initialize logger: %v&amp;quot;, err)
	}
	defer zapLogger.Sync()

	// Load configuration
	cfg, err :&#x3D; config.Load()
	if err !&#x3D; nil {
		zapLogger.Fatal(&amp;quot;Failed to load configuration&amp;quot;, zap.Error(err))
	}

	${
    config.database
      ? &#x60;// Initialize database
	db, err :&#x3D; database.Connect(cfg.DatabaseURL)
	if err !&#x3D; nil {
		zapLogger.Fatal(&amp;quot;Failed to connect to database&amp;quot;, zap.Error(err))
	}

	// Auto-migrate database schemas
	if err :&#x3D; database.Migrate(db); err !&#x3D; nil {
		zapLogger.Fatal(&amp;quot;Failed to migrate database&amp;quot;, zap.Error(err))
	}&#x60;
      : &amp;#39;&amp;#39;
  }

	// Initialize server
	srv :&#x3D; server.New(cfg, ${config.database ? &amp;#39;db, &amp;#39; : &amp;#39;&amp;#39;}zapLogger)

	// Start server
	go func() {
		zapLogger.Info(&amp;quot;Starting server&amp;quot;, zap.String(&amp;quot;address&amp;quot;, cfg.Address))
		if err :&#x3D; srv.ListenAndServe(); err !&#x3D; nil &amp;amp;&amp;amp; err !&#x3D; http.ErrServerClosed {
			zapLogger.Fatal(&amp;quot;Failed to start server&amp;quot;, zap.Error(err))
		}
	}()

	// Wait for interrupt signal to gracefully shutdown the server
	quit :&#x3D; make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	&amp;lt;-quit

	zapLogger.Info(&amp;quot;Shutting down server...&amp;quot;)

	// Give outstanding requests a deadline for completion
	ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Shutdown server
	if err :&#x3D; srv.Shutdown(ctx); err !&#x3D; nil {
		zapLogger.Fatal(&amp;quot;Server forced to shutdown&amp;quot;, zap.Error(err))
	}

	zapLogger.Info(&amp;quot;Server exited&amp;quot;)
}
&#x60;;
  }

  private generateConfig(config: ProjectConfig): string {
    return &#x60;package config

import (
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;

	&amp;quot;github.com/joho/godotenv&amp;quot;
)

// Config holds all configuration for the application
type Config struct {
	Address     string
	Environment string
	${config.database ? &amp;#39;DatabaseURL string&amp;#39; : &amp;#39;&amp;#39;}
	${config.auth ? &amp;#39;JWTSecret   string&amp;#39; : &amp;#39;&amp;#39;}
	LogLevel    string
}

// Load reads configuration from environment variables
func Load() (*Config, error) {
	// Load .env file if it exists
	_ &#x3D; godotenv.Load()

	cfg :&#x3D; &amp;amp;Config{
		Address:     getEnv(&amp;quot;ADDRESS&amp;quot;, &amp;quot;:8080&amp;quot;),
		Environment: getEnv(&amp;quot;ENVIRONMENT&amp;quot;, &amp;quot;development&amp;quot;),
		${config.database ? &#x60;DatabaseURL: getEnv(&amp;quot;DATABASE_URL&amp;quot;, &amp;quot;postgres://user:password@localhost:5432/${config.name.toLowerCase()}?sslmode&#x3D;disable&amp;quot;),&#x60; : &amp;#39;&amp;#39;}
		${config.auth ? &amp;#39;JWTSecret:   getEnv(&amp;quot;JWT_SECRET&amp;quot;, &amp;quot;your-secret-key&amp;quot;),&amp;#39; : &amp;#39;&amp;#39;}
		LogLevel:    getEnv(&amp;quot;LOG_LEVEL&amp;quot;, &amp;quot;info&amp;quot;),
	}

	return cfg, nil
}

// getEnv gets an environment variable with a fallback value
func getEnv(key, fallback string) string {
	if value, exists :&#x3D; os.LookupEnv(key); exists {
		return value
	}
	return fallback
}

// getEnvAsInt gets an environment variable as integer with a fallback value
func getEnvAsInt(key string, fallback int) int {
	if value, exists :&#x3D; os.LookupEnv(key); exists {
		if intValue, err :&#x3D; strconv.Atoi(value); err &#x3D;&#x3D; nil {
			return intValue
		}
	}
	return fallback
}

// getEnvAsBool gets an environment variable as boolean with a fallback value
func getEnvAsBool(key string, fallback bool) bool {
	if value, exists :&#x3D; os.LookupEnv(key); exists {
		if boolValue, err :&#x3D; strconv.ParseBool(value); err &#x3D;&#x3D; nil {
			return boolValue
		}
	}
	return fallback
}
&#x60;;
  }

  private generateDatabase(config: ProjectConfig): string {
    return &#x60;package database

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;gorm.io/driver/postgres&amp;quot;
	&amp;quot;gorm.io/gorm&amp;quot;
	&amp;quot;gorm.io/gorm/logger&amp;quot;

	&amp;quot;${config.name.toLowerCase()}/internal/models&amp;quot;
)

// Connect establishes a database connection
func Connect(databaseURL string) (*gorm.DB, error) {
	config :&#x3D; &amp;amp;gorm.Config{
		Logger: logger.Default.LogMode(logger.Info),
		NowFunc: func() time.Time {
			return time.Now().UTC()
		},
	}

	db, err :&#x3D; gorm.Open(postgres.Open(databaseURL), config)
	if err !&#x3D; nil {
		return nil, fmt.Errorf(&amp;quot;failed to connect to database: %w&amp;quot;, err)
	}

	// Configure connection pool
	sqlDB, err :&#x3D; db.DB()
	if err !&#x3D; nil {
		return nil, fmt.Errorf(&amp;quot;failed to get database instance: %w&amp;quot;, err)
	}

	sqlDB.SetMaxIdleConns(10)
	sqlDB.SetMaxOpenConns(100)
	sqlDB.SetConnMaxLifetime(time.Hour)

	return db, nil
}

// Migrate runs database migrations
func Migrate(db *gorm.DB) error {
	return db.AutoMigrate(
		// Add your models here
		// &amp;amp;models.User{},
		// &amp;amp;models.Item{},
	)
}
&#x60;;
  }

  private generateLogger(): string {
    return &#x60;package logger

import (
	&amp;quot;go.uber.org/zap&amp;quot;
	&amp;quot;go.uber.org/zap/zapcore&amp;quot;
)

// NewLogger creates a new zap logger
func NewLogger() (*zap.Logger, error) {
	config :&#x3D; zap.NewProductionConfig()
	config.Level &#x3D; zap.NewAtomicLevelAt(zap.InfoLevel)
	config.Encoding &#x3D; &amp;quot;json&amp;quot;
	config.EncoderConfig.TimeKey &#x3D; &amp;quot;timestamp&amp;quot;
	config.EncoderConfig.EncodeTime &#x3D; zapcore.ISO8601TimeEncoder
	config.EncoderConfig.StacktraceKey &#x3D; &amp;quot;&amp;quot; // Disable stacktrace in logs

	logger, err :&#x3D; config.Build()
	if err !&#x3D; nil {
		return nil, err
	}

	return logger, nil
}

// NewDevelopmentLogger creates a development logger with console output
func NewDevelopmentLogger() (*zap.Logger, error) {
	config :&#x3D; zap.NewDevelopmentConfig()
	config.EncoderConfig.EncodeLevel &#x3D; zapcore.CapitalColorLevelEncoder

	logger, err :&#x3D; config.Build()
	if err !&#x3D; nil {
		return nil, err
	}

	return logger, nil
}
&#x60;;
  }

  private generateServer(config: ProjectConfig): string {
    return &#x60;package server

import (
	&amp;quot;net/http&amp;quot;

	&amp;quot;github.com/gin-gonic/gin&amp;quot;
	&amp;quot;go.uber.org/zap&amp;quot;
	${config.database ? &#x60;&amp;quot;gorm.io/gorm&amp;quot;&#x60; : &amp;#39;&amp;#39;}

	&amp;quot;${config.name.toLowerCase()}/internal/config&amp;quot;
	&amp;quot;${config.name.toLowerCase()}/internal/handlers&amp;quot;
	&amp;quot;${config.name.toLowerCase()}/internal/middleware&amp;quot;
)

// Server represents the HTTP server
type Server struct {
	config *config.Config
	${config.database ? &amp;#39;db     *gorm.DB&amp;#39; : &amp;#39;&amp;#39;}
	logger *zap.Logger
	router *gin.Engine
}

// New creates a new server instance
func New(cfg *config.Config, ${config.database ? &amp;#39;db *gorm.DB, &amp;#39; : &amp;#39;&amp;#39;}logger *zap.Logger) *http.Server {
	// Set gin mode
	if cfg.Environment &#x3D;&#x3D; &amp;quot;production&amp;quot; {
		gin.SetMode(gin.ReleaseMode)
	}

	// Create router
	router :&#x3D; gin.New()

	// Add middleware
	router.Use(middleware.LoggerMiddleware(logger))
	router.Use(middleware.CORSMiddleware())
	router.Use(gin.Recovery())

	// Health check
	router.GET(&amp;quot;/health&amp;quot;, handlers.HealthCheck)

	// API v1 routes
	v1 :&#x3D; router.Group(&amp;quot;/api/v1&amp;quot;)
	{
		// Add your routes here
		// Example: routes.SetupUserRoutes(v1, userService, logger)
		v1.GET(&amp;quot;/ping&amp;quot;, func(c *gin.Context) {
			c.JSON(http.StatusOK, gin.H{&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;})
		})
	}

	return &amp;amp;http.Server{
		Addr:    cfg.Address,
		Handler: router,
	}
}
&#x60;;
  }

  private generateCORSMiddleware(): string {
    return &#x60;package middleware

import (
	&amp;quot;github.com/gin-gonic/gin&amp;quot;
)

// CORSMiddleware handles CORS headers
func CORSMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Writer.Header().Set(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;)
		c.Writer.Header().Set(&amp;quot;Access-Control-Allow-Credentials&amp;quot;, &amp;quot;true&amp;quot;)
		c.Writer.Header().Set(&amp;quot;Access-Control-Allow-Headers&amp;quot;, &amp;quot;Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With&amp;quot;)
		c.Writer.Header().Set(&amp;quot;Access-Control-Allow-Methods&amp;quot;, &amp;quot;POST, OPTIONS, GET, PUT, DELETE&amp;quot;)

		if c.Request.Method &#x3D;&#x3D; &amp;quot;OPTIONS&amp;quot; {
			c.AbortWithStatus(204)
			return
		}

		c.Next()
	}
}
&#x60;;
  }

  private generateLoggerMiddleware(): string {
    return &#x60;package middleware

import (
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/gin-gonic/gin&amp;quot;
	&amp;quot;go.uber.org/zap&amp;quot;
)

// LoggerMiddleware creates a gin middleware for logging requests
func LoggerMiddleware(logger *zap.Logger) gin.HandlerFunc {
	return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
		logger.Info(&amp;quot;Request&amp;quot;,
			zap.String(&amp;quot;client_ip&amp;quot;, param.ClientIP),
			zap.String(&amp;quot;method&amp;quot;, param.Method),
			zap.String(&amp;quot;path&amp;quot;, param.Path),
			zap.Int(&amp;quot;status&amp;quot;, param.StatusCode),
			zap.Duration(&amp;quot;latency&amp;quot;, param.Latency),
			zap.String(&amp;quot;user_agent&amp;quot;, param.Request.UserAgent()),
			zap.String(&amp;quot;error&amp;quot;, param.ErrorMessage),
		)
		return &amp;quot;&amp;quot;
	})
}
&#x60;;
  }

  private generateHealthHandler(): string {
    return &#x60;package handlers

import (
	&amp;quot;net/http&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/gin-gonic/gin&amp;quot;
)

// HealthCheck handles health check requests
func HealthCheck(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		&amp;quot;status&amp;quot;:    &amp;quot;healthy&amp;quot;,
		&amp;quot;timestamp&amp;quot;: time.Now().UTC(),
		&amp;quot;service&amp;quot;:   &amp;quot;api&amp;quot;,
		&amp;quot;version&amp;quot;:   &amp;quot;1.0.0&amp;quot;,
	})
}
&#x60;;
  }

  private generateEnvExample(config: ProjectConfig): string {
    return &#x60;# Application Configuration
ADDRESS&#x3D;:8080
ENVIRONMENT&#x3D;development
LOG_LEVEL&#x3D;info

${
  config.database
    ? &#x60;# Database Configuration
DATABASE_URL&#x3D;postgres://user:password@localhost:5432/${config.name.toLowerCase()}?sslmode&#x3D;disable&#x60;
    : &amp;#39;&amp;#39;
}

${
  config.auth
    ? &#x60;# Authentication
JWT_SECRET&#x3D;your-super-secret-jwt-key-change-in-production&#x60;
    : &amp;#39;&amp;#39;
}

# Additional configuration as needed
&#x60;;
  }

  private generateTestUtils(config: ProjectConfig): string {
    return &#x60;package testutils

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;net/http/httptest&amp;quot;
	&amp;quot;testing&amp;quot;

	&amp;quot;github.com/gin-gonic/gin&amp;quot;
	&amp;quot;github.com/stretchr/testify/assert&amp;quot;
	&amp;quot;go.uber.org/zap/zaptest&amp;quot;
	${
    config.database
      ? &#x60;&amp;quot;gorm.io/driver/sqlite&amp;quot;
	&amp;quot;gorm.io/gorm&amp;quot;&#x60;
      : &amp;#39;&amp;#39;
  }
)

// SetupTestRouter creates a test router
func SetupTestRouter() *gin.Engine {
	gin.SetMode(gin.TestMode)
	return gin.New()
}

// SetupTestLogger creates a test logger
func SetupTestLogger(t *testing.T) *zap.Logger {
	return zaptest.NewLogger(t)
}

${
  config.database
    ? &#x60;// SetupTestDB creates an in-memory SQLite database for testing
func SetupTestDB(t *testing.T) *gorm.DB {
	db, err :&#x3D; gorm.Open(sqlite.Open(&amp;quot;:memory:&amp;quot;), &amp;amp;gorm.Config{})
	assert.NoError(t, err)

	// Auto-migrate test models here
	// err &#x3D; db.AutoMigrate(&amp;amp;models.User{}, &amp;amp;models.Item{})
	// assert.NoError(t, err)

	return db
}&#x60;
    : &amp;#39;&amp;#39;
}

// MakeRequest makes an HTTP request for testing
func MakeRequest(router *gin.Engine, method, url string, body interface{}) *httptest.ResponseRecorder {
	var reqBody []byte
	if body !&#x3D; nil {
		reqBody, _ &#x3D; json.Marshal(body)
	}

	req, _ :&#x3D; http.NewRequest(method, url, bytes.NewBuffer(reqBody))
	req.Header.Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)

	w :&#x3D; httptest.NewRecorder()
	router.ServeHTTP(w, req)

	return w
}

// AssertJSONResponse asserts that the response body matches expected JSON
func AssertJSONResponse(t *testing.T, w *httptest.ResponseRecorder, expected interface{}) {
	var actual interface{}
	err :&#x3D; json.Unmarshal(w.Body.Bytes(), &amp;amp;actual)
	assert.NoError(t, err)
	assert.Equal(t, expected, actual)
}
&#x60;;
  }

  private generateMakefile(config: ProjectConfig): string {
    return &#x60;.PHONY: build run test clean dev help

# Variables
APP_NAME&#x3D;${config.name.toLowerCase()}
BINARY_DIR&#x3D;bin
BINARY_NAME&#x3D;\${BINARY_DIR}/\${APP_NAME}

# Default target
help: ## Show this help message
	@echo &amp;#39;Available targets:&amp;#39;
	@grep -E &amp;#39;^[a-zA-Z_-]+:.*?## .*$$&amp;#39; \$(MAKEFILE_LIST) | awk &amp;#39;BEGIN {FS &#x3D; &amp;quot;:.*?## &amp;quot;}; {printf &amp;quot;  \\033[36m%-20s\\033[0m %s\\n&amp;quot;, $$1, $$2}&amp;#39;

build: ## Build the application
	@echo &amp;quot;Building \${APP_NAME}...&amp;quot;
	@mkdir -p \${BINARY_DIR}
	@go build -o \${BINARY_NAME} cmd/main.go
	@echo &amp;quot;Build complete: \${BINARY_NAME}&amp;quot;

run: build ## Build and run the application
	@echo &amp;quot;Running \${APP_NAME}...&amp;quot;
	@./\${BINARY_NAME}

dev: ## Run the application in development mode
	@echo &amp;quot;Running \${APP_NAME} in development mode...&amp;quot;
	@go run cmd/main.go

test: ## Run tests
	@echo &amp;quot;Running tests...&amp;quot;
	@go test -v ./...

test-coverage: ## Run tests with coverage
	@echo &amp;quot;Running tests with coverage...&amp;quot;
	@go test -coverprofile&#x3D;coverage.out ./...
	@go tool cover -html&#x3D;coverage.out -o coverage.html
	@echo &amp;quot;Coverage report generated: coverage.html&amp;quot;

fmt: ## Format Go code
	@echo &amp;quot;Formatting code...&amp;quot;
	@go fmt ./...

vet: ## Run go vet
	@echo &amp;quot;Running go vet...&amp;quot;
	@go vet ./...

lint: ## Run golangci-lint
	@echo &amp;quot;Running linter...&amp;quot;
	@golangci-lint run

tidy: ## Tidy go modules
	@echo &amp;quot;Tidying go modules...&amp;quot;
	@go mod tidy

clean: ## Clean build artifacts
	@echo &amp;quot;Cleaning...&amp;quot;
	@rm -rf \${BINARY_DIR}
	@rm -f coverage.out coverage.html

deps: ## Download dependencies
	@echo &amp;quot;Downloading dependencies...&amp;quot;
	@go mod download

${
  config.docker
    ? &#x60;docker-build: ## Build Docker image
	@echo &amp;quot;Building Docker image...&amp;quot;
	@docker build -t \${APP_NAME}:latest .

docker-run: docker-build ## Build and run Docker container
	@echo &amp;quot;Running Docker container...&amp;quot;
	@docker run --rm -p 8080:8080 \${APP_NAME}:latest&#x60;
    : &amp;#39;&amp;#39;
}

# Development database commands (if using Docker)
${
  config.database
    ? &#x60;db-up: ## Start database container
	@echo &amp;quot;Starting database...&amp;quot;
	@docker-compose up -d database

db-down: ## Stop database container
	@echo &amp;quot;Stopping database...&amp;quot;
	@docker-compose down database

db-migrate: ## Run database migrations
	@echo &amp;quot;Running migrations...&amp;quot;
	@go run cmd/migrate.go&#x60;
    : &amp;#39;&amp;#39;
}
&#x60;;
  }

  private generateDockerfile(config: ProjectConfig): string {
    return &#x60;# Multi-stage build for Go application
FROM golang:1.21-alpine AS builder

# Install git and ca-certificates (needed for private repos and HTTPS)
RUN apk add --no-cache git ca-certificates

# Set working directory
WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy source code
COPY . .

# Build the application
RUN CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build -a -installsuffix cgo -o main cmd/main.go

# Final stage
FROM alpine:latest

# Install ca-certificates for HTTPS requests
RUN apk --no-cache add ca-certificates

# Create non-root user
RUN addgroup -g 1001 -S appgroup &amp;amp;&amp;amp; \\
    adduser -u 1001 -S appuser -G appgroup

WORKDIR /root/

# Copy the binary from builder stage
COPY --from&#x3D;builder /app/main .

# Copy any additional files (config, migrations, etc.)
# COPY --from&#x3D;builder /app/migrations ./migrations

# Change ownership to non-root user
RUN chown -R appuser:appgroup /root
USER appuser

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval&#x3D;30s --timeout&#x3D;10s --start-period&#x3D;5s --retries&#x3D;3 \\
    CMD wget --no-verbose --tries&#x3D;1 --spider http://localhost:8080/health || exit 1

# Run the application
CMD [&amp;quot;./main&amp;quot;]
&#x60;;
  }

  private generateDockerCompose(config: ProjectConfig): string {
    const dbService &#x3D;
      config.database &#x3D;&#x3D;&#x3D; &amp;#39;postgres&amp;#39;
        ? &#x60;
  database:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: ${config.name.toLowerCase()}
      POSTGRES_PASSWORD: password
      POSTGRES_DB: ${config.name.toLowerCase()}
    ports:
      - &amp;quot;5432:5432&amp;quot;
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: [&amp;quot;CMD-SHELL&amp;quot;, &amp;quot;pg_isready -U ${config.name.toLowerCase()}&amp;quot;]
      interval: 10s
      timeout: 5s
      retries: 5&#x60;
        : &amp;#39;&amp;#39;;

    return &#x60;version: &amp;#39;3.8&amp;#39;

services:
  app:
    build: .
    ports:
      - &amp;quot;8080:8080&amp;quot;
    environment:
      - ENVIRONMENT&#x3D;development
      ${config.database ? &#x60;- DATABASE_URL&#x3D;postgres://${config.name.toLowerCase()}:password@database:5432/${config.name.toLowerCase()}?sslmode&#x3D;disable&#x60; : &amp;#39;&amp;#39;}
    ${
      config.database
        ? &#x60;depends_on:
      database:
        condition: service_healthy&#x60;
        : &amp;#39;&amp;#39;
    }
    restart: unless-stopped
${dbService}

${
  config.database &#x3D;&#x3D;&#x3D; &amp;#39;postgres&amp;#39;
    ? &#x60;volumes:
  postgres_data:&#x60;
    : &amp;#39;&amp;#39;
}
&#x60;;
  }

  private generateProductionDockerfile(config: BuildConfig): string {
    return &#x60;# Production multi-stage build
FROM golang:1.21-alpine AS builder

# Install build dependencies
RUN apk add --no-cache git ca-certificates gcc musl-dev

WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build with optimizations
RUN CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build \\
    -a -installsuffix cgo \\
    -ldflags&#x3D;&amp;#39;-w -s -extldflags &amp;quot;-static&amp;quot;&amp;#39; \\
    -o main cmd/main.go

# Final minimal stage
FROM scratch

# Copy ca-certificates from builder
COPY --from&#x3D;builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# Copy the binary
COPY --from&#x3D;builder /app/main /main

# Expose port
EXPOSE 8080

# Run the application
ENTRYPOINT [&amp;quot;/main&amp;quot;]
&#x60;;
  }

  private generateGitHubActions(config: BuildConfig): string {
    return &#x60;name: Go Application CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test
        options: &amp;gt;-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: &amp;#39;1.21&amp;#39;
        
    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: \${{ runner.os }}-go-\${{ hashFiles(&amp;#39;**/go.sum&amp;#39;) }}
        restore-keys: |
          \${{ runner.os }}-go-
    
    - name: Download dependencies
      run: go mod download
    
    - name: Verify dependencies
      run: go mod verify
    
    - name: Format check
      run: |
        if [ &amp;quot;$(gofmt -s -l . | wc -l)&amp;quot; -gt 0 ]; then
          echo &amp;quot;Code is not formatted. Please run &amp;#39;gofmt -s -w .&amp;#39;&amp;quot;
          gofmt -s -l .
          exit 1
        fi
    
    - name: Vet
      run: go vet ./...
    
    - name: Lint
      uses: golangci/golangci-lint-action@v3
      with:
        version: latest
    
    - name: Test
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/test?sslmode&#x3D;disable
      run: go test -race -coverprofile&#x3D;coverage.out -covermode&#x3D;atomic ./...
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out
        flags: unittests
        name: codecov-umbrella

  ${
    config.target &#x3D;&#x3D;&#x3D; &amp;#39;production&amp;#39;
      ? &#x60;build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref &#x3D;&#x3D; &amp;#39;refs/heads/main&amp;#39;
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: &amp;#39;1.21&amp;#39;
    
    - name: Build binary
      run: |
        CGO_ENABLED&#x3D;0 GOOS&#x3D;linux go build -a -installsuffix cgo \\
          -ldflags&#x3D;&amp;#39;-w -s -extldflags &amp;quot;-static&amp;quot;&amp;#39; \\
          -o bin/app cmd/main.go
    
    - name: Build Docker image
      run: |
        docker build -f Dockerfile.prod -t your-registry/app:$&#x60; +
        &amp;#39;{{ github.sha }}&amp;#39; +
        &#x60; .
        docker tag your-registry/app:$&#x60; +
        &amp;#39;{{ github.sha }}&amp;#39; +
        &#x60; your-registry/app:latest
    
    - name: Push Docker image
      run: |
        echo &amp;quot;$&#x60; +
        &amp;#39;{{ secrets.DOCKER_PASSWORD }}&amp;#39; +
        &#x60;&amp;quot; | docker login -u &amp;quot;$&#x60; +
        &amp;#39;{{ secrets.DOCKER_USERNAME }}&amp;#39; +
        &#x60;&amp;quot; --password-stdin
        docker push your-registry/app:$&#x60; +
        &#x60;{{ github.sha }}
        docker push your-registry/app:latest&#x60;
      : &amp;#39;&amp;#39;
  }
&#x60;;
  }

  private generateGoReleaser(config: BuildConfig): string {
    return &#x60;# GoReleaser configuration
project_name: ${config.target}

before:
  hooks:
    - go mod tidy
    - go generate ./...

builds:
  - env:
      - CGO_ENABLED&#x3D;0
    goos:
      - linux
      - windows
      - darwin
    goarch:
      - amd64
      - arm64
    main: ./cmd/main.go
    binary: app
    ldflags:
      - -s -w -X main.version&#x3D;{{.Version}} -X main.commit&#x3D;{{.Commit}} -X main.date&#x3D;{{.Date}}

archives:
  - format: tar.gz
    name_template: &amp;gt;-
      {{ .ProjectName }}_
      {{- title .Os }}_
      {{- if eq .Arch &amp;quot;amd64&amp;quot; }}x86_64
      {{- else if eq .Arch &amp;quot;386&amp;quot; }}i386
      {{- else }}{{ .Arch }}{{ end }}
    format_overrides:
      - goos: windows
        format: zip

checksum:
  name_template: &amp;#39;checksums.txt&amp;#39;

snapshot:
  name_template: &amp;quot;{{ incpatch .Version }}-next&amp;quot;

changelog:
  sort: asc
  filters:
    exclude:
      - &amp;#39;^docs:&amp;#39;
      - &amp;#39;^test:&amp;#39;

dockers:
  - image_templates:
      - &amp;quot;your-registry/{{.ProjectName}}:{{ .Tag }}&amp;quot;
      - &amp;quot;your-registry/{{.ProjectName}}:latest&amp;quot;
    dockerfile: Dockerfile.prod
    build_flag_templates:
      - &amp;quot;--platform&#x3D;linux/amd64&amp;quot;
&#x60;;
  }

  private toPascalCase(str: string): string {
    return str.replace(/(?:^|[-_])(\w)/g, (_, c) &#x3D;&amp;gt; c.toUpperCase());
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-16">
                <div class="file-header">ğŸ“„ packages/cli/src/constraints/sandbox.ts</div>
                <div class="file-content">
                    <pre>import { performance } from &amp;quot;node:perf_hooks&amp;quot;;
import type { CLIConfig } from &amp;quot;../types.js&amp;quot;;
import { ConstraintViolationError, globalConstraintEnforcer } from &amp;quot;./core.js&amp;quot;;

/**
 * Operation types that must use server endpoints
 */
export type SandboxedOperation &#x3D;
  | &amp;quot;validate&amp;quot;
  | &amp;quot;analyze&amp;quot;
  | &amp;quot;export&amp;quot;
  | &amp;quot;transform&amp;quot;
  | &amp;quot;check&amp;quot;
  | &amp;quot;import&amp;quot;
  | &amp;quot;diff&amp;quot;
  | &amp;quot;migrate&amp;quot;;

/**
 * Server endpoint configuration for sandboxed operations
 */
export interface ServerEndpoint {
  path: string;
  method: &amp;quot;GET&amp;quot; | &amp;quot;POST&amp;quot; | &amp;quot;PUT&amp;quot; | &amp;quot;DELETE&amp;quot;;
  requiresPayload: boolean;
  maxResponseTime: number;
}

/**
 * Mapping of operations to their required server endpoints
 */
export const REQUIRED_ENDPOINTS: Record&amp;lt;SandboxedOperation, ServerEndpoint&amp;gt; &#x3D; {
  validate: {
    path: &amp;quot;/api/v1/validate&amp;quot;,
    method: &amp;quot;POST&amp;quot;,
    requiresPayload: true,
    maxResponseTime: 500, // Must be within 750ms total constraint
  },
  analyze: {
    path: &amp;quot;/api/v1/analyze&amp;quot;,
    method: &amp;quot;POST&amp;quot;,
    requiresPayload: true,
    maxResponseTime: 600,
  },
  export: {
    path: &amp;quot;/api/v1/export&amp;quot;,
    method: &amp;quot;POST&amp;quot;,
    requiresPayload: true,
    maxResponseTime: 700,
  },
  transform: {
    path: &amp;quot;/api/v1/transform&amp;quot;,
    method: &amp;quot;POST&amp;quot;,
    requiresPayload: true,
    maxResponseTime: 600,
  },
  check: {
    path: &amp;quot;/api/v1/check&amp;quot;,
    method: &amp;quot;POST&amp;quot;,
    requiresPayload: true,
    maxResponseTime: 500,
  },
  import: {
    path: &amp;quot;/api/v1/import&amp;quot;,
    method: &amp;quot;POST&amp;quot;,
    requiresPayload: true,
    maxResponseTime: 400,
  },
  diff: {
    path: &amp;quot;/api/v1/diff&amp;quot;,
    method: &amp;quot;POST&amp;quot;,
    requiresPayload: true,
    maxResponseTime: 300,
  },
  migrate: {
    path: &amp;quot;/api/v1/migrate&amp;quot;,
    method: &amp;quot;POST&amp;quot;,
    requiresPayload: true,
    maxResponseTime: 700,
  },
};

/**
 * Execution context tracking for sandbox validation
 */
interface ExecutionContext {
  operation: SandboxedOperation;
  startTime: number;
  endpointUsed?: string;
  isDirectExecution: boolean;
  callStack: string[];
}

/**
 * Sandbox compliance validator
 * Ensures all operations go through server endpoints, not direct tool execution
 */
export class SandboxValidator {
  private readonly executionStack: ExecutionContext[] &#x3D; [];
  private readonly config: CLIConfig;
  private readonly allowedDirectOperations &#x3D; new Set&amp;lt;string&amp;gt;([
    // Only these operations can execute directly (non-sandboxed)
    &amp;quot;init&amp;quot;,
    &amp;quot;config&amp;quot;,
    &amp;quot;help&amp;quot;,
    &amp;quot;version&amp;quot;,
    &amp;quot;template&amp;quot;,
  ]);

  constructor(config: CLIConfig) {
    this.config &#x3D; config;
  }

  /**
   * Start tracking a potentially sandboxed operation
   */
  startOperation(operation: SandboxedOperation, callStack: string[] &#x3D; []): string {
    const operationId &#x3D; globalConstraintEnforcer.startOperation(&#x60;sandbox:${operation}&#x60;, {
      operation,
      callStack,
    });

    const context: ExecutionContext &#x3D; {
      operation,
      startTime: performance.now(),
      isDirectExecution: false,
      callStack,
    };

    this.executionStack.push(context);

    return operationId;
  }

  /**
   * Mark that an operation is using server endpoint (compliant)
   */
  markServerEndpointUsage(
    operation: SandboxedOperation,
    endpoint: string,
    operationId: string,
  ): void {
    const context &#x3D; this.executionStack.find((ctx) &#x3D;&amp;gt; ctx.operation &#x3D;&#x3D;&#x3D; operation);
    if (!context) {
      throw new Error(&#x60;No active context found for operation: ${operation}&#x60;);
    }

    context.endpointUsed &#x3D; endpoint;
    context.isDirectExecution &#x3D; false;

    // Validate that the correct endpoint is being used
    const requiredEndpoint &#x3D; REQUIRED_ENDPOINTS[operation];
    const expectedPath &#x3D; requiredEndpoint.path;

    if (!endpoint.includes(expectedPath)) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;quot;sandboxCompliance&amp;quot;,
        &#x60;endpoint: ${endpoint}&#x60;,
        &#x60;endpoint containing: ${expectedPath}&#x60;,
        {
          operationId,
          operation,
          providedEndpoint: endpoint,
          expectedEndpoint: expectedPath,
        },
      );

      globalConstraintEnforcer.emit(&amp;quot;constraint:violation&amp;quot;, {
        constraint: &amp;quot;sandboxCompliance&amp;quot;,
        violation,
        operation,
      });

      throw violation;
    }

    // Validate endpoint compliance with global constraint enforcer
    globalConstraintEnforcer.validateSandboxCompliance(
      operation,
      false, // Not direct execution
      operationId,
    );
  }

  /**
   * Mark that an operation is attempting direct execution (violation)
   */
  markDirectExecution(operation: SandboxedOperation, _toolName: string, operationId: string): void {
    const context &#x3D; this.executionStack.find((ctx) &#x3D;&amp;gt; ctx.operation &#x3D;&#x3D;&#x3D; operation);
    if (!context) {
      throw new Error(&#x60;No active context found for operation: ${operation}&#x60;);
    }

    context.isDirectExecution &#x3D; true;

    // This will throw a ConstraintViolationError
    globalConstraintEnforcer.validateSandboxCompliance(
      operation,
      true, // Direct execution detected
      operationId,
    );
  }

  /**
   * End operation tracking and validate compliance
   */
  endOperation(operation: SandboxedOperation, operationId: string): void {
    const contextIndex &#x3D; this.executionStack.findIndex((ctx) &#x3D;&amp;gt; ctx.operation &#x3D;&#x3D;&#x3D; operation);
    if (contextIndex &#x3D;&#x3D;&#x3D; -1) {
      throw new Error(&#x60;No active context found for operation: ${operation}&#x60;);
    }

    const context &#x3D; this.executionStack[contextIndex];

    // Validate that server endpoint was used
    if (!context.endpointUsed &amp;amp;&amp;amp; !context.isDirectExecution) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;quot;sandboxCompliance&amp;quot;,
        &amp;quot;no endpoint usage detected&amp;quot;,
        &amp;quot;server endpoint usage&amp;quot;,
        {
          operationId,
          operation,
          message: &amp;quot;Operation completed without using required server endpoint&amp;quot;,
        },
      );

      globalConstraintEnforcer.emit(&amp;quot;constraint:violation&amp;quot;, {
        constraint: &amp;quot;sandboxCompliance&amp;quot;,
        violation,
        operation,
      });

      throw violation;
    }

    // Remove context from stack
    this.executionStack.splice(contextIndex, 1);

    // End global constraint tracking
    globalConstraintEnforcer.endOperation(operationId);
  }

  /**
   * Validate that a function/tool call is allowed to execute directly
   */
  validateDirectExecution(functionName: string, operation?: string): void {
    if (operation &amp;amp;&amp;amp; this.isOperationSandboxed(operation as SandboxedOperation)) {
      throw new ConstraintViolationError(
        &amp;quot;sandboxCompliance&amp;quot;,
        &#x60;direct execution of ${functionName}&#x60;,
        &amp;quot;server endpoint usage&amp;quot;,
        {
          operation,
          functionName,
          message: &#x60;Function ${functionName} cannot be called directly during sandboxed operation ${operation}&#x60;,
        },
      );
    }

    if (!this.allowedDirectOperations.has(functionName)) {
      const currentOperations &#x3D; this.executionStack.map((ctx) &#x3D;&amp;gt; ctx.operation);
      if (currentOperations.some((op) &#x3D;&amp;gt; this.isOperationSandboxed(op))) {
        throw new ConstraintViolationError(
          &amp;quot;sandboxCompliance&amp;quot;,
          &#x60;direct execution of ${functionName}&#x60;,
          &amp;quot;server endpoint usage&amp;quot;,
          {
            functionName,
            activeOperations: currentOperations,
            message: &#x60;Function ${functionName} cannot be called directly during active sandboxed operations&#x60;,
          },
        );
      }
    }
  }

  /**
   * Check if an operation requires sandboxing
   */
  isOperationSandboxed(operation: string): operation is SandboxedOperation {
    return Object.keys(REQUIRED_ENDPOINTS).includes(operation);
  }

  /**
   * Get required endpoint information for an operation
   */
  getRequiredEndpoint(operation: SandboxedOperation): ServerEndpoint {
    return REQUIRED_ENDPOINTS[operation];
  }

  /**
   * Construct full endpoint URL for an operation
   */
  getEndpointUrl(operation: SandboxedOperation): string {
    const endpoint &#x3D; REQUIRED_ENDPOINTS[operation];
    const baseUrl &#x3D; this.config.apiUrl.replace(/\/+$/, &amp;quot;&amp;quot;); // Remove trailing slashes
    return &#x60;${baseUrl}${endpoint.path}&#x60;;
  }

  /**
   * Get current sandbox status
   */
  getSandboxStatus(): {
    activeOperations: ExecutionContext[];
    violations: number;
    complianceRate: number;
  } {
    const violations &#x3D; this.executionStack.filter((ctx) &#x3D;&amp;gt; ctx.isDirectExecution).length;
    const total &#x3D; this.executionStack.length;
    const complianceRate &#x3D; total &amp;gt; 0 ? ((total - violations) / total) * 100 : 100;

    return {
      activeOperations: [...this.executionStack],
      violations,
      complianceRate,
    };
  }
}

/**
 * Decorator to automatically enforce sandbox compliance
 */
export function sandboxed(operation: SandboxedOperation) {
  return &amp;lt;T extends (...args: any[]) &#x3D;&amp;gt; Promise&amp;lt;any&amp;gt;&amp;gt;(
    _target: any,
    _propertyName: string,
    descriptor: TypedPropertyDescriptor&amp;lt;T&amp;gt;,
  ) &#x3D;&amp;gt; {
    const method &#x3D; descriptor.value!;

    descriptor.value &#x3D; async function (this: any, ...args: any[]) {
      // Get sandbox validator from context or create new one
      const config &#x3D; this.config || globalSandboxConfig;
      const validator &#x3D; new SandboxValidator(config);

      const callStack &#x3D; new Error().stack?.split(&amp;quot;\n&amp;quot;).slice(2, 6) || [];
      const operationId &#x3D; validator.startOperation(operation, callStack);

      try {
        const result &#x3D; await method.apply(this, args);
        validator.endOperation(operation, operationId);
        return result;
      } catch (error) {
        validator.endOperation(operation, operationId);
        throw error;
      }
    } as T;

    return descriptor;
  };
}

/**
 * Global sandbox configuration - should be set by CLI initialization
 */
let globalSandboxConfig: CLIConfig;

/**
 * Initialize global sandbox configuration
 */
export function initializeSandboxConfig(config: CLIConfig): void {
  globalSandboxConfig &#x3D; config;
}

/**
 * Create a sandbox validator instance
 */
export function createSandboxValidator(config: CLIConfig): SandboxValidator {
  return new SandboxValidator(config);
}

/**
 * Utility to wrap API client calls with automatic endpoint tracking
 */
export function withEndpointTracking&amp;lt;T&amp;gt;(
  validator: SandboxValidator,
  operation: SandboxedOperation,
  operationId: string,
  apiCall: () &#x3D;&amp;gt; Promise&amp;lt;T&amp;gt;,
): Promise&amp;lt;T&amp;gt; {
  return new Promise(async (resolve, reject) &#x3D;&amp;gt; {
    try {
      // Track that we&amp;#39;re using the server endpoint
      const endpoint &#x3D; validator.getEndpointUrl(operation);
      validator.markServerEndpointUsage(operation, endpoint, operationId);

      // Execute the API call
      const result &#x3D; await apiCall();
      resolve(result);
    } catch (error) {
      reject(error);
    }
  });
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-17">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/github-template-config.ts</div>
                <div class="file-content">
                    <pre>/**
 * Configuration-based GitHub Template System
 *
 * This module provides a flexible, configuration-driven approach to GitHub templates
 * that supports inheritance, customization, and dynamic generation.
 */

import type {
  GitHubFieldValidation,
  GitHubFileTemplateRef,
  GitHubLabel,
  GitHubTemplateConfig,
  GitHubTemplateOptions,
  GitHubTemplateSections,
  GitHubTemplateSet,
  GitHubTemplateSetSource,
  GitHubTemplatesConfig,
} from &amp;#39;../types.js&amp;#39;;
import type { Epic, Task } from &amp;#39;./sharded-storage.js&amp;#39;;

export interface GeneratedTemplate {
  title: string;
  body: string;
  labels: string[];
  assignees?: string[];
  milestone?: number;
  projects?: number[];
}

export interface TemplateFiles {
  [filePath: string]: string;
}

/**
 * Default template configuration for backward compatibility
 */
export const DEFAULT_TEMPLATES_CONFIG: GitHubTemplatesConfig &#x3D; {
  base: {
    name: &amp;#39;arbiter-default&amp;#39;,
    description: &amp;#39;Default Arbiter template set&amp;#39;,
    sections: {
      description: &amp;#39;## ğŸ“‹ Description\n\n{{description}}\n\n&amp;#39;,
      details: [
        { name: &amp;#39;priority&amp;#39;, label: &amp;#39;Priority&amp;#39;, required: true, type: &amp;#39;select&amp;#39; },
        { name: &amp;#39;status&amp;#39;, label: &amp;#39;Status&amp;#39;, required: true, type: &amp;#39;select&amp;#39; },
        { name: &amp;#39;assignee&amp;#39;, label: &amp;#39;Assignee&amp;#39;, type: &amp;#39;text&amp;#39; },
        { name: &amp;#39;estimatedHours&amp;#39;, label: &amp;#39;Estimated Hours&amp;#39;, type: &amp;#39;number&amp;#39; },
      ],
      acceptanceCriteria:
        &amp;#39;## âœ… Acceptance Criteria\n\n{{#each acceptanceCriteria}}\n- [ ] {{this}}\n{{/each}}\n\n&amp;#39;,
      dependencies: &amp;#39;## ğŸ”— Dependencies\n\n{{#each dependencies}}\n- [ ] {{this}}\n{{/each}}\n\n&amp;#39;,
    },
    labels: [&amp;#39;arbiter-managed&amp;#39;],
    validation: {
      fields: [
        {
          field: &amp;#39;name&amp;#39;,
          required: true,
          minLength: 5,
          maxLength: 80,
          errorMessage: &amp;#39;Name must be 5-80 characters&amp;#39;,
        },
        {
          field: &amp;#39;description&amp;#39;,
          required: true,
          minLength: 10,
          errorMessage: &amp;#39;Description must be at least 10 characters&amp;#39;,
        },
      ],
    },
  },
  epic: {
    inherits: &amp;#39;arbiter-default&amp;#39;,
    name: &amp;#39;Epic&amp;#39;,
    title: &amp;#39;[EPIC] {{priority}}: {{name}}&amp;#39;,
    labels: [&amp;#39;epic&amp;#39;, &amp;#39;priority:{{priority}}&amp;#39;, &amp;#39;status:{{status}}&amp;#39;],
    sections: {
      description:
        &amp;#39;## ğŸ“‹ Epic Description\n\n**Summary:** {{description}}\n\n**Success Criteria:** {{successCriteria}}\n\n&amp;#39;,
      additional: {
        scope:
          &amp;#39;## ğŸ¯ Scope\n\n**In Scope:**\n{{#each inScope}}\n- {{this}}\n{{/each}}\n\n**Out of Scope:**\n{{#each outOfScope}}\n- {{this}}\n{{/each}}\n\n&amp;#39;,
        tasks:
          &amp;#39;## âœ… Tasks Overview\n\n**Total Tasks:** {{tasks.length}}\n\n{{#each tasks}}\n- [ ] {{this.name}} ({{this.status}})\n{{/each}}\n\n&amp;#39;,
      },
    },
    validation: {
      fields: [
        {
          field: &amp;#39;priority&amp;#39;,
          required: true,
          enum: [&amp;#39;critical&amp;#39;, &amp;#39;high&amp;#39;, &amp;#39;medium&amp;#39;, &amp;#39;low&amp;#39;],
          errorMessage: &amp;#39;Priority must be one of: critical, high, medium, low&amp;#39;,
        },
        {
          field: &amp;#39;owner&amp;#39;,
          required: true,
          errorMessage: &amp;#39;Epic must have an assigned owner&amp;#39;,
        },
      ],
    },
  },
  task: {
    inherits: &amp;#39;arbiter-default&amp;#39;,
    name: &amp;#39;Task&amp;#39;,
    title: &amp;#39;[{{type}}] {{priority}}: {{name}}&amp;#39;,
    labels: [&amp;#39;type:{{type}}&amp;#39;, &amp;#39;priority:{{priority}}&amp;#39;, &amp;#39;status:{{status}}&amp;#39;, &amp;#39;epic:{{epicId}}&amp;#39;],
    sections: {
      description:
        &amp;#39;## ğŸ“‹ Task Description\n\n**Summary:** {{description}}\n\n**Context:** {{context}}\n\n&amp;#39;,
      additional: {
        implementation: &amp;#39;## ğŸ“ Implementation Notes\n\n{{implementationNotes}}\n\n&amp;#39;,
        testing:
          &amp;#39;## ğŸ§ª Testing Requirements\n\n- [ ] Unit tests added/updated\n- [ ] Integration tests added/updated\n- [ ] Manual testing completed\n- [ ] Documentation updated\n\n&amp;#39;,
      },
    },
    validation: {
      fields: [
        {
          field: &amp;#39;type&amp;#39;,
          required: true,
          enum: [&amp;#39;feature&amp;#39;, &amp;#39;bug&amp;#39;, &amp;#39;refactor&amp;#39;, &amp;#39;test&amp;#39;, &amp;#39;docs&amp;#39;, &amp;#39;devops&amp;#39;, &amp;#39;research&amp;#39;],
          errorMessage:
            &amp;#39;Task type must be one of: feature, bug, refactor, test, docs, devops, research&amp;#39;,
        },
        {
          field: &amp;#39;acceptanceCriteria&amp;#39;,
          required: true,
          errorMessage: &amp;#39;Task must have at least one acceptance criterion&amp;#39;,
        },
      ],
    },
  },
  bugReport: {
    name: &amp;#39;Bug Report&amp;#39;,
    title: &amp;#39;[BUG] {{priority}}: {{title}}&amp;#39;,
    labels: [&amp;#39;type:bug&amp;#39;, &amp;#39;priority:{{priority}}&amp;#39;],
    sections: {
      description:
        &amp;#39;## ğŸ› Bug Description\n\n**Summary:** {{summary}}\n\n**Expected Behavior:** {{expectedBehavior}}\n\n**Actual Behavior:** {{actualBehavior}}\n\n&amp;#39;,
      additional: {
        reproduction:
          &amp;#39;## ğŸ”„ Steps to Reproduce\n\n{{#each steps}}\n{{@index}. {{this}}\n{{/each}}\n\n&amp;#39;,
        environment:
          &amp;#39;## ğŸŒ Environment\n\n- **OS:** {{os}}\n- **Browser:** {{browser}}\n- **Version:** {{version}}\n\n&amp;#39;,
        impact:
          &amp;#39;## ğŸ“Š Impact Assessment\n\n- **Priority:** {{priority}}\n- **Affected Users:** {{affectedUsers}}\n- **Workaround Available:** {{workaround}}\n\n&amp;#39;,
      },
    },
  },
  featureRequest: {
    name: &amp;#39;Feature Request&amp;#39;,
    title: &amp;#39;[FEATURE] {{title}}&amp;#39;,
    labels: [&amp;#39;type:feature&amp;#39;, &amp;#39;priority:{{priority}}&amp;#39;],
    sections: {
      description:
        &amp;#39;## ğŸ’¡ Feature Description\n\n**Summary:** {{summary}}\n\n**Problem Statement:** {{problemStatement}}\n\n**Proposed Solution:** {{proposedSolution}}\n\n&amp;#39;,
      additional: {
        useCases:
          &amp;#39;## ğŸ¯ Use Cases\n\n{{#each useCases}}\n{{@index}}. **As a {{userType}}, I want {{goal}} so that {{benefit}}**\n{{/each}}\n\n&amp;#39;,
        alternatives: &amp;#39;## ğŸ”„ Alternatives Considered\n\n{{alternatives}}\n\n&amp;#39;,
        impact:
          &amp;#39;## ğŸ“Š Impact Assessment\n\n- **Priority:** {{priority}}\n- **Effort Estimate:** {{effortEstimate}}\n- **Potential Users:** {{potentialUsers}}\n\n&amp;#39;,
      },
    },
  },
  repositoryConfig: {
    issueConfig: {
      blankIssuesEnabled: false,
      contactLinks: [
        {
          name: &amp;#39;ğŸ“š Documentation&amp;#39;,
          url: &amp;#39;https://github.com/{{owner}}/{{repo}}/wiki&amp;#39;,
          about: &amp;#39;Check our documentation for common questions&amp;#39;,
        },
        {
          name: &amp;#39;ğŸ’¬ Discussions&amp;#39;,
          url: &amp;#39;https://github.com/{{owner}}/{{repo}}/discussions&amp;#39;,
          about: &amp;#39;Ask questions and discuss with the community&amp;#39;,
        },
      ],
    },
    labels: [
      // Type labels
      { name: &amp;#39;type:feature&amp;#39;, color: &amp;#39;0e8a16&amp;#39;, description: &amp;#39;New feature or enhancement&amp;#39; },
      { name: &amp;#39;type:bug&amp;#39;, color: &amp;#39;d73a49&amp;#39;, description: &amp;#39;Something is not working&amp;#39; },
      {
        name: &amp;#39;type:refactor&amp;#39;,
        color: &amp;#39;fbca04&amp;#39;,
        description: &amp;#39;Code improvement without new features&amp;#39;,
      },
      { name: &amp;#39;type:test&amp;#39;, color: &amp;#39;c5def5&amp;#39;, description: &amp;#39;Testing related changes&amp;#39; },
      { name: &amp;#39;type:docs&amp;#39;, color: &amp;#39;0052cc&amp;#39;, description: &amp;#39;Documentation improvements&amp;#39; },
      { name: &amp;#39;type:devops&amp;#39;, color: &amp;#39;5319e7&amp;#39;, description: &amp;#39;DevOps and infrastructure changes&amp;#39; },
      { name: &amp;#39;type:research&amp;#39;, color: &amp;#39;d4c5f9&amp;#39;, description: &amp;#39;Research and exploration task&amp;#39; },

      // Priority labels
      {
        name: &amp;#39;priority:critical&amp;#39;,
        color: &amp;#39;b60205&amp;#39;,
        description: &amp;#39;Critical priority - must be addressed immediately&amp;#39;,
      },
      {
        name: &amp;#39;priority:high&amp;#39;,
        color: &amp;#39;ff9500&amp;#39;,
        description: &amp;#39;High priority - should be addressed soon&amp;#39;,
      },
      {
        name: &amp;#39;priority:medium&amp;#39;,
        color: &amp;#39;fbca04&amp;#39;,
        description: &amp;#39;Medium priority - normal timeline&amp;#39;,
      },
      { name: &amp;#39;priority:low&amp;#39;, color: &amp;#39;0e8a16&amp;#39;, description: &amp;#39;Low priority - can wait&amp;#39; },

      // Status labels
      { name: &amp;#39;status:planning&amp;#39;, color: &amp;#39;f0f0f0&amp;#39;, description: &amp;#39;In planning phase&amp;#39; },
      { name: &amp;#39;status:in_progress&amp;#39;, color: &amp;#39;0052cc&amp;#39;, description: &amp;#39;Currently being worked on&amp;#39; },
      { name: &amp;#39;status:review&amp;#39;, color: &amp;#39;fbca04&amp;#39;, description: &amp;#39;In review&amp;#39; },
      { name: &amp;#39;status:testing&amp;#39;, color: &amp;#39;c5def5&amp;#39;, description: &amp;#39;In testing phase&amp;#39; },
      { name: &amp;#39;status:completed&amp;#39;, color: &amp;#39;0e8a16&amp;#39;, description: &amp;#39;Completed&amp;#39; },
      { name: &amp;#39;status:cancelled&amp;#39;, color: &amp;#39;d93f0b&amp;#39;, description: &amp;#39;Cancelled&amp;#39; },

      // Special labels
      { name: &amp;#39;epic&amp;#39;, color: &amp;#39;5319e7&amp;#39;, description: &amp;#39;Large feature epic&amp;#39; },
      { name: &amp;#39;needs-review&amp;#39;, color: &amp;#39;fbca04&amp;#39;, description: &amp;#39;Requires code review&amp;#39; },
      { name: &amp;#39;needs-testing&amp;#39;, color: &amp;#39;c5def5&amp;#39;, description: &amp;#39;Requires testing&amp;#39; },
      {
        name: &amp;#39;parallel-safe&amp;#39;,
        color: &amp;#39;0e8a16&amp;#39;,
        description: &amp;#39;Can run in parallel with other tasks&amp;#39;,
      },
      { name: &amp;#39;arbiter-managed&amp;#39;, color: &amp;#39;d4c5f9&amp;#39;, description: &amp;#39;Managed by Arbiter CLI&amp;#39; },
    ],
  },
};

export class ConfigurableTemplateManager {
  private config: GitHubTemplatesConfig;
  private baseTemplates: Map&amp;lt;string, GitHubTemplateSet&amp;gt; &#x3D; new Map();

  constructor(config?: GitHubTemplatesConfig) {
    this.config &#x3D; config || DEFAULT_TEMPLATES_CONFIG;
    this.loadBaseTemplates();
  }

  private isFileTemplateRef(
    value: GitHubTemplateConfig | GitHubFileTemplateRef
  ): value is GitHubFileTemplateRef {
    return (value as GitHubFileTemplateRef).file !&#x3D;&#x3D; undefined;
  }

  private isTemplateSet(value: GitHubTemplateSetSource): value is GitHubTemplateSet {
    return (
      typeof (value as GitHubTemplateSet).name &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39; &amp;amp;&amp;amp;
      value !&#x3D;&#x3D; undefined &amp;amp;&amp;amp;
      typeof (value as GitHubTemplateSet).sections?.description &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39;
    );
  }

  private ensureTemplateConfig(
    value: GitHubTemplateConfig | GitHubFileTemplateRef
  ): GitHubTemplateConfig {
    if (this.isFileTemplateRef(value)) {
      throw new Error(
        &#x60;File-based templates are not supported by ConfigurableTemplateManager. Use FileBasedTemplateManager for ${value.file}.&#x60;
      );
    }
    return value;
  }

  private extractTemplateMetadata(
    value: GitHubTemplateConfig | GitHubFileTemplateRef | undefined
  ): { name?: string; description?: string } {
    if (!value) return {};
    if (this.isFileTemplateRef(value)) {
      return {
        name: value.metadata?.name,
        description: value.metadata?.description,
      };
    }

    return {
      name: value.name,
      description: value.description,
    };
  }

  /**
   * Load base templates for inheritance
   */
  private loadBaseTemplates(): void {
    if (this.config.base &amp;amp;&amp;amp; this.isTemplateSet(this.config.base)) {
      this.baseTemplates.set(this.config.base.name, this.config.base);
    }

    // Load default base template if not overridden
    if (!this.baseTemplates.has(&amp;#39;arbiter-default&amp;#39;)) {
      this.baseTemplates.set(&amp;#39;arbiter-default&amp;#39;, DEFAULT_TEMPLATES_CONFIG.base as GitHubTemplateSet);
    }
  }

  /**
   * Generate epic template using configuration
   */
  generateEpicTemplate(epic: Epic, options: GitHubTemplateOptions &#x3D; {}): GeneratedTemplate {
    const templateConfig &#x3D; this.config.epic || DEFAULT_TEMPLATES_CONFIG.epic!;
    const resolvedConfig &#x3D; this.resolveTemplateConfig(templateConfig);

    // Validate epic data
    this.validateData(epic, resolvedConfig.validation);

    // Generate template content
    const context &#x3D; this.createTemplateContext(epic, options);
    const title &#x3D; this.renderTemplate(resolvedConfig.title || &amp;#39;{{name}}&amp;#39;, context);
    const body &#x3D; this.generateTemplateBody(resolvedConfig.sections, context);
    const labels &#x3D; this.renderLabels(resolvedConfig.labels || [], context);
    const assignees &#x3D; this.getAssignees(epic, resolvedConfig.assignees);

    return {
      title,
      body,
      labels,
      assignees,
    };
  }

  /**
   * Generate task template using configuration
   */
  generateTaskTemplate(
    task: Task,
    epic: Epic,
    options: GitHubTemplateOptions &#x3D; {}
  ): GeneratedTemplate {
    const templateConfig &#x3D; this.config.task || DEFAULT_TEMPLATES_CONFIG.task!;
    const resolvedConfig &#x3D; this.resolveTemplateConfig(templateConfig);

    // Validate task data
    this.validateData(task, resolvedConfig.validation);

    // Generate template content
    const context &#x3D; this.createTemplateContext({ ...task, epic }, options);
    const title &#x3D; this.renderTemplate(resolvedConfig.title || &amp;#39;{{name}}&amp;#39;, context);
    const body &#x3D; this.generateTemplateBody(resolvedConfig.sections, context);
    const labels &#x3D; this.renderLabels(resolvedConfig.labels || [], context);
    const assignees &#x3D; this.getAssignees(task, resolvedConfig.assignees);

    return {
      title,
      body,
      labels,
      assignees,
    };
  }

  /**
   * Generate repository template files
   */
  generateRepositoryTemplates(): TemplateFiles {
    const files: TemplateFiles &#x3D; {};

    // Generate issue templates
    files[&amp;#39;.github/ISSUE_TEMPLATE/epic.md&amp;#39;] &#x3D; this.generateIssueTemplateFile(
      this.config.epic || DEFAULT_TEMPLATES_CONFIG.epic!,
      &amp;#39;epic&amp;#39;
    );

    files[&amp;#39;.github/ISSUE_TEMPLATE/task.md&amp;#39;] &#x3D; this.generateIssueTemplateFile(
      this.config.task || DEFAULT_TEMPLATES_CONFIG.task!,
      &amp;#39;task&amp;#39;
    );

    files[&amp;#39;.github/ISSUE_TEMPLATE/bug_report.md&amp;#39;] &#x3D; this.generateIssueTemplateFile(
      this.config.bugReport || DEFAULT_TEMPLATES_CONFIG.bugReport!,
      &amp;#39;bug&amp;#39;
    );

    files[&amp;#39;.github/ISSUE_TEMPLATE/feature_request.md&amp;#39;] &#x3D; this.generateIssueTemplateFile(
      this.config.featureRequest || DEFAULT_TEMPLATES_CONFIG.featureRequest!,
      &amp;#39;feature&amp;#39;
    );

    // Generate configuration files
    if (this.config.repositoryConfig?.issueConfig) {
      files[&amp;#39;.github/config.yml&amp;#39;] &#x3D; this.generateConfigFile();
    }

    if (this.config.repositoryConfig?.labels) {
      files[&amp;#39;.github/labels.yml&amp;#39;] &#x3D; this.generateLabelsFile();
    }

    return files;
  }

  /**
   * Resolve template configuration with inheritance
   */
  private resolveTemplateConfig(
    config: GitHubTemplateConfig | GitHubFileTemplateRef
  ): GitHubTemplateConfig {
    const normalizedConfig &#x3D; this.ensureTemplateConfig(config);

    if (!normalizedConfig.inherits) {
      return normalizedConfig;
    }

    const baseTemplate &#x3D; this.baseTemplates.get(normalizedConfig.inherits);
    if (!baseTemplate) {
      throw new Error(&#x60;Base template &amp;quot;${normalizedConfig.inherits}&amp;quot; not found&#x60;);
    }

    // Merge base template with current config
    return {
      ...baseTemplate,
      ...normalizedConfig,
      sections: {
        ...baseTemplate.sections,
        ...normalizedConfig.sections,
        additional: {
          ...baseTemplate.sections.additional,
          ...normalizedConfig.sections?.additional,
        },
      },
      labels: [...(baseTemplate.labels || []), ...(normalizedConfig.labels || [])],
      validation: {
        fields: [
          ...(baseTemplate.validation?.fields || []),
          ...(normalizedConfig.validation?.fields || []),
        ],
        custom: [
          ...(baseTemplate.validation?.custom || []),
          ...(normalizedConfig.validation?.custom || []),
        ],
      },
    };
  }

  /**
   * Create template context from data
   */
  private createTemplateContext(data: any, options: GitHubTemplateOptions): Record&amp;lt;string, any&amp;gt; {
    return {
      ...data,
      ...options.customFields,
      // Helper functions for templates
      helpers: {
        capitalize: (str: string) &#x3D;&amp;gt; str.charAt(0).toUpperCase() + str.slice(1),
        formatDate: (date: string) &#x3D;&amp;gt; new Date(date).toLocaleDateString(),
        statusEmoji: (status: string) &#x3D;&amp;gt; this.getStatusEmoji(status),
      },
    };
  }

  /**
   * Render template string with context
   */
  private renderTemplate(template: string, context: Record&amp;lt;string, any&amp;gt;): string {
    let result &#x3D; template;

    // Simple template rendering (replace {{variable}} with context values)
    result &#x3D; result.replace(/\{\{(\w+)\}\}/g, (match, key) &#x3D;&amp;gt; {
      const value &#x3D; this.getNestedValue(context, key);
      return value !&#x3D;&#x3D; undefined ? String(value) : match;
    });

    // Handle conditional blocks {{#if condition}}...{{/if}}
    result &#x3D; result.replace(
      /\{\{#if\s+(\w+)\}\}(.*?)\{\{\/if\}\}/gs,
      (match, condition, content) &#x3D;&amp;gt; {
        const value &#x3D; this.getNestedValue(context, condition);
        return value ? content : &amp;#39;&amp;#39;;
      }
    );

    // Handle each blocks {{#each array}}...{{/each}}
    result &#x3D; result.replace(
      /\{\{#each\s+(\w+)\}\}(.*?)\{\{\/each\}\}/gs,
      (match, arrayKey, content) &#x3D;&amp;gt; {
        const array &#x3D; this.getNestedValue(context, arrayKey);
        if (!Array.isArray(array)) return &amp;#39;&amp;#39;;

        return array
          .map((item, index) &#x3D;&amp;gt; {
            let itemContent &#x3D; content;
            itemContent &#x3D; itemContent.replace(/\{\{this\}\}/g, String(item));
            itemContent &#x3D; itemContent.replace(/\{\{@index\}\}/g, String(index + 1));
            return itemContent;
          })
          .join(&amp;#39;&amp;#39;);
      }
    );

    return result.trim();
  }

  /**
   * Get nested value from context
   */
  private getNestedValue(obj: any, path: string): any {
    return path.split(&amp;#39;.&amp;#39;).reduce((current, key) &#x3D;&amp;gt; current?.[key], obj);
  }

  /**
   * Generate template body from sections
   */
  private generateTemplateBody(
    sections: Partial&amp;lt;GitHubTemplateSections&amp;gt; | undefined,
    context: Record&amp;lt;string, any&amp;gt;
  ): string {
    if (!sections) return &amp;#39;&amp;#39;;

    let body &#x3D; &amp;#39;&amp;#39;;

    // Add description section
    if (sections.description) {
      body +&#x3D; this.renderTemplate(sections.description, context);
    }

    // Add details table
    if (sections.details &amp;amp;&amp;amp; sections.details.length &amp;gt; 0) {
      body +&#x3D; &amp;#39;## ğŸ“Š Details\n\n&amp;#39;;
      body +&#x3D; &amp;#39;| Field | Value |\n&amp;#39;;
      body +&#x3D; &amp;#39;|-------|-------|\n&amp;#39;;

      sections.details.forEach(field &#x3D;&amp;gt; {
        const value &#x3D; this.getNestedValue(context, field.name);
        const displayValue &#x3D; value !&#x3D;&#x3D; undefined ? String(value) : field.default || &amp;#39;Not specified&amp;#39;;
        body +&#x3D; &#x60;| **${field.label}** | \&#x60;${displayValue}\&#x60; |\n&#x60;;
      });

      body +&#x3D; &amp;#39;\n&amp;#39;;
    }

    // Add acceptance criteria section
    if (sections.acceptanceCriteria) {
      body +&#x3D; this.renderTemplate(sections.acceptanceCriteria, context);
    }

    // Add dependencies section
    if (sections.dependencies) {
      body +&#x3D; this.renderTemplate(sections.dependencies, context);
    }

    // Add additional sections
    if (sections.additional) {
      Object.entries(sections.additional).forEach(([key, template]) &#x3D;&amp;gt; {
        body +&#x3D; this.renderTemplate(template, context);
      });
    }

    return body;
  }

  /**
   * Render labels with context
   */
  private renderLabels(labelTemplates: string[], context: Record&amp;lt;string, any&amp;gt;): string[] {
    return labelTemplates
      .map(template &#x3D;&amp;gt; this.renderTemplate(template, context))
      .filter(label &#x3D;&amp;gt; label.length &amp;gt; 0);
  }

  /**
   * Get assignees for template
   */
  private getAssignees(data: any, configAssignees?: string[]): string[] | undefined {
    const assignees: string[] &#x3D; [];

    if (data.assignee) {
      assignees.push(data.assignee);
    }

    if (data.owner &amp;amp;&amp;amp; data.owner !&#x3D;&#x3D; data.assignee) {
      assignees.push(data.owner);
    }

    if (configAssignees) {
      assignees.push(...configAssignees);
    }

    return assignees.length &amp;gt; 0 ? [...new Set(assignees)] : undefined;
  }

  /**
   * Validate data against template validation rules
   */
  private validateData(data: any, validation?: GitHubTemplateConfig[&amp;#39;validation&amp;#39;]): void {
    if (!validation?.fields) return;

    const errors: string[] &#x3D; [];

    validation.fields.forEach(rule &#x3D;&amp;gt; {
      const value &#x3D; this.getNestedValue(data, rule.field);

      if (rule.required &amp;amp;&amp;amp; (!value || (Array.isArray(value) &amp;amp;&amp;amp; value.length &#x3D;&#x3D;&#x3D; 0))) {
        errors.push(rule.errorMessage || &#x60;${rule.field} is required&#x60;);
        return;
      }

      if (value) {
        if (rule.minLength &amp;amp;&amp;amp; String(value).length &amp;lt; rule.minLength) {
          errors.push(
            rule.errorMessage || &#x60;${rule.field} must be at least ${rule.minLength} characters&#x60;
          );
        }

        if (rule.maxLength &amp;amp;&amp;amp; String(value).length &amp;gt; rule.maxLength) {
          errors.push(
            rule.errorMessage || &#x60;${rule.field} must be at most ${rule.maxLength} characters&#x60;
          );
        }

        if (rule.pattern &amp;amp;&amp;amp; !new RegExp(rule.pattern).test(String(value))) {
          errors.push(rule.errorMessage || &#x60;${rule.field} does not match required pattern&#x60;);
        }

        if (rule.enum &amp;amp;&amp;amp; !rule.enum.includes(String(value))) {
          errors.push(rule.errorMessage || &#x60;${rule.field} must be one of: ${rule.enum.join(&amp;#39;, &amp;#39;)}&#x60;);
        }
      }
    });

    if (errors.length &amp;gt; 0) {
      throw new Error(&#x60;Template validation failed:\n${errors.map(e &#x3D;&amp;gt; &#x60;  â€¢ ${e}&#x60;).join(&amp;#39;\n&amp;#39;)}&#x60;);
    }
  }

  /**
   * Generate issue template file
   */
  private generateIssueTemplateFile(
    config: GitHubTemplateConfig | GitHubFileTemplateRef,
    type: string
  ): string {
    const resolvedConfig &#x3D; this.resolveTemplateConfig(config);

    let template &#x3D; &amp;#39;---\n&amp;#39;;
    template +&#x3D; &#x60;name: ${resolvedConfig.name || type}\n&#x60;;
    template +&#x3D; &#x60;about: Create a new ${resolvedConfig.name || type}\n&#x60;;
    template +&#x3D; &#x60;title: &amp;#39;${resolvedConfig.title?.replace(/\{\{.*?\}\}/g, &amp;#39;&amp;#39;)}&amp;#39;\n&#x60;;
    template +&#x3D; &#x60;labels: &amp;#39;${(resolvedConfig.labels || []).join(&amp;#39;,&amp;#39;).replace(/\{\{.*?\}\}/g, &amp;#39;&amp;#39;)}&amp;#39;\n&#x60;;
    template +&#x3D; &#x60;assignees: &amp;#39;${(resolvedConfig.assignees || []).join(&amp;#39;,&amp;#39;)}&amp;#39;\n&#x60;;
    template +&#x3D; &amp;#39;---\n\n&amp;#39;;

    // Add template body structure
    template +&#x3D; &amp;#39;&amp;lt;!-- DO NOT EDIT: Arbiter ID will be filled automatically --&amp;gt;\n&amp;#39;;
    template +&#x3D; &amp;#39;&amp;lt;!-- arbiter-id:  --&amp;gt;\n&amp;#39;;
    template +&#x3D; &#x60;&amp;lt;!-- arbiter-type: ${type} --&amp;gt;\n\n&#x60;;

    // Add template sections as placeholders
    if (resolvedConfig.sections) {
      template +&#x3D; this.generateTemplateBody(resolvedConfig.sections, {});
    }

    return template;
  }

  /**
   * Generate config.yml file
   */
  private generateConfigFile(): string {
    const config &#x3D; this.config.repositoryConfig?.issueConfig;
    if (!config) return &amp;#39;&amp;#39;;

    let content &#x3D; &amp;#39;# Configuration for GitHub features\n\n&amp;#39;;
    content +&#x3D; &#x60;blank_issues_enabled: ${config.blankIssuesEnabled || false}\n&#x60;;

    if (config.contactLinks) {
      content +&#x3D; &amp;#39;contact_links:\n&amp;#39;;
      config.contactLinks.forEach(link &#x3D;&amp;gt; {
        content +&#x3D; &#x60;  - name: ${link.name}\n&#x60;;
        content +&#x3D; &#x60;    url: ${link.url}\n&#x60;;
        content +&#x3D; &#x60;    about: ${link.about}\n&#x60;;
      });
    }

    return content;
  }

  /**
   * Generate labels.yml file
   */
  private generateLabelsFile(): string {
    const labels &#x3D; this.config.repositoryConfig?.labels;
    if (!labels) return &amp;#39;&amp;#39;;

    let content &#x3D; &amp;#39;# GitHub Labels for Arbiter-managed projects\n\n&amp;#39;;

    labels.forEach(label &#x3D;&amp;gt; {
      content +&#x3D; &#x60;- name: &amp;#39;${label.name}&amp;#39;\n&#x60;;
      content +&#x3D; &#x60;  color: &amp;#39;${label.color}&amp;#39;\n&#x60;;
      if (label.description) {
        content +&#x3D; &#x60;  description: &amp;#39;${label.description}&amp;#39;\n&#x60;;
      }
    });

    return content;
  }

  /**
   * Get status emoji for display
   */
  private getStatusEmoji(status: string): string {
    const emojis: Record&amp;lt;string, string&amp;gt; &#x3D; {
      todo: &amp;#39;ğŸ“‹&amp;#39;,
      planning: &amp;#39;ğŸ“‹&amp;#39;,
      in_progress: &amp;#39;ğŸš§&amp;#39;,
      review: &amp;#39;ğŸ‘€&amp;#39;,
      testing: &amp;#39;ğŸ§ª&amp;#39;,
      completed: &amp;#39;âœ…&amp;#39;,
      cancelled: &amp;#39;âŒ&amp;#39;,
    };
    return emojis[status] || &amp;#39;â“&amp;#39;;
  }

  /**
   * Get available templates
   */
  getAvailableTemplates(): Array&amp;lt;{ name: string; type: string; description?: string }&amp;gt; {
    const templates &#x3D; [];

    if (this.config.epic) {
      const meta &#x3D; this.extractTemplateMetadata(this.config.epic);
      templates.push({
        name: meta.name || &amp;#39;epic&amp;#39;,
        type: &amp;#39;epic&amp;#39;,
        description: meta.description,
      });
    }

    if (this.config.task) {
      const meta &#x3D; this.extractTemplateMetadata(this.config.task);
      templates.push({
        name: meta.name || &amp;#39;task&amp;#39;,
        type: &amp;#39;task&amp;#39;,
        description: meta.description,
      });
    }

    if (this.config.bugReport) {
      const meta &#x3D; this.extractTemplateMetadata(this.config.bugReport);
      templates.push({
        name: meta.name || &amp;#39;bug_report&amp;#39;,
        type: &amp;#39;bug&amp;#39;,
        description: meta.description,
      });
    }

    if (this.config.featureRequest) {
      const meta &#x3D; this.extractTemplateMetadata(this.config.featureRequest);
      templates.push({
        name: meta.name || &amp;#39;feature_request&amp;#39;,
        type: &amp;#39;feature&amp;#39;,
        description: meta.description,
      });
    }

    return templates;
  }

  /**
   * Validate template configuration
   */
  validateTemplateConfig(): Array&amp;lt;{ field: string; message: string }&amp;gt; {
    const errors: Array&amp;lt;{ field: string; message: string }&amp;gt; &#x3D; [];

    // Validate base template references
    const templateConfigs &#x3D; [
      { name: &amp;#39;epic&amp;#39;, config: this.config.epic },
      { name: &amp;#39;task&amp;#39;, config: this.config.task },
      { name: &amp;#39;bugReport&amp;#39;, config: this.config.bugReport },
      { name: &amp;#39;featureRequest&amp;#39;, config: this.config.featureRequest },
    ];

    templateConfigs.forEach(({ name, config }) &#x3D;&amp;gt; {
      if (config?.inherits &amp;amp;&amp;amp; !this.baseTemplates.has(config.inherits)) {
        errors.push({
          field: &#x60;${name}.inherits&#x60;,
          message: &#x60;Base template &amp;quot;${config.inherits}&amp;quot; not found&#x60;,
        });
      }
    });

    return errors;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-18">
                <div class="file-header">ğŸ“„ packages/cli/src/language-plugins/rust.ts</div>
                <div class="file-content">
                    <pre>/**
 * Rust Language Plugin - Axum + SQLx + Modern Rust Patterns
 * Supports: Rust 1.70+, Axum, SQLx, Tokio, Serde, modern async patterns
 */

import type {
  BuildConfig,
  ComponentConfig,
  GeneratedFile,
  GenerationResult,
  LanguagePlugin,
  ProjectConfig,
  ServiceConfig,
} from &amp;#39;./index.js&amp;#39;;

export class RustPlugin implements LanguagePlugin {
  readonly name &#x3D; &amp;#39;Rust Plugin&amp;#39;;
  readonly language &#x3D; &amp;#39;rust&amp;#39;;
  readonly version &#x3D; &amp;#39;1.0.0&amp;#39;;
  readonly description &#x3D; &amp;#39;Modern Rust with Axum, SQLx, and zero-cost abstractions&amp;#39;;
  readonly supportedFeatures &#x3D; [
    &amp;#39;web-server&amp;#39;,
    &amp;#39;api&amp;#39;,
    &amp;#39;database&amp;#39;,
    &amp;#39;async-runtime&amp;#39;,
    &amp;#39;memory-safety&amp;#39;,
    &amp;#39;performance&amp;#39;,
    &amp;#39;testing&amp;#39;,
    &amp;#39;serialization&amp;#39;,
    &amp;#39;error-handling&amp;#39;,
  ];
  readonly capabilities &#x3D; {
    services: true,
    api: true,
    testing: true,
  };

  // Rust doesn&amp;#39;t have UI components like frontend frameworks
  async generateComponent(config: ComponentConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    throw new Error(&amp;#39;Component generation not supported for Rust. Use generateService instead.&amp;#39;);
  }

  async generateService(config: ServiceConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    const files: GeneratedFile[] &#x3D; [];
    const dependencies: string[] &#x3D; [];

    switch (config.type) {
      case &amp;#39;api&amp;#39;:
        files.push({
          path: &#x60;src/handlers/${config.name.toLowerCase()}.rs&#x60;,
          content: this.generateAPIHandler(config),
        });
        files.push({
          path: &#x60;src/routes/${config.name.toLowerCase()}.rs&#x60;,
          content: this.generateRoutes(config),
        });
        dependencies.push(&amp;#39;axum&amp;#39;, &amp;#39;tokio&amp;#39;, &amp;#39;serde&amp;#39;);
        break;
      case &amp;#39;service&amp;#39;:
        files.push({
          path: &#x60;src/services/${config.name.toLowerCase()}.rs&#x60;,
          content: this.generateBusinessService(config),
        });
        break;
      case &amp;#39;model&amp;#39;:
        files.push({
          path: &#x60;src/models/${config.name.toLowerCase()}.rs&#x60;,
          content: this.generateModel(config),
        });
        dependencies.push(&amp;#39;sqlx&amp;#39;, &amp;#39;serde&amp;#39;, &amp;#39;uuid&amp;#39;);
        break;
      case &amp;#39;middleware&amp;#39;:
        files.push({
          path: &#x60;src/middleware/${config.name.toLowerCase()}.rs&#x60;,
          content: this.generateMiddleware(config),
        });
        break;
    }

    if (config.validation) {
      dependencies.push(&amp;#39;validator&amp;#39;);
    }

    if (config.database) {
      dependencies.push(&amp;#39;sqlx&amp;#39;, &amp;#39;uuid&amp;#39;);
    }

    return { files, dependencies };
  }

  async initializeProject(config: ProjectConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    const files: GeneratedFile[] &#x3D; [];
    const dependencies &#x3D; [
      &amp;#39;axum&amp;#39;,
      &amp;#39;tokio&amp;#39;,
      &amp;#39;serde&amp;#39;,
      &amp;#39;serde_json&amp;#39;,
      &amp;#39;tracing&amp;#39;,
      &amp;#39;tracing-subscriber&amp;#39;,
      &amp;#39;tower&amp;#39;,
      &amp;#39;tower-http&amp;#39;,
    ];

    // Cargo.toml
    files.push({
      path: &amp;#39;Cargo.toml&amp;#39;,
      content: this.generateCargoToml(config),
    });

    // Main application
    files.push({
      path: &amp;#39;src/main.rs&amp;#39;,
      content: this.generateMainApp(config),
    });

    // Application state and configuration
    files.push({
      path: &amp;#39;src/config.rs&amp;#39;,
      content: this.generateConfig(config),
    });

    files.push({
      path: &amp;#39;src/app.rs&amp;#39;,
      content: this.generateAppState(config),
    });

    // Database setup (if needed)
    if (config.database) {
      files.push({
        path: &amp;#39;src/database.rs&amp;#39;,
        content: this.generateDatabase(config),
      });
      dependencies.push(&amp;#39;sqlx&amp;#39;);
    }

    // Error handling
    files.push({
      path: &amp;#39;src/errors.rs&amp;#39;,
      content: this.generateErrors(),
    });

    // Models module
    files.push({
      path: &amp;#39;src/models/mod.rs&amp;#39;,
      content: this.generateModelsModule(),
    });

    // Services module
    files.push({
      path: &amp;#39;src/services/mod.rs&amp;#39;,
      content: this.generateServicesModule(),
    });

    // Handlers module
    files.push({
      path: &amp;#39;src/handlers/mod.rs&amp;#39;,
      content: this.generateHandlersModule(),
    });

    // Routes module
    files.push({
      path: &amp;#39;src/routes/mod.rs&amp;#39;,
      content: this.generateRoutesModule(config),
    });

    // Middleware module
    files.push({
      path: &amp;#39;src/middleware/mod.rs&amp;#39;,
      content: this.generateMiddlewareModule(),
    });

    // Health check
    files.push({
      path: &amp;#39;src/handlers/health.rs&amp;#39;,
      content: this.generateHealthHandler(),
    });

    // Library file
    files.push({
      path: &amp;#39;src/lib.rs&amp;#39;,
      content: this.generateLibFile(config),
    });

    // Environment file
    files.push({
      path: &amp;#39;.env.example&amp;#39;,
      content: this.generateEnvExample(config),
    });

    // Testing setup (if requested)
    if (config.testing) {
      files.push({
        path: &amp;#39;src/tests/mod.rs&amp;#39;,
        content: this.generateTestModule(),
      });
      files.push({
        path: &amp;#39;src/tests/integration.rs&amp;#39;,
        content: this.generateIntegrationTests(config),
      });
    }

    // Docker setup (if requested)
    if (config.docker) {
      files.push({
        path: &amp;#39;Dockerfile&amp;#39;,
        content: this.generateDockerfile(config),
      });
      files.push({
        path: &amp;#39;docker-compose.yml&amp;#39;,
        content: this.generateDockerCompose(config),
      });
    }

    // Justfile for common tasks
    files.push({
      path: &amp;#39;justfile&amp;#39;,
      content: this.generateJustfile(config),
    });

    return {
      files,
      dependencies,
      scripts: {
        dev: &amp;#39;cargo watch -x run&amp;#39;,
        build: &amp;#39;cargo build --release&amp;#39;,
        test: &amp;#39;cargo test&amp;#39;,
        &amp;#39;test:coverage&amp;#39;: &amp;#39;cargo tarpaulin --out html&amp;#39;,
        lint: &amp;#39;cargo clippy -- -D warnings&amp;#39;,
        format: &amp;#39;cargo fmt&amp;#39;,
        check: &amp;#39;cargo check&amp;#39;,
      },
    };
  }

  async generateBuildConfig(config: BuildConfig): Promise&amp;lt;GenerationResult&amp;gt; {
    const files: GeneratedFile[] &#x3D; [];

    // Production dockerfile
    if (config.target &#x3D;&#x3D;&#x3D; &amp;#39;production&amp;#39;) {
      files.push({
        path: &amp;#39;Dockerfile.prod&amp;#39;,
        content: this.generateProductionDockerfile(config),
      });
    }

    // CI/CD configuration
    files.push({
      path: &amp;#39;.github/workflows/rust.yml&amp;#39;,
      content: this.generateGitHubActions(config),
    });

    // Cargo configuration
    files.push({
      path: &amp;#39;.cargo/config.toml&amp;#39;,
      content: this.generateCargoConfig(config),
    });

    return { files };
  }

  private generateAPIHandler(config: ServiceConfig): string {
    const structName &#x3D; this.toPascalCase(config.name);
    const moduleName &#x3D; config.name.toLowerCase();

    return &#x60;use axum::{
    extract::{Path, Query, State},
    response::Json,
    http::StatusCode,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use tracing::{info, error};

use crate::{
    app::AppState,
    errors::AppError,
    models::${moduleName}::{${structName}, Create${structName}Request, Update${structName}Request},
    services::${moduleName}::${structName}Service,
};

#[derive(Debug, Deserialize)]
pub struct QueryParams {
    pub page: Option&amp;lt;u32&amp;gt;,
    pub limit: Option&amp;lt;u32&amp;gt;,
}

#[derive(Debug, Serialize)]
pub struct ${structName}Response {
    pub data: Vec&amp;lt;${structName}&amp;gt;,
    pub total: u64,
    pub page: u32,
    pub limit: u32,
}

/// Get all ${config.name} items
pub async fn get_all_${moduleName}(
    State(app_state): State&amp;lt;AppState&amp;gt;,
    Query(params): Query&amp;lt;QueryParams&amp;gt;,
) -&amp;gt; Result&amp;lt;Json&amp;lt;${structName}Response&amp;gt;, AppError&amp;gt; {
    info!(&amp;quot;Fetching all ${config.name} items&amp;quot;);
    
    let page &#x3D; params.page.unwrap_or(1);
    let limit &#x3D; params.limit.unwrap_or(20);
    
    let service &#x3D; ${structName}Service::new(${config.database ? &amp;#39;&amp;amp;app_state.db_pool&amp;#39; : &amp;#39;&amp;#39;});
    
    let (items, total) &#x3D; service.get_all(page, limit).await?;
    
    let response &#x3D; ${structName}Response {
        data: items,
        total,
        page,
        limit,
    };
    
    Ok(Json(response))
}

/// Get ${config.name} by ID
pub async fn get_${moduleName}_by_id(
    State(app_state): State&amp;lt;AppState&amp;gt;,
    Path(id): Path&amp;lt;Uuid&amp;gt;,
) -&amp;gt; Result&amp;lt;Json&amp;lt;${structName}&amp;gt;, AppError&amp;gt; {
    info!(&amp;quot;Fetching ${config.name} with ID: {}&amp;quot;, id);
    
    let service &#x3D; ${structName}Service::new(${config.database ? &amp;#39;&amp;amp;app_state.db_pool&amp;#39; : &amp;#39;&amp;#39;});
    let item &#x3D; service.get_by_id(id).await?;
    
    Ok(Json(item))
}

/// Create new ${config.name}
pub async fn create_${moduleName}(
    State(app_state): State&amp;lt;AppState&amp;gt;,
    Json(payload): Json&amp;lt;Create${structName}Request&amp;gt;,
) -&amp;gt; Result&amp;lt;(StatusCode, Json&amp;lt;${structName}&amp;gt;), AppError&amp;gt; {
    info!(&amp;quot;Creating new ${config.name}&amp;quot;);
    
    // Validate payload if validation is enabled
    ${config.validation ? &amp;#39;payload.validate()?;&amp;#39; : &amp;#39;&amp;#39;}
    
    let service &#x3D; ${structName}Service::new(${config.database ? &amp;#39;&amp;amp;app_state.db_pool&amp;#39; : &amp;#39;&amp;#39;});
    let item &#x3D; service.create(payload).await?;
    
    Ok((StatusCode::CREATED, Json(item)))
}

/// Update ${config.name}
pub async fn update_${moduleName}(
    State(app_state): State&amp;lt;AppState&amp;gt;,
    Path(id): Path&amp;lt;Uuid&amp;gt;,
    Json(payload): Json&amp;lt;Update${structName}Request&amp;gt;,
) -&amp;gt; Result&amp;lt;Json&amp;lt;${structName}&amp;gt;, AppError&amp;gt; {
    info!(&amp;quot;Updating ${config.name} with ID: {}&amp;quot;, id);
    
    // Validate payload if validation is enabled
    ${config.validation ? &amp;#39;payload.validate()?;&amp;#39; : &amp;#39;&amp;#39;}
    
    let service &#x3D; ${structName}Service::new(${config.database ? &amp;#39;&amp;amp;app_state.db_pool&amp;#39; : &amp;#39;&amp;#39;});
    let item &#x3D; service.update(id, payload).await?;
    
    Ok(Json(item))
}

/// Delete ${config.name}
pub async fn delete_${moduleName}(
    State(app_state): State&amp;lt;AppState&amp;gt;,
    Path(id): Path&amp;lt;Uuid&amp;gt;,
) -&amp;gt; Result&amp;lt;StatusCode, AppError&amp;gt; {
    info!(&amp;quot;Deleting ${config.name} with ID: {}&amp;quot;, id);
    
    let service &#x3D; ${structName}Service::new(${config.database ? &amp;#39;&amp;amp;app_state.db_pool&amp;#39; : &amp;#39;&amp;#39;});
    service.delete(id).await?;
    
    Ok(StatusCode::NO_CONTENT)
}
&#x60;;
  }

  private generateRoutes(config: ServiceConfig): string {
    const moduleName &#x3D; config.name.toLowerCase();

    return &#x60;use axum::{
    routing::{get, post, put, delete},
    Router,
};

use crate::{
    app::AppState,
    handlers::${moduleName}::{
        get_all_${moduleName},
        get_${moduleName}_by_id,
        create_${moduleName},
        update_${moduleName},
        delete_${moduleName},
    },
};

/// Create ${config.name} routes
pub fn create_${moduleName}_routes() -&amp;gt; Router&amp;lt;AppState&amp;gt; {
    Router::new()
        .route(&amp;quot;/&amp;quot;, get(get_all_${moduleName}).post(create_${moduleName}))
        .route(&amp;quot;/:id&amp;quot;, get(get_${moduleName}_by_id).put(update_${moduleName}).delete(delete_${moduleName}))
}
&#x60;;
  }

  private generateBusinessService(config: ServiceConfig): string {
    const structName &#x3D; this.toPascalCase(config.name);
    const moduleName &#x3D; config.name.toLowerCase();

    return &#x60;use uuid::Uuid;
use tracing::{info, error};
${config.database ? &amp;#39;use sqlx::{PgPool, Row};&amp;#39; : &amp;#39;&amp;#39;}

use crate::{
    errors::AppError,
    models::${moduleName}::{${structName}, Create${structName}Request, Update${structName}Request},
};

/// Service for ${config.name} business logic
pub struct ${structName}Service${config.database ? &amp;quot;&amp;lt;&amp;#39;a&amp;gt;&amp;quot; : &amp;#39;&amp;#39;} {
    ${config.database ? &amp;quot;db_pool: &amp;amp;&amp;#39;a PgPool,&amp;quot; : &amp;#39;&amp;#39;}
}

impl${config.database ? &amp;quot;&amp;lt;&amp;#39;a&amp;gt;&amp;quot; : &amp;#39;&amp;#39;} ${structName}Service${config.database ? &amp;quot;&amp;lt;&amp;#39;a&amp;gt;&amp;quot; : &amp;#39;&amp;#39;} {
    /// Create a new service instance
    pub fn new(${config.database ? &amp;quot;db_pool: &amp;amp;&amp;#39;a PgPool&amp;quot; : &amp;#39;&amp;#39;}) -&amp;gt; Self {
        Self {
            ${config.database ? &amp;#39;db_pool,&amp;#39; : &amp;#39;&amp;#39;}
        }
    }

    /// Get all ${config.name} items with pagination
    pub async fn get_all(&amp;amp;self, page: u32, limit: u32) -&amp;gt; Result&amp;lt;(Vec&amp;lt;${structName}&amp;gt;, u64), AppError&amp;gt; {
        info!(&amp;quot;Fetching all ${config.name} items (page: {}, limit: {})&amp;quot;, page, limit);
        
        ${
          config.database
            ? &#x60;
        let offset &#x3D; (page - 1) * limit;
        
        // Get total count
        let count_row &#x3D; sqlx::query!(
            &amp;quot;SELECT COUNT(*) as count FROM ${moduleName}s WHERE deleted_at IS NULL&amp;quot;
        )
        .fetch_one(self.db_pool)
        .await
        .map_err(|e| {
            error!(&amp;quot;Failed to count ${config.name} items: {}&amp;quot;, e);
            AppError::DatabaseError(e.to_string())
        })?;

        let total &#x3D; count_row.count.unwrap_or(0) as u64;

        // Get paginated items
        let items &#x3D; sqlx::query_as!(
            ${structName},
            &amp;quot;SELECT id, name, description, is_active, created_at, updated_at 
             FROM ${moduleName}s 
             WHERE deleted_at IS NULL 
             ORDER BY created_at DESC 
             LIMIT $1 OFFSET $2&amp;quot;,
            limit as i32,
            offset as i32
        )
        .fetch_all(self.db_pool)
        .await
        .map_err(|e| {
            error!(&amp;quot;Failed to fetch ${config.name} items: {}&amp;quot;, e);
            AppError::DatabaseError(e.to_string())
        })?;

        Ok((items, total))
        &#x60;
            : &#x60;
        // Placeholder implementation without database
        let items &#x3D; vec![];
        let total &#x3D; 0;
        Ok((items, total))
        &#x60;
        }
    }

    /// Get ${config.name} by ID
    pub async fn get_by_id(&amp;amp;self, id: Uuid) -&amp;gt; Result&amp;lt;${structName}, AppError&amp;gt; {
        info!(&amp;quot;Fetching ${config.name} with ID: {}&amp;quot;, id);
        
        ${
          config.database
            ? &#x60;
        let item &#x3D; sqlx::query_as!(
            ${structName},
            &amp;quot;SELECT id, name, description, is_active, created_at, updated_at 
             FROM ${moduleName}s 
             WHERE id &#x3D; $1 AND deleted_at IS NULL&amp;quot;,
            id
        )
        .fetch_optional(self.db_pool)
        .await
        .map_err(|e| {
            error!(&amp;quot;Failed to fetch ${config.name} {}: {}&amp;quot;, id, e);
            AppError::DatabaseError(e.to_string())
        })?
        .ok_or_else(|| {
            error!(&amp;quot;${config.name} not found: {}&amp;quot;, id);
            AppError::NotFound(format!(&amp;quot;${config.name} with ID {} not found&amp;quot;, id))
        })?;

        Ok(item)
        &#x60;
            : &#x60;
        // Placeholder implementation without database
        Err(AppError::NotFound(format!(&amp;quot;${config.name} with ID {} not found&amp;quot;, id)))
        &#x60;
        }
    }

    /// Create new ${config.name}
    pub async fn create(&amp;amp;self, request: Create${structName}Request) -&amp;gt; Result&amp;lt;${structName}, AppError&amp;gt; {
        info!(&amp;quot;Creating new ${config.name}&amp;quot;);
        
        ${
          config.database
            ? &#x60;
        let id &#x3D; Uuid::new_v4();
        let now &#x3D; chrono::Utc::now();

        let item &#x3D; sqlx::query_as!(
            ${structName},
            &amp;quot;INSERT INTO ${moduleName}s (id, name, description, is_active, created_at, updated_at)
             VALUES ($1, $2, $3, true, $4, $4)
             RETURNING id, name, description, is_active, created_at, updated_at&amp;quot;,
            id,
            request.name,
            request.description,
            now,
        )
        .fetch_one(self.db_pool)
        .await
        .map_err(|e| {
            error!(&amp;quot;Failed to create ${config.name}: {}&amp;quot;, e);
            AppError::DatabaseError(e.to_string())
        })?;

        Ok(item)
        &#x60;
            : &#x60;
        // Placeholder implementation without database
        let item &#x3D; ${structName} {
            id: Uuid::new_v4(),
            name: request.name,
            description: request.description,
            is_active: true,
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
        };
        Ok(item)
        &#x60;
        }
    }

    /// Update ${config.name}
    pub async fn update(&amp;amp;self, id: Uuid, request: Update${structName}Request) -&amp;gt; Result&amp;lt;${structName}, AppError&amp;gt; {
        info!(&amp;quot;Updating ${config.name} with ID: {}&amp;quot;, id);
        
        ${
          config.database
            ? &#x60;
        let now &#x3D; chrono::Utc::now();

        let item &#x3D; sqlx::query_as!(
            ${structName},
            &amp;quot;UPDATE ${moduleName}s 
             SET name &#x3D; COALESCE($2, name),
                 description &#x3D; COALESCE($3, description),
                 is_active &#x3D; COALESCE($4, is_active),
                 updated_at &#x3D; $5
             WHERE id &#x3D; $1 AND deleted_at IS NULL
             RETURNING id, name, description, is_active, created_at, updated_at&amp;quot;,
            id,
            request.name,
            request.description,
            request.is_active,
            now,
        )
        .fetch_optional(self.db_pool)
        .await
        .map_err(|e| {
            error!(&amp;quot;Failed to update ${config.name} {}: {}&amp;quot;, id, e);
            AppError::DatabaseError(e.to_string())
        })?
        .ok_or_else(|| {
            error!(&amp;quot;${config.name} not found for update: {}&amp;quot;, id);
            AppError::NotFound(format!(&amp;quot;${config.name} with ID {} not found&amp;quot;, id))
        })?;

        Ok(item)
        &#x60;
            : &#x60;
        // Placeholder implementation without database
        Err(AppError::NotFound(format!(&amp;quot;${config.name} with ID {} not found&amp;quot;, id)))
        &#x60;
        }
    }

    /// Delete ${config.name} (soft delete)
    pub async fn delete(&amp;amp;self, id: Uuid) -&amp;gt; Result&amp;lt;(), AppError&amp;gt; {
        info!(&amp;quot;Deleting ${config.name} with ID: {}&amp;quot;, id);
        
        ${
          config.database
            ? &#x60;
        let now &#x3D; chrono::Utc::now();

        let result &#x3D; sqlx::query!(
            &amp;quot;UPDATE ${moduleName}s SET deleted_at &#x3D; $1 WHERE id &#x3D; $2 AND deleted_at IS NULL&amp;quot;,
            now,
            id
        )
        .execute(self.db_pool)
        .await
        .map_err(|e| {
            error!(&amp;quot;Failed to delete ${config.name} {}: {}&amp;quot;, id, e);
            AppError::DatabaseError(e.to_string())
        })?;

        if result.rows_affected() &#x3D;&#x3D; 0 {
            error!(&amp;quot;${config.name} not found for deletion: {}&amp;quot;, id);
            return Err(AppError::NotFound(format!(&amp;quot;${config.name} with ID {} not found&amp;quot;, id)));
        }

        Ok(())
        &#x60;
            : &#x60;
        // Placeholder implementation without database
        Err(AppError::NotFound(format!(&amp;quot;${config.name} with ID {} not found&amp;quot;, id)))
        &#x60;
        }
    }
}
&#x60;;
  }

  private generateModel(config: ServiceConfig): string {
    const structName &#x3D; this.toPascalCase(config.name);

    return &#x60;use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};
${config.validation ? &amp;#39;use validator::Validate;&amp;#39; : &amp;#39;&amp;#39;}

/// ${structName} model
#[derive(Debug, Clone, Serialize, Deserialize)]
${config.database ? &amp;#39;#[derive(sqlx::FromRow)]&amp;#39; : &amp;#39;&amp;#39;}
pub struct ${structName} {
    pub id: Uuid,
    pub name: String,
    pub description: Option&amp;lt;String&amp;gt;,
    pub is_active: bool,
    pub created_at: DateTime&amp;lt;Utc&amp;gt;,
    pub updated_at: DateTime&amp;lt;Utc&amp;gt;,
}

/// Request payload for creating a ${structName}
#[derive(Debug, Deserialize${config.validation ? &amp;#39;, Validate&amp;#39; : &amp;#39;&amp;#39;})]
pub struct Create${structName}Request {
    ${config.validation ? &amp;#39;#[validate(length(min &#x3D; 1, max &#x3D; 100))]&amp;#39; : &amp;#39;&amp;#39;}
    pub name: String,
    ${config.validation ? &amp;#39;#[validate(length(max &#x3D; 500))]&amp;#39; : &amp;#39;&amp;#39;}
    pub description: Option&amp;lt;String&amp;gt;,
}

/// Request payload for updating a ${structName}
#[derive(Debug, Deserialize${config.validation ? &amp;#39;, Validate&amp;#39; : &amp;#39;&amp;#39;})]
pub struct Update${structName}Request {
    ${config.validation ? &amp;#39;#[validate(length(min &#x3D; 1, max &#x3D; 100))]&amp;#39; : &amp;#39;&amp;#39;}
    pub name: Option&amp;lt;String&amp;gt;,
    ${config.validation ? &amp;#39;#[validate(length(max &#x3D; 500))]&amp;#39; : &amp;#39;&amp;#39;}
    pub description: Option&amp;lt;String&amp;gt;,
    pub is_active: Option&amp;lt;bool&amp;gt;,
}

impl ${structName} {
    /// Create a new ${structName} instance
    pub fn new(name: String, description: Option&amp;lt;String&amp;gt;) -&amp;gt; Self {
        let now &#x3D; Utc::now();
        Self {
            id: Uuid::new_v4(),
            name,
            description,
            is_active: true,
            created_at: now,
            updated_at: now,
        }
    }

    /// Check if the ${structName} is active
    pub fn is_active(&amp;amp;self) -&amp;gt; bool {
        self.is_active
    }

    /// Update the ${structName} with new data
    pub fn update(&amp;amp;mut self, request: Update${structName}Request) {
        if let Some(name) &#x3D; request.name {
            self.name &#x3D; name;
        }
        if let Some(description) &#x3D; request.description {
            self.description &#x3D; Some(description);
        }
        if let Some(is_active) &#x3D; request.is_active {
            self.is_active &#x3D; is_active;
        }
        self.updated_at &#x3D; Utc::now();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_${config.name.toLowerCase()}_creation() {
        let name &#x3D; &amp;quot;Test ${structName}&amp;quot;.to_string();
        let description &#x3D; Some(&amp;quot;Test description&amp;quot;.to_string());
        let ${config.name.toLowerCase()} &#x3D; ${structName}::new(name.clone(), description.clone());

        assert_eq!(${config.name.toLowerCase()}.name, name);
        assert_eq!(${config.name.toLowerCase()}.description, description);
        assert!(${config.name.toLowerCase()}.is_active);
        assert!(${config.name.toLowerCase()}.created_at &amp;lt;&#x3D; Utc::now());
        assert!(${config.name.toLowerCase()}.updated_at &amp;lt;&#x3D; Utc::now());
    }

    #[test]
    fn test_${config.name.toLowerCase()}_update() {
        let mut ${config.name.toLowerCase()} &#x3D; ${structName}::new(
            &amp;quot;Original Name&amp;quot;.to_string(),
            Some(&amp;quot;Original Description&amp;quot;.to_string())
        );

        let update_request &#x3D; Update${structName}Request {
            name: Some(&amp;quot;Updated Name&amp;quot;.to_string()),
            description: Some(&amp;quot;Updated Description&amp;quot;.to_string()),
            is_active: Some(false),
        };

        ${config.name.toLowerCase()}.update(update_request);

        assert_eq!(${config.name.toLowerCase()}.name, &amp;quot;Updated Name&amp;quot;);
        assert_eq!(${config.name.toLowerCase()}.description, Some(&amp;quot;Updated Description&amp;quot;.to_string()));
        assert!(!${config.name.toLowerCase()}.is_active);
    }
}
&#x60;;
  }

  private generateMiddleware(config: ServiceConfig): string {
    const middlewareName &#x3D; this.toPascalCase(config.name);

    return &#x60;use axum::{
    extract::Request,
    middleware::Next,
    response::Response,
};
use tracing::{info, warn};

/// ${middlewareName} middleware
pub async fn ${config.name.toLowerCase()}_middleware(
    request: Request,
    next: Next,
) -&amp;gt; Response {
    // Pre-processing logic
    info!(&amp;quot;${middlewareName} middleware - processing request&amp;quot;);

    // Extract request information if needed
    let method &#x3D; request.method().clone();
    let uri &#x3D; request.uri().clone();

    // Process the request
    let response &#x3D; next.run(request).await;

    // Post-processing logic
    let status &#x3D; response.status();
    info!(&amp;quot;${middlewareName} middleware - request completed: {} {} -&amp;gt; {}&amp;quot;,
          method, uri, status);

    response
}
&#x60;;
  }

  private generateCargoToml(config: ProjectConfig): string {
    type CargoDependency &#x3D; string | { version: string; features?: string[] };

    const dependencies: Record&amp;lt;string, CargoDependency&amp;gt; &#x3D; {
      axum: &amp;#39;0.7&amp;#39;,
      tokio: { version: &amp;#39;1.0&amp;#39;, features: [&amp;#39;full&amp;#39;] },
      serde: { version: &amp;#39;1.0&amp;#39;, features: [&amp;#39;derive&amp;#39;] },
      serde_json: &amp;#39;1.0&amp;#39;,
      tracing: &amp;#39;0.1&amp;#39;,
      &amp;#39;tracing-subscriber&amp;#39;: { version: &amp;#39;0.3&amp;#39;, features: [&amp;#39;env-filter&amp;#39;] },
      tower: &amp;#39;0.4&amp;#39;,
      &amp;#39;tower-http&amp;#39;: { version: &amp;#39;0.5&amp;#39;, features: [&amp;#39;cors&amp;#39;, &amp;#39;trace&amp;#39;] },
      uuid: { version: &amp;#39;1.0&amp;#39;, features: [&amp;#39;v4&amp;#39;, &amp;#39;serde&amp;#39;] },
      chrono: { version: &amp;#39;0.4&amp;#39;, features: [&amp;#39;serde&amp;#39;] },
      anyhow: &amp;#39;1.0&amp;#39;,
      thiserror: &amp;#39;1.0&amp;#39;,
    };

    if (config.database) {
      dependencies.sqlx &#x3D; {
        version: &amp;#39;0.7&amp;#39;,
        features: [&amp;#39;runtime-tokio-rustls&amp;#39;, &amp;#39;postgres&amp;#39;, &amp;#39;uuid&amp;#39;, &amp;#39;chrono&amp;#39;, &amp;#39;macros&amp;#39;],
      };
    }

    if (config.auth) {
      dependencies.jsonwebtoken &#x3D; &amp;#39;9.0&amp;#39;;
      dependencies.bcrypt &#x3D; &amp;#39;0.15&amp;#39;;
    }

    if (config.testing) {
      dependencies[&amp;#39;tokio-test&amp;#39;] &#x3D; &amp;#39;0.4&amp;#39;;
    }

    return &#x60;[package]
name &#x3D; &amp;quot;${config.name.toLowerCase().replace(/[^a-z0-9-_]/g, &amp;#39;-&amp;#39;)}&amp;quot;
version &#x3D; &amp;quot;0.1.0&amp;quot;
edition &#x3D; &amp;quot;2021&amp;quot;
description &#x3D; &amp;quot;${config.description || &#x60;Modern Rust application: ${config.name}&#x60;}&amp;quot;

[dependencies]
${Object.entries(dependencies)
  .map(([name, version]) &#x3D;&amp;gt; {
    if (typeof version &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39;) {
      return &#x60;${name} &#x3D; &amp;quot;${version}&amp;quot;&#x60;;
    }
    const versionStr &#x3D; version.version ? &#x60;version &#x3D; &amp;quot;${version.version}&amp;quot;&#x60; : &amp;#39;&amp;#39;;
    const featuresStr &#x3D; version.features
      ? &#x60;features &#x3D; [${version.features.map((f: string) &#x3D;&amp;gt; &#x60;&amp;quot;${f}&amp;quot;&#x60;).join(&amp;#39;, &amp;#39;)}]&#x60;
      : &amp;#39;&amp;#39;;
    const parts &#x3D; [versionStr, featuresStr].filter(Boolean);
    return &#x60;${name} &#x3D; { ${parts.join(&amp;#39;, &amp;#39;)} }&#x60;;
  })
  .join(&amp;#39;\n&amp;#39;)}

[dev-dependencies]
tower-test &#x3D; &amp;quot;0.4&amp;quot;
hyper &#x3D; { version &#x3D; &amp;quot;1.0&amp;quot;, features &#x3D; [&amp;quot;full&amp;quot;] }
${config.testing ? &#x60;tokio-test &#x3D; &amp;quot;0.4&amp;quot;&#x60; : &amp;#39;&amp;#39;}

[[bin]]
name &#x3D; &amp;quot;${config.name.toLowerCase()}&amp;quot;
path &#x3D; &amp;quot;src/main.rs&amp;quot;

[profile.release]
lto &#x3D; true
codegen-units &#x3D; 1
panic &#x3D; &amp;quot;abort&amp;quot;
strip &#x3D; true
&#x60;;
  }

  private generateMainApp(config: ProjectConfig): string {
    return &#x60;use std::net::SocketAddr;

use axum::Server;
use tracing::{info, error};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

use ${config.name.toLowerCase().replace(/[^a-z0-9_]/g, &amp;#39;_&amp;#39;)}::{
    app::create_app,
    config::Config,
    ${config.database ? &amp;#39;database::create_pool,&amp;#39; : &amp;#39;&amp;#39;}
};

#[tokio::main]
async fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {
    // Initialize tracing
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| &amp;quot;${config.name.toLowerCase()}&#x3D;debug,tower_http&#x3D;debug&amp;quot;.into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    info!(&amp;quot;Starting ${config.name} application&amp;quot;);

    // Load configuration
    let config &#x3D; Config::from_env()?;
    
    ${
      config.database
        ? &#x60;// Create database connection pool
    let db_pool &#x3D; create_pool(&amp;amp;config.database_url).await?;
    info!(&amp;quot;Database connection pool created&amp;quot;);

    // Run migrations
    sqlx::migrate!(&amp;quot;./migrations&amp;quot;)
        .run(&amp;amp;db_pool)
        .await
        .map_err(|e| {
            error!(&amp;quot;Failed to run migrations: {}&amp;quot;, e);
            e
        })?;
    info!(&amp;quot;Database migrations completed&amp;quot;);&#x60;
        : &amp;#39;&amp;#39;
    }

    // Create application
    let app &#x3D; create_app(${config.database ? &amp;#39;db_pool&amp;#39; : &amp;#39;&amp;#39;}).await?;

    // Setup server
    let addr &#x3D; SocketAddr::from(([0, 0, 0, 0], config.port));
    info!(&amp;quot;Server listening on {}&amp;quot;, addr);

    // Start server
    let listener &#x3D; tokio::net::TcpListener::bind(&amp;amp;addr).await?;
    axum::serve(listener, app)
        .await
        .map_err(|e| {
            error!(&amp;quot;Server error: {}&amp;quot;, e);
            e
        })?;

    Ok(())
}
&#x60;;
  }

  private generateConfig(config: ProjectConfig): string {
    return &#x60;use std::env;

/// Application configuration
#[derive(Debug, Clone)]
pub struct Config {
    pub port: u16,
    pub environment: String,
    ${config.database ? &amp;#39;pub database_url: String,&amp;#39; : &amp;#39;&amp;#39;}
    ${config.auth ? &amp;#39;pub jwt_secret: String,&amp;#39; : &amp;#39;&amp;#39;}
    pub log_level: String,
}

impl Config {
    /// Load configuration from environment variables
    pub fn from_env() -&amp;gt; Result&amp;lt;Self, Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {
        let port &#x3D; env::var(&amp;quot;PORT&amp;quot;)
            .unwrap_or_else(|_| &amp;quot;3000&amp;quot;.to_string())
            .parse::&amp;lt;u16&amp;gt;()
            .unwrap_or(3000);

        let environment &#x3D; env::var(&amp;quot;ENVIRONMENT&amp;quot;)
            .unwrap_or_else(|_| &amp;quot;development&amp;quot;.to_string());

        ${
          config.database
            ? &#x60;let database_url &#x3D; env::var(&amp;quot;DATABASE_URL&amp;quot;)
            .unwrap_or_else(|_| &amp;quot;postgres://user:password@localhost:5432/${config.name.toLowerCase()}&amp;quot;.to_string());&#x60;
            : &amp;#39;&amp;#39;
        }

        ${
          config.auth
            ? &#x60;let jwt_secret &#x3D; env::var(&amp;quot;JWT_SECRET&amp;quot;)
            .unwrap_or_else(|_| &amp;quot;your-secret-key&amp;quot;.to_string());&#x60;
            : &amp;#39;&amp;#39;
        }

        let log_level &#x3D; env::var(&amp;quot;LOG_LEVEL&amp;quot;)
            .unwrap_or_else(|_| &amp;quot;info&amp;quot;.to_string());

        Ok(Self {
            port,
            environment,
            ${config.database ? &amp;#39;database_url,&amp;#39; : &amp;#39;&amp;#39;}
            ${config.auth ? &amp;#39;jwt_secret,&amp;#39; : &amp;#39;&amp;#39;}
            log_level,
        })
    }

    /// Check if running in production
    pub fn is_production(&amp;amp;self) -&amp;gt; bool {
        self.environment &#x3D;&#x3D; &amp;quot;production&amp;quot;
    }

    /// Check if running in development
    pub fn is_development(&amp;amp;self) -&amp;gt; bool {
        self.environment &#x3D;&#x3D; &amp;quot;development&amp;quot;
    }
}
&#x60;;
  }

  private generateAppState(config: ProjectConfig): string {
    return &#x60;use axum::{
    http::{
        header::{ACCEPT, AUTHORIZATION, CONTENT_TYPE},
        HeaderValue, Method,
    },
    Router,
};
use tower::ServiceBuilder;
use tower_http::{
    cors::CorsLayer,
    trace::TraceLayer,
};
${config.database ? &amp;#39;use sqlx::PgPool;&amp;#39; : &amp;#39;&amp;#39;}

use crate::{
    routes::create_routes,
    errors::AppError,
};

/// Application state
#[derive(Clone)]
pub struct AppState {
    ${config.database ? &amp;#39;pub db_pool: PgPool,&amp;#39; : &amp;#39;&amp;#39;}
}

impl AppState {
    /// Create new application state
    pub fn new(${config.database ? &amp;#39;db_pool: PgPool&amp;#39; : &amp;#39;&amp;#39;}) -&amp;gt; Self {
        Self {
            ${config.database ? &amp;#39;db_pool,&amp;#39; : &amp;#39;&amp;#39;}
        }
    }
}

/// Create the main application with all routes and middleware
pub async fn create_app(${config.database ? &amp;#39;db_pool: PgPool&amp;#39; : &amp;#39;&amp;#39;}) -&amp;gt; Result&amp;lt;Router, AppError&amp;gt; {
    // Create application state
    let app_state &#x3D; AppState::new(${config.database ? &amp;#39;db_pool&amp;#39; : &amp;#39;&amp;#39;});

    // Create CORS layer
    let cors &#x3D; CorsLayer::new()
        .allow_origin(&amp;quot;http://localhost:3000&amp;quot;.parse::&amp;lt;HeaderValue&amp;gt;().unwrap())
        .allow_methods([Method::GET, Method::POST, Method::PATCH, Method::DELETE])
        .allow_credentials(true)
        .allow_headers([AUTHORIZATION, ACCEPT, CONTENT_TYPE]);

    // Build the application
    let app &#x3D; Router::new()
        .merge(create_routes())
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(cors),
        )
        .with_state(app_state);

    Ok(app)
}
&#x60;;
  }

  private generateDatabase(config: ProjectConfig): string {
    if (config.database !&#x3D;&#x3D; &amp;#39;postgres&amp;#39;) {
      return &amp;#39;// Database configuration not implemented for this database type&amp;#39;;
    }

    return &#x60;use sqlx::{PgPool, postgres::PgPoolOptions};
use tracing::{info, error};

use crate::errors::AppError;

/// Create database connection pool
pub async fn create_pool(database_url: &amp;amp;str) -&amp;gt; Result&amp;lt;PgPool, AppError&amp;gt; {
    info!(&amp;quot;Creating database connection pool&amp;quot;);

    let pool &#x3D; PgPoolOptions::new()
        .max_connections(10)
        .connect(database_url)
        .await
        .map_err(|e| {
            error!(&amp;quot;Failed to create database pool: {}&amp;quot;, e);
            AppError::DatabaseError(e.to_string())
        })?;

    // Test the connection
    sqlx::query(&amp;quot;SELECT 1&amp;quot;)
        .execute(&amp;amp;pool)
        .await
        .map_err(|e| {
            error!(&amp;quot;Failed to test database connection: {}&amp;quot;, e);
            AppError::DatabaseError(e.to_string())
        })?;

    info!(&amp;quot;Database connection pool created successfully&amp;quot;);
    Ok(pool)
}
&#x60;;
  }

  private generateErrors(): string {
    return &#x60;use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;
use thiserror::Error;
${this.supportedFeatures.includes(&amp;#39;validation&amp;#39;) ? &amp;#39;use validator::ValidationErrors;&amp;#39; : &amp;#39;&amp;#39;}

/// Application error types
#[derive(Error, Debug)]
pub enum AppError {
    #[error(&amp;quot;Not found: {0}&amp;quot;)]
    NotFound(String),

    #[error(&amp;quot;Bad request: {0}&amp;quot;)]
    BadRequest(String),

    #[error(&amp;quot;Unauthorized: {0}&amp;quot;)]
    Unauthorized(String),

    #[error(&amp;quot;Forbidden: {0}&amp;quot;)]
    Forbidden(String),

    #[error(&amp;quot;Internal server error: {0}&amp;quot;)]
    InternalServerError(String),

    #[error(&amp;quot;Database error: {0}&amp;quot;)]
    DatabaseError(String),

    ${
      this.supportedFeatures.includes(&amp;#39;validation&amp;#39;)
        ? &#x60;#[error(&amp;quot;Validation error&amp;quot;)]
    ValidationError(#[from] ValidationErrors),&#x60;
        : &amp;#39;&amp;#39;
    }

    #[error(&amp;quot;Serialization error: {0}&amp;quot;)]
    SerializationError(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -&amp;gt; Response {
        let (status, error_message) &#x3D; match &amp;amp;self {
            AppError::NotFound(msg) &#x3D;&amp;gt; (StatusCode::NOT_FOUND, msg.clone()),
            AppError::BadRequest(msg) &#x3D;&amp;gt; (StatusCode::BAD_REQUEST, msg.clone()),
            AppError::Unauthorized(msg) &#x3D;&amp;gt; (StatusCode::UNAUTHORIZED, msg.clone()),
            AppError::Forbidden(msg) &#x3D;&amp;gt; (StatusCode::FORBIDDEN, msg.clone()),
            AppError::DatabaseError(_) &#x3D;&amp;gt; (
                StatusCode::INTERNAL_SERVER_ERROR,
                &amp;quot;Database error occurred&amp;quot;.to_string(),
            ),
            ${
              this.supportedFeatures.includes(&amp;#39;validation&amp;#39;)
                ? &#x60;AppError::ValidationError(errors) &#x3D;&amp;gt; (
                StatusCode::BAD_REQUEST,
                format!(&amp;quot;Validation error: {}&amp;quot;, errors),
            ),&#x60;
                : &amp;#39;&amp;#39;
            }
            AppError::SerializationError(_) &#x3D;&amp;gt; (
                StatusCode::INTERNAL_SERVER_ERROR,
                &amp;quot;Serialization error occurred&amp;quot;.to_string(),
            ),
            AppError::InternalServerError(_) &#x3D;&amp;gt; (
                StatusCode::INTERNAL_SERVER_ERROR,
                &amp;quot;Internal server error occurred&amp;quot;.to_string(),
            ),
        };

        let body &#x3D; Json(json!({
            &amp;quot;error&amp;quot;: error_message,
            &amp;quot;status&amp;quot;: status.as_u16()
        }));

        (status, body).into_response()
    }
}

// Helper function for database errors
impl From&amp;lt;sqlx::Error&amp;gt; for AppError {
    fn from(error: sqlx::Error) -&amp;gt; Self {
        match error {
            sqlx::Error::RowNotFound &#x3D;&amp;gt; AppError::NotFound(&amp;quot;Resource not found&amp;quot;.to_string()),
            _ &#x3D;&amp;gt; AppError::DatabaseError(error.to_string()),
        }
    }
}

// Helper function for serialization errors
impl From&amp;lt;serde_json::Error&amp;gt; for AppError {
    fn from(error: serde_json::Error) -&amp;gt; Self {
        AppError::SerializationError(error.to_string())
    }
}
&#x60;;
  }

  private generateModelsModule(): string {
    return &#x60;//! Data models for the application

pub mod health;

// Add your model modules here
// pub mod user;
// pub mod item;
&#x60;;
  }

  private generateServicesModule(): string {
    return &#x60;//! Business logic services

// Add your service modules here
// pub mod user;
// pub mod item;
&#x60;;
  }

  private generateHandlersModule(): string {
    return &#x60;//! HTTP request handlers

pub mod health;

// Add your handler modules here
// pub mod user;
// pub mod item;
&#x60;;
  }

  private generateRoutesModule(config: ProjectConfig): string {
    return &#x60;//! Application routes

use axum::{
    routing::get,
    Router,
};

use crate::{
    app::AppState,
    handlers::health::health_check,
};

/// Create all application routes
pub fn create_routes() -&amp;gt; Router&amp;lt;AppState&amp;gt; {
    Router::new()
        .route(&amp;quot;/health&amp;quot;, get(health_check))
        // API v1 routes
        .nest(&amp;quot;/api/v1&amp;quot;, create_api_v1_routes())
}

/// Create API v1 routes
fn create_api_v1_routes() -&amp;gt; Router&amp;lt;AppState&amp;gt; {
    Router::new()
        .route(&amp;quot;/ping&amp;quot;, get(ping))
        // Add your API routes here
        // .nest(&amp;quot;/users&amp;quot;, user_routes())
        // .nest(&amp;quot;/items&amp;quot;, item_routes())
}

/// Ping endpoint
async fn ping() -&amp;gt; &amp;amp;&amp;#39;static str {
    &amp;quot;pong&amp;quot;
}
&#x60;;
  }

  private generateMiddlewareModule(): string {
    return &#x60;//! Application middleware

// Add your middleware modules here
// pub mod auth;
// pub mod cors;
// pub mod logging;
&#x60;;
  }

  private generateHealthHandler(): string {
    return &#x60;use axum::{response::Json, http::StatusCode};
use serde_json::{json, Value};
use chrono::Utc;

/// Health check endpoint
pub async fn health_check() -&amp;gt; (StatusCode, Json&amp;lt;Value&amp;gt;) {
    let health_info &#x3D; json!({
        &amp;quot;status&amp;quot;: &amp;quot;healthy&amp;quot;,
        &amp;quot;timestamp&amp;quot;: Utc::now(),
        &amp;quot;service&amp;quot;: &amp;quot;api&amp;quot;,
        &amp;quot;version&amp;quot;: env!(&amp;quot;CARGO_PKG_VERSION&amp;quot;)
    });

    (StatusCode::OK, Json(health_info))
}

#[cfg(test)]
mod tests {
    use super::*;
    use axum_test::TestServer;
    use crate::app::create_app;

    #[tokio::test]
    async fn test_health_check() {
        let app &#x3D; create_app(/* db_pool if needed */).await.unwrap();
        let server &#x3D; TestServer::new(app).unwrap();

        let response &#x3D; server.get(&amp;quot;/health&amp;quot;).await;
        
        assert_eq!(response.status_code(), StatusCode::OK);
        
        let json: serde_json::Value &#x3D; response.json();
        assert_eq!(json[&amp;quot;status&amp;quot;], &amp;quot;healthy&amp;quot;);
        assert!(json[&amp;quot;timestamp&amp;quot;].is_string());
    }
}
&#x60;;
  }

  private generateLibFile(config: ProjectConfig): string {
    return &#x60;//! ${config.name} - ${config.description || &amp;#39;A modern Rust application&amp;#39;}

pub mod app;
pub mod config;
${config.database ? &amp;#39;pub mod database;&amp;#39; : &amp;#39;&amp;#39;}
pub mod errors;
pub mod handlers;
pub mod middleware;
pub mod models;
pub mod routes;
pub mod services;

pub use config::Config;
${config.database ? &amp;#39;pub use database::create_pool;&amp;#39; : &amp;#39;&amp;#39;}
pub use errors::AppError;

// Re-export commonly used types
pub use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    Router,
};
pub use serde::{Deserialize, Serialize};
pub use uuid::Uuid;
&#x60;;
  }

  private generateEnvExample(config: ProjectConfig): string {
    return &#x60;# Application Configuration
PORT&#x3D;3000
ENVIRONMENT&#x3D;development
LOG_LEVEL&#x3D;info

${
  config.database
    ? &#x60;# Database Configuration
DATABASE_URL&#x3D;postgres://user:password@localhost:5432/${config.name.toLowerCase()}&#x60;
    : &amp;#39;&amp;#39;
}

${
  config.auth
    ? &#x60;# Authentication
JWT_SECRET&#x3D;your-super-secret-jwt-key-change-in-production&#x60;
    : &amp;#39;&amp;#39;
}

# Additional configuration as needed
&#x60;;
  }

  private generateTestModule(): string {
    return &#x60;//! Integration tests

#[cfg(test)]
mod integration;

// Test utilities
pub mod common {
    use axum_test::TestServer;
    ${this.supportedFeatures.includes(&amp;#39;database&amp;#39;) ? &amp;#39;use sqlx::PgPool;&amp;#39; : &amp;#39;&amp;#39;}

    use crate::app::create_app;

    /// Create a test server for integration testing
    pub async fn create_test_server(${this.supportedFeatures.includes(&amp;#39;database&amp;#39;) ? &amp;#39;db_pool: PgPool&amp;#39; : &amp;#39;&amp;#39;}) -&amp;gt; TestServer {
        let app &#x3D; create_app(${this.supportedFeatures.includes(&amp;#39;database&amp;#39;) ? &amp;#39;db_pool&amp;#39; : &amp;#39;&amp;#39;}).await.unwrap();
        TestServer::new(app).unwrap()
    }

    ${
      this.supportedFeatures.includes(&amp;#39;database&amp;#39;)
        ? &#x60;/// Create a test database pool
    pub async fn create_test_db_pool() -&amp;gt; PgPool {
        // Implementation would create a test database connection
        // This is a placeholder
        todo!(&amp;quot;Implement test database setup&amp;quot;)
    }&#x60;
        : &amp;#39;&amp;#39;
    }
}
&#x60;;
  }

  private generateIntegrationTests(config: ProjectConfig): string {
    return &#x60;use axum::http::StatusCode;
use axum_test::TestServer;
${config.database ? &amp;#39;use sqlx::PgPool;&amp;#39; : &amp;#39;&amp;#39;}

use crate::tests::common::{create_test_server${config.database ? &amp;#39;, create_test_db_pool&amp;#39; : &amp;#39;&amp;#39;}};

#[tokio::test]
async fn test_health_endpoint() {
    ${config.database ? &amp;#39;let db_pool &#x3D; create_test_db_pool().await;&amp;#39; : &amp;#39;&amp;#39;}
    let server &#x3D; create_test_server(${config.database ? &amp;#39;db_pool&amp;#39; : &amp;#39;&amp;#39;}).await;

    let response &#x3D; server.get(&amp;quot;/health&amp;quot;).await;
    
    assert_eq!(response.status_code(), StatusCode::OK);
    
    let json: serde_json::Value &#x3D; response.json();
    assert_eq!(json[&amp;quot;status&amp;quot;], &amp;quot;healthy&amp;quot;);
}

#[tokio::test]
async fn test_ping_endpoint() {
    ${config.database ? &amp;#39;let db_pool &#x3D; create_test_db_pool().await;&amp;#39; : &amp;#39;&amp;#39;}
    let server &#x3D; create_test_server(${config.database ? &amp;#39;db_pool&amp;#39; : &amp;#39;&amp;#39;}).await;

    let response &#x3D; server.get(&amp;quot;/api/v1/ping&amp;quot;).await;
    
    assert_eq!(response.status_code(), StatusCode::OK);
    assert_eq!(response.text(), &amp;quot;pong&amp;quot;);
}

#[tokio::test]
async fn test_not_found() {
    ${config.database ? &amp;#39;let db_pool &#x3D; create_test_db_pool().await;&amp;#39; : &amp;#39;&amp;#39;}
    let server &#x3D; create_test_server(${config.database ? &amp;#39;db_pool&amp;#39; : &amp;#39;&amp;#39;}).await;

    let response &#x3D; server.get(&amp;quot;/nonexistent&amp;quot;).await;
    
    assert_eq!(response.status_code(), StatusCode::NOT_FOUND);
}
&#x60;;
  }

  private generateJustfile(config: ProjectConfig): string {
    return &#x60;# Justfile for ${config.name}

# Show available commands
default:
    @just --list

# Run the application in development mode
dev:
    cargo watch -x run

# Build the application
build:
    cargo build --release

# Run tests
test:
    cargo test

# Run tests with coverage
test-coverage:
    cargo tarpaulin --out html

# Check code without building
check:
    cargo check

# Run clippy lints
lint:
    cargo clippy -- -D warnings

# Format code
fmt:
    cargo fmt

# Fix code formatting and lints
fix:
    cargo fix --allow-dirty --allow-staged
    cargo fmt

# Clean build artifacts
clean:
    cargo clean

# Install development dependencies
install-dev:
    cargo install cargo-watch cargo-tarpaulin

${
  config.database
    ? &#x60;# Run database migrations
migrate:
    sqlx migrate run

# Create a new migration
migrate-create name:
    sqlx migrate add {{name}}

# Revert the last migration
migrate-revert:
    sqlx migrate revert&#x60;
    : &amp;#39;&amp;#39;
}

${
  config.docker
    ? &#x60;# Build Docker image
docker-build:
    docker build -t ${config.name.toLowerCase()}:latest .

# Run Docker container
docker-run:
    docker run --rm -p 3000:3000 ${config.name.toLowerCase()}:latest

# Build and run with Docker Compose
docker-up:
    docker-compose up --build

# Stop Docker Compose
docker-down:
    docker-compose down&#x60;
    : &amp;#39;&amp;#39;
}

# Run all checks (format, lint, test)
ci: fmt lint test

# Prepare for commit
pre-commit: fix test
&#x60;;
  }

  private generateDockerfile(config: ProjectConfig): string {
    return &#x60;# Multi-stage build for Rust application
FROM rust:1.70 as builder

# Create app directory
WORKDIR /app

# Copy manifests
COPY Cargo.toml Cargo.lock ./

# Build dependencies (this is the caching Docker layer!)
RUN mkdir src &amp;amp;&amp;amp; echo &amp;quot;fn main() {}&amp;quot; &amp;gt; src/main.rs
RUN cargo build --release
RUN rm src/main.rs

# Copy source code
COPY src ./src

# Build application
RUN touch src/main.rs &amp;amp;&amp;amp; cargo build --release

# Runtime stage
FROM debian:bookworm-slim

# Install runtime dependencies
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y \\
    ca-certificates \\
    &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*

# Create non-root user
RUN useradd -m -u 1001 appuser

# Copy the binary from builder stage
COPY --from&#x3D;builder /app/target/release/${config.name.toLowerCase()} /usr/local/bin/app

# Change to non-root user
USER appuser

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval&#x3D;30s --timeout&#x3D;10s --start-period&#x3D;5s --retries&#x3D;3 \\
    CMD curl -f http://localhost:3000/health || exit 1

# Run the application
CMD [&amp;quot;app&amp;quot;]
&#x60;;
  }

  private generateDockerCompose(config: ProjectConfig): string {
    const dbService &#x3D;
      config.database &#x3D;&#x3D;&#x3D; &amp;#39;postgres&amp;#39;
        ? &#x60;
  database:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: ${config.name.toLowerCase()}
      POSTGRES_PASSWORD: password
      POSTGRES_DB: ${config.name.toLowerCase()}
    ports:
      - &amp;quot;5432:5432&amp;quot;
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: [&amp;quot;CMD-SHELL&amp;quot;, &amp;quot;pg_isready -U ${config.name.toLowerCase()}&amp;quot;]
      interval: 10s
      timeout: 5s
      retries: 5&#x60;
        : &amp;#39;&amp;#39;;

    return &#x60;version: &amp;#39;3.8&amp;#39;

services:
  app:
    build: .
    ports:
      - &amp;quot;3000:3000&amp;quot;
    environment:
      - ENVIRONMENT&#x3D;development
      ${config.database ? &#x60;- DATABASE_URL&#x3D;postgres://${config.name.toLowerCase()}:password@database:5432/${config.name.toLowerCase()}&#x60; : &amp;#39;&amp;#39;}
    ${
      config.database
        ? &#x60;depends_on:
      database:
        condition: service_healthy&#x60;
        : &amp;#39;&amp;#39;
    }
    restart: unless-stopped
${dbService}

${
  config.database &#x3D;&#x3D;&#x3D; &amp;#39;postgres&amp;#39;
    ? &#x60;volumes:
  postgres_data:&#x60;
    : &amp;#39;&amp;#39;
}
&#x60;;
  }

  private generateProductionDockerfile(config: BuildConfig): string {
    return &#x60;# Production multi-stage build with distroless
FROM rust:1.70 as builder

WORKDIR /app

# Install build dependencies
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y \\
    pkg-config \\
    libssl-dev \\
    &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*

# Copy manifests
COPY Cargo.toml Cargo.lock ./

# Build dependencies
RUN mkdir src &amp;amp;&amp;amp; echo &amp;quot;fn main() {}&amp;quot; &amp;gt; src/main.rs
RUN cargo build --release
RUN rm src/main.rs

# Copy source code
COPY src ./src

# Build application with optimizations
RUN touch src/main.rs &amp;amp;&amp;amp; cargo build --release

# Final stage with distroless
FROM gcr.io/distroless/cc-debian12

# Copy the binary from builder stage
COPY --from&#x3D;builder /app/target/release/app /app

EXPOSE 3000

USER nonroot:nonroot

ENTRYPOINT [&amp;quot;/app&amp;quot;]
&#x60;;
  }

  private generateGitHubActions(config: BuildConfig): string {
    return &#x60;name: Rust Application CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test
        options: &amp;gt;-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v4
    
    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy
        
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: \${{ runner.os }}-cargo-\${{ hashFiles(&amp;#39;**/Cargo.lock&amp;#39;) }}
        restore-keys: |
          \${{ runner.os }}-cargo-
    
    - name: Check formatting
      run: cargo fmt -- --check
    
    - name: Run clippy
      run: cargo clippy -- -D warnings
    
    - name: Run tests
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/test
      run: cargo test --verbose

  ${
    config.target &#x3D;&#x3D;&#x3D; &amp;#39;production&amp;#39;
      ? &#x60;build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref &#x3D;&#x3D; &amp;#39;refs/heads/main&amp;#39;
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
    
    - name: Build binary
      run: cargo build --release
    
    - name: Build Docker image
      run: |
        docker build -f Dockerfile.prod -t your-registry/app:$&#x60; +
        &amp;#39;{{ github.sha }}&amp;#39; +
        &#x60; .
        docker tag your-registry/app:$&#x60; +
        &amp;#39;{{ github.sha }}&amp;#39; +
        &#x60; your-registry/app:latest
    
    - name: Push Docker image
      run: |
        echo &amp;quot;$&#x60; +
        &amp;#39;{{ secrets.DOCKER_PASSWORD }}&amp;#39; +
        &#x60;&amp;quot; | docker login -u &amp;quot;$&#x60; +
        &amp;#39;{{ secrets.DOCKER_USERNAME }}&amp;#39; +
        &#x60;&amp;quot; --password-stdin
        docker push your-registry/app:$&#x60; +
        &#x60;{{ github.sha }}
        docker push your-registry/app:latest&#x60;
      : &amp;#39;&amp;#39;
  }

  security-audit:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: dtolnay/rust-toolchain@stable
    - name: Install cargo-audit
      run: cargo install cargo-audit
    - name: Run security audit
      run: cargo audit
&#x60;;
  }

  private generateCargoConfig(config: BuildConfig): string {
    return &#x60;[target.x86_64-unknown-linux-gnu]
linker &#x3D; &amp;quot;clang&amp;quot;
rustflags &#x3D; [&amp;quot;-C&amp;quot;, &amp;quot;link-arg&#x3D;-fuse-ld&#x3D;lld&amp;quot;]

[build]
rustc-wrapper &#x3D; &amp;quot;sccache&amp;quot;

[registries.crates-io]
protocol &#x3D; &amp;quot;sparse&amp;quot;

${
  config.optimization
    ? &#x60;[profile.release]
lto &#x3D; true
codegen-units &#x3D; 1
panic &#x3D; &amp;quot;abort&amp;quot;
strip &#x3D; true
opt-level &#x3D; 3&#x60;
    : &amp;#39;&amp;#39;
}
&#x60;;
  }

  private toPascalCase(str: string): string {
    return str.replace(/(?:^|[-_])(\w)/g, (_, c) &#x3D;&amp;gt; c.toUpperCase());
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-19">
                <div class="file-header">ğŸ“„ packages/shared/src/utils.ts</div>
                <div class="file-content">
                    <pre>/**
 * Shared utilities for Arbiter CLI and API
 */

/**
 * Format validation errors into a human-readable string
 */
export function formatValidationErrors(
  errors: Array&amp;lt;{
    message: string;
    line?: number;
    column?: number;
    path?: string;
  }&amp;gt;
): string {
  return errors
    .map(error &#x3D;&amp;gt; {
      let formatted &#x3D; error.message;
      if (error.path) {
        formatted &#x3D; &#x60;${error.path}: ${formatted}&#x60;;
      }
      if (error.line !&#x3D;&#x3D; undefined) {
        formatted &#x3D; &#x60;${formatted} (line ${error.line}${error.column ? &#x60;, column ${error.column}&#x60; : &amp;#39;&amp;#39;})&#x60;;
      }
      return formatted;
    })
    .join(&amp;#39;\n&amp;#39;);
}

/**
 * Check if a path is relative
 */
export function isRelativePath(path: string): boolean {
  return !path.startsWith(&amp;#39;/&amp;#39;) &amp;amp;&amp;amp; !path.match(/^[a-zA-Z]:\\/);
}

/**
 * Normalize path separators to forward slashes
 */
export function normalizePath(path: string): string {
  return path.replace(/\\/g, &amp;#39;/&amp;#39;);
}

/**
 * Simple debounce utility
 */
export function debounce&amp;lt;T extends (...args: unknown[]) &#x3D;&amp;gt; void&amp;gt;(
  func: T,
  wait: number
): (...args: Parameters&amp;lt;T&amp;gt;) &#x3D;&amp;gt; void {
  let timeout: NodeJS.Timeout;
  return (...args: Parameters&amp;lt;T&amp;gt;) &#x3D;&amp;gt; {
    clearTimeout(timeout);
    timeout &#x3D; setTimeout(() &#x3D;&amp;gt; func(...args), wait);
  };
}

/**
 * Translate CUE error messages into more user-friendly messages
 */
export function translateCueErrors(
  errorMessage: string
): Array&amp;lt;{ friendlyMessage: string; category: string }&amp;gt; {
  // Simple translation for common CUE error patterns
  const translations &#x3D; [
    {
      pattern: /.*undefined field.*/i,
      friendlyMessage: &amp;#39;This field is not defined in the schema&amp;#39;,
      category: &amp;#39;schema&amp;#39;,
    },
    {
      pattern: /.*conflicting values.*/i,
      friendlyMessage: &amp;#39;Values conflict with schema requirements&amp;#39;,
      category: &amp;#39;validation&amp;#39;,
    },
    {
      pattern: /.*cannot unify.*/i,
      friendlyMessage: &amp;#39;Cannot combine these values according to the schema&amp;#39;,
      category: &amp;#39;type&amp;#39;,
    },
    {
      pattern: /.*incomplete value.*/i,
      friendlyMessage: &amp;#39;This value is missing required information&amp;#39;,
      category: &amp;#39;validation&amp;#39;,
    },
  ];

  for (const translation of translations) {
    if (translation.pattern.test(errorMessage)) {
      return [
        {
          friendlyMessage: translation.friendlyMessage,
          category: translation.category,
        },
      ];
    }
  }

  // If no pattern matches, return the original message
  return [
    {
      friendlyMessage: errorMessage,
      category: &amp;#39;validation&amp;#39;,
    },
  ];
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-20">
                <div class="file-header">ğŸ“„ packages/cli/src/constraints/filesystem.ts</div>
                <div class="file-content">
                    <pre>import path from &amp;quot;node:path&amp;quot;;
import fs from &amp;quot;fs-extra&amp;quot;;
import { ConstraintViolationError, globalConstraintEnforcer } from &amp;quot;./core.js&amp;quot;;

/**
 * File system operation types that must be constrained
 */
export type FileSystemOperation &#x3D;
  | &amp;quot;read&amp;quot;
  | &amp;quot;write&amp;quot;
  | &amp;quot;copy&amp;quot;
  | &amp;quot;move&amp;quot;
  | &amp;quot;delete&amp;quot;
  | &amp;quot;create&amp;quot;
  | &amp;quot;bundle&amp;quot;
  | &amp;quot;export&amp;quot;;

/**
 * File system path validation result
 */
export interface PathValidationResult {
  isValid: boolean;
  resolvedPath: string;
  isSymlink: boolean;
  symlinkTarget?: string;
  securityIssues: string[];
}

/**
 * File system constraint enforcer
 * Implements &amp;quot;Don&amp;#39;t emit symlinks&amp;quot; and &amp;quot;standalone/bundle copy files&amp;quot; constraints
 */
export class FileSystemConstraints {
  private readonly maxPathLength &#x3D; 4096; // Maximum path length
  private readonly maxSymlinkDepth &#x3D; 0; // No symlinks allowed per constraints
  private readonly allowedExtensions &#x3D; new Set([
    &amp;quot;.cue&amp;quot;,
    &amp;quot;.json&amp;quot;,
    &amp;quot;.yaml&amp;quot;,
    &amp;quot;.yml&amp;quot;,
    &amp;quot;.md&amp;quot;,
    &amp;quot;.txt&amp;quot;,
    &amp;quot;.ts&amp;quot;,
    &amp;quot;.js&amp;quot;,
    &amp;quot;.py&amp;quot;,
    &amp;quot;.rs&amp;quot;,
    &amp;quot;.go&amp;quot;,
  ]);

  /**
   * Validate a file path for constraint compliance
   */
  async validatePath(
    filePath: string,
    operation: FileSystemOperation,
    operationId?: string,
  ): Promise&amp;lt;PathValidationResult&amp;gt; {
    const result: PathValidationResult &#x3D; {
      isValid: true,
      resolvedPath: &amp;quot;&amp;quot;,
      isSymlink: false,
      securityIssues: [],
    };

    try {
      // Resolve the path to handle relative paths and symlinks
      const resolvedPath &#x3D; path.resolve(filePath);
      result.resolvedPath &#x3D; resolvedPath;

      // Check path length
      if (resolvedPath.length &amp;gt; this.maxPathLength) {
        result.isValid &#x3D; false;
        result.securityIssues.push(&#x60;Path too long: ${resolvedPath.length} &amp;gt; ${this.maxPathLength}&#x60;);
      }

      // Check for path traversal attempts
      if (this.hasPathTraversal(resolvedPath)) {
        result.isValid &#x3D; false;
        result.securityIssues.push(&amp;quot;Path traversal detected&amp;quot;);
      }

      // Check if path exists
      const exists &#x3D; await fs.pathExists(resolvedPath);
      if (!exists &amp;amp;&amp;amp; (operation &#x3D;&#x3D;&#x3D; &amp;quot;read&amp;quot; || operation &#x3D;&#x3D;&#x3D; &amp;quot;copy&amp;quot; || operation &#x3D;&#x3D;&#x3D; &amp;quot;move&amp;quot;)) {
        result.isValid &#x3D; false;
        result.securityIssues.push(&amp;quot;Path does not exist&amp;quot;);
      }

      if (exists) {
        // Check for symlinks (not allowed)
        const stats &#x3D; await fs.lstat(resolvedPath);
        if (stats.isSymbolicLink()) {
          result.isSymlink &#x3D; true;
          result.symlinkTarget &#x3D; await fs.readlink(resolvedPath);

          // Symlinks are forbidden per constraint
          result.isValid &#x3D; false;
          result.securityIssues.push(&amp;quot;Symlinks are not allowed&amp;quot;);

          const violation &#x3D; new ConstraintViolationError(
            &amp;quot;symlinkPrevention&amp;quot;,
            &#x60;symlink: ${filePath} -&amp;gt; ${result.symlinkTarget}&#x60;,
            &amp;quot;standalone file copy (no symlinks)&amp;quot;,
            {
              operationId,
              operation,
              filePath,
              symlinkTarget: result.symlinkTarget,
              resolvedPath,
            },
          );

          globalConstraintEnforcer.emit(&amp;quot;constraint:violation&amp;quot;, {
            constraint: &amp;quot;symlinkPrevention&amp;quot;,
            violation,
            filePath,
          });

          throw violation;
        }

        // Check file extension for security
        const ext &#x3D; path.extname(resolvedPath).toLowerCase();
        if (ext &amp;amp;&amp;amp; !this.allowedExtensions.has(ext)) {
          result.securityIssues.push(&#x60;File extension ${ext} not allowed&#x60;);
        }
      }

      // Validate the result
      if (!result.isValid) {
        const violation &#x3D; new ConstraintViolationError(
          &amp;quot;fileSystemValidation&amp;quot;,
          &#x60;invalid path: ${filePath}&#x60;,
          &amp;quot;valid file system path&amp;quot;,
          {
            operationId,
            operation,
            filePath,
            resolvedPath,
            securityIssues: result.securityIssues,
          },
        );

        globalConstraintEnforcer.emit(&amp;quot;constraint:violation&amp;quot;, {
          constraint: &amp;quot;fileSystemValidation&amp;quot;,
          violation,
          filePath,
        });

        throw violation;
      }

      globalConstraintEnforcer.emit(&amp;quot;filesystem:validated&amp;quot;, {
        operationId,
        operation,
        filePath,
        resolvedPath,
      });

      return result;
    } catch (error) {
      if (error instanceof ConstraintViolationError) {
        throw error; // Re-throw constraint violations
      }

      // Convert other errors to constraint violations
      result.isValid &#x3D; false;
      result.securityIssues.push(
        &#x60;File system error: ${error instanceof Error ? error.message : String(error)}&#x60;,
      );

      const violation &#x3D; new ConstraintViolationError(
        &amp;quot;fileSystemError&amp;quot;,
        error instanceof Error ? error.message : String(error),
        &amp;quot;successful file system access&amp;quot;,
        {
          operationId,
          operation,
          filePath,
          originalError: error,
        },
      );

      globalConstraintEnforcer.emit(&amp;quot;constraint:violation&amp;quot;, {
        constraint: &amp;quot;fileSystemError&amp;quot;,
        violation,
        filePath,
      });

      throw violation;
    }
  }

  /**
   * Copy a file ensuring no symlinks are created (standalone copies only)
   */
  async copyFileStandalone(src: string, dest: string, operationId?: string): Promise&amp;lt;void&amp;gt; {
    // Validate source path
    await this.validatePath(src, &amp;quot;copy&amp;quot;, operationId);

    // Validate destination path (create operation)
    const destDir &#x3D; path.dirname(dest);
    await fs.ensureDir(destDir);

    try {
      // Read source file content (this dereferences any symlinks)
      const content &#x3D; await fs.readFile(src);

      // Write content directly to destination (no symlink creation)
      await fs.writeFile(dest, content);

      // Verify the copy was successful and is not a symlink
      const destStats &#x3D; await fs.lstat(dest);
      if (destStats.isSymbolicLink()) {
        // This should not happen with writeFile, but check anyway
        await fs.remove(dest);
        throw new ConstraintViolationError(
          &amp;quot;symlinkPrevention&amp;quot;,
          &amp;quot;symlink created during copy&amp;quot;,
          &amp;quot;standalone file copy&amp;quot;,
          {
            operationId,
            src,
            dest,
          },
        );
      }

      globalConstraintEnforcer.emit(&amp;quot;filesystem:copied&amp;quot;, {
        operationId,
        src,
        dest,
        size: content.length,
      });
    } catch (error) {
      if (error instanceof ConstraintViolationError) {
        throw error;
      }

      const violation &#x3D; new ConstraintViolationError(
        &amp;quot;fileSystemCopy&amp;quot;,
        error instanceof Error ? error.message : String(error),
        &amp;quot;successful standalone file copy&amp;quot;,
        {
          operationId,
          src,
          dest,
          originalError: error,
        },
      );

      throw violation;
    }
  }

  /**
   * Bundle files into a directory ensuring all are standalone copies
   */
  async bundleFiles(files: string[], outputDir: string, operationId?: string): Promise&amp;lt;void&amp;gt; {
    // Ensure output directory exists
    await fs.ensureDir(outputDir);

    const bundleId &#x3D; globalConstraintEnforcer.startOperation(&#x60;bundle:${outputDir}&#x60;, {
      fileCount: files.length,
      outputDir,
    });

    try {
      // Process files in parallel with concurrency limit
      const concurrency &#x3D; 5;
      const chunks &#x3D; this.chunkArray(files, concurrency);

      for (const chunk of chunks) {
        await Promise.all(
          chunk.map(async (file) &#x3D;&amp;gt; {
            const fileName &#x3D; path.basename(file);
            const destPath &#x3D; path.join(outputDir, fileName);

            // Ensure unique names to prevent conflicts
            const uniqueDestPath &#x3D; await this.ensureUniqueFileName(destPath);

            await this.copyFileStandalone(file, uniqueDestPath, bundleId);
          }),
        );
      }

      globalConstraintEnforcer.emit(&amp;quot;filesystem:bundled&amp;quot;, {
        operationId,
        bundleId,
        fileCount: files.length,
        outputDir,
      });
    } finally {
      globalConstraintEnforcer.endOperation(bundleId);
    }
  }

  /**
   * Export files with constraint validation
   */
  async exportFiles(
    files: Record&amp;lt;string, string&amp;gt;,
    outputDir: string,
    operationId?: string,
  ): Promise&amp;lt;void&amp;gt; {
    await fs.ensureDir(outputDir);

    const exportId &#x3D; globalConstraintEnforcer.startOperation(&#x60;export:${outputDir}&#x60;, {
      fileCount: Object.keys(files).length,
      outputDir,
    });

    try {
      // Validate and write each file
      for (const [relativePath, content] of Object.entries(files)) {
        const fullPath &#x3D; path.join(outputDir, relativePath);
        const dir &#x3D; path.dirname(fullPath);

        // Ensure directory exists
        await fs.ensureDir(dir);

        // Validate the output path
        await this.validatePath(fullPath, &amp;quot;export&amp;quot;, exportId);

        // Validate content size
        globalConstraintEnforcer.validatePayloadSize(content, exportId);

        // Write file (never create symlinks)
        await fs.writeFile(fullPath, content, &amp;quot;utf8&amp;quot;);

        // Verify no symlink was created
        const stats &#x3D; await fs.lstat(fullPath);
        if (stats.isSymbolicLink()) {
          await fs.remove(fullPath);
          throw new ConstraintViolationError(
            &amp;quot;symlinkPrevention&amp;quot;,
            &amp;quot;symlink created during export&amp;quot;,
            &amp;quot;standalone file&amp;quot;,
            {
              operationId: exportId,
              filePath: fullPath,
            },
          );
        }
      }

      globalConstraintEnforcer.emit(&amp;quot;filesystem:exported&amp;quot;, {
        operationId,
        exportId,
        fileCount: Object.keys(files).length,
        outputDir,
      });
    } finally {
      globalConstraintEnforcer.endOperation(exportId);
    }
  }

  /**
   * Check for path traversal attempts
   */
  private hasPathTraversal(filePath: string): boolean {
    const normalized &#x3D; path.normalize(filePath);
    return normalized.includes(&amp;quot;../&amp;quot;) || normalized.includes(&amp;quot;..\\&amp;quot;);
  }

  /**
   * Ensure unique file name to prevent conflicts during bundling
   */
  private async ensureUniqueFileName(filePath: string): Promise&amp;lt;string&amp;gt; {
    let uniquePath &#x3D; filePath;
    let counter &#x3D; 1;

    while (await fs.pathExists(uniquePath)) {
      const ext &#x3D; path.extname(filePath);
      const base &#x3D; path.basename(filePath, ext);
      const dir &#x3D; path.dirname(filePath);
      uniquePath &#x3D; path.join(dir, &#x60;${base}_${counter}${ext}&#x60;);
      counter++;
    }

    return uniquePath;
  }

  /**
   * Chunk array for parallel processing
   */
  private chunkArray&amp;lt;T&amp;gt;(array: T[], size: number): T[][] {
    const chunks: T[][] &#x3D; [];
    for (let i &#x3D; 0; i &amp;lt; array.length; i +&#x3D; size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }

  /**
   * Get file system constraint status
   */
  getConstraintStatus(): {
    maxPathLength: number;
    maxSymlinkDepth: number;
    allowedExtensions: string[];
    violations: {
      symlinks: number;
      pathTraversal: number;
      invalidPaths: number;
    };
  } {
    return {
      maxPathLength: this.maxPathLength,
      maxSymlinkDepth: this.maxSymlinkDepth,
      allowedExtensions: Array.from(this.allowedExtensions),
      violations: {
        symlinks: 0, // Would be tracked via event listeners
        pathTraversal: 0,
        invalidPaths: 0,
      },
    };
  }
}

/**
 * Global file system constraints instance
 */
export const globalFileSystemConstraints &#x3D; new FileSystemConstraints();

/**
 * Decorator for automatic file system constraint enforcement
 */
export function withFileSystemConstraints(operation: FileSystemOperation) {
  return &amp;lt;T extends (...args: any[]) &#x3D;&amp;gt; Promise&amp;lt;any&amp;gt;&amp;gt;(
    _target: any,
    propertyName: string,
    descriptor: TypedPropertyDescriptor&amp;lt;T&amp;gt;,
  ) &#x3D;&amp;gt; {
    const method &#x3D; descriptor.value!;

    descriptor.value &#x3D; async function (this: any, ...args: any[]) {
      const operationId &#x3D; globalConstraintEnforcer.startOperation(&#x60;fs:${operation}&#x60;, {
        method: propertyName,
        args: args.length,
      });

      try {
        // Validate file paths in arguments if they exist
        for (const arg of args) {
          if (typeof arg &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; &amp;amp;&amp;amp; (arg.includes(&amp;quot;/&amp;quot;) || arg.includes(&amp;quot;\\&amp;quot;))) {
            await globalFileSystemConstraints.validatePath(arg, operation, operationId);
          }
        }

        const result &#x3D; await method.apply(this, args);
        globalConstraintEnforcer.endOperation(operationId);
        return result;
      } catch (error) {
        globalConstraintEnforcer.endOperation(operationId);
        throw error;
      }
    } as T;

    return descriptor;
  };
}

/**
 * Utility function for safe file operations with constraint enforcement
 */
export async function safeFileOperation&amp;lt;T&amp;gt;(
  operation: FileSystemOperation,
  filePath: string,
  fn: (validatedPath: string) &#x3D;&amp;gt; Promise&amp;lt;T&amp;gt;,
  operationId?: string,
): Promise&amp;lt;T&amp;gt; {
  const validation &#x3D; await globalFileSystemConstraints.validatePath(
    filePath,
    operation,
    operationId,
  );
  return await fn(validation.resolvedPath);
}

/**
 * Utility to copy files ensuring no symlinks (implements &amp;quot;standalone/bundle copy files&amp;quot; constraint)
 */
export async function copyStandalone(
  src: string,
  dest: string,
  operationId?: string,
): Promise&amp;lt;void&amp;gt; {
  return globalFileSystemConstraints.copyFileStandalone(src, dest, operationId);
}

/**
 * Utility to bundle multiple files ensuring all are standalone copies
 */
export async function bundleStandalone(
  files: string[],
  outputDir: string,
  operationId?: string,
): Promise&amp;lt;void&amp;gt; {
  return globalFileSystemConstraints.bundleFiles(files, outputDir, operationId);
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-21">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/surface.ts</div>
                <div class="file-content">
                    <pre>import chalk from &amp;#39;chalk&amp;#39;;
import { glob } from &amp;#39;glob&amp;#39;;
import type { CLIConfig } from &amp;#39;../types.js&amp;#39;;
import { withStepProgress } from &amp;#39;../utils/progress.js&amp;#39;;
import { resolveSmartNaming } from &amp;#39;../utils/smart-naming.js&amp;#39;;
import {
  type SurfaceOutput,
  createOutputManager,
  shouldUseAgentMode,
} from &amp;#39;../utils/standardized-output.js&amp;#39;;

import type { APISurface, APISymbol, SurfaceOptions } from &amp;#39;../surface-extraction/types.js&amp;#39;;
import { getExtractor } from &amp;#39;../surface-extraction/index.js&amp;#39;;
import { calculateSurfaceDelta } from &amp;#39;../surface-extraction/delta.js&amp;#39;;

export type { APISurface } from &amp;#39;../surface-extraction/types.js&amp;#39;;

/**
 * Surface command implementation
 * Extracts API surface from source code and generates surface.json for diff analysis
 */
export async function surfaceCommand(options: SurfaceOptions, _config: CLIConfig): Promise&amp;lt;number&amp;gt; {
  const agentMode &#x3D; shouldUseAgentMode(options);
  const outputManager &#x3D; createOutputManager(&amp;#39;surface&amp;#39;, agentMode, options.ndjsonOutput);

  // Define the steps for surface extraction
  const steps &#x3D; [
    &amp;#39;Resolving project configuration&amp;#39;,
    &amp;#39;Scanning source files&amp;#39;,
    &amp;#39;Analyzing code structure&amp;#39;,
    &amp;#39;Extracting API symbols&amp;#39;,
    &amp;#39;Generating surface definition&amp;#39;,
    &amp;#39;Writing output file&amp;#39;,
  ];

  return withStepProgress(
    {
      title: &#x60;Extracting ${options.language} API surface&#x60;,
      steps,
      color: &amp;#39;blue&amp;#39;,
    },
    async progress &#x3D;&amp;gt; {
      try {
        // Step 1: Resolve smart naming for output file
        if (&amp;#39;nextStep&amp;#39; in progress) {
          progress.nextStep(&amp;#39;Resolving project configuration&amp;#39;);
        } else {
          progress.log(&amp;#39;Resolving project configuration&amp;#39;);
        }
        const namingResult &#x3D; await resolveSmartNaming(&amp;#39;surface&amp;#39;, {
          output: options.output,
          outputDir: options.outputDir,
          projectName: options.projectName,
          useGenericNames: options.genericNames ?? false,
        });

        // Emit start event for agent mode
        outputManager.emitEvent({
          phase: &amp;#39;surface&amp;#39;,
          status: &amp;#39;start&amp;#39;,
          data: {
            language: options.language,
            outputFile: namingResult.filename,
            projectName: namingResult.context.name,
          },
        });

        if (!agentMode &amp;amp;&amp;amp; namingResult.context.name) {
          console.log(chalk.dim(&#x60;   Project: ${namingResult.context.name}&#x60;));
          console.log(chalk.dim(&#x60;   Output: ${namingResult.filename}&#x60;));
        }

        // Step 2: Scan source files
        if (&amp;#39;nextStep&amp;#39; in progress) {
          progress.nextStep(&amp;#39;Scanning source files&amp;#39;);
        } else {
          progress.log(&amp;#39;Scanning source files&amp;#39;);
        }
        const sourceFiles &#x3D; await findSourceFiles(options.language);

        if (sourceFiles.length &#x3D;&#x3D;&#x3D; 0) {
          if (&amp;#39;failCurrentStep&amp;#39; in progress) {
            progress.failCurrentStep(&#x60;No ${options.language} files found&#x60;);
          } else {
            progress.error(&#x60;No ${options.language} files found&#x60;);
          }
          return 1;
        }

        // Step 3: Analyze code structure
        if (&amp;#39;nextStep&amp;#39; in progress) {
          progress.nextStep(&#x60;Analyzing code structure (${sourceFiles.length} files)&#x60;);
        } else {
          progress.log(&#x60;Analyzing code structure (${sourceFiles.length} files)&#x60;);
        }

        // Step 4: Extract API symbols
        if (&amp;#39;nextStep&amp;#39; in progress) {
          progress.nextStep(&amp;#39;Extracting API symbols&amp;#39;);
        } else {
          progress.log(&amp;#39;Extracting API symbols&amp;#39;);
        }
        const surface &#x3D; await extractAPISurface(options, sourceFiles);

        if (!surface) {
          if (&amp;#39;failCurrentStep&amp;#39; in progress) {
            progress.failCurrentStep(&amp;#39;Failed to extract API surface&amp;#39;);
          } else {
            progress.error(&amp;#39;Failed to extract API surface&amp;#39;);
          }
          outputManager.emitEvent({
            phase: &amp;#39;surface&amp;#39;,
            status: &amp;#39;error&amp;#39;,
            error: &amp;#39;Failed to extract API surface&amp;#39;,
          });
          return 1;
        }

        // Step 5: Generate surface definition and calculate delta if requested
        if (&amp;#39;nextStep&amp;#39; in progress) {
          progress.nextStep(&amp;#39;Generating surface definition&amp;#39;);
        } else {
          progress.log(&amp;#39;Generating surface definition&amp;#39;);
        }
        let delta;
        if (options.diff) {
          delta &#x3D; await calculateSurfaceDelta(surface, namingResult.fullPath);
        }

        // Create standardized surface output
        const surfaceOutput: SurfaceOutput &#x3D; {
          apiVersion: &amp;#39;arbiter.dev/v2&amp;#39;,
          timestamp: Date.now(),
          command: &amp;#39;surface&amp;#39;,
          kind: &amp;#39;Surface&amp;#39;,
          language: options.language,
          surface: {
            symbols: surface.symbols.map(s &#x3D;&amp;gt; ({
              name: s.name,
              type: s.type,
              visibility: s.visibility,
              signature: s.signature,
              location: s.location,
            })),
            statistics: surface.statistics,
          },
          delta,
        };

        // Step 6: Write output file
        if (&amp;#39;nextStep&amp;#39; in progress) {
          progress.nextStep(&amp;#39;Writing output file&amp;#39;);
        } else {
          progress.log(&amp;#39;Writing output file&amp;#39;);
        }
        await outputManager.writeSurfaceFile(surfaceOutput, namingResult.fullPath);

        if (!agentMode) {
          console.log(chalk.cyan(&amp;#39;\nStatistics:&amp;#39;));
          console.log(&#x60;  Total symbols: ${surface.statistics.totalSymbols}&#x60;);
          console.log(&#x60;  Public symbols: ${surface.statistics.publicSymbols}&#x60;);
          console.log(&#x60;  Private symbols: ${surface.statistics.privateSymbols}&#x60;);

          // Show breakdown by type
          for (const [type, count] of Object.entries(surface.statistics.byType)) {
            console.log(&#x60;  ${type}: ${count}&#x60;);
          }

          if (delta) {
            console.log(chalk.yellow(&amp;#39;\nâš ï¸  API changes detected:&amp;#39;));
            if (delta.added &amp;gt; 0) {
              console.log(chalk.green(&#x60;  + ${delta.added} added symbols&#x60;));
            }
            if (delta.removed &amp;gt; 0) {
              console.log(chalk.red(&#x60;  - ${delta.removed} removed symbols&#x60;));
            }
            if (delta.breaking) {
              console.log(
                chalk.red(&#x60;  ğŸš¨ Breaking changes detected - ${delta.requiredBump} bump recommended&#x60;)
              );
            }
          }
        }

        // Emit completion event
        outputManager.emitEvent({
          phase: &amp;#39;surface&amp;#39;,
          status: &amp;#39;complete&amp;#39;,
          data: {
            symbols: surface.statistics.totalSymbols,
            delta,
          },
        });

        outputManager.close();
        return 0;
      } catch (error) {
        const errorMessage &#x3D; error instanceof Error ? error.message : String(error);

        if (!agentMode) {
          console.error(chalk.red(&amp;#39;âŒ Surface command failed:&amp;#39;), errorMessage);
        }

        outputManager.emitEvent({
          phase: &amp;#39;surface&amp;#39;,
          status: &amp;#39;error&amp;#39;,
          error: errorMessage,
        });

        outputManager.close();
        return 1;
      }
    }
  );
}

/**
 * Find source files for the specified language
 */
async function findSourceFiles(language: string): Promise&amp;lt;string[]&amp;gt; {
  const patterns: Record&amp;lt;string, string[]&amp;gt; &#x3D; {
    typescript: [&amp;#39;**/*.ts&amp;#39;, &amp;#39;**/*.tsx&amp;#39;],
    python: [&amp;#39;**/*.py&amp;#39;],
    rust: [&amp;#39;**/*.rs&amp;#39;],
    go: [&amp;#39;**/*.go&amp;#39;],
    bash: [&amp;#39;**/*.sh&amp;#39;, &amp;#39;**/*.bash&amp;#39;],
  };

  const ignorePatterns &#x3D; [
    &amp;#39;node_modules/**&amp;#39;,
    &amp;#39;dist/**&amp;#39;,
    &amp;#39;build/**&amp;#39;,
    &amp;#39;target/**&amp;#39;,
    &amp;#39;**/*.test.*&amp;#39;,
    &amp;#39;**/*.spec.*&amp;#39;,
    &amp;#39;**/*_test.*&amp;#39;,
    &amp;#39;**/__tests__/**&amp;#39;,
    &amp;#39;**/.git/**&amp;#39;,
  ];

  const files &#x3D; await glob(patterns[language] || [], {
    ignore: ignorePatterns,
  });

  return files;
}

/**
 * Extract API surface based on language
 */
async function extractAPISurface(
  options: SurfaceOptions,
  sourceFiles: string[]
): Promise&amp;lt;APISurface | null&amp;gt; {
  const extractor &#x3D; getExtractor(options.language);
  if (extractor) {
    return extractor(options, sourceFiles);
  }

  switch (options.language) {
    default:
      throw new Error(&#x60;Unsupported language: ${options.language}&#x60;);
  }
}

/**
 * Calculate surface delta between current and previous versions
 */
</pre>
                </div>
            </div>
            <div class="file-section" id="file-22">
                <div class="file-header">ğŸ“„ packages/cli/src/connection-validator.ts</div>
                <div class="file-content">
                    <pre>import { COMMON_PORTS } from &amp;#39;./config.js&amp;#39;;
import type { CLIConfig } from &amp;#39;./types.js&amp;#39;;

/**
 * Connection validation and auto-discovery utility
 */
export class ConnectionValidator {
  constructor(private config: CLIConfig) {}

  /**
   * Validate server connection with auto-discovery fallback
   */
  async validateConnection(): Promise&amp;lt;{
    success: boolean;
    url?: string;
    port?: number;
    error?: string;
    suggestions?: string[];
  }&amp;gt; {
    const baseUrl &#x3D; new URL(this.config.apiUrl);
    const hostname &#x3D; baseUrl.hostname;
    const protocol &#x3D; baseUrl.protocol;
    const configuredPort &#x3D; Number.parseInt(baseUrl.port, 10) || (protocol &#x3D;&#x3D;&#x3D; &amp;#39;https:&amp;#39; ? 443 : 80);

    // First try configured URL
    const configuredResult &#x3D; await this.testConnection(
      &#x60;${protocol}//${hostname}:${configuredPort}&#x60;
    );
    if (configuredResult.success) {
      return {
        success: true,
        url: &#x60;${protocol}//${hostname}:${configuredPort}&#x60;,
        port: configuredPort,
      };
    }

    // Try common ports for auto-discovery
    const suggestions: string[] &#x3D; [];
    for (const port of COMMON_PORTS) {
      const testUrl &#x3D; &#x60;${protocol}//${hostname}:${port}&#x60;;
      const result &#x3D; await this.testConnection(testUrl);

      if (result.success) {
        return {
          success: true,
          url: testUrl,
          port: port,
        };
      }

      if (result.partialSuccess) {
        suggestions.push(&#x60;Port ${port}: ${result.error}&#x60;);
      }
    }

    return {
      success: false,
      error: &#x60;No Arbiter server found at ${hostname}&#x60;,
      suggestions: [
        &#x60;Tried ports: ${COMMON_PORTS.join(&amp;#39;, &amp;#39;)}&#x60;,
        &amp;#39;Make sure the server is running with: bun run dev&amp;#39;,
        &amp;#39;Or with Docker: docker-compose up&amp;#39;,
        ...suggestions,
      ],
    };
  }

  /**
   * Test connection to a specific URL
   */
  private async testConnection(url: string): Promise&amp;lt;{
    success: boolean;
    partialSuccess: boolean;
    error?: string;
  }&amp;gt; {
    try {
      const controller &#x3D; new AbortController();
      const timeoutId &#x3D; setTimeout(() &#x3D;&amp;gt; controller.abort(), 3000);

      const response &#x3D; await fetch(&#x60;${url}/health&#x60;, {
        signal: controller.signal,
        method: &amp;#39;GET&amp;#39;,
      });

      clearTimeout(timeoutId);

      if (response.ok) {
        const data &#x3D; await response.json();
        // Verify it&amp;#39;s actually an Arbiter server
        if (data.status &amp;amp;&amp;amp; typeof data.timestamp &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39;) {
          return { success: true, partialSuccess: true };
        }
      }

      return {
        success: false,
        partialSuccess: true,
        error: &#x60;Server responded with ${response.status}&#x60;,
      };
    } catch (error) {
      if (error instanceof Error) {
        if (error.name &#x3D;&#x3D;&#x3D; &amp;#39;AbortError&amp;#39;) {
          return {
            success: false,
            partialSuccess: true,
            error: &amp;#39;Connection timeout&amp;#39;,
          };
        }

        if (error.message.includes(&amp;#39;ECONNREFUSED&amp;#39;)) {
          return {
            success: false,
            partialSuccess: false,
            error: &amp;#39;Connection refused&amp;#39;,
          };
        }
      }

      return {
        success: false,
        partialSuccess: false,
        error: &amp;#39;Network error&amp;#39;,
      };
    }
  }

  /**
   * Get diagnostic information for troubleshooting
   */
  async getDiagnostics(): Promise&amp;lt;{
    configuredUrl: string;
    commonPorts: readonly number[];
    networkTests: Array&amp;lt;{
      port: number;
      status: &amp;#39;success&amp;#39; | &amp;#39;timeout&amp;#39; | &amp;#39;refused&amp;#39; | &amp;#39;error&amp;#39;;
      responseTime?: number;
      error?: string;
    }&amp;gt;;
  }&amp;gt; {
    const baseUrl &#x3D; new URL(this.config.apiUrl);
    const hostname &#x3D; baseUrl.hostname;
    const protocol &#x3D; baseUrl.protocol;

    const networkTests &#x3D; await Promise.all(
      COMMON_PORTS.map(async port &#x3D;&amp;gt; {
        const startTime &#x3D; Date.now();
        const testUrl &#x3D; &#x60;${protocol}//${hostname}:${port}&#x60;;

        try {
          const controller &#x3D; new AbortController();
          const timeoutId &#x3D; setTimeout(() &#x3D;&amp;gt; controller.abort(), 2000);

          const response &#x3D; await fetch(&#x60;${testUrl}/health&#x60;, {
            signal: controller.signal,
          });

          clearTimeout(timeoutId);
          const responseTime &#x3D; Date.now() - startTime;

          return {
            port,
            status: response.ok ? (&amp;#39;success&amp;#39; as const) : (&amp;#39;error&amp;#39; as const),
            responseTime,
            error: response.ok ? undefined : &#x60;HTTP ${response.status}&#x60;,
          };
        } catch (error) {
          const responseTime &#x3D; Date.now() - startTime;

          if (error instanceof Error) {
            if (error.name &#x3D;&#x3D;&#x3D; &amp;#39;AbortError&amp;#39;) {
              return { port, status: &amp;#39;timeout&amp;#39; as const, responseTime };
            }

            if (error.message.includes(&amp;#39;ECONNREFUSED&amp;#39;)) {
              return { port, status: &amp;#39;refused&amp;#39; as const, responseTime };
            }
          }

          return {
            port,
            status: &amp;#39;error&amp;#39; as const,
            responseTime,
            error: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
          };
        }
      })
    );

    return {
      configuredUrl: this.config.apiUrl,
      commonPorts: COMMON_PORTS,
      networkTests,
    };
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-23">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/diff.ts</div>
                <div class="file-content">
                    <pre>import fs from &amp;#39;node:fs/promises&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;

export interface DiffOptions {
  migration?: boolean;
  format?: &amp;#39;text&amp;#39; | &amp;#39;json&amp;#39;;
  context?: number;
  summary?: boolean;
}

export interface SchemaChange {
  type: &amp;#39;added&amp;#39; | &amp;#39;removed&amp;#39; | &amp;#39;modified&amp;#39;;
  category: &amp;#39;constraint&amp;#39; | &amp;#39;field&amp;#39; | &amp;#39;import&amp;#39; | &amp;#39;package&amp;#39; | &amp;#39;comment&amp;#39;;
  location: string;
  old_value?: string;
  new_value?: string;
  impact: &amp;#39;breaking&amp;#39; | &amp;#39;compatible&amp;#39; | &amp;#39;neutral&amp;#39;;
  description: string;
  line_number?: number;
  migration_hint?: string;
}

export interface SchemaDiff {
  summary: {
    total_changes: number;
    breaking_changes: number;
    added: number;
    removed: number;
    modified: number;
  };
  changes: SchemaChange[];
  migration_needed: boolean;
  compatibility_score: number; // 0-100, higher is more compatible
}

/**
 * Parse CUE file and extract structural information
 */
async function parseCueStructure(filePath: string): Promise&amp;lt;Map&amp;lt;string, string&amp;gt;&amp;gt; {
  const content &#x3D; await fs.readFile(filePath, &amp;#39;utf-8&amp;#39;);
  const lines &#x3D; content.split(&amp;#39;\n&amp;#39;);
  const structure &#x3D; new Map&amp;lt;string, string&amp;gt;();

  const currentPath: string[] &#x3D; [];
  let inMultiLineComment &#x3D; false;
  let _braceDepth &#x3D; 0;

  for (let i &#x3D; 0; i &amp;lt; lines.length; i++) {
    const line &#x3D; lines[i];
    const trimmed &#x3D; line.trim();
    const _lineNumber &#x3D; i + 1;

    // Skip empty lines
    if (!trimmed) continue;

    // Handle multi-line comments
    if (trimmed.includes(&amp;#39;/*&amp;#39;)) {
      inMultiLineComment &#x3D; true;
      continue;
    }
    if (trimmed.includes(&amp;#39;*/&amp;#39;)) {
      inMultiLineComment &#x3D; false;
      continue;
    }
    if (inMultiLineComment) continue;

    // Skip single-line comments
    if (trimmed.startsWith(&amp;#39;//&amp;#39;)) continue;

    // Package declaration
    if (trimmed.startsWith(&amp;#39;package &amp;#39;)) {
      const packageName &#x3D; trimmed.replace(&amp;#39;package &amp;#39;, &amp;#39;&amp;#39;);
      structure.set(&amp;#39;package&amp;#39;, packageName);
      continue;
    }

    // Import statements
    if (trimmed.startsWith(&amp;#39;import &amp;#39;)) {
      const importMatch &#x3D; trimmed.match(/import\s+(?:(\w+)\s+)?&amp;quot;([^&amp;quot;]+)&amp;quot;/);
      if (importMatch) {
        const importPath &#x3D; importMatch[2];
        const importAlias &#x3D; importMatch[1] || path.basename(importPath);
        structure.set(&#x60;import.${importAlias}&#x60;, importPath);
      }
      continue;
    }

    // Field definitions and constraints
    const fieldMatch &#x3D; trimmed.match(/^(\w+):\s*(.+)$/);
    if (fieldMatch) {
      const fieldName &#x3D; fieldMatch[1];
      const fieldValue &#x3D; fieldMatch[2];
      const fullPath &#x3D; currentPath.length &amp;gt; 0 ? &#x60;${currentPath.join(&amp;#39;.&amp;#39;)}.${fieldName}&#x60; : fieldName;
      structure.set(fullPath, fieldValue);
      continue;
    }

    // Constraint definitions (starting with #)
    const constraintMatch &#x3D; trimmed.match(/^#(\w+):\s*\{?(.*)$/);
    if (constraintMatch) {
      const constraintName &#x3D; constraintMatch[1];
      const constraintValue &#x3D; constraintMatch[2];
      structure.set(&#x60;constraint.${constraintName}&#x60;, constraintValue);
      if (trimmed.endsWith(&amp;#39;{&amp;#39;)) {
        currentPath.push(&#x60;constraint.${constraintName}&#x60;);
        _braceDepth++;
      }
      continue;
    }

    // Handle braces for nesting
    const openBraces &#x3D; (line.match(/\{/g) || []).length;
    const closeBraces &#x3D; (line.match(/\}/g) || []).length;

    _braceDepth +&#x3D; openBraces - closeBraces;

    if (closeBraces &amp;gt; 0) {
      // Pop from current path for each closing brace
      for (let j &#x3D; 0; j &amp;lt; closeBraces; j++) {
        if (currentPath.length &amp;gt; 0) {
          currentPath.pop();
        }
      }
    }

    if (openBraces &amp;gt; closeBraces) {
      // This line opened more braces than it closed
      const fieldName &#x3D; trimmed.replace(/\s*\{.*$/, &amp;#39;&amp;#39;).replace(/:.*$/, &amp;#39;&amp;#39;);
      if (fieldName &amp;amp;&amp;amp; fieldName !&#x3D;&#x3D; trimmed) {
        const fullPath &#x3D;
          currentPath.length &amp;gt; 0 ? &#x60;${currentPath.join(&amp;#39;.&amp;#39;)}.${fieldName}&#x60; : fieldName;
        currentPath.push(fullPath);
      }
    }
  }

  return structure;
}

/**
 * Compare two schema structures and generate diff
 */
function compareSchemas(
  oldStructure: Map&amp;lt;string, string&amp;gt;,
  newStructure: Map&amp;lt;string, string&amp;gt;
): SchemaChange[] {
  const changes: SchemaChange[] &#x3D; [];
  const allKeys &#x3D; new Set([...oldStructure.keys(), ...newStructure.keys()]);

  for (const key of allKeys) {
    const oldValue &#x3D; oldStructure.get(key);
    const newValue &#x3D; newStructure.get(key);

    if (oldValue &amp;amp;&amp;amp; !newValue) {
      // Field was removed
      const change: SchemaChange &#x3D; {
        type: &amp;#39;removed&amp;#39;,
        category: getCategoryFromKey(key),
        location: key,
        old_value: oldValue,
        impact: getRemovalImpact(key, oldValue),
        description: &#x60;Removed ${getCategoryFromKey(key)}: ${key}&#x60;,
        migration_hint: getRemovalMigrationHint(key, oldValue),
      };
      changes.push(change);
    } else if (!oldValue &amp;amp;&amp;amp; newValue) {
      // Field was added
      const change: SchemaChange &#x3D; {
        type: &amp;#39;added&amp;#39;,
        category: getCategoryFromKey(key),
        location: key,
        new_value: newValue,
        impact: getAdditionImpact(key, newValue),
        description: &#x60;Added ${getCategoryFromKey(key)}: ${key}&#x60;,
        migration_hint: getAdditionMigrationHint(key, newValue),
      };
      changes.push(change);
    } else if (oldValue &amp;amp;&amp;amp; newValue &amp;amp;&amp;amp; oldValue !&#x3D;&#x3D; newValue) {
      // Field was modified
      const change: SchemaChange &#x3D; {
        type: &amp;#39;modified&amp;#39;,
        category: getCategoryFromKey(key),
        location: key,
        old_value: oldValue,
        new_value: newValue,
        impact: getModificationImpact(key, oldValue, newValue),
        description: &#x60;Modified ${getCategoryFromKey(key)}: ${key}&#x60;,
        migration_hint: getModificationMigrationHint(key, oldValue, newValue),
      };
      changes.push(change);
    }
  }

  return changes.sort((a, b) &#x3D;&amp;gt; {
    // Sort by impact (breaking first), then by location
    const impactOrder &#x3D; { breaking: 0, compatible: 1, neutral: 2 };
    if (impactOrder[a.impact] !&#x3D;&#x3D; impactOrder[b.impact]) {
      return impactOrder[a.impact] - impactOrder[b.impact];
    }
    return a.location.localeCompare(b.location);
  });
}

/**
 * Determine category from key path
 */
function getCategoryFromKey(key: string): SchemaChange[&amp;#39;category&amp;#39;] {
  if (key &#x3D;&#x3D;&#x3D; &amp;#39;package&amp;#39;) return &amp;#39;package&amp;#39;;
  if (key.startsWith(&amp;#39;import.&amp;#39;)) return &amp;#39;import&amp;#39;;
  if (key.startsWith(&amp;#39;constraint.&amp;#39;)) return &amp;#39;constraint&amp;#39;;
  if (key.includes(&amp;#39;validation&amp;#39;) || key.includes(&amp;#39;rules&amp;#39;) || key.includes(&amp;#39;limit&amp;#39;))
    return &amp;#39;constraint&amp;#39;;
  return &amp;#39;field&amp;#39;;
}

/**
 * Determine impact of removal
 */
function getRemovalImpact(key: string, _value: string): SchemaChange[&amp;#39;impact&amp;#39;] {
  if (key.startsWith(&amp;#39;constraint.&amp;#39;) || key.includes(&amp;#39;validation&amp;#39;) || key.includes(&amp;#39;required&amp;#39;)) {
    return &amp;#39;breaking&amp;#39;;
  }
  if (key.startsWith(&amp;#39;import.&amp;#39;)) {
    return &amp;#39;breaking&amp;#39;;
  }
  return &amp;#39;compatible&amp;#39;;
}

/**
 * Determine impact of addition
 */
function getAdditionImpact(key: string, value: string): SchemaChange[&amp;#39;impact&amp;#39;] {
  if (key.includes(&amp;#39;required&amp;#39;) || (key.includes(&amp;#39;constraint&amp;#39;) &amp;amp;&amp;amp; value.includes(&amp;#39;&amp;amp;&amp;#39;))) {
    return &amp;#39;breaking&amp;#39;;
  }
  return &amp;#39;compatible&amp;#39;;
}

/**
 * Determine impact of modification
 */
function getModificationImpact(
  key: string,
  oldValue: string,
  newValue: string
): SchemaChange[&amp;#39;impact&amp;#39;] {
  // Check for constraint tightening
  if (key.includes(&amp;#39;limit&amp;#39;) || key.includes(&amp;#39;constraint&amp;#39;)) {
    if (isConstraintTighter(oldValue, newValue)) {
      return &amp;#39;breaking&amp;#39;;
    }
  }

  // Check for type changes
  if (hasTypeChange(oldValue, newValue)) {
    return &amp;#39;breaking&amp;#39;;
  }

  return &amp;#39;compatible&amp;#39;;
}

/**
 * Check if constraint became tighter
 */
function isConstraintTighter(oldValue: string, newValue: string): boolean {
  // Extract numeric limits
  const oldLimit &#x3D; extractNumericValue(oldValue);
  const newLimit &#x3D; extractNumericValue(newValue);

  if (oldLimit !&#x3D;&#x3D; null &amp;amp;&amp;amp; newLimit !&#x3D;&#x3D; null) {
    // Check if limit became stricter
    if (oldValue.includes(&amp;#39;&amp;gt;&amp;#39;) &amp;amp;&amp;amp; newValue.includes(&amp;#39;&amp;gt;&amp;#39;)) {
      return newLimit &amp;gt; oldLimit; // Higher minimum is stricter
    }
    if (oldValue.includes(&amp;#39;&amp;lt;&amp;#39;) &amp;amp;&amp;amp; newValue.includes(&amp;#39;&amp;lt;&amp;#39;)) {
      return newLimit &amp;lt; oldLimit; // Lower maximum is stricter
    }
  }

  // Check for additional constraints
  const oldConstraints &#x3D; oldValue.split(&amp;#39;&amp;amp;&amp;#39;).length;
  const newConstraints &#x3D; newValue.split(&amp;#39;&amp;amp;&amp;#39;).length;
  return newConstraints &amp;gt; oldConstraints;
}

/**
 * Check if there&amp;#39;s a type change
 */
function hasTypeChange(oldValue: string, newValue: string): boolean {
  const oldType &#x3D; extractType(oldValue);
  const newType &#x3D; extractType(newValue);
  return oldType !&#x3D;&#x3D; newType &amp;amp;&amp;amp; oldType !&#x3D;&#x3D; null &amp;amp;&amp;amp; newType !&#x3D;&#x3D; null;
}

/**
 * Extract numeric value from constraint
 */
function extractNumericValue(value: string): number | null {
  const numMatch &#x3D; value.match(/([&amp;gt;&amp;lt;]&#x3D;?)\s*([0-9]+(?:\.[0-9]+)?)/);
  return numMatch ? Number.parseFloat(numMatch[2]) : null;
}

/**
 * Extract type from value
 */
function extractType(value: string): string | null {
  const typeMatch &#x3D; value.match(/\b(string|number|bool|int|float)\b/);
  return typeMatch ? typeMatch[1] : null;
}

/**
 * Generate migration hints
 */
function getRemovalMigrationHint(key: string, value: string): string {
  if (key.startsWith(&amp;#39;constraint.&amp;#39;)) {
    return &#x60;Update existing data to work without the ${key.replace(&amp;#39;constraint.&amp;#39;, &amp;#39;&amp;#39;)} constraint&#x60;;
  }
  if (key.startsWith(&amp;#39;import.&amp;#39;)) {
    return &#x60;Remove usage of ${value} from dependent schemas&#x60;;
  }
  return &#x60;Remove references to ${key} from configuration values&#x60;;
}

function getAdditionMigrationHint(key: string, _value: string): string {
  if (key.includes(&amp;#39;required&amp;#39;) || key.includes(&amp;#39;constraint&amp;#39;)) {
    return &#x60;Ensure existing data satisfies the new ${key} constraint&#x60;;
  }
  return &#x60;New field ${key} is available for use&#x60;;
}

function getModificationMigrationHint(key: string, oldValue: string, newValue: string): string {
  if (isConstraintTighter(oldValue, newValue)) {
    return &#x60;Update existing data to satisfy stricter constraint: ${newValue}&#x60;;
  }
  if (hasTypeChange(oldValue, newValue)) {
    return &#x60;Convert existing values from ${extractType(oldValue)} to ${extractType(newValue)}&#x60;;
  }
  return &#x60;Update references to ${key} to use new value: ${newValue}&#x60;;
}

/**
 * Calculate compatibility score
 */
function calculateCompatibilityScore(changes: SchemaChange[]): number {
  if (changes.length &#x3D;&#x3D;&#x3D; 0) return 100;

  let score &#x3D; 100;
  for (const change of changes) {
    switch (change.impact) {
      case &amp;#39;breaking&amp;#39;:
        score -&#x3D; 20;
        break;
      case &amp;#39;compatible&amp;#39;:
        score -&#x3D; 5;
        break;
      case &amp;#39;neutral&amp;#39;:
        score -&#x3D; 1;
        break;
    }
  }

  return Math.max(0, Math.min(100, score));
}

/**
 * Generate diff summary
 */
function generateSummary(changes: SchemaChange[]): SchemaDiff[&amp;#39;summary&amp;#39;] {
  const summary &#x3D; {
    total_changes: changes.length,
    breaking_changes: changes.filter(c &#x3D;&amp;gt; c.impact &#x3D;&#x3D;&#x3D; &amp;#39;breaking&amp;#39;).length,
    added: changes.filter(c &#x3D;&amp;gt; c.type &#x3D;&#x3D;&#x3D; &amp;#39;added&amp;#39;).length,
    removed: changes.filter(c &#x3D;&amp;gt; c.type &#x3D;&#x3D;&#x3D; &amp;#39;removed&amp;#39;).length,
    modified: changes.filter(c &#x3D;&amp;gt; c.type &#x3D;&#x3D;&#x3D; &amp;#39;modified&amp;#39;).length,
  };

  return summary;
}

/**
 * Format diff for text output
 */
function formatDiffText(diff: SchemaDiff, options: DiffOptions): string {
  let output &#x3D; &amp;#39;&amp;#39;;

  // Header
  output +&#x3D; chalk.cyan(&amp;#39;Schema Evolution Analysis\n&amp;#39;);
  output +&#x3D; &#x60;${chalk.dim(&amp;#39;&#x3D;&amp;#39;.repeat(50))}\n\n&#x60;;

  // Summary
  output +&#x3D; chalk.bold(&amp;#39;Summary:\n&amp;#39;);
  output +&#x3D; &#x60;  Total changes: ${diff.summary.total_changes}\n&#x60;;
  output +&#x3D; &#x60;  Breaking changes: ${chalk.red(diff.summary.breaking_changes)}\n&#x60;;
  output +&#x3D; &#x60;  Added: ${chalk.green(diff.summary.added)}\n&#x60;;
  output +&#x3D; &#x60;  Removed: ${chalk.red(diff.summary.removed)}\n&#x60;;
  output +&#x3D; &#x60;  Modified: ${chalk.yellow(diff.summary.modified)}\n&#x60;;
  output +&#x3D; &#x60;  Compatibility score: ${getCompatibilityColor(diff.compatibility_score)}${diff.compatibility_score}/100${chalk.reset()}\n&#x60;;
  output +&#x3D; &#x60;  Migration needed: ${diff.migration_needed ? chalk.red(&amp;#39;Yes&amp;#39;) : chalk.green(&amp;#39;No&amp;#39;)}\n\n&#x60;;

  if (options.summary) {
    return output;
  }

  // Changes
  if (diff.changes.length &amp;gt; 0) {
    output +&#x3D; chalk.bold(&amp;#39;Changes:\n\n&amp;#39;);

    for (const change of diff.changes) {
      const icon &#x3D; getChangeIcon(change.type, change.impact);
      const color &#x3D; getChangeColor(change.impact);

      output +&#x3D; &#x60;${icon} ${color}${change.description}${chalk.reset()}\n&#x60;;
      output +&#x3D; &#x60;  Location: ${chalk.dim(change.location)}\n&#x60;;

      if (change.old_value) {
        output +&#x3D; &#x60;  Old: ${chalk.red(change.old_value)}\n&#x60;;
      }
      if (change.new_value) {
        output +&#x3D; &#x60;  New: ${chalk.green(change.new_value)}\n&#x60;;
      }

      output +&#x3D; &#x60;  Impact: ${getImpactLabel(change.impact)}\n&#x60;;

      if (options.migration &amp;amp;&amp;amp; change.migration_hint) {
        output +&#x3D; &#x60;  Migration: ${chalk.yellow(change.migration_hint)}\n&#x60;;
      }

      output +&#x3D; &amp;#39;\n&amp;#39;;
    }
  } else {
    output +&#x3D; chalk.green(&amp;#39;âœ“ No changes detected\n&amp;#39;);
  }

  return output;
}

/**
 * Get appropriate color for compatibility score
 */
function getCompatibilityColor(score: number): string {
  if (score &amp;gt;&#x3D; 80) return chalk.green.toString();
  if (score &amp;gt;&#x3D; 60) return chalk.yellow.toString();
  return chalk.red.toString();
}

/**
 * Get icon for change type and impact
 */
function getChangeIcon(type: SchemaChange[&amp;#39;type&amp;#39;], impact: SchemaChange[&amp;#39;impact&amp;#39;]): string {
  if (impact &#x3D;&#x3D;&#x3D; &amp;#39;breaking&amp;#39;) return chalk.red(&amp;#39;ğŸ’¥&amp;#39;);

  switch (type) {
    case &amp;#39;added&amp;#39;:
      return chalk.green(&amp;#39;â•&amp;#39;);
    case &amp;#39;removed&amp;#39;:
      return chalk.red(&amp;#39;â–&amp;#39;);
    case &amp;#39;modified&amp;#39;:
      return chalk.yellow(&amp;#39;ğŸ”§&amp;#39;);
    default:
      return &amp;#39;â€¢&amp;#39;;
  }
}

/**
 * Get color for change impact
 */
function getChangeColor(impact: SchemaChange[&amp;#39;impact&amp;#39;]): typeof chalk.green {
  switch (impact) {
    case &amp;#39;breaking&amp;#39;:
      return chalk.red;
    case &amp;#39;compatible&amp;#39;:
      return chalk.green;
    case &amp;#39;neutral&amp;#39;:
      return chalk.dim;
    default:
      return chalk.white;
  }
}

/**
 * Get impact label
 */
function getImpactLabel(impact: SchemaChange[&amp;#39;impact&amp;#39;]): string {
  switch (impact) {
    case &amp;#39;breaking&amp;#39;:
      return chalk.red(&amp;#39;BREAKING&amp;#39;);
    case &amp;#39;compatible&amp;#39;:
      return chalk.green(&amp;#39;Compatible&amp;#39;);
    case &amp;#39;neutral&amp;#39;:
      return chalk.dim(&amp;#39;Neutral&amp;#39;);
    default:
      return &amp;#39;Unknown&amp;#39;;
  }
}

/**
 * Generate migration script
 */
function generateMigrationScript(diff: SchemaDiff): string {
  const breakingChanges &#x3D; diff.changes.filter(c &#x3D;&amp;gt; c.impact &#x3D;&#x3D;&#x3D; &amp;#39;breaking&amp;#39;);
  if (breakingChanges.length &#x3D;&#x3D;&#x3D; 0) {
    return &amp;#39;# No migration needed - all changes are backward compatible\n&amp;#39;;
  }

  let script &#x3D; &amp;#39;# Schema Migration Script\n&amp;#39;;
  script +&#x3D; &#x60;# Generated: ${new Date().toISOString()}\n\n&#x60;;
  script +&#x3D; &amp;#39;# Breaking changes require manual review and data migration\n\n&amp;#39;;

  for (const change of breakingChanges) {
    script +&#x3D; &#x60;# ${change.description}\n&#x60;;
    script +&#x3D; &#x60;# Location: ${change.location}\n&#x60;;
    if (change.migration_hint) {
      script +&#x3D; &#x60;# Action required: ${change.migration_hint}\n&#x60;;
    }
    script +&#x3D; &amp;#39;\n&amp;#39;;
  }

  return script;
}

/**
 * Diff command - Compare two schema versions
 */
export async function diffCommand(
  oldFile: string,
  newFile: string,
  options: DiffOptions &#x3D; {}
): Promise&amp;lt;number&amp;gt; {
  try {
    // Check if files exist
    try {
      await fs.access(oldFile);
      await fs.access(newFile);
    } catch (error) {
      console.error(
        chalk.red(&amp;#39;File not found:&amp;#39;),
        error instanceof Error ? error.message : String(error)
      );
      return 1;
    }

    console.log(chalk.dim(&#x60;Comparing ${oldFile} â†’ ${newFile}&#x60;));
    console.log();

    // Parse both schemas
    const oldStructure &#x3D; await parseCueStructure(oldFile);
    const newStructure &#x3D; await parseCueStructure(newFile);

    // Generate diff
    const changes &#x3D; compareSchemas(oldStructure, newStructure);
    const summary &#x3D; generateSummary(changes);
    const compatibilityScore &#x3D; calculateCompatibilityScore(changes);
    const migrationNeeded &#x3D; changes.some(c &#x3D;&amp;gt; c.impact &#x3D;&#x3D;&#x3D; &amp;#39;breaking&amp;#39;);

    const diff: SchemaDiff &#x3D; {
      summary,
      changes,
      migration_needed: migrationNeeded,
      compatibility_score: compatibilityScore,
    };

    // Output results
    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      console.log(JSON.stringify(diff, null, 2));
    } else {
      console.log(formatDiffText(diff, options));
    }

    // Generate migration script if requested
    if (options.migration &amp;amp;&amp;amp; diff.migration_needed) {
      const migrationScript &#x3D; generateMigrationScript(diff);
      const migrationPath &#x3D; &#x60;${path.basename(newFile, &amp;#39;.cue&amp;#39;)}-migration.md&#x60;;
      await fs.writeFile(migrationPath, migrationScript, &amp;#39;utf-8&amp;#39;);

      console.log(chalk.green(&#x60;âœ“ Migration guide created: ${migrationPath}&#x60;));
    }

    return diff.migration_needed ? 1 : 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Error comparing schemas:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-24">
                <div class="file-header">ğŸ“„ packages/cli/src/constraints/idempotency.ts</div>
                <div class="file-content">
                    <pre>import { createHash } from &amp;#39;node:crypto&amp;#39;;
import { ConstraintViolationError, globalConstraintEnforcer } from &amp;#39;./core.js&amp;#39;;

/**
 * Operation types that must be idempotent
 */
export type IdempotentOperation &#x3D;
  | &amp;#39;validate&amp;#39;
  | &amp;#39;export&amp;#39;
  | &amp;#39;transform&amp;#39;
  | &amp;#39;analyze&amp;#39;
  | &amp;#39;generate&amp;#39;
  | &amp;#39;bundle&amp;#39;
  | &amp;#39;diff&amp;#39;
  | &amp;#39;migrate&amp;#39;;

/**
 * Idempotency cache entry
 */
interface IdempotencyRecord {
  operation: string;
  inputHash: string;
  outputHash: string;
  timestamp: number;
  metadata: Record&amp;lt;string, unknown&amp;gt;;
}

/**
 * Idempotency validation options
 */
interface IdempotencyOptions {
  /** Maximum cache age in milliseconds */
  maxCacheAge?: number;
  /** Whether to ignore timestamp differences in comparison */
  ignoreTimestamps?: boolean;
  /** Custom comparison function */
  customComparator?: (a: unknown, b: unknown) &#x3D;&amp;gt; boolean;
}

/**
 * Idempotent operation validator
 * Implements &amp;quot;Don&amp;#39;t generate non-idempotent edits&amp;quot; constraint
 */
export class IdempotencyValidator {
  private readonly cache &#x3D; new Map&amp;lt;string, IdempotencyRecord&amp;gt;();
  private readonly defaultOptions: Required&amp;lt;IdempotencyOptions&amp;gt; &#x3D; {
    maxCacheAge: 5 * 60 * 1000, // 5 minutes
    ignoreTimestamps: true,
    customComparator: this.defaultComparator.bind(this),
  };

  /**
   * Validate that an operation produces idempotent results
   */
  async validateIdempotency&amp;lt;TInput, TOutput&amp;gt;(
    operation: IdempotentOperation,
    inputs: TInput,
    executor: (inputs: TInput) &#x3D;&amp;gt; Promise&amp;lt;TOutput&amp;gt;,
    options: IdempotencyOptions &#x3D; {},
    operationId?: string
  ): Promise&amp;lt;TOutput&amp;gt; {
    const opts &#x3D; { ...this.defaultOptions, ...options };
    const cacheKey &#x3D; this.generateCacheKey(operation, inputs);
    const cached &#x3D; this.cache.get(cacheKey);

    if (cached &amp;amp;&amp;amp; this.isCacheValid(cached, opts.maxCacheAge)) {
      return await this.validateCachedResult(
        cached,
        executor,
        inputs,
        operation,
        operationId,
        cacheKey
      );
    }

    return await this.executeAndCacheOperation(
      operation,
      inputs,
      executor,
      operationId,
      cacheKey,
      cached
    );
  }

  /**
   * Validate cached result by re-executing operation and comparing outputs
   */
  private async validateCachedResult&amp;lt;TInput, TOutput&amp;gt;(
    cached: IdempotencyRecord,
    executor: (inputs: TInput) &#x3D;&amp;gt; Promise&amp;lt;TOutput&amp;gt;,
    inputs: TInput,
    operation: IdempotentOperation,
    operationId?: string,
    cacheKey?: string
  ): Promise&amp;lt;TOutput&amp;gt; {
    const newResult &#x3D; await executor(inputs);
    const newOutputHash &#x3D; this.hashValue(newResult);

    if (cached.outputHash !&#x3D;&#x3D; newOutputHash) {
      this.throwIdempotencyViolation(&amp;#39;different output&amp;#39;, newOutputHash, cached.outputHash, {
        operationId,
        operation,
        cacheKey,
        cachedTimestamp: cached.timestamp,
        currentTimestamp: Date.now(),
        inputHash: cached.inputHash,
      });
    }

    this.emitIdempotencyVerified(operationId, operation, cacheKey);
    return newResult;
  }

  /**
   * Execute operation and cache the result
   */
  private async executeAndCacheOperation&amp;lt;TInput, TOutput&amp;gt;(
    operation: IdempotentOperation,
    inputs: TInput,
    executor: (inputs: TInput) &#x3D;&amp;gt; Promise&amp;lt;TOutput&amp;gt;,
    operationId?: string,
    cacheKey?: string,
    cached?: IdempotencyRecord
  ): Promise&amp;lt;TOutput&amp;gt; {
    const result &#x3D; await executor(inputs);
    const record &#x3D; this.createCacheRecord(operation, inputs, result, operationId);

    this.cache.set(cacheKey!, record);
    this.handleExpiredCacheValidation(cached, record, operation, operationId, cacheKey);
    this.emitCacheEvent(operationId, operation, cacheKey, record);

    return result;
  }

  /**
   * Create cache record for storing operation result
   */
  private createCacheRecord&amp;lt;TInput, TOutput&amp;gt;(
    operation: IdempotentOperation,
    inputs: TInput,
    result: TOutput,
    operationId?: string
  ): IdempotencyRecord {
    return {
      operation,
      inputHash: this.hashValue(inputs),
      outputHash: this.hashValue(result),
      timestamp: Date.now(),
      metadata: {
        operationId,
        inputType: typeof inputs,
        outputType: typeof result,
      },
    };
  }

  /**
   * Handle validation when cache was expired
   */
  private handleExpiredCacheValidation(
    cached: IdempotencyRecord | undefined,
    currentRecord: IdempotencyRecord,
    operation: IdempotentOperation,
    operationId?: string,
    cacheKey?: string
  ): void {
    if (cached &amp;amp;&amp;amp; cached.outputHash !&#x3D;&#x3D; currentRecord.outputHash) {
      this.emitConstraintViolation(
        &amp;#39;cache expired but results differ&amp;#39;,
        &amp;#39;consistent results across time&amp;#39;,
        {
          operationId,
          operation,
          cacheKey,
          previousHash: cached.outputHash,
          currentHash: currentRecord.outputHash,
        }
      );
    }
  }

  /**
   * Throw idempotency violation with proper error structure
   */
  private throwIdempotencyViolation(
    message: string,
    actual: string,
    expected: string,
    metadata: Record&amp;lt;string, unknown&amp;gt;
  ): never {
    const violation &#x3D; new ConstraintViolationError(
      &amp;#39;idempotency&amp;#39;,
      &#x60;${message}: ${actual}&#x60;,
      &#x60;consistent output: ${expected}&#x60;,
      metadata
    );

    globalConstraintEnforcer.emit(&amp;#39;constraint:violation&amp;#39;, {
      constraint: &amp;#39;idempotency&amp;#39;,
      violation,
      operation: metadata.operation,
    });

    throw violation;
  }

  /**
   * Emit constraint violation event
   */
  private emitConstraintViolation(
    message: string,
    expected: string,
    metadata: Record&amp;lt;string, unknown&amp;gt;
  ): void {
    const violation &#x3D; new ConstraintViolationError(&amp;#39;idempotency&amp;#39;, message, expected, metadata);

    globalConstraintEnforcer.emit(&amp;#39;constraint:violation&amp;#39;, {
      constraint: &amp;#39;idempotency&amp;#39;,
      violation,
      operation: metadata.operation,
    });
  }

  /**
   * Emit idempotency verified event
   */
  private emitIdempotencyVerified(
    operationId?: string,
    operation?: IdempotentOperation,
    cacheKey?: string
  ): void {
    globalConstraintEnforcer.emit(&amp;#39;idempotency:verified&amp;#39;, {
      operationId,
      operation,
      cacheKey,
      consistent: true,
    });
  }

  /**
   * Emit cache event for successful operation
   */
  private emitCacheEvent(
    operationId?: string,
    operation?: IdempotentOperation,
    cacheKey?: string,
    record?: IdempotencyRecord
  ): void {
    globalConstraintEnforcer.emit(&amp;#39;idempotency:cached&amp;#39;, {
      operationId,
      operation,
      cacheKey,
      inputHash: record?.inputHash,
      outputHash: record?.outputHash,
    });
  }

  /**
   * Validate that repeated execution produces identical results
   */
  async validateRepeatedExecution&amp;lt;TInput, TOutput&amp;gt;(
    operation: IdempotentOperation,
    inputs: TInput,
    executor: (inputs: TInput) &#x3D;&amp;gt; Promise&amp;lt;TOutput&amp;gt;,
    repetitions &#x3D; 2,
    operationId?: string
  ): Promise&amp;lt;TOutput&amp;gt; {
    const validatedRepetitions &#x3D; this.validateAndGetRepetitions(repetitions);
    const executionResults &#x3D; await this.performRepeatedExecution(
      operation,
      inputs,
      executor,
      validatedRepetitions,
      operationId
    );

    return this.processExecutionResults(
      executionResults,
      operation,
      validatedRepetitions,
      operationId
    );
  }

  /**
   * Validate and return the repetition count
   */
  private validateAndGetRepetitions(repetitions: number): number {
    this.validateRepetitionCount(repetitions);
    return repetitions;
  }

  /**
   * Perform the repeated execution and collect results
   */
  private async performRepeatedExecution&amp;lt;TInput, TOutput&amp;gt;(
    operation: IdempotentOperation,
    inputs: TInput,
    executor: (inputs: TInput) &#x3D;&amp;gt; Promise&amp;lt;TOutput&amp;gt;,
    repetitions: number,
    operationId?: string
  ): Promise&amp;lt;{ results: TOutput[]; hashes: string[] }&amp;gt; {
    return await this.executeRepeatedOperations(
      operation,
      inputs,
      executor,
      repetitions,
      operationId
    );
  }

  /**
   * Process execution results and return the first result
   */
  private processExecutionResults&amp;lt;TOutput&amp;gt;(
    executionResults: { results: TOutput[]; hashes: string[] },
    operation: IdempotentOperation,
    repetitions: number,
    operationId?: string
  ): TOutput {
    this.validateResultConsistency(executionResults.hashes, operation, repetitions, operationId);

    this.emitValidationSuccess(operation, repetitions, operationId, executionResults.hashes[0]);

    return executionResults.results[0];
  }

  /**
   * Validate repetition count is sufficient for testing
   */
  private validateRepetitionCount(repetitions: number): void {
    if (repetitions &amp;lt; 2) {
      throw new Error(&amp;#39;Repetitions must be at least 2 for idempotency validation&amp;#39;);
    }
  }

  /**
   * Execute operation multiple times and collect results
   */
  private async executeRepeatedOperations&amp;lt;TInput, TOutput&amp;gt;(
    operation: IdempotentOperation,
    inputs: TInput,
    executor: (inputs: TInput) &#x3D;&amp;gt; Promise&amp;lt;TOutput&amp;gt;,
    repetitions: number,
    operationId?: string
  ): Promise&amp;lt;{ results: TOutput[]; hashes: string[] }&amp;gt; {
    const results: TOutput[] &#x3D; [];
    const hashes: string[] &#x3D; [];

    for (let i &#x3D; 0; i &amp;lt; repetitions; i++) {
      const result &#x3D; await this.executeSingleIteration(
        operation,
        inputs,
        executor,
        i,
        repetitions,
        operationId
      );

      const resultHash &#x3D; this.hashValue(result);
      results.push(result);
      hashes.push(resultHash);
    }

    return { results, hashes };
  }

  /**
   * Execute a single iteration with proper error handling
   */
  private async executeSingleIteration&amp;lt;TInput, TOutput&amp;gt;(
    operation: IdempotentOperation,
    inputs: TInput,
    executor: (inputs: TInput) &#x3D;&amp;gt; Promise&amp;lt;TOutput&amp;gt;,
    iteration: number,
    totalRepetitions: number,
    operationId?: string
  ): Promise&amp;lt;TOutput&amp;gt; {
    const iterationId &#x3D; globalConstraintEnforcer.startOperation(
      &#x60;${operation}:repeat:${iteration}&#x60;,
      {
        operationId,
        iteration,
        totalRepetitions,
      }
    );

    try {
      const result &#x3D; await executor(inputs);
      globalConstraintEnforcer.endOperation(iterationId);
      return result;
    } catch (error) {
      globalConstraintEnforcer.endOperation(iterationId);
      throw error;
    }
  }

  /**
   * Validate that all execution results are consistent
   */
  private validateResultConsistency(
    hashes: string[],
    operation: IdempotentOperation,
    repetitions: number,
    operationId?: string
  ): void {
    const firstHash &#x3D; hashes[0];

    for (let i &#x3D; 1; i &amp;lt; hashes.length; i++) {
      if (hashes[i] !&#x3D;&#x3D; firstHash) {
        this.handleInconsistentResult(i, hashes, firstHash, operation, repetitions, operationId);
      }
    }
  }

  /**
   * Handle inconsistent result by creating and throwing violation
   */
  private handleInconsistentResult(
    divergentIteration: number,
    allHashes: string[],
    expectedHash: string,
    operation: IdempotentOperation,
    repetitions: number,
    operationId?: string
  ): never {
    const violation &#x3D; new ConstraintViolationError(
      &amp;#39;idempotency&amp;#39;,
      &#x60;iteration ${divergentIteration} hash: ${allHashes[divergentIteration]}&#x60;,
      &#x60;consistent hash: ${expectedHash}&#x60;,
      {
        operationId,
        operation,
        repetitions,
        allHashes,
        divergentIteration,
      }
    );

    globalConstraintEnforcer.emit(&amp;#39;constraint:violation&amp;#39;, {
      constraint: &amp;#39;idempotency&amp;#39;,
      violation,
      operation,
    });

    throw violation;
  }

  /**
   * Emit success event for validated repeated execution
   */
  private emitValidationSuccess(
    operation: IdempotentOperation,
    repetitions: number,
    operationId: string | undefined,
    resultHash: string
  ): void {
    globalConstraintEnforcer.emit(&amp;#39;idempotency:repeated_validated&amp;#39;, {
      operationId,
      operation,
      repetitions,
      consistent: true,
      resultHash,
    });
  }

  /**
   * Track edit operations to ensure they produce idempotent results
   */
  async validateEditIdempotency&amp;lt;TInput, TEdit&amp;gt;(
    operation: IdempotentOperation,
    baseContent: TInput,
    editFunction: (content: TInput) &#x3D;&amp;gt; Promise&amp;lt;TEdit&amp;gt;,
    applyEdit: (content: TInput, edit: TEdit) &#x3D;&amp;gt; Promise&amp;lt;TInput&amp;gt;,
    operationId?: string
  ): Promise&amp;lt;{ finalContent: TInput; edit: TEdit }&amp;gt; {
    // Generate edit
    const edit &#x3D; await editFunction(baseContent);

    // Apply edit to get result
    const editedContent &#x3D; await applyEdit(baseContent, edit);

    // Re-apply the same edit to verify idempotency
    const secondEdit &#x3D; await editFunction(baseContent);
    const secondEditedContent &#x3D; await applyEdit(baseContent, secondEdit);

    // Compare edit operations
    const editHash1 &#x3D; this.hashValue(edit);
    const editHash2 &#x3D; this.hashValue(secondEdit);

    if (editHash1 !&#x3D;&#x3D; editHash2) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;idempotency&amp;#39;,
        &amp;#39;non-deterministic edit generation&amp;#39;,
        &amp;#39;consistent edit operations&amp;#39;,
        {
          operationId,
          operation,
          firstEditHash: editHash1,
          secondEditHash: editHash2,
          baseContentHash: this.hashValue(baseContent),
        }
      );

      globalConstraintEnforcer.emit(&amp;#39;constraint:violation&amp;#39;, {
        constraint: &amp;#39;idempotency&amp;#39;,
        violation,
        operation,
      });

      throw violation;
    }

    // Compare final results
    const resultHash1 &#x3D; this.hashValue(editedContent);
    const resultHash2 &#x3D; this.hashValue(secondEditedContent);

    if (resultHash1 !&#x3D;&#x3D; resultHash2) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;idempotency&amp;#39;,
        &amp;#39;non-deterministic edit application&amp;#39;,
        &amp;#39;consistent edit results&amp;#39;,
        {
          operationId,
          operation,
          firstResultHash: resultHash1,
          secondResultHash: resultHash2,
          editHash: editHash1,
        }
      );

      globalConstraintEnforcer.emit(&amp;#39;constraint:violation&amp;#39;, {
        constraint: &amp;#39;idempotency&amp;#39;,
        violation,
        operation,
      });

      throw violation;
    }

    globalConstraintEnforcer.emit(&amp;#39;idempotency:edit_validated&amp;#39;, {
      operationId,
      operation,
      editHash: editHash1,
      resultHash: resultHash1,
      consistent: true,
    });

    return { finalContent: editedContent, edit };
  }

  /**
   * Clear expired cache entries
   */
  clearExpiredCache(): number {
    const _now &#x3D; Date.now();
    let cleared &#x3D; 0;

    for (const [key, record] of this.cache.entries()) {
      if (!this.isCacheValid(record, this.defaultOptions.maxCacheAge)) {
        this.cache.delete(key);
        cleared++;
      }
    }

    globalConstraintEnforcer.emit(&amp;#39;idempotency:cache_cleared&amp;#39;, {
      entriesCleared: cleared,
      remainingEntries: this.cache.size,
    });

    return cleared;
  }

  /**
   * Get idempotency validation statistics
   */
  getValidationStats(): {
    cacheSize: number;
    validations: number;
    violations: number;
    cacheHitRate: number;
  } {
    return {
      cacheSize: this.cache.size,
      validations: 0, // Would be tracked via event listeners
      violations: 0, // Would be tracked via event listeners
      cacheHitRate: 0, // Would be calculated from event data
    };
  }

  /**
   * Generate cache key for operation and inputs
   */
  private generateCacheKey&amp;lt;T&amp;gt;(operation: string, inputs: T): string {
    const inputHash &#x3D; this.hashValue(inputs);
    return &#x60;${operation}:${inputHash}&#x60;;
  }

  /**
   * Hash any value for consistent comparison
   */
  private hashValue(value: unknown): string {
    let serialized: string;

    if (typeof value &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39;) {
      serialized &#x3D; value;
    } else if (Buffer.isBuffer(value)) {
      serialized &#x3D; value.toString(&amp;#39;base64&amp;#39;);
    } else {
      // Normalize object for consistent hashing
      serialized &#x3D; JSON.stringify(this.normalizeForHashing(value));
    }

    return createHash(&amp;#39;sha256&amp;#39;).update(serialized, &amp;#39;utf8&amp;#39;).digest(&amp;#39;hex&amp;#39;);
  }

  /**
   * Normalize value for consistent hashing (sort keys, handle timestamps)
   */
  private normalizeForHashing(value: unknown): unknown {
    if (value &#x3D;&#x3D;&#x3D; null || value &#x3D;&#x3D;&#x3D; undefined) {
      return value;
    }

    if (typeof value !&#x3D;&#x3D; &amp;#39;object&amp;#39;) {
      return value;
    }

    if (Array.isArray(value)) {
      return value.map(item &#x3D;&amp;gt; this.normalizeForHashing(item));
    }

    if (value instanceof Date) {
      // Optionally ignore timestamps for idempotency
      return this.defaultOptions.ignoreTimestamps ? &amp;#39;[TIMESTAMP]&amp;#39; : value.toISOString();
    }

    const obj &#x3D; value as Record&amp;lt;string, unknown&amp;gt;;
    const normalized: Record&amp;lt;string, unknown&amp;gt; &#x3D; {};

    // Sort keys for consistent ordering
    const sortedKeys &#x3D; Object.keys(obj).sort();

    for (const key of sortedKeys) {
      // Skip timestamp fields if configured to ignore them
      if (this.defaultOptions.ignoreTimestamps &amp;amp;&amp;amp; this.isTimestampField(key)) {
        normalized[key] &#x3D; &amp;#39;[TIMESTAMP]&amp;#39;;
      } else {
        normalized[key] &#x3D; this.normalizeForHashing(obj[key]);
      }
    }

    return normalized;
  }

  /**
   * Check if a field name represents a timestamp
   */
  private isTimestampField(fieldName: string): boolean {
    const timestampFields &#x3D; [
      &amp;#39;timestamp&amp;#39;,
      &amp;#39;createdAt&amp;#39;,
      &amp;#39;updatedAt&amp;#39;,
      &amp;#39;modifiedAt&amp;#39;,
      &amp;#39;date&amp;#39;,
      &amp;#39;time&amp;#39;,
      &amp;#39;created_at&amp;#39;,
      &amp;#39;updated_at&amp;#39;,
      &amp;#39;modified_at&amp;#39;,
      &amp;#39;processed_at&amp;#39;,
    ];

    return timestampFields.includes(fieldName.toLowerCase());
  }

  /**
   * Check if cache entry is still valid
   */
  private isCacheValid(record: IdempotencyRecord, maxAge: number): boolean {
    return Date.now() - record.timestamp &amp;lt;&#x3D; maxAge;
  }

  /**
   * Default comparison function
   */
  private defaultComparator(a: unknown, b: unknown): boolean {
    return this.hashValue(a) &#x3D;&#x3D;&#x3D; this.hashValue(b);
  }
}

/**
 * Global idempotency validator instance
 */
export const globalIdempotencyValidator &#x3D; new IdempotencyValidator();

/**
 * Decorator for automatic idempotency validation
 */
export function idempotent(operation: IdempotentOperation, options: IdempotencyOptions &#x3D; {}) {
  return &amp;lt;T extends (...args: any[]) &#x3D;&amp;gt; Promise&amp;lt;any&amp;gt;&amp;gt;(
    _target: any,
    propertyName: string,
    descriptor: TypedPropertyDescriptor&amp;lt;T&amp;gt;
  ) &#x3D;&amp;gt; {
    const method &#x3D; descriptor.value!;

    descriptor.value &#x3D; async function (this: any, ...args: any[]) {
      const operationId &#x3D; globalConstraintEnforcer.startOperation(&#x60;idempotent:${operation}&#x60;, {
        method: propertyName,
        args: args.length,
      });

      try {
        const result &#x3D; await globalIdempotencyValidator.validateIdempotency(
          operation,
          args, // Use args as inputs
          async () &#x3D;&amp;gt; method.apply(this, args),
          options,
          operationId
        );

        globalConstraintEnforcer.endOperation(operationId);
        return result;
      } catch (error) {
        globalConstraintEnforcer.endOperation(operationId);
        throw error;
      }
    } as T;

    return descriptor;
  };
}

/**
 * Utility function to wrap any operation with idempotency validation
 */
export async function withIdempotencyValidation&amp;lt;TInput, TOutput&amp;gt;(
  operation: IdempotentOperation,
  inputs: TInput,
  executor: (inputs: TInput) &#x3D;&amp;gt; Promise&amp;lt;TOutput&amp;gt;,
  options: IdempotencyOptions &#x3D; {}
): Promise&amp;lt;TOutput&amp;gt; {
  return globalIdempotencyValidator.validateIdempotency(operation, inputs, executor, options);
}

/**
 * Utility for validating edit operations are idempotent
 */
export async function validateIdempotentEdits&amp;lt;TContent, TEdit&amp;gt;(
  operation: IdempotentOperation,
  baseContent: TContent,
  editFunction: (content: TContent) &#x3D;&amp;gt; Promise&amp;lt;TEdit&amp;gt;,
  applyEdit: (content: TContent, edit: TEdit) &#x3D;&amp;gt; Promise&amp;lt;TContent&amp;gt;
): Promise&amp;lt;{ finalContent: TContent; edit: TEdit }&amp;gt; {
  return globalIdempotencyValidator.validateEditIdempotency(
    operation,
    baseContent,
    editFunction,
    applyEdit
  );
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-25">
                <div class="file-header">ğŸ“„ apps/api/src/auth.ts</div>
                <div class="file-content">
                    <pre>/**
 * Authentication and authorization module
 */
import type { AuthContext, ServerConfig } from &amp;#39;./types.ts&amp;#39;;
import { logger, parseBearerToken } from &amp;#39;./utils.ts&amp;#39;;

export class AuthService {
  private validTokens: Set&amp;lt;string&amp;gt; &#x3D; new Set();
  private tokenToUserMap: Map&amp;lt;string, string&amp;gt; &#x3D; new Map();
  private userProjectAccess: Map&amp;lt;string, string[]&amp;gt; &#x3D; new Map();

  constructor(private config: ServerConfig) {
    // Initialize with some default tokens for development
    if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &amp;#39;development&amp;#39;) {
      this.addToken(&amp;#39;dev-token&amp;#39;, &amp;#39;dev-user&amp;#39;, [&amp;#39;*&amp;#39;]);
      logger.info(&amp;#39;Development mode: added default auth token&amp;#39;);
    }
  }

  /**
   * Add a valid token with user and project access
   */
  addToken(token: string, userId: string, projectAccess: string[] &#x3D; []): void {
    this.validTokens.add(token);
    this.tokenToUserMap.set(token, userId);
    this.userProjectAccess.set(userId, projectAccess);

    logger.info(&amp;#39;Token added for user&amp;#39;, {
      userId,
      projectCount: projectAccess.length,
    });
  }

  /**
   * Remove a token
   */
  removeToken(token: string): void {
    const userId &#x3D; this.tokenToUserMap.get(token);

    this.validTokens.delete(token);
    this.tokenToUserMap.delete(token);

    if (userId) {
      this.userProjectAccess.delete(userId);
      logger.info(&amp;#39;Token removed for user&amp;#39;, { userId });
    }
  }

  /**
   * Validate token and return auth context
   */
  validateToken(token: string): AuthContext | null {
    if (!this.validTokens.has(token)) {
      return null;
    }

    const userId &#x3D; this.tokenToUserMap.get(token);
    const projectAccess &#x3D; userId ? (this.userProjectAccess.get(userId) ?? []) : [];

    return {
      token,
      user_id: userId,
      project_access: projectAccess,
    };
  }

  /**
   * Check if user has access to a specific project
   */
  hasProjectAccess(authContext: AuthContext, projectId: string): boolean {
    // Wildcard access
    if (authContext.project_access.includes(&amp;#39;*&amp;#39;)) {
      return true;
    }

    // Specific project access
    return authContext.project_access.includes(projectId);
  }

  /**
   * Extract and validate auth context from request headers
   */
  async authenticateRequest(headers: Headers): Promise&amp;lt;AuthContext | null&amp;gt; {
    if (!this.config.auth_required) {
      // Return a default context when auth is disabled
      return {
        token: &amp;#39;no-auth&amp;#39;,
        user_id: &amp;#39;anonymous&amp;#39;,
        project_access: [&amp;#39;*&amp;#39;],
      };
    }

    const authHeader &#x3D; headers.get(&amp;#39;authorization&amp;#39;);
    const token &#x3D; parseBearerToken(authHeader ?? undefined);

    if (!token) {
      return null;
    }

    return this.validateToken(token);
  }

  /**
   * Create auth middleware for HTTP requests
   */
  createAuthMiddleware() {
    return async (
      request: Request
    ): Promise&amp;lt;{
      authorized: boolean;
      authContext?: AuthContext;
      response?: Response;
    }&amp;gt; &#x3D;&amp;gt; {
      try {
        const authContext &#x3D; await this.authenticateRequest(request.headers);

        if (!authContext) {
          return {
            authorized: false,
            response: new Response(
              JSON.stringify({
                type: &amp;#39;https://httpstatuses.com/401&amp;#39;,
                title: &amp;#39;Unauthorized&amp;#39;,
                status: 401,
                detail: &amp;#39;Valid bearer token required&amp;#39;,
              }),
              {
                status: 401,
                headers: {
                  &amp;#39;Content-Type&amp;#39;: &amp;#39;application/problem+json&amp;#39;,
                  &amp;#39;WWW-Authenticate&amp;#39;: &amp;#39;Bearer&amp;#39;,
                },
              }
            ),
          };
        }

        return { authorized: true, authContext };
      } catch (error) {
        logger.error(&amp;#39;Auth middleware error&amp;#39;, error instanceof Error ? error : undefined);

        return {
          authorized: false,
          response: new Response(
            JSON.stringify({
              type: &amp;#39;https://httpstatuses.com/500&amp;#39;,
              title: &amp;#39;Internal Server Error&amp;#39;,
              status: 500,
              detail: &amp;#39;Authentication service error&amp;#39;,
            }),
            {
              status: 500,
              headers: { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/problem+json&amp;#39; },
            }
          ),
        };
      }
    };
  }

  /**
   * Create project access middleware
   */
  createProjectAccessMiddleware() {
    return (
      authContext: AuthContext,
      projectId: string
    ): {
      authorized: boolean;
      response?: Response;
    } &#x3D;&amp;gt; {
      if (!this.hasProjectAccess(authContext, projectId)) {
        return {
          authorized: false,
          response: new Response(
            JSON.stringify({
              type: &amp;#39;https://httpstatuses.com/403&amp;#39;,
              title: &amp;#39;Forbidden&amp;#39;,
              status: 403,
              detail: &#x60;Access denied to project: ${projectId}&#x60;,
            }),
            {
              status: 403,
              headers: { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/problem+json&amp;#39; },
            }
          ),
        };
      }

      return { authorized: true };
    };
  }

  /**
   * Get user info for a token
   */
  getUserInfo(token: string): { userId?: string; projectAccess: string[] } | null {
    const userId &#x3D; this.tokenToUserMap.get(token);
    if (!userId) {
      return null;
    }

    return {
      userId,
      projectAccess: this.userProjectAccess.get(userId) ?? [],
    };
  }

  /**
   * List all active tokens (for admin purposes)
   */
  listTokens(): Array&amp;lt;{
    token: string;
    userId?: string;
    projectCount: number;
  }&amp;gt; {
    return Array.from(this.validTokens).map(token &#x3D;&amp;gt; {
      const userId &#x3D; this.tokenToUserMap.get(token);
      const projectAccess &#x3D; userId ? (this.userProjectAccess.get(userId) ?? []) : [];

      return {
        token: &#x60;${token.substring(0, 8)}...&#x60;, // Partial token for security
        userId,
        projectCount: projectAccess.length,
      };
    });
  }

  /**
   * Start OAuth service if enabled (placeholder when OAuth is disabled)
   */
  async startOAuthService(): Promise&amp;lt;void&amp;gt; {
    // OAuth functionality requires SuperTokens integration
    // Currently disabled - no OAuth service to start
  }

  /**
   * Stop OAuth service if enabled (placeholder when OAuth is disabled)
   */
  async stopOAuthService(): Promise&amp;lt;void&amp;gt; {
    // OAuth functionality requires SuperTokens integration
    // Currently disabled - no OAuth service to stop
  }

  /**
   * Get OAuth service instance (placeholder when OAuth is disabled)
   */
  getOAuthService(): undefined {
    return undefined;
  }

  /**
   * Get protected resource metadata for OAuth (placeholder when OAuth is disabled)
   */
  getProtectedResourceMetadata(): undefined {
    return undefined;
  }

  /**
   * Get OAuth authorization server instance (placeholder when OAuth is disabled)
   */
  getAuthorizationServer(): undefined {
    return undefined;
  }

  /**
   * Get OAuth provider instance (placeholder when OAuth is disabled)
   */
  getOAuthProvider(): undefined {
    return undefined;
  }

  /**
   * Create OAuth-aware auth middleware (falls back to regular auth when OAuth is disabled)
   */
  createOAuthAwareAuthMiddleware() {
    // When OAuth is disabled, fall back to regular auth middleware
    return this.createAuthMiddleware();
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-26">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/sync.ts</div>
                <div class="file-content">
                    <pre>import crypto from &amp;#39;node:crypto&amp;#39;;
import fs from &amp;#39;node:fs/promises&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import packageJson from &amp;#39;../../package.json&amp;#39; with { type: &amp;#39;json&amp;#39; };
import type { CLIConfig, SyncOptions } from &amp;#39;../types.js&amp;#39;;

interface ManifestFile {
  path: string;
  type: &amp;#39;package.json&amp;#39; | &amp;#39;pyproject.toml&amp;#39; | &amp;#39;Cargo.toml&amp;#39; | &amp;#39;Makefile&amp;#39;;
  exists: boolean;
  language: string;
}

interface ConflictResolution {
  path: string;
  type: &amp;#39;value_conflict&amp;#39; | &amp;#39;section_exists&amp;#39; | &amp;#39;section_replaced&amp;#39; | &amp;#39;merge_required&amp;#39; | &amp;#39;error&amp;#39;;
  resolution:
    | &amp;#39;merged&amp;#39;
    | &amp;#39;preserved_existing&amp;#39;
    | &amp;#39;replaced_with_template&amp;#39;
    | &amp;#39;replaced_with_source&amp;#39;
    | &amp;#39;failed&amp;#39;;
  applied?: boolean;
  details: string;
}

interface SyncResult {
  modified: boolean;
  conflicts: ConflictResolution[];
  checksum: string;
  backupPath?: string;
}

interface ChangeSet {
  added: Record&amp;lt;string, any&amp;gt;;
  modified: Record&amp;lt;string, { from: any; to: any }&amp;gt;;
  removed: Record&amp;lt;string, any&amp;gt;;
}

/**
 * Detect manifest files in the project
 */
async function detectManifestFiles(projectPath: string): Promise&amp;lt;ManifestFile[]&amp;gt; {
  const manifests: ManifestFile[] &#x3D; [
    { path: &amp;#39;package.json&amp;#39;, type: &amp;#39;package.json&amp;#39;, exists: false, language: &amp;#39;typescript&amp;#39; },
    { path: &amp;#39;pyproject.toml&amp;#39;, type: &amp;#39;pyproject.toml&amp;#39;, exists: false, language: &amp;#39;python&amp;#39; },
    { path: &amp;#39;Cargo.toml&amp;#39;, type: &amp;#39;Cargo.toml&amp;#39;, exists: false, language: &amp;#39;rust&amp;#39; },
    { path: &amp;#39;Makefile&amp;#39;, type: &amp;#39;Makefile&amp;#39;, exists: false, language: &amp;#39;bash&amp;#39; },
  ];

  for (const manifest of manifests) {
    const fullPath &#x3D; path.join(projectPath, manifest.path);
    try {
      await fs.access(fullPath);
      manifest.exists &#x3D; true;
    } catch {
      manifest.exists &#x3D; false;
    }
  }

  return manifests.filter(m &#x3D;&amp;gt; m.exists);
}

/**
 * Calculate file checksum for idempotency validation
 */
function calculateChecksum(content: string): string {
  return crypto.createHash(&amp;#39;sha256&amp;#39;).update(content).digest(&amp;#39;hex&amp;#39;).substring(0, 16);
}

/**
 * Create backup of a file with timestamp
 */
async function createBackup(filePath: string): Promise&amp;lt;string&amp;gt; {
  const timestamp &#x3D; new Date().toISOString().replace(/[:.]/g, &amp;#39;-&amp;#39;);
  const backupPath &#x3D; &#x60;${filePath}.backup.${timestamp}&#x60;;
  await fs.copyFile(filePath, backupPath);
  return backupPath;
}

/**
 * Deep merge objects, handling conflicts intelligently
 */
function deepMerge(
  target: any,
  source: any,
  conflicts: ConflictResolution[],
  path &#x3D; &amp;#39;&amp;#39;,
  force &#x3D; false
): any {
  const result &#x3D; { ...target };

  for (const key in source) {
    const currentPath &#x3D; path ? &#x60;${path}.${key}&#x60; : key;

    if (!(key in result)) {
      // New property - safe to add
      result[key] &#x3D; source[key];
    } else if (
      typeof source[key] &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp;
      typeof result[key] &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp;
      !Array.isArray(source[key])
    ) {
      // Both objects - recursive merge
      result[key] &#x3D; deepMerge(result[key], source[key], conflicts, currentPath, force);
    } else if (JSON.stringify(result[key]) !&#x3D;&#x3D; JSON.stringify(source[key])) {
      // Conflict detected
      if (force) {
        conflicts.push({
          path: currentPath,
          type: &amp;#39;value_conflict&amp;#39;,
          resolution: &amp;#39;replaced_with_source&amp;#39;,
          applied: true,
          details: &#x60;Overwrote ${currentPath}: ${JSON.stringify(result[key])} â†’ ${JSON.stringify(source[key])}&#x60;,
        });
        result[key] &#x3D; source[key];
      } else {
        conflicts.push({
          path: currentPath,
          type: &amp;#39;value_conflict&amp;#39;,
          resolution: &amp;#39;preserved_existing&amp;#39;,
          applied: false,
          details: &#x60;Preserved existing ${currentPath}: ${JSON.stringify(result[key])} (would be ${JSON.stringify(source[key])})&#x60;,
        });
      }
    }
  }

  return result;
}

/**
 * Generate change set showing what would be modified
 */
function generateChangeSet(original: any, modified: any): ChangeSet {
  const changeSet: ChangeSet &#x3D; {
    added: {},
    modified: {},
    removed: {},
  };

  // Find added and modified keys
  for (const key in modified) {
    if (!(key in original)) {
      changeSet.added[key] &#x3D; modified[key];
    } else if (JSON.stringify(original[key]) !&#x3D;&#x3D; JSON.stringify(modified[key])) {
      changeSet.modified[key] &#x3D; {
        from: original[key],
        to: modified[key],
      };
    }
  }

  // Find removed keys
  for (const key in original) {
    if (!(key in modified)) {
      changeSet.removed[key] &#x3D; original[key];
    }
  }

  return changeSet;
}

/**
 * Validate that sync operation is idempotent
 */
async function validateIdempotency(filePath: string, expectedChecksum: string): Promise&amp;lt;boolean&amp;gt; {
  try {
    const currentContent &#x3D; await fs.readFile(filePath, &amp;#39;utf8&amp;#39;);
    const currentChecksum &#x3D; calculateChecksum(currentContent);
    return currentChecksum &#x3D;&#x3D;&#x3D; expectedChecksum;
  } catch {
    return false;
  }
}

/**
 * Enhanced sync package.json with intelligent conflict resolution
 */
/**
 * Load and parse package.json content
 */
async function loadPackageJson(filePath: string): Promise&amp;lt;{
  originalContent: string;
  originalPkg: any;
  originalChecksum: string;
}&amp;gt; {
  const originalContent &#x3D; await fs.readFile(filePath, &amp;#39;utf8&amp;#39;);
  const originalPkg &#x3D; JSON.parse(originalContent);
  const originalChecksum &#x3D; calculateChecksum(originalContent);

  return { originalContent, originalPkg, originalChecksum };
}

/**
 * Get Arbiter configuration updates for package.json
 */
function getArbiterPackageUpdates() {
  return {
    scripts: {
      &amp;#39;arbiter:check&amp;#39;: &amp;#39;arbiter check&amp;#39;,
      &amp;#39;arbiter:watch&amp;#39;: &amp;#39;arbiter watch&amp;#39;,
      &amp;#39;arbiter:surface&amp;#39;: &amp;#39;arbiter surface typescript --output surface.json&amp;#39;,
      &amp;#39;arbiter:test:scaffold&amp;#39;: &amp;#39;arbiter tests scaffold --language typescript&amp;#39;,
      &amp;#39;arbiter:test:cover&amp;#39;: &amp;#39;arbiter tests cover --threshold 0.8&amp;#39;,
      &amp;#39;arbiter:version:plan&amp;#39;: &amp;#39;arbiter version plan --strict&amp;#39;,
      &amp;#39;arbiter:sync&amp;#39;: &amp;#39;arbiter sync --language typescript&amp;#39;,
    },
    devDependencies: {
      &amp;#39;@arbiter/cli&amp;#39;: &#x60;^${packageJson.version}&#x60;,
    },
    arbiter: {
      profiles: [&amp;#39;library&amp;#39;],
      coverage: {
        threshold: 0.8,
      },
      surface: {
        language: &amp;#39;typescript&amp;#39;,
        output: &amp;#39;surface.json&amp;#39;,
      },
    },
  };
}

/**
 * Apply Arbiter updates to package object
 */
function applyArbiterUpdates(
  pkg: any,
  arbiterUpdates: ReturnType&amp;lt;typeof getArbiterPackageUpdates&amp;gt;,
  force: boolean
): ConflictResolution[] {
  const conflicts: ConflictResolution[] &#x3D; [];

  // Initialize sections if not present
  if (!pkg.scripts) pkg.scripts &#x3D; {};
  if (!pkg.devDependencies) pkg.devDependencies &#x3D; {};

  // Use intelligent merge for each section
  pkg.scripts &#x3D; deepMerge(pkg.scripts, arbiterUpdates.scripts, conflicts, &amp;#39;scripts&amp;#39;, force);
  pkg.devDependencies &#x3D; deepMerge(
    pkg.devDependencies,
    arbiterUpdates.devDependencies,
    conflicts,
    &amp;#39;devDependencies&amp;#39;,
    force
  );
  pkg.arbiter &#x3D; deepMerge(pkg.arbiter || {}, arbiterUpdates.arbiter, conflicts, &amp;#39;arbiter&amp;#39;, force);

  return conflicts;
}

/**
 * Report changes that would be made
 */
function reportPotentialChanges(changeSet: any, conflicts: ConflictResolution[]): void {
  // Report changes
  if (Object.keys(changeSet.added).length &amp;gt; 0) {
    console.log(chalk.green(&amp;#39;  âœ¨ Would add:&amp;#39;));
    for (const [key, value] of Object.entries(changeSet.added)) {
      console.log(chalk.dim(&#x60;    ${key}: ${JSON.stringify(value, null, 2).split(&amp;#39;\n&amp;#39;)[0]}...&#x60;));
    }
  }

  if (Object.keys(changeSet.modified).length &amp;gt; 0) {
    console.log(chalk.yellow(&amp;#39;  ğŸ”„ Would modify:&amp;#39;));
    for (const [key, change] of Object.entries(changeSet.modified) as Array&amp;lt;[string, any]&amp;gt;) {
      console.log(
        chalk.dim(&#x60;    ${key}: ${JSON.stringify(change.from)} â†’ ${JSON.stringify(change.to)}&#x60;)
      );
    }
  }

  // Report conflicts
  if (conflicts.length &amp;gt; 0) {
    console.log(chalk.yellow(&#x60;  âš ï¸  ${conflicts.length} conflict(s) detected:&#x60;));
    for (const conflict of conflicts) {
      const status &#x3D; conflict.applied ? chalk.green(&amp;#39;RESOLVED&amp;#39;) : chalk.red(&amp;#39;PRESERVED&amp;#39;);
      console.log(chalk.dim(&#x60;    ${status}: ${conflict.details}&#x60;));
    }
  }
}

/**
 * Apply changes to package.json file
 */
async function applyPackageChanges(
  filePath: string,
  newContent: string,
  backup: boolean,
  newChecksum: string
): Promise&amp;lt;string | undefined&amp;gt; {
  let backupPath: string | undefined;

  if (backup) {
    backupPath &#x3D; await createBackup(filePath);
    console.log(chalk.dim(&#x60;  ğŸ“¦ Created backup: ${path.basename(backupPath)}&#x60;));
  }

  await fs.writeFile(filePath, newContent);

  // Validate idempotency
  const isIdempotent &#x3D; await validateIdempotency(filePath, newChecksum);
  if (!isIdempotent) {
    console.log(chalk.yellow(&amp;#39;  âš ï¸  Warning: File was modified by external process during sync&amp;#39;));
  }

  return backupPath;
}

async function syncPackageJson(
  filePath: string,
  dryRun: boolean,
  backup: boolean,
  force: boolean
): Promise&amp;lt;SyncResult&amp;gt; {
  try {
    // Load package.json content
    const { originalContent, originalPkg, originalChecksum } &#x3D; await loadPackageJson(filePath);

    // Create working copy and apply updates
    const pkg &#x3D; JSON.parse(originalContent);
    const arbiterUpdates &#x3D; getArbiterPackageUpdates();
    const conflicts &#x3D; applyArbiterUpdates(pkg, arbiterUpdates, force);

    // Check if anything actually changed
    const newContent &#x3D; &#x60;${JSON.stringify(pkg, null, 2)}\n&#x60;;
    const newChecksum &#x3D; calculateChecksum(newContent);
    const modified &#x3D; originalChecksum !&#x3D;&#x3D; newChecksum;

    // Generate change set for reporting
    const changeSet &#x3D; generateChangeSet(originalPkg, pkg);

    // Report changes in dry-run mode
    if (modified) {
      reportPotentialChanges(changeSet, conflicts);
    }

    // Apply changes if not dry run
    let backupPath: string | undefined;
    if (modified &amp;amp;&amp;amp; !dryRun) {
      backupPath &#x3D; await applyPackageChanges(filePath, newContent, backup, newChecksum);
    }

    return {
      modified,
      conflicts,
      checksum: newChecksum,
      backupPath,
    };
  } catch (error) {
    console.error(
      chalk.red(&#x60;  âŒ Failed to sync ${filePath}:&#x60;),
      error instanceof Error ? error.message : String(error)
    );
    return {
      modified: false,
      conflicts: [],
      checksum: &amp;#39;&amp;#39;,
      backupPath: undefined,
    };
  }
}

/**
 * Sync pyproject.toml with Arbiter configuration
 */
async function syncPyprojectToml(
  filePath: string,
  dryRun: boolean,
  backup: boolean,
  force: boolean
): Promise&amp;lt;SyncResult&amp;gt; {
  try {
    const content &#x3D; await fs.readFile(filePath, &amp;#39;utf8&amp;#39;);
    let modified &#x3D; false;

    // Check if tool.arbiter section exists
    const arbiterSectionRegex &#x3D; /\[tool\.arbiter\]/;
    const hasArbiterSection &#x3D; arbiterSectionRegex.test(content);

    const conflicts: ConflictResolution[] &#x3D; [];
    let backupPath: string | undefined;

    if (hasArbiterSection &amp;amp;&amp;amp; !force) {
      conflicts.push({
        path: &amp;#39;[tool.arbiter]&amp;#39;,
        type: &amp;#39;section_exists&amp;#39;,
        resolution: &amp;#39;preserved_existing&amp;#39;,
        details: &amp;#39;Use --force to overwrite existing Arbiter section&amp;#39;,
      });
      console.log(
        chalk.yellow(
          &amp;#39;âš ï¸  pyproject.toml already has [tool.arbiter] section. Use --force to overwrite.&amp;#39;
        )
      );
      return {
        modified: false,
        conflicts,
        checksum: calculateChecksum(content),
      };
    }

    const arbiterConfig &#x3D; &#x60;
[tool.arbiter]
profiles &#x3D; [&amp;quot;library&amp;quot;]
surface_language &#x3D; &amp;quot;python&amp;quot;
surface_output &#x3D; &amp;quot;surface.json&amp;quot;

[tool.arbiter.coverage]
threshold &#x3D; 0.8

[tool.arbiter.scripts]
check &#x3D; &amp;quot;arbiter check&amp;quot;
watch &#x3D; &amp;quot;arbiter watch&amp;quot;
surface &#x3D; &amp;quot;arbiter surface python --output surface.json&amp;quot;
test_scaffold &#x3D; &amp;quot;arbiter tests scaffold --language python&amp;quot;
test_cover &#x3D; &amp;quot;arbiter tests cover --threshold 0.8&amp;quot;
version_plan &#x3D; &amp;quot;arbiter version plan --strict&amp;quot;
sync &#x3D; &amp;quot;arbiter sync --language python&amp;quot;
&#x60;;

    let newContent &#x3D; content;

    if (!hasArbiterSection) {
      // Add to end of file
      newContent &#x3D; &#x60;${content.trim()}\n${arbiterConfig}&#x60;;
      modified &#x3D; true;
    } else if (force) {
      // Replace existing section
      const sectionEnd &#x3D; content.indexOf(&amp;#39;[&amp;#39;, content.indexOf(&amp;#39;[tool.arbiter]&amp;#39;) + 1);
      if (sectionEnd &#x3D;&#x3D;&#x3D; -1) {
        // Section is at the end of the file
        newContent &#x3D; content.substring(0, content.indexOf(&amp;#39;[tool.arbiter]&amp;#39;)) + arbiterConfig.trim();
      } else {
        // Section is in the middle
        newContent &#x3D; &#x60;${
          content.substring(0, content.indexOf(&amp;#39;[tool.arbiter]&amp;#39;)) + arbiterConfig.trim()
        }\n\n${content.substring(sectionEnd)}&#x60;;
      }
      modified &#x3D; true;
    }

    if (modified &amp;amp;&amp;amp; !dryRun) {
      if (backup) {
        backupPath &#x3D; await createBackup(filePath);
        console.log(chalk.dim(&#x60;ğŸ“¦ Created backup: ${backupPath}&#x60;));
      }

      await fs.writeFile(filePath, newContent);
    }

    if (modified &amp;amp;&amp;amp; force &amp;amp;&amp;amp; hasArbiterSection) {
      conflicts.push({
        path: &amp;#39;[tool.arbiter]&amp;#39;,
        type: &amp;#39;section_replaced&amp;#39;,
        resolution: &amp;#39;replaced_with_template&amp;#39;,
        details: &amp;#39;Existing section replaced due to --force flag&amp;#39;,
      });
    }

    const newChecksum &#x3D; calculateChecksum(modified ? newContent : content);
    return {
      modified,
      conflicts,
      checksum: newChecksum,
      backupPath,
    };
  } catch (error) {
    console.error(
      chalk.red(&#x60;âŒ Failed to sync ${filePath}:&#x60;),
      error instanceof Error ? error.message : String(error)
    );
    return {
      modified: false,
      conflicts: [
        {
          path: filePath,
          type: &amp;#39;error&amp;#39;,
          resolution: &amp;#39;failed&amp;#39;,
          details: error instanceof Error ? error.message : String(error),
        },
      ],
      checksum: &amp;#39;&amp;#39;,
    };
  }
}

/**
 * Sync Cargo.toml with Arbiter metadata
 */
async function syncCargoToml(
  filePath: string,
  dryRun: boolean,
  backup: boolean,
  force: boolean
): Promise&amp;lt;SyncResult&amp;gt; {
  try {
    const originalContent &#x3D; await fs.readFile(filePath, &amp;#39;utf8&amp;#39;);
    let newContent &#x3D; originalContent;
    let modified &#x3D; false;
    const conflicts: ConflictResolution[] &#x3D; [];
    let backupPath: string | undefined;

    // Check if [package.metadata.arbiter] section exists
    const arbiterSectionRegex &#x3D; /\[package\.metadata\.arbiter\]/;
    const hasArbiterSection &#x3D; arbiterSectionRegex.test(originalContent);

    const arbiterConfig &#x3D; &#x60;
[package.metadata.arbiter]
profiles &#x3D; [&amp;quot;library&amp;quot;]
surface_language &#x3D; &amp;quot;rust&amp;quot;
surface_output &#x3D; &amp;quot;surface.json&amp;quot;
coverage_threshold &#x3D; 0.8

[package.metadata.arbiter.scripts]
check &#x3D; &amp;quot;arbiter check&amp;quot;
watch &#x3D; &amp;quot;arbiter watch&amp;quot;
surface &#x3D; &amp;quot;arbiter surface rust --output surface.json&amp;quot;
test_scaffold &#x3D; &amp;quot;arbiter tests scaffold --language rust&amp;quot;
test_cover &#x3D; &amp;quot;arbiter tests cover --threshold 0.8&amp;quot;
version_plan &#x3D; &amp;quot;arbiter version plan --strict&amp;quot;
sync &#x3D; &amp;quot;arbiter sync --language rust&amp;quot;
&#x60;;

    if (!hasArbiterSection) {
      // Add after [package] section
      const packageSectionEnd &#x3D; originalContent.indexOf(
        &amp;#39;\n[&amp;#39;,
        originalContent.indexOf(&amp;#39;[package]&amp;#39;) + 1
      );
      if (packageSectionEnd &#x3D;&#x3D;&#x3D; -1) {
        // No other sections after [package]
        newContent &#x3D; &#x60;${originalContent.trim()}\n${arbiterConfig}&#x60;;
      } else {
        // Insert before next section
        newContent &#x3D; &#x60;${originalContent.substring(0, packageSectionEnd)}\n${arbiterConfig.trim()}${originalContent.substring(packageSectionEnd)}&#x60;;
      }
      modified &#x3D; true;
    } else if (!force) {
      conflicts.push({
        path: &amp;#39;[package.metadata.arbiter]&amp;#39;,
        type: &amp;#39;section_exists&amp;#39;,
        resolution: &amp;#39;preserved_existing&amp;#39;,
        details: &amp;#39;Use --force to overwrite existing Arbiter section&amp;#39;,
      });
      console.log(
        chalk.yellow(
          &amp;#39;âš ï¸  Cargo.toml already has [package.metadata.arbiter] section. Use --force to overwrite.&amp;#39;
        )
      );
    } else {
      // Replace existing section with force
      const sectionStart &#x3D; originalContent.indexOf(&amp;#39;[package.metadata.arbiter]&amp;#39;);
      const nextSection &#x3D; originalContent.indexOf(&amp;#39;\n[&amp;#39;, sectionStart + 1);

      if (nextSection &#x3D;&#x3D;&#x3D; -1) {
        newContent &#x3D; originalContent.substring(0, sectionStart) + arbiterConfig.trim();
      } else {
        newContent &#x3D; &#x60;${
          originalContent.substring(0, sectionStart) + arbiterConfig.trim()
        }\n${originalContent.substring(nextSection)}&#x60;;
      }
      modified &#x3D; true;
      conflicts.push({
        path: &amp;#39;[package.metadata.arbiter]&amp;#39;,
        type: &amp;#39;section_replaced&amp;#39;,
        resolution: &amp;#39;replaced_with_template&amp;#39;,
        details: &amp;#39;Existing section replaced due to --force flag&amp;#39;,
      });
    }

    if (modified &amp;amp;&amp;amp; !dryRun) {
      if (backup) {
        backupPath &#x3D; await createBackup(filePath);
        console.log(chalk.dim(&#x60;ğŸ“¦ Created backup: ${backupPath}&#x60;));
      }

      await fs.writeFile(filePath, newContent);
    }

    return {
      modified,
      conflicts,
      checksum: calculateChecksum(newContent),
      backupPath,
    };
  } catch (error) {
    console.error(
      chalk.red(&#x60;âŒ Failed to sync ${filePath}:&#x60;),
      error instanceof Error ? error.message : String(error)
    );
    return {
      modified: false,
      conflicts: [
        {
          path: filePath,
          type: &amp;#39;error&amp;#39;,
          resolution: &amp;#39;failed&amp;#39;,
          details: error instanceof Error ? error.message : String(error),
        },
      ],
      checksum: &amp;#39;&amp;#39;,
    };
  }
}

/**
 * Sync Makefile with Arbiter targets
 */
async function syncMakefile(
  filePath: string,
  dryRun: boolean,
  backup: boolean,
  force: boolean
): Promise&amp;lt;SyncResult&amp;gt; {
  try {
    const originalContent &#x3D; await fs.readFile(filePath, &amp;#39;utf8&amp;#39;);
    let newContent &#x3D; originalContent;
    let modified &#x3D; false;
    const conflicts: ConflictResolution[] &#x3D; [];
    let backupPath: string | undefined;

    // Check if Arbiter targets exist
    const hasArbiterTargets &#x3D; originalContent.includes(&amp;#39;# Arbiter targets&amp;#39;);

    const arbiterTargets &#x3D; &#x60;
# Arbiter targets
.PHONY: arbiter-check arbiter-watch arbiter-surface arbiter-test-scaffold arbiter-test-cover arbiter-version-plan arbiter-sync

arbiter-check:
	arbiter check

arbiter-watch:
	arbiter watch

arbiter-surface:
	arbiter surface bash --output surface.json

arbiter-test-scaffold:
	arbiter tests scaffold --language bash

arbiter-test-cover:
	arbiter tests cover --threshold 0.8

arbiter-version-plan:
	arbiter version plan --strict

arbiter-sync:
	arbiter sync --language bash
&#x60;;

    if (!hasArbiterTargets) {
      // Add to end of file
      newContent &#x3D; &#x60;${originalContent.trim()}\n${arbiterTargets}&#x60;;
      modified &#x3D; true;
    } else if (!force) {
      conflicts.push({
        path: &amp;#39;# Arbiter targets&amp;#39;,
        type: &amp;#39;section_exists&amp;#39;,
        resolution: &amp;#39;preserved_existing&amp;#39;,
        details: &amp;#39;Use --force to overwrite existing Arbiter targets&amp;#39;,
      });
      console.log(
        chalk.yellow(&amp;#39;âš ï¸  Makefile already has Arbiter targets. Use --force to overwrite.&amp;#39;)
      );
    } else {
      // Replace existing Arbiter section with force
      const sectionStart &#x3D; originalContent.indexOf(&amp;#39;# Arbiter targets&amp;#39;);
      const nextSection &#x3D; originalContent.indexOf(&amp;#39;\n# &amp;#39;, sectionStart + 1);

      if (nextSection &#x3D;&#x3D;&#x3D; -1) {
        // Section is at the end
        newContent &#x3D; originalContent.substring(0, sectionStart) + arbiterTargets.trim();
      } else {
        // Section is in the middle
        newContent &#x3D; &#x60;${
          originalContent.substring(0, sectionStart) + arbiterTargets.trim()
        }\n\n${originalContent.substring(nextSection)}&#x60;;
      }
      modified &#x3D; true;
      conflicts.push({
        path: &amp;#39;# Arbiter targets&amp;#39;,
        type: &amp;#39;section_replaced&amp;#39;,
        resolution: &amp;#39;replaced_with_template&amp;#39;,
        details: &amp;#39;Existing targets replaced due to --force flag&amp;#39;,
      });
    }

    if (modified &amp;amp;&amp;amp; !dryRun) {
      if (backup) {
        backupPath &#x3D; await createBackup(filePath);
        console.log(chalk.dim(&#x60;ğŸ“¦ Created backup: ${backupPath}&#x60;));
      }

      await fs.writeFile(filePath, newContent);
    }

    return {
      modified,
      conflicts,
      checksum: calculateChecksum(newContent),
      backupPath,
    };
  } catch (error) {
    console.error(
      chalk.red(&#x60;âŒ Failed to sync ${filePath}:&#x60;),
      error instanceof Error ? error.message : String(error)
    );
    return {
      modified: false,
      conflicts: [
        {
          path: filePath,
          type: &amp;#39;error&amp;#39;,
          resolution: &amp;#39;failed&amp;#39;,
          details: error instanceof Error ? error.message : String(error),
        },
      ],
      checksum: &amp;#39;&amp;#39;,
    };
  }
}

/**
 * Sync command implementation
 */
export async function syncCommand(options: SyncOptions, _config: CLIConfig): Promise&amp;lt;number&amp;gt; {
  try {
    const context &#x3D; await initializeSyncContext(options);
    if (!context) return 1;

    const syncResults &#x3D; await executeSynchronization(context);
    displaySynchronizationResults(context, syncResults);
    displayNextStepsGuidance(context, syncResults);

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;âŒ Synchronization failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

interface SyncContext {
  projectPath: string;
  targetManifests: ManifestFile[];
  dryRun: boolean;
  backup: boolean;
  force: boolean;
}

async function initializeSyncContext(options: SyncOptions): Promise&amp;lt;SyncContext | null&amp;gt; {
  const projectPath &#x3D; process.cwd();
  displaySyncHeader(projectPath);

  const manifests &#x3D; await detectAndDisplayManifests(projectPath);
  if (!manifests) return null;

  const targetManifests &#x3D; filterManifestsByLanguage(manifests, options.language);
  if (!targetManifests) return null;

  const syncOptions &#x3D; extractSyncOptions(options);
  displaySyncMode(syncOptions.dryRun);

  return {
    projectPath,
    targetManifests,
    ...syncOptions,
  };
}

function displaySyncHeader(projectPath: string): void {
  console.log(chalk.blue(&amp;#39;ğŸ”„ Arbiter manifest synchronization&amp;#39;));
  console.log(chalk.dim(&#x60;Project: ${projectPath}&#x60;));
}

async function detectAndDisplayManifests(projectPath: string): Promise&amp;lt;ManifestFile[] | null&amp;gt; {
  console.log(chalk.blue(&amp;#39;ğŸ” Detecting manifest files...&amp;#39;));
  const manifests &#x3D; await detectManifestFiles(projectPath);

  if (manifests.length &#x3D;&#x3D;&#x3D; 0) {
    console.log(chalk.yellow(&amp;#39;âš ï¸  No supported manifest files found&amp;#39;));
    console.log(chalk.dim(&amp;#39;Supported: package.json, pyproject.toml, Cargo.toml, Makefile&amp;#39;));
    return null;
  }

  console.log(chalk.green(&#x60;âœ… Found ${manifests.length} manifest file(s):&#x60;));
  for (const manifest of manifests) {
    console.log(chalk.dim(&#x60;  â€¢ ${manifest.path} (${manifest.language})&#x60;));
  }

  return manifests;
}

function filterManifestsByLanguage(
  manifests: ManifestFile[],
  language?: string
): ManifestFile[] | null {
  if (!language || language &#x3D;&#x3D;&#x3D; &amp;#39;all&amp;#39;) {
    return manifests;
  }

  const filtered &#x3D; manifests.filter(m &#x3D;&amp;gt; m.language &#x3D;&#x3D;&#x3D; language);
  if (filtered.length &#x3D;&#x3D;&#x3D; 0) {
    console.log(chalk.yellow(&#x60;âš ï¸  No ${language} manifest files found&#x60;));
    return null;
  }

  return filtered;
}

function extractSyncOptions(options: SyncOptions): {
  dryRun: boolean;
  backup: boolean;
  force: boolean;
} {
  return {
    dryRun: options.dryRun || false,
    backup: options.backup || false,
    force: options.force || false,
  };
}

function displaySyncMode(dryRun: boolean): void {
  if (dryRun) {
    console.log(chalk.yellow(&amp;#39;ğŸ“‹ Dry run mode - no files will be modified&amp;#39;));
  }
}

async function executeSynchronization(context: SyncContext): Promise&amp;lt;SyncResult[]&amp;gt; {
  console.log(chalk.blue(&amp;#39;\nğŸ”„ Synchronizing manifests...&amp;#39;));
  const syncResults: SyncResult[] &#x3D; [];

  for (const manifest of context.targetManifests) {
    const result &#x3D; await processSingleManifest(manifest, context);
    syncResults.push(result);
    displayManifestResult(manifest, result, context.dryRun);
  }

  return syncResults;
}

async function processSingleManifest(
  manifest: ManifestFile,
  context: SyncContext
): Promise&amp;lt;SyncResult&amp;gt; {
  const filePath &#x3D; path.join(context.projectPath, manifest.path);
  console.log(chalk.cyan(&#x60;\nğŸ“ Processing ${manifest.path}...&#x60;));

  const manifestProcessors &#x3D; {
    &amp;#39;package.json&amp;#39;: syncPackageJson,
    &amp;#39;pyproject.toml&amp;#39;: syncPyprojectToml,
    &amp;#39;Cargo.toml&amp;#39;: syncCargoToml,
    Makefile: syncMakefile,
  };

  const processor &#x3D; manifestProcessors[manifest.type];
  if (processor) {
    return await processor(filePath, context.dryRun, context.backup, context.force);
  }

  return { modified: false, conflicts: [], checksum: &amp;#39;&amp;#39; };
}

function displayManifestResult(manifest: ManifestFile, result: SyncResult, dryRun: boolean): void {
  if (result.modified) {
    const status &#x3D; dryRun ? &amp;#39;Would modify&amp;#39; : &amp;#39;Modified&amp;#39;;
    const conflictCount &#x3D; result.conflicts.filter(c &#x3D;&amp;gt; c.applied).length;
    if (conflictCount &amp;gt; 0) {
      console.log(
        chalk.green(&#x60;âœ… ${status} ${manifest.path} (${conflictCount} conflict(s) resolved)&#x60;)
      );
    } else {
      console.log(chalk.green(&#x60;âœ… ${status} ${manifest.path}&#x60;));
    }
  } else {
    console.log(chalk.dim(&#x60;â­ï¸  No changes needed for ${manifest.path}&#x60;));
  }
}

function displaySynchronizationResults(context: SyncContext, syncResults: SyncResult[]): void {
  const totalModified &#x3D; syncResults.filter(r &#x3D;&amp;gt; r.modified).length;

  console.log(chalk.green(&amp;#39;\nğŸ‰ Synchronization complete!&amp;#39;));
  console.log(
    chalk.cyan(
      &#x60;ğŸ“Š Summary: ${totalModified}/${context.targetManifests.length} files ${context.dryRun ? &amp;#39;would be&amp;#39; : &amp;#39;were&amp;#39;} modified&#x60;
    )
  );
}

function displayNextStepsGuidance(context: SyncContext, syncResults: SyncResult[]): void {
  const totalModified &#x3D; syncResults.filter(r &#x3D;&amp;gt; r.modified).length;

  if (totalModified &amp;gt; 0 &amp;amp;&amp;amp; !context.dryRun) {
    console.log(chalk.cyan(&amp;#39;\nNext steps:&amp;#39;));
    displayLanguageSpecificGuidance(context.targetManifests);
  }

  if (context.dryRun &amp;amp;&amp;amp; totalModified &amp;gt; 0) {
    console.log(chalk.yellow(&amp;#39;\nğŸ’¡ Run without --dry-run to apply these changes&amp;#39;));
  }
}

function displayLanguageSpecificGuidance(manifests: ManifestFile[]): void {
  const guidanceMap &#x3D; {
    &amp;#39;package.json&amp;#39;: [
      &amp;#39;  â€¢ Run &amp;quot;npm install&amp;quot; to install new dev dependencies&amp;#39;,
      &amp;#39;  â€¢ Use &amp;quot;npm run arbiter:check&amp;quot; to validate CUE files&amp;#39;,
    ],
    &amp;#39;pyproject.toml&amp;#39;: [&amp;#39;  â€¢ Run &amp;quot;pip install -e .&amp;quot; to install in development mode&amp;#39;],
    &amp;#39;Cargo.toml&amp;#39;: [&amp;#39;  â€¢ Run &amp;quot;cargo build&amp;quot; to update dependencies&amp;#39;],
    Makefile: [&amp;#39;  â€¢ Use &amp;quot;make arbiter-check&amp;quot; to validate CUE files&amp;#39;],
  };

  for (const [manifestType, guidance] of Object.entries(guidanceMap)) {
    if (manifests.some(m &#x3D;&amp;gt; m.type &#x3D;&#x3D;&#x3D; manifestType)) {
      guidance.forEach(line &#x3D;&amp;gt; console.log(chalk.dim(line)));
    }
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-27">
                <div class="file-header">ğŸ“„ apps/api/src/handlers/executor.ts</div>
                <div class="file-content">
                    <pre>/**
 * Handler execution pipeline
 * Executes custom webhook handlers with sandboxing and error handling
 */

import { setTimeout } from &amp;#39;node:timers/promises&amp;#39;;
import type { SpecWorkbenchDB } from &amp;#39;../db.js&amp;#39;;
import type { EventService } from &amp;#39;../events.js&amp;#39;;
import { logger as defaultLogger, generateId, getCurrentTimestamp } from &amp;#39;../utils.js&amp;#39;;
import { HandlerLoader } from &amp;#39;./loader.js&amp;#39;;
import { HandlerSecurityValidator } from &amp;#39;./services.js&amp;#39;;
import type { HandlerDiscovery } from &amp;#39;./discovery.js&amp;#39;;
import type {
  EnhancedWebhookPayload,
  HandlerContext,
  HandlerExecution,
  HandlerResult,
  HandlerServices,
  Logger,
  RegisteredHandler,
  WebhookHandler,
  WebhookPayload,
  WebhookRequest,
} from &amp;#39;./types.js&amp;#39;;

export class HandlerExecutor {
  private activeExecutions &#x3D; new Map&amp;lt;string, AbortController&amp;gt;();
  private executionHistory: HandlerExecution[] &#x3D; [];
  private loader: HandlerLoader;

  constructor(
    private discovery: HandlerDiscovery,
    private services: HandlerServices,
    private logger: Logger &#x3D; defaultLogger
  ) {
    this.loader &#x3D; new HandlerLoader(this.logger);
  }

  /**
   * Execute handlers for a webhook event
   */
  async executeHandlers(projectId: string, request: WebhookRequest): Promise&amp;lt;HandlerResult[]&amp;gt; {
    const { provider, event } &#x3D; request;

    // Get handlers for this event
    const handlers &#x3D; this.discovery.getHandlersForEvent(provider, event);

    if (handlers.length &#x3D;&#x3D;&#x3D; 0) {
      this.logger.debug(&amp;#39;No handlers found for event&amp;#39;, { provider, event });
      return [];
    }

    this.logger.info(&amp;#39;Executing handlers for webhook event&amp;#39;, {
      projectId,
      provider,
      event,
      handlerCount: handlers.length,
    });

    // Enhance payload with parsed data
    const enhancedPayload &#x3D; await this.enhancePayload(request);

    // Execute handlers in parallel
    const executions &#x3D; handlers.map(handler &#x3D;&amp;gt;
      this.executeHandler(projectId, handler, enhancedPayload)
    );

    const results &#x3D; await Promise.allSettled(executions);

    // Process results
    const handlerResults: HandlerResult[] &#x3D; [];
    for (let i &#x3D; 0; i &amp;lt; results.length; i++) {
      const result &#x3D; results[i];
      const handler &#x3D; handlers[i];

      if (result.status &#x3D;&#x3D;&#x3D; &amp;#39;fulfilled&amp;#39;) {
        handlerResults.push(result.value.result);
        this.updateHandlerStats(handler.id, result.value.result);
      } else {
        const errorResult: HandlerResult &#x3D; {
          success: false,
          message: &#x60;Handler execution failed: ${result.reason}&#x60;,
          errors: [
            {
              code: &amp;#39;EXECUTION_FAILED&amp;#39;,
              message: result.reason?.message || &amp;#39;Unknown error&amp;#39;,
              stack: result.reason?.stack,
            },
          ],
        };
        handlerResults.push(errorResult);
        this.updateHandlerStats(handler.id, errorResult);
      }
    }

    return handlerResults;
  }

  /**
   * Execute a single handler with timeout and error handling
   */
  private async executeHandler(
    projectId: string,
    handler: RegisteredHandler,
    payload: EnhancedWebhookPayload
  ): Promise&amp;lt;{ result: HandlerResult; execution: HandlerExecution }&amp;gt; {
    const executionId &#x3D; generateId();
    const startTime &#x3D; Date.now();
    const startedAt &#x3D; getCurrentTimestamp();

    this.logger.debug(&amp;#39;Starting handler execution&amp;#39;, {
      executionId,
      handlerId: handler.id,
      handlerName: handler.metadata?.name,
      projectId,
    });

    // Create abort controller for timeout
    const abortController &#x3D; new AbortController();
    this.activeExecutions.set(executionId, abortController);

    let result: HandlerResult;
    let completedAt: string;
    let duration: number;

    try {
      // Load handler module
      const handlerModule &#x3D; await this.loadHandlerModule(handler);

      // Create execution context
      const context &#x3D; await this.createHandlerContext(
        projectId,
        handler,
        executionId,
        abortController.signal
      );

      // Execute with timeout
      const timeoutPromise &#x3D; setTimeout(handler.config.timeout, null, {
        signal: abortController.signal,
      });

      const executionPromise &#x3D; this.executeWithRetries(
        handlerModule.handler,
        payload,
        context,
        handler.config.retries
      );

      const raceResult &#x3D; await Promise.race([executionPromise, timeoutPromise]);

      if (raceResult &#x3D;&#x3D;&#x3D; null) {
        throw new Error(&#x60;Handler execution timed out after ${handler.config.timeout}ms&#x60;);
      }

      result &#x3D; raceResult as HandlerResult;

      // Add timing information
      const endTime &#x3D; Date.now();
      duration &#x3D; endTime - startTime;
      completedAt &#x3D; getCurrentTimestamp();
      result.duration &#x3D; duration;

      this.logger.info(&amp;#39;Handler execution completed&amp;#39;, {
        executionId,
        handlerId: handler.id,
        success: result.success,
        duration,
        actionsCount: result.actions?.length || 0,
      });
    } catch (error) {
      const endTime &#x3D; Date.now();
      duration &#x3D; endTime - startTime;
      completedAt &#x3D; getCurrentTimestamp();

      this.logger.error(&amp;#39;Handler execution failed&amp;#39;, error as Error, {
        executionId,
        handlerId: handler.id,
        projectId,
        duration,
      });

      result &#x3D; {
        success: false,
        message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
        duration,
        errors: [
          {
            code: &amp;#39;HANDLER_EXECUTION_ERROR&amp;#39;,
            message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
            stack: error instanceof Error ? error.stack : undefined,
          },
        ],
      };
    } finally {
      // Clean up
      this.activeExecutions.delete(executionId);
      abortController.abort();
    }

    // Record execution
    const execution: HandlerExecution &#x3D; {
      id: executionId,
      handlerId: handler.id,
      projectId,
      provider: payload.repository.full_name.includes(&amp;#39;gitlab&amp;#39;) ? &amp;#39;gitlab&amp;#39; : &amp;#39;github&amp;#39;,
      event: payload.parsed.eventType,
      payload,
      result,
      startedAt,
      completedAt,
      duration,
    };

    this.executionHistory.push(execution);

    // Trim history to prevent memory leaks (keep last 1000 executions)
    if (this.executionHistory.length &amp;gt; 1000) {
      this.executionHistory &#x3D; this.executionHistory.slice(-1000);
    }

    return { result, execution };
  }

  /**
   * Execute handler with retry logic
   */
  private async executeWithRetries(
    handler: WebhookHandler,
    payload: EnhancedWebhookPayload,
    context: HandlerContext,
    retries: number
  ): Promise&amp;lt;HandlerResult&amp;gt; {
    let lastError: Error | undefined;

    for (let attempt &#x3D; 0; attempt &amp;lt;&#x3D; retries; attempt++) {
      try {
        if (attempt &amp;gt; 0) {
          const delay &#x3D; Math.min(1000 * 2 ** (attempt - 1), 5000); // Exponential backoff
          await setTimeout(delay);

          this.logger.info(&amp;#39;Retrying handler execution&amp;#39;, {
            attempt,
            maxRetries: retries,
            delay,
          });
        }

        const result &#x3D; await handler(payload, context);

        // If successful or explicitly non-retryable, return immediately
        if (result.success || !this.isRetryableError(result)) {
          return result;
        }

        lastError &#x3D; new Error(result.message);
      } catch (error) {
        lastError &#x3D; error as Error;

        // If not retryable, fail immediately
        if (!this.isRetryableError(error)) {
          throw error;
        }
      }
    }

    // All retries exhausted
    throw new Error(&#x60;Handler failed after ${retries + 1} attempts: ${lastError?.message}&#x60;);
  }

  /**
   * Check if an error is retryable
   */
  private isRetryableError(error: unknown): boolean {
    if (error instanceof Error) {
      const message &#x3D; error.message.toLowerCase();

      // Network/timeout errors are retryable
      if (
        message.includes(&amp;#39;timeout&amp;#39;) ||
        message.includes(&amp;#39;network&amp;#39;) ||
        message.includes(&amp;#39;connection&amp;#39;) ||
        message.includes(&amp;#39;econnreset&amp;#39;) ||
        message.includes(&amp;#39;enotfound&amp;#39;)
      ) {
        return true;
      }

      // HTTP 5xx errors are retryable
      if (message.includes(&amp;#39;5&amp;#39;) &amp;amp;&amp;amp; message.includes(&amp;#39;error&amp;#39;)) {
        return true;
      }
    }

    if (typeof error &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp; error !&#x3D;&#x3D; null) {
      const result &#x3D; error as HandlerResult;
      if (result.errors) {
        return result.errors.some(e &#x3D;&amp;gt;
          [&amp;#39;TIMEOUT&amp;#39;, &amp;#39;NETWORK_ERROR&amp;#39;, &amp;#39;SERVICE_UNAVAILABLE&amp;#39;].includes(e.code)
        );
      }
    }

    return false;
  }

  /**
   * Load handler module dynamically
   */
  private async loadHandlerModule(handler: RegisteredHandler): Promise&amp;lt;any&amp;gt; {
    return this.loader.load(handler);
  }

  /**
   * Create handler execution context
   */
  private async createHandlerContext(
    projectId: string,
    handler: RegisteredHandler,
    executionId: string,
    abortSignal: AbortSignal
  ): Promise&amp;lt;HandlerContext&amp;gt; {
    const sanitizedEnvironment &#x3D; HandlerSecurityValidator.sanitizeEnvironment(
      handler.config.environment
    );

    const secretsValidation &#x3D; HandlerSecurityValidator.validateSecrets(handler.config.secrets);
    if (!secretsValidation.valid) {
      throw new Error(
        &#x60;Handler secrets configuration invalid: ${secretsValidation.errors.join(&amp;#39;, &amp;#39;)}&#x60;
      );
    }

    const sanitizedConfig &#x3D; {
      ...handler.config,
      environment: sanitizedEnvironment,
      secrets: { ...handler.config.secrets },
    } as HandlerContext[&amp;#39;config&amp;#39;];

    return {
      projectId,
      config: sanitizedConfig,
      logger: this.createHandlerLogger(handler.id, executionId),
      services: this.services,
      metadata: {
        handlerPath: handler.handlerPath,
        version: handler.metadata?.version || &amp;#39;1.0.0&amp;#39;,
        executionId,
        timestamp: getCurrentTimestamp(),
      },
    };
  }

  /**
   * Create scoped logger for handler
   */
  private createHandlerLogger(handlerId: string, executionId: string): Logger {
    return {
      info: (message: string, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
        this.logger.info(message, { ...meta, handlerId, executionId });
      },
      warn: (message: string, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
        this.logger.warn(message, { ...meta, handlerId, executionId });
      },
      error: (message: string, error?: Error, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
        this.logger.error(message, error, { ...meta, handlerId, executionId });
      },
      debug: (message: string, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
        this.logger.debug(message, { ...meta, handlerId, executionId });
      },
    };
  }

  /**
   * Enhance webhook payload with parsed data
   */
  private async enhancePayload(request: WebhookRequest): Promise&amp;lt;EnhancedWebhookPayload&amp;gt; {
    const { provider, event, payload } &#x3D; request;

    // Parse payload based on provider and event type
    const parsed &#x3D; await this.parsePayload(provider, event, payload);

    return {
      ...payload,
      parsed,
    };
  }

  /**
   * Parse webhook payload into standardized format
   */
  private async parsePayload(
    provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;,
    event: string,
    payload: WebhookPayload
  ): Promise&amp;lt;EnhancedWebhookPayload[&amp;#39;parsed&amp;#39;]&amp;gt; {
    const parsed: EnhancedWebhookPayload[&amp;#39;parsed&amp;#39;] &#x3D; {
      eventType: event,
      author: {
        name: &amp;#39;Unknown&amp;#39;,
        email: undefined,
        username: undefined,
      },
      repository: {
        name: payload.repository?.full_name?.split(&amp;#39;/&amp;#39;).pop() || &amp;#39;unknown&amp;#39;,
        fullName: payload.repository?.full_name || &amp;#39;unknown&amp;#39;,
        owner: payload.repository?.full_name?.split(&amp;#39;/&amp;#39;)[0] || &amp;#39;unknown&amp;#39;,
        url: payload.repository?.clone_url || &amp;#39;&amp;#39;,
        defaultBranch: payload.repository?.default_branch || &amp;#39;main&amp;#39;,
        isPrivate: false,
      },
    };

    // Provider-specific parsing
    if (provider &#x3D;&#x3D;&#x3D; &amp;#39;github&amp;#39;) {
      await this.parseGitHubPayload(event, payload, parsed);
    } else if (provider &#x3D;&#x3D;&#x3D; &amp;#39;gitlab&amp;#39;) {
      await this.parseGitLabPayload(event, payload, parsed);
    }

    return parsed;
  }

  /**
   * Parse GitHub webhook payload
   */
  private async parseGitHubPayload(
    event: string,
    payload: any,
    parsed: EnhancedWebhookPayload[&amp;#39;parsed&amp;#39;]
  ): Promise&amp;lt;void&amp;gt; {
    // Common GitHub fields
    if (payload.sender) {
      parsed.author.username &#x3D; payload.sender.login;
      parsed.author.name &#x3D; payload.sender.login;
    }

    if (payload.repository) {
      parsed.repository.isPrivate &#x3D; payload.repository.private;
      parsed.repository.url &#x3D; payload.repository.html_url;
    }

    // Event-specific parsing
    switch (event) {
      case &amp;#39;push&amp;#39;:
        if (payload.commits) {
          parsed.commits &#x3D; payload.commits.map((commit: any) &#x3D;&amp;gt; ({
            sha: commit.id,
            message: commit.message,
            author: commit.author.name,
            url: commit.url,
            timestamp: commit.timestamp,
            added: commit.added || [],
            modified: commit.modified || [],
            removed: commit.removed || [],
          }));
        }
        break;

      case &amp;#39;pull_request&amp;#39;:
        if (payload.pull_request) {
          parsed.action &#x3D; payload.action;
          parsed.pullRequest &#x3D; {
            id: payload.pull_request.number,
            title: payload.pull_request.title,
            body: payload.pull_request.body || &amp;#39;&amp;#39;,
            state: payload.pull_request.state,
            baseBranch: payload.pull_request.base.ref,
            headBranch: payload.pull_request.head.ref,
            url: payload.pull_request.html_url,
            merged: payload.pull_request.merged,
            mergeable: payload.pull_request.mergeable,
          };
        }
        break;

      case &amp;#39;issues&amp;#39;:
        if (payload.issue) {
          parsed.action &#x3D; payload.action;
          parsed.issue &#x3D; {
            id: payload.issue.number,
            title: payload.issue.title,
            body: payload.issue.body || &amp;#39;&amp;#39;,
            state: payload.issue.state,
            labels: payload.issue.labels?.map((l: any) &#x3D;&amp;gt; l.name) || [],
            assignees: payload.issue.assignees?.map((a: any) &#x3D;&amp;gt; a.login) || [],
            url: payload.issue.html_url,
          };
        }
        break;
    }
  }

  /**
   * Parse GitLab webhook payload
   */
  private async parseGitLabPayload(
    event: string,
    payload: any,
    parsed: EnhancedWebhookPayload[&amp;#39;parsed&amp;#39;]
  ): Promise&amp;lt;void&amp;gt; {
    // Common GitLab fields
    if (payload.user) {
      parsed.author.username &#x3D; payload.user.username;
      parsed.author.name &#x3D; payload.user.name;
      parsed.author.email &#x3D; payload.user.email;
    }

    if (payload.project) {
      parsed.repository.name &#x3D; payload.project.name;
      parsed.repository.fullName &#x3D; payload.project.path_with_namespace;
      parsed.repository.url &#x3D; payload.project.web_url;
      parsed.repository.isPrivate &#x3D; payload.project.visibility_level &amp;lt; 20;
      parsed.repository.defaultBranch &#x3D; payload.project.default_branch;
    }

    // Event-specific parsing
    switch (event) {
      case &amp;#39;Push Hook&amp;#39;:
        if (payload.commits) {
          parsed.commits &#x3D; payload.commits.map((commit: any) &#x3D;&amp;gt; ({
            sha: commit.id,
            message: commit.message,
            author: commit.author.name,
            url: commit.url,
            timestamp: commit.timestamp,
            added: commit.added || [],
            modified: commit.modified || [],
            removed: commit.removed || [],
          }));
        }
        break;

      case &amp;#39;Merge Request Hook&amp;#39;:
        if (payload.merge_request) {
          parsed.action &#x3D; payload.action;
          parsed.pullRequest &#x3D; {
            id: payload.merge_request.iid,
            title: payload.merge_request.title,
            body: payload.merge_request.description || &amp;#39;&amp;#39;,
            state: payload.merge_request.state,
            baseBranch: payload.merge_request.target_branch,
            headBranch: payload.merge_request.source_branch,
            url: payload.merge_request.url,
            merged: payload.merge_request.state &#x3D;&#x3D;&#x3D; &amp;#39;merged&amp;#39;,
            mergeable: payload.merge_request.merge_status &#x3D;&#x3D;&#x3D; &amp;#39;can_be_merged&amp;#39;,
          };
        }
        break;
    }
  }

  /**
   * Update handler statistics
   */
  private updateHandlerStats(handlerId: string, result: HandlerResult): void {
    const handler &#x3D; this.discovery.getHandler(handlerId);
    if (handler) {
      handler.executionCount++;
      handler.lastExecuted &#x3D; getCurrentTimestamp();

      if (!result.success) {
        handler.errorCount++;
      }

      this.discovery.updateHandlerConfig(handlerId, {
        executionCount: handler.executionCount,
        errorCount: handler.errorCount,
        lastExecuted: handler.lastExecuted,
      });
    }
  }

  /**
   * Get execution history
   */
  getExecutionHistory(limit &#x3D; 100): HandlerExecution[] {
    return this.executionHistory.slice(-limit);
  }

  /**
   * Get active executions count
   */
  getActiveExecutionCount(): number {
    return this.activeExecutions.size;
  }

  /**
   * Cancel all active executions
   */
  cancelAllExecutions(): void {
    for (const [executionId, controller] of this.activeExecutions) {
      controller.abort();
      this.logger.info(&amp;#39;Cancelled handler execution&amp;#39;, { executionId });
    }
    this.activeExecutions.clear();
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    this.cancelAllExecutions();
    this.executionHistory.length &#x3D; 0;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-28">
                <div class="file-header">ğŸ“„ apps/api/src/handlers/manager.ts</div>
                <div class="file-content">
                    <pre>/**
 * Handler Manager - Integrates custom handlers with existing webhook system
 * This is the main integration point that extends the WebhookService
 */

import { access, mkdir, writeFile } from &amp;#39;node:fs/promises&amp;#39;;
import { join } from &amp;#39;node:path&amp;#39;;
import type { SpecWorkbenchDB } from &amp;#39;../db.js&amp;#39;;
import type { EventService } from &amp;#39;../events.js&amp;#39;;
import type { ServerConfig } from &amp;#39;../types.js&amp;#39;;
import { logger as defaultLogger } from &amp;#39;../utils.js&amp;#39;;
import { HandlerDiscovery } from &amp;#39;./discovery.js&amp;#39;;
import { HandlerExecutor } from &amp;#39;./executor.js&amp;#39;;
import {
  HandlerGitService,
  HandlerHttpClient,
  HandlerNotificationService,
  type HandlerEmailConfig,
} from &amp;#39;./services.js&amp;#39;;
import type {
  HandlerDiscoveryConfig,
  HandlerExecution,
  HandlerResult,
  HandlerServices,
  Logger,
  RegisteredHandler,
  WebhookRequest,
  HandlerCreationOptions,
} from &amp;#39;./types.js&amp;#39;;

export class CustomHandlerManager {
  private discovery: HandlerDiscovery;
  private executor: HandlerExecutor;
  private services: HandlerServices;
  private initialized &#x3D; false;

  constructor(
    private config: ServerConfig,
    private events: EventService,
    private db: SpecWorkbenchDB,
    private logger: Logger &#x3D; defaultLogger
  ) {
    // Initialize handler services
    const emailConfig &#x3D; this.config.handlers?.notifications?.email as
      | HandlerEmailConfig
      | undefined;

    this.services &#x3D; {
      events: this.events,
      db: this.db,
      http: new HandlerHttpClient(this.logger),
      notifications: new HandlerNotificationService(this.logger, emailConfig),
      git: new HandlerGitService(this.logger),
    };

    // Configure discovery
    const discoveryConfig: HandlerDiscoveryConfig &#x3D; {
      handlersDirectory: join(process.cwd(), &amp;#39;arbiter&amp;#39;, &amp;#39;handlers&amp;#39;),
      enableAutoReload: this.config.handlers?.enableAutoReload ?? false,
      maxConcurrentExecutions: this.config.handlers?.maxConcurrentExecutions ?? 10,
      defaultTimeout: this.config.handlers?.defaultTimeout ?? 30000,
      defaultRetries: this.config.handlers?.defaultRetries ?? 2,
      sandboxEnabled: this.config.handlers?.sandboxEnabled ?? true,
      allowedModules: this.config.handlers?.allowedModules ?? [
        &amp;#39;node:crypto&amp;#39;,
        &amp;#39;node:util&amp;#39;,
        &amp;#39;node:url&amp;#39;,
        &amp;#39;node:path&amp;#39;,
      ],
      enableMetrics: this.config.handlers?.enableMetrics ?? true,
    };

    this.discovery &#x3D; new HandlerDiscovery(discoveryConfig, this.logger);
    this.executor &#x3D; new HandlerExecutor(this.discovery, this.services, this.logger);
  }

  /**
   * Initialize the handler system
   */
  async initialize(): Promise&amp;lt;void&amp;gt; {
    if (this.initialized) return;

    this.logger.info(&amp;#39;Initializing custom handler manager&amp;#39;);

    try {
      // Discover and load all handlers
      const handlers &#x3D; await this.discovery.discoverHandlers();

      this.logger.info(&amp;#39;Custom handler manager initialized&amp;#39;, {
        handlersCount: handlers.length,
        enabledHandlers: handlers.filter(h &#x3D;&amp;gt; h.enabled).length,
      });

      this.initialized &#x3D; true;
    } catch (error) {
      this.logger.error(&amp;#39;Failed to initialize custom handler manager&amp;#39;, error as Error);
      throw error;
    }
  }

  /**
   * Process webhook with custom handlers (integrates with existing WebhookService)
   */
  async processWebhookWithCustomHandlers(
    projectId: string,
    request: WebhookRequest
  ): Promise&amp;lt;string[]&amp;gt; {
    if (!this.initialized) {
      await this.initialize();
    }

    const actions: string[] &#x3D; [];

    try {
      this.logger.info(&amp;#39;Processing webhook with custom handlers&amp;#39;, {
        projectId,
        provider: request.provider,
        event: request.event,
      });

      // Execute custom handlers
      const handlerResults &#x3D; await this.executor.executeHandlers(projectId, request);

      // Process results and extract actions
      for (const result of handlerResults) {
        if (result.success &amp;amp;&amp;amp; result.actions) {
          actions.push(...result.actions);
        } else if (!result.success) {
          actions.push(&#x60;Custom handler failed: ${result.message}&#x60;);

          // Log handler errors
          if (result.errors) {
            for (const error of result.errors) {
              this.logger.error(&amp;#39;Custom handler error&amp;#39;, new Error(error.message), {
                projectId,
                errorCode: error.code,
                errorDetails: error.details,
              });
            }
          }
        }
      }

      // Broadcast custom handler events
      if (handlerResults.length &amp;gt; 0) {
        await this.events.broadcastToProject(projectId, {
          project_id: projectId,
          event_type: &amp;#39;webhook_received&amp;#39;,
          data: {
            provider: request.provider,
            event: request.event,
            customHandlersExecuted: handlerResults.length,
            successfulHandlers: handlerResults.filter(r &#x3D;&amp;gt; r.success).length,
            failedHandlers: handlerResults.filter(r &#x3D;&amp;gt; !r.success).length,
            totalActions: actions.length,
          },
        });
      }
    } catch (error) {
      this.logger.error(&amp;#39;Custom handler processing failed&amp;#39;, error as Error, {
        projectId,
        provider: request.provider,
        event: request.event,
      });

      actions.push(&amp;#39;Custom handler processing failed&amp;#39;);
    }

    return actions;
  }

  /**
   * Create and register a new handler on disk
   */
  async createHandler(options: HandlerCreationOptions): Promise&amp;lt;RegisteredHandler&amp;gt; {
    if (!options.code || options.code.trim().length &#x3D;&#x3D;&#x3D; 0) {
      throw new Error(&amp;#39;Handler code must not be empty&amp;#39;);
    }

    if (options.provider !&#x3D;&#x3D; &amp;#39;github&amp;#39; &amp;amp;&amp;amp; options.provider !&#x3D;&#x3D; &amp;#39;gitlab&amp;#39;) {
      throw new Error(&#x60;Unsupported provider: ${options.provider}&#x60;);
    }

    if (!this.initialized) {
      await this.initialize();
    }

    const normalizedEvent &#x3D; this.normalizeEventName(options.event);
    const handlersRoot &#x3D; join(process.cwd(), &amp;#39;arbiter&amp;#39;, &amp;#39;handlers&amp;#39;, options.provider);
    await mkdir(handlersRoot, { recursive: true });

    const extension &#x3D; this.detectFileExtension(options.code);
    let fileName &#x3D; &#x60;${normalizedEvent}${extension}&#x60;;
    let handlerPath &#x3D; join(handlersRoot, fileName);
    let counter &#x3D; 1;

    while (await this.pathExists(handlerPath)) {
      fileName &#x3D; &#x60;${normalizedEvent}-${counter++}${extension}&#x60;;
      handlerPath &#x3D; join(handlersRoot, fileName);
    }

    const source &#x3D; this.buildHandlerModuleSource(options, normalizedEvent);
    await writeFile(handlerPath, source, &amp;#39;utf-8&amp;#39;);

    const handler &#x3D; await this.discovery.registerHandlerFromFile(
      handlerPath,
      options.provider,
      normalizedEvent
    );

    this.logger.info(&amp;#39;Custom handler created&amp;#39;, {
      id: handler.id,
      provider: handler.provider,
      event: handler.event,
      path: handler.handlerPath,
    });

    return handler;
  }

  /**
   * Get all registered handlers
   */
  getHandlers(): RegisteredHandler[] {
    return this.discovery.getHandlers();
  }

  /**
   * Get handlers for specific provider/event
   */
  getHandlersForEvent(provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;, event: string): RegisteredHandler[] {
    return this.discovery.getHandlersForEvent(provider, event);
  }

  /**
   * Get handler by ID
   */
  getHandler(id: string): RegisteredHandler | undefined {
    return this.discovery.getHandler(id);
  }

  /**
   * Update handler configuration
   */
  updateHandlerConfig(id: string, updates: Partial&amp;lt;RegisteredHandler&amp;gt;): boolean {
    return this.discovery.updateHandlerConfig(id, updates);
  }

  /**
   * Enable/disable handler
   */
  setHandlerEnabled(id: string, enabled: boolean): boolean {
    return this.discovery.setHandlerEnabled(id, enabled);
  }

  /**
   * Remove handler
   */
  removeHandler(id: string): boolean {
    return this.discovery.removeHandler(id);
  }

  /**
   * Reload handler from file
   */
  async reloadHandler(id: string): Promise&amp;lt;boolean&amp;gt; {
    return await this.discovery.reloadHandler(id);
  }

  /**
   * Get execution history
   */
  getExecutionHistory(limit &#x3D; 100): HandlerExecution[] {
    return this.executor.getExecutionHistory(limit);
  }

  /**
   * Get handler statistics
   */
  getHandlerStats(): {
    totalHandlers: number;
    enabledHandlers: number;
    activeExecutions: number;
    totalExecutions: number;
    failedExecutions: number;
  } {
    const handlers &#x3D; this.discovery.getHandlers();
    const executions &#x3D; this.executor.getExecutionHistory();

    return {
      totalHandlers: handlers.length,
      enabledHandlers: handlers.filter(h &#x3D;&amp;gt; h.enabled).length,
      activeExecutions: this.executor.getActiveExecutionCount(),
      totalExecutions: executions.length,
      failedExecutions: executions.filter(e &#x3D;&amp;gt; !e.result.success).length,
    };
  }



  private normalizeEventName(event: string): string {
    const trimmed &#x3D; event.trim().toLowerCase();
    if (trimmed.length &#x3D;&#x3D;&#x3D; 0) {
      throw new Error(&amp;#39;Event name is required&amp;#39;);
    }

    if (trimmed.includes(&amp;#39;/&amp;#39;) || trimmed.includes(&amp;#39;\\&amp;#39;)) {
      throw new Error(&amp;#39;Event name cannot contain path separators&amp;#39;);
    }

    return trimmed.replace(/[^a-z0-9._-]/g, &amp;#39;-&amp;#39;);
  }

  private detectFileExtension(code: string): &amp;#39;.ts&amp;#39; | &amp;#39;.js&amp;#39; {
    const trimmed &#x3D; code.trim();
    if (trimmed.includes(&amp;#39;module.exports&amp;#39;) || trimmed.includes(&amp;#39;require(&amp;#39;)) {
      return &amp;#39;.js&amp;#39;;
    }

    if (trimmed.includes(&amp;#39;export &amp;#39;) || trimmed.includes(&amp;#39;import &amp;#39;)) {
      return &amp;#39;.ts&amp;#39;;
    }

    return &amp;#39;.ts&amp;#39;;
  }

  private async pathExists(target: string): Promise&amp;lt;boolean&amp;gt; {
    try {
      await access(target);
      return true;
    } catch {
      return false;
    }
  }

  private buildHandlerModuleSource(
    options: HandlerCreationOptions,
    normalizedEvent: string
  ): string {
    const trimmed &#x3D; options.code.trim();

    if (trimmed.includes(&amp;#39;export default&amp;#39;)) {
      const transformed &#x3D; trimmed.replace(/export\s+default/, &amp;#39;module.exports &#x3D;&amp;#39;);
      return transformed.endsWith(&amp;#39;\n&amp;#39;) ? transformed : &#x60;${transformed}\n&#x60;;
    }

    if (trimmed.includes(&amp;#39;module.exports&amp;#39;) || trimmed.includes(&amp;#39;exports.&amp;#39;)) {
      return trimmed.endsWith(&amp;#39;\n&amp;#39;) ? trimmed : &#x60;${trimmed}\n&#x60;;
    }

    const defaultTimeout &#x3D; this.config.handlers?.defaultTimeout ?? 30000;
    const defaultRetries &#x3D; this.config.handlers?.defaultRetries ?? 2;

    const config &#x3D; {
      enabled: options.config?.enabled ?? true,
      timeout: options.config?.timeout ?? defaultTimeout,
      retries: options.config?.retries ?? defaultRetries,
      environment: options.config?.environment ?? {},
      secrets: options.config?.secrets ?? {},
    };

    const metadata &#x3D; {
      name: options.metadata?.name ?? &#x60;${options.provider} ${normalizedEvent} handler&#x60;,
      description:
        options.metadata?.description ?? &amp;#39;Custom webhook handler generated by Arbiter&amp;#39;,
      version: options.metadata?.version ?? &amp;#39;1.0.0&amp;#39;,
      author: options.metadata?.author ?? &amp;#39;Arbiter&amp;#39;,
      supportedEvents: [normalizedEvent],
      requiredPermissions: [],
    };

    const defaultBody &#x3D; [
      &amp;#39;return {&amp;#39;,
      &amp;quot;  success: true,&amp;quot;,
      &amp;quot;  message: &amp;#39;Handler executed successfully&amp;#39;,&amp;quot;,
      &amp;#39;  actions: [],&amp;#39;,
      &amp;#39;};&amp;#39;,
    ].join(&amp;quot;\n&amp;quot;);

    const body &#x3D; trimmed.length &amp;gt; 0 ? this.indentSnippet(trimmed) : this.indentSnippet(defaultBody);

    return &#x60;module.exports &#x3D; {
  config: ${this.formatObjectLiteral(config, 4)},
  metadata: ${this.formatObjectLiteral(metadata, 4)},
  handler: async (payload, context) &#x3D;&amp;gt; {
${body}
  },
};
&#x60;;
  }

  private formatObjectLiteral(value: unknown, indent: number): string {
    const json &#x3D; JSON.stringify(value, null, 2);
    const lines &#x3D; json.split(&amp;quot;\n&amp;quot;);
    return lines
      .map((line, index) &#x3D;&amp;gt; {
        if (index &#x3D;&#x3D;&#x3D; 0 || index &#x3D;&#x3D;&#x3D; lines.length - 1) {
          return line;
        }
        return &#x60;${&amp;#39; &amp;#39;.repeat(indent)}${line.trimStart()}&#x60;;
      })
      .join(&amp;#39;\n&amp;#39;);
  }

  private indentSnippet(snippet: string, indentSize &#x3D; 4): string {
    const indent &#x3D; &amp;#39; &amp;#39;.repeat(indentSize);
    return snippet
      .split(&amp;#39;\n&amp;#39;)
      .map(line &#x3D;&amp;gt; &#x60;${indent}${line.trimEnd()}&#x60;)
      .join(&amp;#39;\n&amp;#39;);
  }

  /**
   * Create a new handler directory structure
   */
  async createHandlerStructure(): Promise&amp;lt;void&amp;gt; {
    const { promises: fs } &#x3D; await import(&amp;#39;node:fs&amp;#39;);
    const path &#x3D; await import(&amp;#39;node:path&amp;#39;);

    const handlersDir &#x3D; path.join(process.cwd(), &amp;#39;arbiter&amp;#39;, &amp;#39;handlers&amp;#39;);

    try {
      // Create directory structure
      await fs.mkdir(path.join(handlersDir, &amp;#39;github&amp;#39;), { recursive: true });
      await fs.mkdir(path.join(handlersDir, &amp;#39;gitlab&amp;#39;), { recursive: true });
      await fs.mkdir(path.join(handlersDir, &amp;#39;shared&amp;#39;), { recursive: true });
      await fs.mkdir(path.join(handlersDir, &amp;#39;examples&amp;#39;), { recursive: true });

      // Create example configuration
      const configExample &#x3D; {
        $schema: &amp;#39;./handler-config.schema.json&amp;#39;,
        defaults: {
          timeout: 30000,
          retries: 2,
          enabled: true,
        },
        handlers: {
          &amp;#39;github/push&amp;#39;: {
            enabled: true,
            timeout: 15000,
            environment: {
              NODE_ENV: &amp;#39;production&amp;#39;,
            },
            secrets: {
              SLACK_WEBHOOK: &amp;#39;${HANDLER_SLACK_WEBHOOK}&amp;#39;,
              JIRA_TOKEN: &amp;#39;${HANDLER_JIRA_TOKEN}&amp;#39;,
            },
          },
        },
      };

      await fs.writeFile(
        path.join(handlersDir, &amp;#39;.handlers-config.json&amp;#39;),
        JSON.stringify(configExample, null, 2)
      );

      // Create shared utilities example
      const utilsExample &#x3D; &#x60;/**
 * Shared utilities for webhook handlers
 */

export function formatSlackMessage(title: string, details: Record&amp;lt;string, unknown&amp;gt;) {
  return {
    blocks: [
      {
        type: &amp;#39;section&amp;#39;,
        text: {
          type: &amp;#39;mrkdwn&amp;#39;,
          text: \&#x60;*\${title}*\&#x60;
        }
      },
      {
        type: &amp;#39;section&amp;#39;,
        fields: Object.entries(details).map(([key, value]) &#x3D;&amp;gt; ({
          type: &amp;#39;mrkdwn&amp;#39;,
          text: \&#x60;*\${key}:* \${value}\&#x60;
        }))
      }
    ]
  };
}

export function extractSpecFiles(filePaths: string[]): string[] {
  return filePaths.filter(path &#x3D;&amp;gt; path.endsWith(&amp;#39;.cue&amp;#39;) || path.endsWith(&amp;#39;.spec.ts&amp;#39;));
}

export function shouldNotify(branch: string, defaultBranch: string): boolean {
  return branch &#x3D;&#x3D;&#x3D; \&#x60;refs/heads/\${defaultBranch}\&#x60; || branch.includes(&amp;#39;release&amp;#39;);
}
&#x60;;

      await fs.writeFile(path.join(handlersDir, &amp;#39;shared&amp;#39;, &amp;#39;utils.ts&amp;#39;), utilsExample);

      this.logger.info(&amp;#39;Handler directory structure created&amp;#39;, { path: handlersDir });
    } catch (error) {
      this.logger.error(&amp;#39;Failed to create handler structure&amp;#39;, error as Error);
      throw error;
    }
  }

  /**
   * Validate handler file
   */
  async validateHandler(filePath: string): Promise&amp;lt;{
    valid: boolean;
    errors: string[];
    warnings: string[];
  }&amp;gt; {
    const result &#x3D; {
      valid: true,
      errors: [] as string[],
      warnings: [] as string[],
    };

    try {
      // Basic file validation
      const { promises: fs } &#x3D; await import(&amp;#39;node:fs&amp;#39;);
      const content &#x3D; await fs.readFile(filePath, &amp;#39;utf-8&amp;#39;);

      // Check for required exports
      if (!content.includes(&amp;#39;export default&amp;#39;) &amp;amp;&amp;amp; !content.includes(&amp;#39;exports.handler&amp;#39;)) {
        result.errors.push(&amp;#39;Handler must export a default handler module&amp;#39;);
        result.valid &#x3D; false;
      }

      // Check for async handler function
      if (!content.includes(&amp;#39;async&amp;#39;) || !content.includes(&amp;#39;Promise&amp;#39;)) {
        result.warnings.push(&amp;#39;Handler should be async and return a Promise&amp;lt;HandlerResult&amp;gt;&amp;#39;);
      }

      // Check for proper error handling
      if (!content.includes(&amp;#39;try&amp;#39;) || !content.includes(&amp;#39;catch&amp;#39;)) {
        result.warnings.push(&amp;#39;Handler should include proper error handling (try/catch)&amp;#39;);
      }

      // Check for context usage
      if (!content.includes(&amp;#39;context.logger&amp;#39;) &amp;amp;&amp;amp; !content.includes(&amp;#39;logger&amp;#39;)) {
        result.warnings.push(&amp;#39;Handler should use context.logger for logging&amp;#39;);
      }
    } catch (error) {
      result.errors.push(
        &#x60;Failed to read handler file: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;
      );
      result.valid &#x3D; false;
    }

    return result;
  }

  /**
   * Shutdown handler manager
   */
  async dispose(): Promise&amp;lt;void&amp;gt; {
    this.logger.info(&amp;#39;Shutting down custom handler manager&amp;#39;);

    this.executor.dispose();
    this.discovery.dispose();

    this.initialized &#x3D; false;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-29">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/github-templates.ts</div>
                <div class="file-content">
                    <pre>/**
 * GitHub Templates and Field Management
 *
 * Provides structured templates for GitHub issues and proper field organization
 * instead of just putting everything in the body text.
 *
 * @deprecated Use ConfigurableTemplateManager from github-template-config.ts instead
 */

import {
  ConfigurableTemplateManager,
  DEFAULT_TEMPLATES_CONFIG,
  type GeneratedTemplate,
  type TemplateFiles,
} from &amp;#39;./github-template-config.js&amp;#39;;
import type { Epic, Task } from &amp;#39;./sharded-storage.js&amp;#39;;

export interface GitHubEpicTemplate {
  title: string;
  body: string;
  labels: string[];
  assignees?: string[];
  milestone?: number;
  projects?: number[];
}

export interface GitHubTaskTemplate {
  title: string;
  body: string;
  labels: string[];
  assignees?: string[];
  milestone?: number;
  projects?: number[];
}

export interface GitHubTemplateOptions {
  includeMetadata?: boolean;
  includeArbiterIds?: boolean;
  includeAcceptanceCriteria?: boolean;
  includeDependencies?: boolean;
  includeEstimations?: boolean;
  customFields?: Record&amp;lt;string, string&amp;gt;;
}

export interface ValidationRule {
  field: string;
  required: boolean;
  validator?: (value: any) &#x3D;&amp;gt; boolean;
  errorMessage?: string;
}

export interface TemplateValidationConfig {
  epic: ValidationRule[];
  task: ValidationRule[];
  milestone: ValidationRule[];
}

/**
 * Default validation rules for GitHub templates
 */
export const DEFAULT_VALIDATION_CONFIG: TemplateValidationConfig &#x3D; {
  epic: [
    {
      field: &amp;#39;name&amp;#39;,
      required: true,
      validator: (value: string) &#x3D;&amp;gt; value.length &amp;gt;&#x3D; 5 &amp;amp;&amp;amp; value.length &amp;lt;&#x3D; 80,
      errorMessage: &amp;#39;Epic name must be 5-80 characters&amp;#39;,
    },
    {
      field: &amp;#39;description&amp;#39;,
      required: true,
      validator: (value: string) &#x3D;&amp;gt; value.length &amp;gt;&#x3D; 20,
      errorMessage: &amp;#39;Epic description must be at least 20 characters&amp;#39;,
    },
    {
      field: &amp;#39;priority&amp;#39;,
      required: true,
      validator: (value: string) &#x3D;&amp;gt; [&amp;#39;critical&amp;#39;, &amp;#39;high&amp;#39;, &amp;#39;medium&amp;#39;, &amp;#39;low&amp;#39;].includes(value),
      errorMessage: &amp;#39;Priority must be one of: critical, high, medium, low&amp;#39;,
    },
    {
      field: &amp;#39;owner&amp;#39;,
      required: true,
      validator: (value: string) &#x3D;&amp;gt; value.length &amp;gt; 0,
      errorMessage: &amp;#39;Epic must have an assigned owner&amp;#39;,
    },
  ],
  task: [
    {
      field: &amp;#39;name&amp;#39;,
      required: true,
      validator: (value: string) &#x3D;&amp;gt; value.length &amp;gt;&#x3D; 5 &amp;amp;&amp;amp; value.length &amp;lt;&#x3D; 80,
      errorMessage: &amp;#39;Task name must be 5-80 characters&amp;#39;,
    },
    {
      field: &amp;#39;description&amp;#39;,
      required: true,
      validator: (value: string) &#x3D;&amp;gt; value.length &amp;gt;&#x3D; 10,
      errorMessage: &amp;#39;Task description must be at least 10 characters&amp;#39;,
    },
    {
      field: &amp;#39;type&amp;#39;,
      required: true,
      validator: (value: string) &#x3D;&amp;gt;
        [&amp;#39;feature&amp;#39;, &amp;#39;bug&amp;#39;, &amp;#39;refactor&amp;#39;, &amp;#39;test&amp;#39;, &amp;#39;docs&amp;#39;, &amp;#39;devops&amp;#39;, &amp;#39;research&amp;#39;].includes(value),
      errorMessage:
        &amp;#39;Task type must be one of: feature, bug, refactor, test, docs, devops, research&amp;#39;,
    },
    {
      field: &amp;#39;acceptanceCriteria&amp;#39;,
      required: true,
      validator: (value: string[]) &#x3D;&amp;gt; Array.isArray(value) &amp;amp;&amp;amp; value.length &amp;gt; 0,
      errorMessage: &amp;#39;Task must have at least one acceptance criterion&amp;#39;,
    },
  ],
  milestone: [
    {
      field: &amp;#39;name&amp;#39;,
      required: true,
      validator: (value: string) &#x3D;&amp;gt; value.length &amp;gt;&#x3D; 5 &amp;amp;&amp;amp; value.length &amp;lt;&#x3D; 80,
      errorMessage: &amp;#39;Milestone name must be 5-80 characters&amp;#39;,
    },
  ],
};

export class GitHubTemplateManager {
  private validationConfig: TemplateValidationConfig;

  constructor(validationConfig: TemplateValidationConfig &#x3D; DEFAULT_VALIDATION_CONFIG) {
    this.validationConfig &#x3D; validationConfig;
  }

  /**
   * Generate epic template with proper structured fields
   */
  generateEpicTemplate(epic: Epic, options: GitHubTemplateOptions &#x3D; {}): GitHubEpicTemplate {
    // Validate epic before generating template
    this.validateEpic(epic);

    const title &#x3D; this.generateEpicTitle(epic);
    const body &#x3D; this.generateEpicBody(epic, options);
    const labels &#x3D; this.generateEpicLabels(epic);
    const assignees &#x3D; this.generateEpicAssignees(epic);

    return {
      title,
      body,
      labels,
      assignees,
    };
  }

  /**
   * Generate task template with proper structured fields
   */
  generateTaskTemplate(
    task: Task,
    epic: Epic,
    options: GitHubTemplateOptions &#x3D; {}
  ): GitHubTaskTemplate {
    // Validate task before generating template
    this.validateTask(task);

    const title &#x3D; this.generateTaskTitle(task, epic);
    const body &#x3D; this.generateTaskBody(task, epic, options);
    const labels &#x3D; this.generateTaskLabels(task, epic);
    const assignees &#x3D; this.generateTaskAssignees(task);

    return {
      title,
      body,
      labels,
      assignees,
    };
  }

  /**
   * Validate epic against configured rules
   */
  validateEpic(epic: Epic): void {
    const errors: string[] &#x3D; [];

    for (const rule of this.validationConfig.epic) {
      const value &#x3D; (epic as any)[rule.field];

      if (rule.required &amp;amp;&amp;amp; (!value || (Array.isArray(value) &amp;amp;&amp;amp; value.length &#x3D;&#x3D;&#x3D; 0))) {
        errors.push(rule.errorMessage || &#x60;${rule.field} is required&#x60;);
        continue;
      }

      if (value &amp;amp;&amp;amp; rule.validator &amp;amp;&amp;amp; !rule.validator(value)) {
        errors.push(rule.errorMessage || &#x60;${rule.field} is invalid&#x60;);
      }
    }

    if (errors.length &amp;gt; 0) {
      throw new Error(&#x60;Epic validation failed:\n${errors.map(e &#x3D;&amp;gt; &#x60;  â€¢ ${e}&#x60;).join(&amp;#39;\n&amp;#39;)}&#x60;);
    }
  }

  /**
   * Validate task against configured rules
   */
  validateTask(task: Task): void {
    const errors: string[] &#x3D; [];

    for (const rule of this.validationConfig.task) {
      const value &#x3D; (task as any)[rule.field];

      if (rule.required &amp;amp;&amp;amp; (!value || (Array.isArray(value) &amp;amp;&amp;amp; value.length &#x3D;&#x3D;&#x3D; 0))) {
        errors.push(rule.errorMessage || &#x60;${rule.field} is required&#x60;);
        continue;
      }

      if (value &amp;amp;&amp;amp; rule.validator &amp;amp;&amp;amp; !rule.validator(value)) {
        errors.push(rule.errorMessage || &#x60;${rule.field} is invalid&#x60;);
      }
    }

    if (errors.length &amp;gt; 0) {
      throw new Error(&#x60;Task validation failed:\n${errors.map(e &#x3D;&amp;gt; &#x60;  â€¢ ${e}&#x60;).join(&amp;#39;\n&amp;#39;)}&#x60;);
    }
  }

  /**
   * Generate properly structured epic title
   */
  private generateEpicTitle(epic: Epic): string {
    const prefix &#x3D; &amp;#39;[EPIC]&amp;#39;;
    const priority &#x3D; epic.priority?.toUpperCase() || &amp;#39;MEDIUM&amp;#39;;
    return &#x60;${prefix} ${priority}: ${epic.name}&#x60;;
  }

  /**
   * Generate properly structured task title
   */
  private generateTaskTitle(task: Task, epic: Epic): string {
    const prefix &#x3D; &#x60;[${task.type?.toUpperCase() || &amp;#39;TASK&amp;#39;}]&#x60;;
    const priority &#x3D; task.priority?.toUpperCase() || &amp;#39;MEDIUM&amp;#39;;
    return &#x60;${prefix} ${priority}: ${task.name}&#x60;;
  }

  /**
   * Generate structured epic body using GitHub&amp;#39;s field formatting
   */
  private generateEpicBody(epic: Epic, options: GitHubTemplateOptions): string {
    let body &#x3D; &amp;#39;&amp;#39;;

    // Add hidden Arbiter ID for tracking
    if (options.includeArbiterIds !&#x3D;&#x3D; false) {
      body +&#x3D; &#x60;&amp;lt;!-- arbiter-id: ${epic.id} --&amp;gt;\n&amp;lt;!-- arbiter-type: epic --&amp;gt;\n\n&#x60;;
    }

    // Description section
    body +&#x3D; &#x60;## ğŸ“‹ Description\n\n${epic.description || &amp;#39;No description provided&amp;#39;}\n\n&#x60;;

    // Epic Details section
    body +&#x3D; &amp;#39;## ğŸ“Š Epic Details\n\n&amp;#39;;
    body +&#x3D; &amp;#39;| Field | Value |\n&amp;#39;;
    body +&#x3D; &amp;#39;|-------|-------|\n&amp;#39;;
    body +&#x3D; &#x60;| **Priority** | \&#x60;${epic.priority}\&#x60; |\n&#x60;;
    body +&#x3D; &#x60;| **Status** | \&#x60;${epic.status}\&#x60; |\n&#x60;;
    body +&#x3D; &#x60;| **Owner** | ${epic.owner ? &#x60;@${epic.owner}&#x60; : &amp;#39;Unassigned&amp;#39;} |\n&#x60;;
    body +&#x3D; &#x60;| **Assignee** | ${epic.assignee ? &#x60;@${epic.assignee}&#x60; : &amp;#39;Unassigned&amp;#39;} |\n&#x60;;

    if (options.includeEstimations !&#x3D;&#x3D; false) {
      if (epic.estimatedHours) {
        body +&#x3D; &#x60;| **Estimated Hours** | ${epic.estimatedHours}h |\n&#x60;;
      }
      if (epic.actualHours) {
        body +&#x3D; &#x60;| **Actual Hours** | ${epic.actualHours}h |\n&#x60;;
      }
    }

    if (epic.startDate) {
      body +&#x3D; &#x60;| **Start Date** | ${epic.startDate} |\n&#x60;;
    }
    if (epic.dueDate) {
      body +&#x3D; &#x60;| **Due Date** | ${epic.dueDate} |\n&#x60;;
    }

    body +&#x3D; &amp;#39;\n&amp;#39;;

    // Tasks Overview section
    if (epic.tasks.length &amp;gt; 0) {
      body +&#x3D; &amp;#39;## âœ… Tasks Overview\n\n&amp;#39;;
      body +&#x3D; &#x60;**Total Tasks:** ${epic.tasks.length}\n\n&#x60;;

      const tasksByStatus &#x3D; epic.tasks.reduce(
        (acc, task) &#x3D;&amp;gt; {
          acc[task.status] &#x3D; (acc[task.status] || 0) + 1;
          return acc;
        },
        {} as Record&amp;lt;string, number&amp;gt;
      );

      body +&#x3D; &amp;#39;**Status Breakdown:**\n&amp;#39;;
      Object.entries(tasksByStatus).forEach(([status, count]) &#x3D;&amp;gt; {
        const emoji &#x3D; this.getStatusEmoji(status);
        body +&#x3D; &#x60;- ${emoji} ${status}: ${count} tasks\n&#x60;;
      });
      body +&#x3D; &amp;#39;\n&amp;#39;;
    }

    // Dependencies section
    if (
      options.includeDependencies !&#x3D;&#x3D; false &amp;amp;&amp;amp;
      epic.dependencies &amp;amp;&amp;amp;
      epic.dependencies.length &amp;gt; 0
    ) {
      body +&#x3D; &amp;#39;## ğŸ”— Dependencies\n\n&amp;#39;;
      epic.dependencies.forEach(dep &#x3D;&amp;gt; {
        body +&#x3D; &#x60;- [ ] ${dep}\n&#x60;;
      });
      body +&#x3D; &amp;#39;\n&amp;#39;;
    }

    // Labels and Tags section
    if (epic.labels &amp;amp;&amp;amp; epic.labels.length &amp;gt; 0) {
      body +&#x3D; &amp;#39;## ğŸ·ï¸ Labels\n\n&amp;#39;;
      epic.labels.forEach(label &#x3D;&amp;gt; {
        body +&#x3D; &#x60;\&#x60;${label}\&#x60; &#x60;;
      });
      body +&#x3D; &amp;#39;\n\n&amp;#39;;
    }

    // Custom fields
    if (options.customFields &amp;amp;&amp;amp; Object.keys(options.customFields).length &amp;gt; 0) {
      body +&#x3D; &amp;#39;## ğŸ”§ Additional Information\n\n&amp;#39;;
      Object.entries(options.customFields).forEach(([key, value]) &#x3D;&amp;gt; {
        body +&#x3D; &#x60;**${key}:** ${value}\n&#x60;;
      });
      body +&#x3D; &amp;#39;\n&amp;#39;;
    }

    return body.trim();
  }

  /**
   * Generate structured task body using GitHub&amp;#39;s field formatting
   */
  private generateTaskBody(task: Task, epic: Epic, options: GitHubTemplateOptions): string {
    let body &#x3D; &amp;#39;&amp;#39;;

    // Add hidden Arbiter ID for tracking
    if (options.includeArbiterIds !&#x3D;&#x3D; false) {
      body +&#x3D; &#x60;&amp;lt;!-- arbiter-id: ${task.id} --&amp;gt;\n&amp;lt;!-- arbiter-type: task --&amp;gt;\n&#x60;;
      body +&#x3D; &#x60;&amp;lt;!-- arbiter-epic-id: ${epic.id} --&amp;gt;\n\n&#x60;;
    }

    // Description section
    body +&#x3D; &#x60;## ğŸ“‹ Description\n\n${task.description || &amp;#39;No description provided&amp;#39;}\n\n&#x60;;

    // Task Details section
    body +&#x3D; &amp;#39;## ğŸ“Š Task Details\n\n&amp;#39;;
    body +&#x3D; &amp;#39;| Field | Value |\n&amp;#39;;
    body +&#x3D; &amp;#39;|-------|-------|\n&amp;#39;;
    body +&#x3D; &#x60;| **Epic** | [${epic.name}](../issues) |\n&#x60;;
    body +&#x3D; &#x60;| **Type** | \&#x60;${task.type}\&#x60; |\n&#x60;;
    body +&#x3D; &#x60;| **Priority** | \&#x60;${task.priority}\&#x60; |\n&#x60;;
    body +&#x3D; &#x60;| **Status** | \&#x60;${task.status}\&#x60; |\n&#x60;;
    body +&#x3D; &#x60;| **Assignee** | ${task.assignee ? &#x60;@${task.assignee}&#x60; : &amp;#39;Unassigned&amp;#39;} |\n&#x60;;
    body +&#x3D; &#x60;| **Reviewer** | ${task.reviewer ? &#x60;@${task.reviewer}&#x60; : &amp;#39;TBD&amp;#39;} |\n&#x60;;

    if (options.includeEstimations !&#x3D;&#x3D; false) {
      if (task.estimatedHours) {
        body +&#x3D; &#x60;| **Estimated Hours** | ${task.estimatedHours}h |\n&#x60;;
      }
      if (task.actualHours) {
        body +&#x3D; &#x60;| **Actual Hours** | ${task.actualHours}h |\n&#x60;;
      }
    }

    body +&#x3D; &amp;#39;\n&amp;#39;;

    // Acceptance Criteria section
    if (
      options.includeAcceptanceCriteria !&#x3D;&#x3D; false &amp;amp;&amp;amp;
      task.acceptanceCriteria &amp;amp;&amp;amp;
      task.acceptanceCriteria.length &amp;gt; 0
    ) {
      body +&#x3D; &amp;#39;## âœ… Acceptance Criteria\n\n&amp;#39;;
      task.acceptanceCriteria.forEach((criteria, index) &#x3D;&amp;gt; {
        body +&#x3D; &#x60;${index + 1}. [ ] ${criteria}\n&#x60;;
      });
      body +&#x3D; &amp;#39;\n&amp;#39;;
    }

    // Dependencies section
    if (options.includeDependencies !&#x3D;&#x3D; false &amp;amp;&amp;amp; task.dependsOn &amp;amp;&amp;amp; task.dependsOn.length &amp;gt; 0) {
      body +&#x3D; &amp;#39;## ğŸ”— Dependencies\n\n&amp;#39;;
      body +&#x3D; &amp;#39;This task depends on the following:\n\n&amp;#39;;
      task.dependsOn.forEach(dep &#x3D;&amp;gt; {
        body +&#x3D; &#x60;- [ ] ${dep}\n&#x60;;
      });
      body +&#x3D; &amp;#39;\n&amp;#39;;
    }

    // Configuration section
    if (task.config) {
      body +&#x3D; &amp;#39;## âš™ï¸ Configuration\n\n&amp;#39;;
      if (task.config.canRunInParallel) {
        body +&#x3D; &amp;#39;- âœ… Can run in parallel with other tasks\n&amp;#39;;
      }
      if (task.config.requiresReview) {
        body +&#x3D; &amp;#39;- ğŸ‘€ Requires code review before completion\n&amp;#39;;
      }
      if (task.config.requiresTesting) {
        body +&#x3D; &amp;#39;- ğŸ§ª Requires testing before completion\n&amp;#39;;
      }
      if (task.config.blocksOtherTasks) {
        body +&#x3D; &amp;#39;- ğŸš§ Blocks other tasks until completed\n&amp;#39;;
      }
      body +&#x3D; &amp;#39;\n&amp;#39;;
    }

    // Custom fields
    if (options.customFields &amp;amp;&amp;amp; Object.keys(options.customFields).length &amp;gt; 0) {
      body +&#x3D; &amp;#39;## ğŸ”§ Additional Information\n\n&amp;#39;;
      Object.entries(options.customFields).forEach(([key, value]) &#x3D;&amp;gt; {
        body +&#x3D; &#x60;**${key}:** ${value}\n&#x60;;
      });
      body +&#x3D; &amp;#39;\n&amp;#39;;
    }

    return body.trim();
  }

  /**
   * Generate epic labels with proper categorization
   */
  private generateEpicLabels(epic: Epic): string[] {
    const labels: string[] &#x3D; [];

    // Type label
    labels.push(&amp;#39;epic&amp;#39;);

    // Priority label
    labels.push(&#x60;priority:${epic.priority}&#x60;);

    // Status label
    labels.push(&#x60;status:${epic.status}&#x60;);

    // Custom labels from epic
    if (epic.labels &amp;amp;&amp;amp; epic.labels.length &amp;gt; 0) {
      labels.push(...epic.labels);
    }

    return [...new Set(labels)]; // Remove duplicates
  }

  /**
   * Generate task labels with proper categorization
   */
  private generateTaskLabels(task: Task, epic: Epic): string[] {
    const labels: string[] &#x3D; [];

    // Type label
    labels.push(&#x60;type:${task.type}&#x60;);

    // Priority label
    labels.push(&#x60;priority:${task.priority}&#x60;);

    // Status label
    labels.push(&#x60;status:${task.status}&#x60;);

    // Epic reference
    labels.push(&#x60;epic:${epic.id}&#x60;);

    // Configuration-based labels
    if (task.config?.requiresReview) {
      labels.push(&amp;#39;needs-review&amp;#39;);
    }
    if (task.config?.requiresTesting) {
      labels.push(&amp;#39;needs-testing&amp;#39;);
    }
    if (task.config?.canRunInParallel) {
      labels.push(&amp;#39;parallel-safe&amp;#39;);
    }

    return [...new Set(labels)]; // Remove duplicates
  }

  /**
   * Generate epic assignees
   */
  private generateEpicAssignees(epic: Epic): string[] | undefined {
    const assignees: string[] &#x3D; [];

    if (epic.assignee) {
      assignees.push(epic.assignee);
    }
    if (epic.owner &amp;amp;&amp;amp; epic.owner !&#x3D;&#x3D; epic.assignee) {
      assignees.push(epic.owner);
    }

    return assignees.length &amp;gt; 0 ? assignees : undefined;
  }

  /**
   * Generate task assignees
   */
  private generateTaskAssignees(task: Task): string[] | undefined {
    const assignees: string[] &#x3D; [];

    if (task.assignee) {
      assignees.push(task.assignee);
    }

    return assignees.length &amp;gt; 0 ? assignees : undefined;
  }

  /**
   * Get status emoji for display
   */
  private getStatusEmoji(status: string): string {
    const emojis: Record&amp;lt;string, string&amp;gt; &#x3D; {
      todo: &amp;#39;ğŸ“‹&amp;#39;,
      planning: &amp;#39;ğŸ“‹&amp;#39;,
      in_progress: &amp;#39;ğŸš§&amp;#39;,
      review: &amp;#39;ğŸ‘€&amp;#39;,
      testing: &amp;#39;ğŸ§ª&amp;#39;,
      completed: &amp;#39;âœ…&amp;#39;,
      cancelled: &amp;#39;âŒ&amp;#39;,
    };
    return emojis[status] || &amp;#39;â“&amp;#39;;
  }
}

/**
 * Create GitHub issue template files for repositories
 * @deprecated Use ConfigurableTemplateManager.generateRepositoryTemplates() instead
 */
export function generateGitHubIssueTemplates(): Record&amp;lt;string, string&amp;gt; {
  const manager &#x3D; new ConfigurableTemplateManager();
  return manager.generateRepositoryTemplates();
}

/**
 * Generate repository configuration for GitHub templates
 * @deprecated Use ConfigurableTemplateManager.generateRepositoryTemplates() instead
 */
export function generateGitHubConfiguration(): Record&amp;lt;string, string&amp;gt; {
  const manager &#x3D; new ConfigurableTemplateManager();
  const allFiles &#x3D; manager.generateRepositoryTemplates();

  // Return only configuration files (not template files)
  const configFiles: Record&amp;lt;string, string&amp;gt; &#x3D; {};
  Object.entries(allFiles).forEach(([path, content]) &#x3D;&amp;gt; {
    if (path.includes(&amp;#39;config.yml&amp;#39;) || path.includes(&amp;#39;labels.yml&amp;#39;)) {
      configFiles[path] &#x3D; content;
    }
  });

  return configFiles;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-30">
                <div class="file-header">ğŸ“„ packages/cli/src/constraints/monitoring.ts</div>
                <div class="file-content">
                    <pre>import { EventEmitter } from &amp;#39;node:events&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import type { ConstraintViolationError } from &amp;#39;./core.js&amp;#39;;

/**
 * Violation event data
 */
export interface ViolationEvent {
  constraint: string;
  violation: ConstraintViolationError;
  timestamp: number;
  operation?: string;
  context?: Record&amp;lt;string, unknown&amp;gt;;
}

/**
 * Performance metrics
 */
export interface PerformanceMetrics {
  operationCount: number;
  totalDuration: number;
  averageDuration: number;
  maxDuration: number;
  minDuration: number;
  violationsCount: number;
  successRate: number;
}

/**
 * Monitoring configuration
 */
export interface MonitoringConfig {
  enableMetrics: boolean;
  enableViolationTracking: boolean;
  metricsRetentionDays: number;
  violationLogPath?: string;
  metricsLogPath?: string;
  alertThresholds: {
    maxViolationsPerHour: number;
    maxAverageResponseTime: number;
    minSuccessRate: number;
  };
}

/**
 * Default monitoring configuration
 */
export const DEFAULT_MONITORING_CONFIG: MonitoringConfig &#x3D; {
  enableMetrics: true,
  enableViolationTracking: true,
  metricsRetentionDays: 7,
  alertThresholds: {
    maxViolationsPerHour: 10,
    maxAverageResponseTime: 500, // 500ms
    minSuccessRate: 95, // 95%
  },
};

/**
 * Comprehensive constraint monitoring and reporting system
 */
export class ConstraintMonitor extends EventEmitter {
  private readonly config: MonitoringConfig;
  private readonly violations: ViolationEvent[] &#x3D; [];
  private readonly operationMetrics &#x3D; new Map&amp;lt;string, PerformanceMetrics&amp;gt;();
  private readonly startTime &#x3D; Date.now();

  private violationCounts &#x3D; {
    total: 0,
    lastHour: 0,
    byConstraint: new Map&amp;lt;string, number&amp;gt;(),
    byOperation: new Map&amp;lt;string, number&amp;gt;(),
  };

  constructor(config: Partial&amp;lt;MonitoringConfig&amp;gt; &#x3D; {}) {
    super();
    this.config &#x3D; { ...DEFAULT_MONITORING_CONFIG, ...config };

    if (this.config.enableMetrics || this.config.enableViolationTracking) {
      this.startMonitoring();
    }
  }

  /**
   * Record a constraint violation
   */
  recordViolation(event: ViolationEvent): void {
    if (!this.config.enableViolationTracking) return;

    // Store violation
    this.violations.push(event);

    // Update counts
    this.violationCounts.total++;
    this.violationCounts.lastHour++; // Will be reset hourly

    const constraintCount &#x3D; this.violationCounts.byConstraint.get(event.constraint) || 0;
    this.violationCounts.byConstraint.set(event.constraint, constraintCount + 1);

    if (event.operation) {
      const operationCount &#x3D; this.violationCounts.byOperation.get(event.operation) || 0;
      this.violationCounts.byOperation.set(event.operation, operationCount + 1);
    }

    // Emit alert if thresholds exceeded
    this.checkAlertThresholds();

    // Log violation
    this.logViolation(event);

    // Emit monitoring event
    this.emit(&amp;#39;violation_recorded&amp;#39;, event);
  }

  /**
   * Record operation performance metrics
   */
  recordOperation(
    operation: string,
    duration: number,
    success: boolean,
    context?: Record&amp;lt;string, unknown&amp;gt;
  ): void {
    if (!this.config.enableMetrics) return;

    const metrics &#x3D; this.operationMetrics.get(operation) || {
      operationCount: 0,
      totalDuration: 0,
      averageDuration: 0,
      maxDuration: 0,
      minDuration: Number.POSITIVE_INFINITY,
      violationsCount: 0,
      successRate: 100,
    };

    // Update metrics
    metrics.operationCount++;
    metrics.totalDuration +&#x3D; duration;
    metrics.averageDuration &#x3D; metrics.totalDuration / metrics.operationCount;
    metrics.maxDuration &#x3D; Math.max(metrics.maxDuration, duration);
    metrics.minDuration &#x3D; Math.min(metrics.minDuration, duration);

    if (!success) {
      metrics.violationsCount++;
    }

    metrics.successRate &#x3D;
      ((metrics.operationCount - metrics.violationsCount) / metrics.operationCount) * 100;

    this.operationMetrics.set(operation, metrics);

    // Log performance data
    this.logPerformanceMetric(operation, duration, success, context);

    // Check performance alerts
    this.checkPerformanceAlerts(operation, metrics);

    // Emit monitoring event
    this.emit(&amp;#39;operation_recorded&amp;#39;, { operation, duration, success, metrics });
  }

  /**
   * Generate report header
   */
  private generateReportHeader(): string[] {
    const lines: string[] &#x3D; [];
    const uptime &#x3D; Date.now() - this.startTime;

    lines.push(chalk.bold(&amp;#39;ğŸ” Constraint System Monitoring Report&amp;#39;));
    lines.push(chalk.dim(&#x60;Generated: ${new Date().toISOString()}&#x60;));
    lines.push(chalk.dim(&#x60;Uptime: ${this.formatDuration(uptime)}&#x60;));
    lines.push(&amp;#39;&amp;#39;);

    return lines;
  }

  /**
   * Generate violations summary section
   */
  private generateViolationsSummary(): string[] {
    const lines: string[] &#x3D; [];

    lines.push(chalk.bold(&amp;#39;Violations Summary:&amp;#39;));
    lines.push(
      &#x60;Total Violations: ${this.getViolationColor(this.violationCounts.total)}${this.violationCounts.total}&#x60;
    );
    lines.push(
      &#x60;Last Hour: ${this.getViolationColor(this.violationCounts.lastHour)}${this.violationCounts.lastHour}&#x60;
    );
    lines.push(&#x60;Violation Rate: ${this.calculateViolationRate()} violations/hour&#x60;);
    lines.push(&amp;#39;&amp;#39;);

    return lines;
  }

  /**
   * Generate violations by constraint section
   */
  private generateViolationsByConstraint(): string[] {
    const lines: string[] &#x3D; [];

    if (this.violationCounts.byConstraint.size &amp;gt; 0) {
      lines.push(chalk.bold(&amp;#39;Violations by Constraint:&amp;#39;));
      const sortedConstraints &#x3D; Array.from(this.violationCounts.byConstraint.entries()).sort(
        ([, a], [, b]) &#x3D;&amp;gt; b - a
      );

      for (const [constraint, count] of sortedConstraints) {
        const percentage &#x3D; ((count / this.violationCounts.total) * 100).toFixed(1);
        lines.push(&#x60;  ${chalk.red(constraint)}: ${count} (${percentage}%)&#x60;);
      }
      lines.push(&amp;#39;&amp;#39;);
    }

    return lines;
  }

  /**
   * Generate violations by operation section
   */
  private generateViolationsByOperation(): string[] {
    const lines: string[] &#x3D; [];

    if (this.violationCounts.byOperation.size &amp;gt; 0) {
      lines.push(chalk.bold(&amp;#39;Violations by Operation:&amp;#39;));
      const sortedOperations &#x3D; Array.from(this.violationCounts.byOperation.entries()).sort(
        ([, a], [, b]) &#x3D;&amp;gt; b - a
      );

      for (const [operation, count] of sortedOperations.slice(0, 10)) {
        lines.push(&#x60;  ${chalk.yellow(operation)}: ${count}&#x60;);
      }
      lines.push(&amp;#39;&amp;#39;);
    }

    return lines;
  }

  /**
   * Generate performance metrics section
   */
  private generatePerformanceMetrics(): string[] {
    const lines: string[] &#x3D; [];

    if (this.operationMetrics.size &amp;gt; 0) {
      lines.push(chalk.bold(&amp;#39;Performance Metrics:&amp;#39;));
      const sortedMetrics &#x3D; Array.from(this.operationMetrics.entries()).sort(
        ([, a], [, b]) &#x3D;&amp;gt; b.operationCount - a.operationCount
      );

      for (const [operation, metrics] of sortedMetrics.slice(0, 10)) {
        const successColor &#x3D;
          metrics.successRate &amp;gt;&#x3D; 95
            ? chalk.green
            : metrics.successRate &amp;gt;&#x3D; 80
              ? chalk.yellow
              : chalk.red;
        const avgColor &#x3D;
          metrics.averageDuration &amp;lt;&#x3D; 500
            ? chalk.green
            : metrics.averageDuration &amp;lt;&#x3D; 750
              ? chalk.yellow
              : chalk.red;

        lines.push(&#x60;  ${operation}:&#x60;);
        lines.push(&#x60;    Operations: ${metrics.operationCount}&#x60;);
        lines.push(&#x60;    Success Rate: ${successColor(&#x60;${metrics.successRate.toFixed(1)}%&#x60;)}&#x60;);
        lines.push(&#x60;    Avg Duration: ${avgColor(&#x60;${Math.round(metrics.averageDuration)}ms&#x60;)}&#x60;);
        lines.push(&#x60;    Max Duration: ${Math.round(metrics.maxDuration)}ms&#x60;);
      }
      lines.push(&amp;#39;&amp;#39;);
    }

    return lines;
  }

  /**
   * Generate recent violations section
   */
  private generateRecentViolations(): string[] {
    const lines: string[] &#x3D; [];

    if (this.violations.length &amp;gt; 0) {
      lines.push(chalk.bold(&amp;#39;Recent Violations (Last 10):&amp;#39;));
      const recentViolations &#x3D; this.violations.slice(-10).reverse();

      for (const violation of recentViolations) {
        const timeAgo &#x3D; this.formatTimeAgo(violation.timestamp);
        lines.push(&#x60;  ${chalk.red(violation.constraint)} - ${timeAgo}&#x60;);
        lines.push(&#x60;    ${chalk.dim(violation.violation.message)}&#x60;);
        if (violation.operation) {
          lines.push(&#x60;    Operation: ${chalk.yellow(violation.operation)}&#x60;);
        }
      }
      lines.push(&amp;#39;&amp;#39;);
    }

    return lines;
  }

  /**
   * Generate health status section
   */
  private generateHealthStatus(): string[] {
    const lines: string[] &#x3D; [];

    lines.push(chalk.bold(&amp;#39;System Health:&amp;#39;));
    const healthStatus &#x3D; this.getSystemHealth();
    const healthColor &#x3D; healthStatus.isHealthy ? chalk.green : chalk.red;
    lines.push(&#x60;Overall Status: ${healthColor(healthStatus.isHealthy ? &amp;#39;HEALTHY&amp;#39; : &amp;#39;UNHEALTHY&amp;#39;)}&#x60;);

    if (healthStatus.issues.length &amp;gt; 0) {
      lines.push(&amp;#39;Issues:&amp;#39;);
      for (const issue of healthStatus.issues) {
        lines.push(&#x60;  ${chalk.red(&amp;#39;â€¢&amp;#39;)} ${issue}&#x60;);
      }
    }

    if (healthStatus.recommendations.length &amp;gt; 0) {
      lines.push(&amp;#39;Recommendations:&amp;#39;);
      for (const rec of healthStatus.recommendations) {
        lines.push(&#x60;  ${chalk.yellow(&amp;#39;â€¢&amp;#39;)} ${rec}&#x60;);
      }
    }

    return lines;
  }

  /**
   * Generate comprehensive monitoring report
   */
  generateReport(): string {
    const sections &#x3D; this.collectReportSections();
    return this.formatReportSections(sections);
  }

  /**
   * Collect all report sections in order
   */
  private collectReportSections(): string[][] {
    return [
      this.generateReportHeader(),
      this.generateViolationsSummary(),
      this.generateViolationsByConstraint(),
      this.generateViolationsByOperation(),
      this.generatePerformanceMetrics(),
      this.generateRecentViolations(),
      this.generateHealthStatus(),
    ];
  }

  /**
   * Format and join all report sections
   */
  private formatReportSections(sections: string[][]): string {
    return sections.flat().join(&amp;#39;\n&amp;#39;);
  }

  /**
   * Export monitoring data for external analysis
   */
  async exportData(outputPath: string): Promise&amp;lt;void&amp;gt; {
    const data &#x3D; {
      timestamp: new Date().toISOString(),
      uptime: Date.now() - this.startTime,
      violationCounts: {
        total: this.violationCounts.total,
        lastHour: this.violationCounts.lastHour,
        byConstraint: Object.fromEntries(this.violationCounts.byConstraint),
        byOperation: Object.fromEntries(this.violationCounts.byOperation),
      },
      performanceMetrics: Object.fromEntries(this.operationMetrics),
      recentViolations: this.violations.slice(-100), // Last 100 violations
      systemHealth: this.getSystemHealth(),
    };

    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeJson(outputPath, data, { spaces: 2 });

    this.emit(&amp;#39;data_exported&amp;#39;, { outputPath, recordCount: this.violations.length });
  }

  /**
   * Clear old data based on retention policy
   */
  cleanup(): void {
    const retentionMs &#x3D; this.config.metricsRetentionDays * 24 * 60 * 60 * 1000;
    const cutoff &#x3D; Date.now() - retentionMs;

    // Remove old violations
    const beforeCount &#x3D; this.violations.length;
    const filtered &#x3D; this.violations.filter(v &#x3D;&amp;gt; v.timestamp &amp;gt;&#x3D; cutoff);
    this.violations.length &#x3D; 0;
    this.violations.push(...filtered);

    const cleaned &#x3D; beforeCount - this.violations.length;

    if (cleaned &amp;gt; 0) {
      this.emit(&amp;#39;cleanup_completed&amp;#39;, {
        recordsCleaned: cleaned,
        remaining: this.violations.length,
      });
    }
  }

  /**
   * Get current system health status
   */
  getSystemHealth(): {
    isHealthy: boolean;
    issues: string[];
    recommendations: string[];
    scores: {
      violationScore: number;
      performanceScore: number;
      availabilityScore: number;
      overallScore: number;
    };
  } {
    const issues: string[] &#x3D; [];
    const recommendations: string[] &#x3D; [];

    // Check violation rate
    const violationRate &#x3D; this.calculateViolationRate();
    const violationScore &#x3D; Math.max(0, 100 - violationRate * 10);

    if (violationRate &amp;gt; this.config.alertThresholds.maxViolationsPerHour) {
      issues.push(&#x60;High violation rate: ${violationRate.toFixed(1)}/hour&#x60;);
      recommendations.push(&amp;#39;Review constraint configurations and operation patterns&amp;#39;);
    }

    // Check performance metrics
    let performanceScore &#x3D; 100;
    for (const [operation, metrics] of this.operationMetrics.entries()) {
      if (metrics.averageDuration &amp;gt; this.config.alertThresholds.maxAverageResponseTime) {
        issues.push(&#x60;Slow operation: ${operation} (${Math.round(metrics.averageDuration)}ms avg)&#x60;);
        recommendations.push(&#x60;Optimize ${operation} performance&#x60;);
        performanceScore &#x3D; Math.min(performanceScore, 80);
      }

      if (metrics.successRate &amp;lt; this.config.alertThresholds.minSuccessRate) {
        issues.push(&#x60;Low success rate: ${operation} (${metrics.successRate.toFixed(1)}%)&#x60;);
        recommendations.push(&#x60;Investigate ${operation} reliability issues&#x60;);
        performanceScore &#x3D; Math.min(performanceScore, 70);
      }
    }

    // Calculate availability score
    const totalOperations &#x3D; Array.from(this.operationMetrics.values()).reduce(
      (sum, m) &#x3D;&amp;gt; sum + m.operationCount,
      0
    );
    const successfulOperations &#x3D; Array.from(this.operationMetrics.values()).reduce(
      (sum, m) &#x3D;&amp;gt; sum + (m.operationCount - m.violationsCount),
      0
    );

    const availabilityScore &#x3D;
      totalOperations &amp;gt; 0 ? (successfulOperations / totalOperations) * 100 : 100;

    // Overall health score
    const overallScore &#x3D; (violationScore + performanceScore + availabilityScore) / 3;

    return {
      isHealthy: issues.length &#x3D;&#x3D;&#x3D; 0 &amp;amp;&amp;amp; overallScore &amp;gt;&#x3D; 90,
      issues,
      recommendations,
      scores: {
        violationScore,
        performanceScore,
        availabilityScore,
        overallScore,
      },
    };
  }

  /**
   * Start monitoring background tasks
   */
  private startMonitoring(): void {
    // Reset hourly counters
    setInterval(
      () &#x3D;&amp;gt; {
        this.violationCounts.lastHour &#x3D; 0;
      },
      60 * 60 * 1000
    ); // Every hour

    // Cleanup old data
    setInterval(
      () &#x3D;&amp;gt; {
        this.cleanup();
      },
      24 * 60 * 60 * 1000
    ); // Daily

    // Performance monitoring
    setInterval(
      () &#x3D;&amp;gt; {
        this.checkSystemHealth();
      },
      5 * 60 * 1000
    ); // Every 5 minutes
  }

  /**
   * Check alert thresholds and emit alerts
   */
  private checkAlertThresholds(): void {
    const violationRate &#x3D; this.calculateViolationRate();

    if (violationRate &amp;gt; this.config.alertThresholds.maxViolationsPerHour) {
      this.emit(&amp;#39;alert&amp;#39;, {
        type: &amp;#39;high_violation_rate&amp;#39;,
        message: &#x60;Violation rate exceeded threshold: ${violationRate.toFixed(1)}/hour&#x60;,
        threshold: this.config.alertThresholds.maxViolationsPerHour,
        actual: violationRate,
      });
    }
  }

  /**
   * Check performance alerts for specific operations
   */
  private checkPerformanceAlerts(operation: string, metrics: PerformanceMetrics): void {
    if (metrics.averageDuration &amp;gt; this.config.alertThresholds.maxAverageResponseTime) {
      this.emit(&amp;#39;alert&amp;#39;, {
        type: &amp;#39;slow_operation&amp;#39;,
        message: &#x60;${operation} average response time exceeded threshold&#x60;,
        operation,
        threshold: this.config.alertThresholds.maxAverageResponseTime,
        actual: metrics.averageDuration,
      });
    }

    if (metrics.successRate &amp;lt; this.config.alertThresholds.minSuccessRate) {
      this.emit(&amp;#39;alert&amp;#39;, {
        type: &amp;#39;low_success_rate&amp;#39;,
        message: &#x60;${operation} success rate below threshold&#x60;,
        operation,
        threshold: this.config.alertThresholds.minSuccessRate,
        actual: metrics.successRate,
      });
    }
  }

  /**
   * Check overall system health periodically
   */
  private checkSystemHealth(): void {
    const health &#x3D; this.getSystemHealth();

    if (!health.isHealthy) {
      this.emit(&amp;#39;alert&amp;#39;, {
        type: &amp;#39;system_health&amp;#39;,
        message: &amp;#39;System health degraded&amp;#39;,
        issues: health.issues,
        score: health.scores.overallScore,
      });
    }
  }

  /**
   * Log violation to file
   */
  private async logViolation(event: ViolationEvent): Promise&amp;lt;void&amp;gt; {
    if (!this.config.violationLogPath) return;

    try {
      const logEntry &#x3D; {
        timestamp: new Date(event.timestamp).toISOString(),
        constraint: event.constraint,
        message: event.violation.message,
        operation: event.operation,
        details: event.violation.details,
      };

      const logLine &#x3D; &#x60;${JSON.stringify(logEntry)}\n&#x60;;
      await fs.appendFile(this.config.violationLogPath, logLine);
    } catch (error) {
      this.emit(&amp;#39;error&amp;#39;, { type: &amp;#39;log_violation_failed&amp;#39;, error });
    }
  }

  /**
   * Log performance metric to file
   */
  private async logPerformanceMetric(
    operation: string,
    duration: number,
    success: boolean,
    context?: Record&amp;lt;string, unknown&amp;gt;
  ): Promise&amp;lt;void&amp;gt; {
    if (!this.config.metricsLogPath) return;

    try {
      const logEntry &#x3D; {
        timestamp: new Date().toISOString(),
        operation,
        duration,
        success,
        context,
      };

      const logLine &#x3D; &#x60;${JSON.stringify(logEntry)}\n&#x60;;
      await fs.appendFile(this.config.metricsLogPath, logLine);
    } catch (error) {
      this.emit(&amp;#39;error&amp;#39;, { type: &amp;#39;log_metric_failed&amp;#39;, error });
    }
  }

  /**
   * Calculate current violation rate per hour
   */
  private calculateViolationRate(): number {
    const uptimeHours &#x3D; (Date.now() - this.startTime) / (1000 * 60 * 60);
    return uptimeHours &amp;gt; 0 ? this.violationCounts.total / uptimeHours : 0;
  }

  /**
   * Get appropriate color for violation count
   */
  private getViolationColor(count: number): typeof chalk.green {
    if (count &#x3D;&#x3D;&#x3D; 0) return chalk.green;
    if (count &amp;lt;&#x3D; 5) return chalk.yellow;
    return chalk.red;
  }

  /**
   * Format duration in human-readable format
   */
  private formatDuration(ms: number): string {
    const seconds &#x3D; Math.floor(ms / 1000);
    const minutes &#x3D; Math.floor(seconds / 60);
    const hours &#x3D; Math.floor(minutes / 60);
    const days &#x3D; Math.floor(hours / 24);

    if (days &amp;gt; 0) return &#x60;${days}d ${hours % 24}h&#x60;;
    if (hours &amp;gt; 0) return &#x60;${hours}h ${minutes % 60}m&#x60;;
    if (minutes &amp;gt; 0) return &#x60;${minutes}m ${seconds % 60}s&#x60;;
    return &#x60;${seconds}s&#x60;;
  }

  /**
   * Format time ago in human-readable format
   */
  private formatTimeAgo(timestamp: number): string {
    const elapsed &#x3D; Date.now() - timestamp;
    const seconds &#x3D; Math.floor(elapsed / 1000);
    const minutes &#x3D; Math.floor(seconds / 60);
    const hours &#x3D; Math.floor(minutes / 60);
    const days &#x3D; Math.floor(hours / 24);

    if (days &amp;gt; 0) return &#x60;${days}d ago&#x60;;
    if (hours &amp;gt; 0) return &#x60;${hours}h ago&#x60;;
    if (minutes &amp;gt; 0) return &#x60;${minutes}m ago&#x60;;
    return &#x60;${seconds}s ago&#x60;;
  }
}

/**
 * Global monitoring instance
 */
export const globalConstraintMonitor &#x3D; new ConstraintMonitor();

/**
 * Create monitoring instance with configuration
 */
export function createConstraintMonitor(config?: Partial&amp;lt;MonitoringConfig&amp;gt;): ConstraintMonitor {
  return new ConstraintMonitor(config);
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-31">
                <div class="file-header">ğŸ“„ packages/cli/src/constraints/schema.ts</div>
                <div class="file-content">
                    <pre>import { z } from &amp;#39;zod&amp;#39;;
import { ConstraintViolationError, globalConstraintEnforcer } from &amp;#39;./core.js&amp;#39;;

/**
 * Latest API version - must be updated when schema changes
 * This enforces the &amp;quot;Don&amp;#39;t write older schemas&amp;quot; constraint
 */
export const LATEST_API_VERSION &#x3D; &amp;#39;2024-12-26&amp;#39;;

/**
 * Version compatibility matrix
 * Defines which versions are compatible for reading/writing
 */
export const VERSION_COMPATIBILITY &#x3D; {
  // Current version (write operations must use this)
  current: LATEST_API_VERSION,

  // Supported versions for read operations
  supported: [
    &amp;#39;2024-12-26&amp;#39;,
    &amp;#39;2024-12-25&amp;#39;, // Previous version for migration support
  ],

  // Deprecated versions (read-only, warn on usage)
  deprecated: [&amp;#39;2024-12-24&amp;#39;, &amp;#39;2024-12-23&amp;#39;],

  // Unsupported versions (reject all operations)
  unsupported: [&amp;#39;2024-12-22&amp;#39;, &amp;#39;2024-12-21&amp;#39;],
};

/**
 * Base envelope schema that all API responses must conform to
 */
export const envelopeBaseSchema &#x3D; z.object({
  apiVersion: z
    .string()
    .refine(
      version &#x3D;&amp;gt;
        VERSION_COMPATIBILITY.supported.includes(version) ||
        VERSION_COMPATIBILITY.deprecated.includes(version),
      {
        message: &#x60;API version must be one of: ${[...VERSION_COMPATIBILITY.supported, ...VERSION_COMPATIBILITY.deprecated].join(&amp;#39;, &amp;#39;)}&#x60;,
      }
    ),
  kind: z.string(),
  metadata: z
    .object({
      name: z.string().optional(),
      createdAt: z.string().datetime().optional(),
      version: z.string().optional(),
      migrationNotes: z.string().optional(),
    })
    .optional(),
});

/**
 * Schema for validation results with version enforcement
 */
export const validationResultSchema &#x3D; envelopeBaseSchema.extend({
  kind: z.literal(&amp;#39;ValidationResult&amp;#39;),
  spec: z.object({
    success: z.boolean(),
    errors: z
      .array(
        z.object({
          line: z.number(),
          column: z.number(),
          message: z.string(),
          severity: z.enum([&amp;#39;error&amp;#39;, &amp;#39;warning&amp;#39;]),
          category: z.string(),
        })
      )
      .optional(),
    warnings: z
      .array(
        z.object({
          line: z.number(),
          column: z.number(),
          message: z.string(),
          category: z.string(),
        })
      )
      .optional(),
  }),
});

/**
 * Schema for export results with version enforcement
 */
export const exportResultSchema &#x3D; envelopeBaseSchema.extend({
  kind: z.literal(&amp;#39;ExportResult&amp;#39;),
  spec: z.object({
    format: z.string(),
    content: z.string(),
    metadata: z.record(z.unknown()).optional(),
  }),
});

/**
 * Schema for analysis results with version enforcement
 */
export const analysisResultSchema &#x3D; envelopeBaseSchema.extend({
  kind: z.literal(&amp;#39;AnalysisResult&amp;#39;),
  spec: z.object({
    summary: z.string(),
    issues: z
      .array(
        z.object({
          type: z.string(),
          severity: z.enum([&amp;#39;low&amp;#39;, &amp;#39;medium&amp;#39;, &amp;#39;high&amp;#39;, &amp;#39;critical&amp;#39;]),
          message: z.string(),
          location: z
            .object({
              line: z.number(),
              column: z.number(),
            })
            .optional(),
        })
      )
      .optional(),
    metrics: z.record(z.number()).optional(),
  }),
});

/**
 * Union type for all valid envelope schemas
 */
export const envelopeSchema &#x3D; z.discriminatedUnion(&amp;#39;kind&amp;#39;, [
  validationResultSchema,
  exportResultSchema,
  analysisResultSchema,
]);

export type EnvelopeData &#x3D; z.infer&amp;lt;typeof envelopeSchema&amp;gt;;
export type ValidationResult &#x3D; z.infer&amp;lt;typeof validationResultSchema&amp;gt;;
export type ExportResult &#x3D; z.infer&amp;lt;typeof exportResultSchema&amp;gt;;
export type AnalysisResult &#x3D; z.infer&amp;lt;typeof analysisResultSchema&amp;gt;;

/**
 * Schema version validator and enforcer
 */
export class SchemaVersionValidator {
  /**
   * Validate that data conforms to the latest envelope schema for write operations
   */
  validateWriteSchema(data: unknown, operationId?: string): EnvelopeData {
    // First validate that it has the correct structure
    const parseResult &#x3D; envelopeSchema.safeParse(data);
    if (!parseResult.success) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;schemaValidation&amp;#39;,
        &amp;#39;invalid envelope structure&amp;#39;,
        &amp;#39;valid envelope schema&amp;#39;,
        {
          operationId,
          validationErrors: parseResult.error.errors,
          providedData: typeof data &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; ? Object.keys(data as object) : typeof data,
        }
      );

      globalConstraintEnforcer.emit(&amp;#39;constraint:violation&amp;#39;, {
        constraint: &amp;#39;schemaValidation&amp;#39;,
        violation,
        data,
      });

      throw violation;
    }

    const envelope &#x3D; parseResult.data;

    // Enforce that write operations use the latest API version
    globalConstraintEnforcer.validateApiVersion(envelope.apiVersion, operationId);

    // Additional validation for specific envelope types
    this.validateEnvelopeContent(envelope, operationId);

    globalConstraintEnforcer.emit(&amp;#39;schema:validated&amp;#39;, {
      operationId,
      kind: envelope.kind,
      apiVersion: envelope.apiVersion,
    });

    return envelope;
  }

  /**
   * Validate envelope for read operations (more permissive)
   */
  validateReadSchema(data: unknown, operationId?: string): EnvelopeData {
    const parseResult &#x3D; envelopeSchema.safeParse(data);
    if (!parseResult.success) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;schemaValidation&amp;#39;,
        &amp;#39;invalid envelope structure&amp;#39;,
        &amp;#39;valid envelope schema&amp;#39;,
        {
          operationId,
          validationErrors: parseResult.error.errors,
          providedData: typeof data &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; ? Object.keys(data as object) : typeof data,
        }
      );

      globalConstraintEnforcer.emit(&amp;#39;constraint:violation&amp;#39;, {
        constraint: &amp;#39;schemaValidation&amp;#39;,
        violation,
        data,
      });

      throw violation;
    }

    const envelope &#x3D; parseResult.data;

    // Check version compatibility for read operations
    this.validateVersionCompatibility(envelope.apiVersion, &amp;#39;read&amp;#39;, operationId);

    globalConstraintEnforcer.emit(&amp;#39;schema:validated&amp;#39;, {
      operationId,
      kind: envelope.kind,
      apiVersion: envelope.apiVersion,
      operation: &amp;#39;read&amp;#39;,
    });

    return envelope;
  }

  /**
   * Create a new envelope with the latest API version
   */
  createEnvelope&amp;lt;T extends EnvelopeData&amp;gt;(
    kind: T[&amp;#39;kind&amp;#39;],
    spec: T[&amp;#39;spec&amp;#39;],
    metadata?: T[&amp;#39;metadata&amp;#39;]
  ): T {
    const envelope &#x3D; {
      apiVersion: LATEST_API_VERSION,
      kind,
      spec,
      metadata: {
        createdAt: new Date().toISOString(),
        ...metadata,
      },
    } as T;

    // Validate the created envelope
    this.validateWriteSchema(envelope);

    return envelope;
  }

  /**
   * Migrate an older envelope to the latest version
   */
  migrateToLatest(envelope: EnvelopeData, operationId?: string): EnvelopeData {
    if (envelope.apiVersion &#x3D;&#x3D;&#x3D; LATEST_API_VERSION) {
      return envelope; // Already latest
    }

    // Check if migration is supported
    if (!this.isMigrationSupported(envelope.apiVersion)) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;versionMigration&amp;#39;,
        envelope.apiVersion,
        &amp;#39;supported version for migration&amp;#39;,
        {
          operationId,
          currentVersion: envelope.apiVersion,
          latestVersion: LATEST_API_VERSION,
          supportedVersions: VERSION_COMPATIBILITY.supported,
        }
      );

      globalConstraintEnforcer.emit(&amp;#39;constraint:violation&amp;#39;, {
        constraint: &amp;#39;versionMigration&amp;#39;,
        violation,
        envelope,
      });

      throw violation;
    }

    // Perform version migration
    const migrated &#x3D; {
      ...envelope,
      apiVersion: LATEST_API_VERSION,
      metadata: {
        ...envelope.metadata,
        migratedFrom: envelope.apiVersion,
        migratedAt: new Date().toISOString(),
      },
    };

    // Apply version-specific migrations
    const fullyMigrated &#x3D; this.applyVersionMigrations(migrated, envelope.apiVersion);

    globalConstraintEnforcer.emit(&amp;#39;schema:migrated&amp;#39;, {
      operationId,
      fromVersion: envelope.apiVersion,
      toVersion: LATEST_API_VERSION,
      kind: envelope.kind,
    });

    return fullyMigrated;
  }

  /**
   * Check if a version supports migration
   */
  private isMigrationSupported(version: string): boolean {
    return (
      VERSION_COMPATIBILITY.supported.includes(version) ||
      VERSION_COMPATIBILITY.deprecated.includes(version)
    );
  }

  /**
   * Validate version compatibility for different operations
   */
  private validateVersionCompatibility(
    version: string,
    operation: &amp;#39;read&amp;#39; | &amp;#39;write&amp;#39;,
    operationId?: string
  ): void {
    if (VERSION_COMPATIBILITY.unsupported.includes(version)) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;versionCompatibility&amp;#39;,
        version,
        &amp;#39;supported API version&amp;#39;,
        {
          operationId,
          operation,
          version,
          supportedVersions: VERSION_COMPATIBILITY.supported,
          reason: &amp;#39;Version is no longer supported&amp;#39;,
        }
      );

      globalConstraintEnforcer.emit(&amp;#39;constraint:violation&amp;#39;, {
        constraint: &amp;#39;versionCompatibility&amp;#39;,
        violation,
        version,
      });

      throw violation;
    }

    if (operation &#x3D;&#x3D;&#x3D; &amp;#39;write&amp;#39; &amp;amp;&amp;amp; version !&#x3D;&#x3D; LATEST_API_VERSION) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;versionCompatibility&amp;#39;,
        version,
        LATEST_API_VERSION,
        {
          operationId,
          operation,
          version,
          latestVersion: LATEST_API_VERSION,
          reason: &amp;#39;Write operations must use latest API version&amp;#39;,
        }
      );

      globalConstraintEnforcer.emit(&amp;#39;constraint:violation&amp;#39;, {
        constraint: &amp;#39;versionCompatibility&amp;#39;,
        violation,
        version,
      });

      throw violation;
    }

    // Warn about deprecated versions
    if (VERSION_COMPATIBILITY.deprecated.includes(version)) {
      globalConstraintEnforcer.emit(&amp;#39;schema:deprecated_version&amp;#39;, {
        operationId,
        version,
        latestVersion: LATEST_API_VERSION,
        message: &#x60;API version ${version} is deprecated. Please upgrade to ${LATEST_API_VERSION}&#x60;,
      });
    }
  }

  /**
   * Validate envelope content based on kind
   */
  private validateEnvelopeContent(envelope: EnvelopeData, operationId?: string): void {
    switch (envelope.kind) {
      case &amp;#39;ValidationResult&amp;#39;:
        this.validateValidationResult(envelope, operationId);
        break;
      case &amp;#39;ExportResult&amp;#39;:
        this.validateExportResult(envelope, operationId);
        break;
      case &amp;#39;AnalysisResult&amp;#39;:
        this.validateAnalysisResult(envelope, operationId);
        break;
      default:
        // Extensibility for future envelope types
        break;
    }
  }

  /**
   * Apply version-specific migration logic
   */
  private applyVersionMigrations(envelope: EnvelopeData, fromVersion: string): EnvelopeData {
    let migrated &#x3D; envelope;

    // Apply migrations in sequence based on version
    if (fromVersion &#x3D;&#x3D;&#x3D; &amp;#39;2024-12-25&amp;#39;) {
      migrated &#x3D; this.migrateFrom20241225(migrated);
    }

    if (fromVersion &#x3D;&#x3D;&#x3D; &amp;#39;2024-12-24&amp;#39;) {
      migrated &#x3D; this.migrateFrom20241224(migrated);
    }

    return migrated;
  }

  /**
   * Migration from version 2024-12-25 to latest
   */
  private migrateFrom20241225(envelope: EnvelopeData): EnvelopeData {
    // Add any specific migration logic here
    // For now, just update metadata
    return {
      ...envelope,
      metadata: {
        ...envelope.metadata,
        migrationNotes: &amp;#39;Migrated from 2024-12-25 - no structural changes required&amp;#39;,
      },
    };
  }

  /**
   * Migration from version 2024-12-24 to latest
   */
  private migrateFrom20241224(envelope: EnvelopeData): EnvelopeData {
    // Add any specific migration logic here
    return {
      ...envelope,
      metadata: {
        ...envelope.metadata,
        migrationNotes: &amp;#39;Migrated from 2024-12-24 - deprecated fields removed&amp;#39;,
      },
    };
  }

  private validateValidationResult(envelope: ValidationResult, operationId?: string): void {
    // Additional validation for ValidationResult envelopes
    if (!envelope.spec.success &amp;amp;&amp;amp; (!envelope.spec.errors || envelope.spec.errors.length &#x3D;&#x3D;&#x3D; 0)) {
      globalConstraintEnforcer.emit(&amp;#39;schema:warning&amp;#39;, {
        operationId,
        message: &amp;#39;ValidationResult marked as unsuccessful but no errors provided&amp;#39;,
        envelope: envelope.kind,
      });
    }
  }

  private validateExportResult(envelope: ExportResult, operationId?: string): void {
    // Additional validation for ExportResult envelopes
    if (!envelope.spec.content || envelope.spec.content.trim() &#x3D;&#x3D;&#x3D; &amp;#39;&amp;#39;) {
      const violation &#x3D; new ConstraintViolationError(
        &amp;#39;schemaValidation&amp;#39;,
        &amp;#39;empty export content&amp;#39;,
        &amp;#39;non-empty export content&amp;#39;,
        {
          operationId,
          format: envelope.spec.format,
        }
      );

      throw violation;
    }
  }

  private validateAnalysisResult(envelope: AnalysisResult, operationId?: string): void {
    // Additional validation for AnalysisResult envelopes
    if (!envelope.spec.summary || envelope.spec.summary.trim() &#x3D;&#x3D;&#x3D; &amp;#39;&amp;#39;) {
      globalConstraintEnforcer.emit(&amp;#39;schema:warning&amp;#39;, {
        operationId,
        message: &amp;#39;AnalysisResult has empty summary&amp;#39;,
        envelope: envelope.kind,
      });
    }
  }
}

/**
 * Global schema validator instance
 */
export const globalSchemaValidator &#x3D; new SchemaVersionValidator();

/**
 * Utility function to ensure data is written with latest schema
 */
export function ensureLatestSchema&amp;lt;T extends EnvelopeData&amp;gt;(data: T, operationId?: string): T {
  return globalSchemaValidator.validateWriteSchema(data, operationId) as T;
}

/**
 * Utility function to validate read data with version compatibility
 */
export function validateReadData(data: unknown, operationId?: string): EnvelopeData {
  return globalSchemaValidator.validateReadSchema(data, operationId);
}

/**
 * Decorator to automatically enforce schema validation on API responses
 */
export function withSchemaValidation(operation: &amp;#39;read&amp;#39; | &amp;#39;write&amp;#39;) {
  return &amp;lt;T extends (...args: any[]) &#x3D;&amp;gt; Promise&amp;lt;any&amp;gt;&amp;gt;(
    _target: any,
    _propertyName: string,
    descriptor: TypedPropertyDescriptor&amp;lt;T&amp;gt;
  ) &#x3D;&amp;gt; {
    const method &#x3D; descriptor.value!;

    descriptor.value &#x3D; async function (this: any, ...args: any[]) {
      const result &#x3D; await method.apply(this, args);

      // Validate the result based on operation type
      if (operation &#x3D;&#x3D;&#x3D; &amp;#39;write&amp;#39;) {
        return globalSchemaValidator.validateWriteSchema(result);
      }
      return globalSchemaValidator.validateReadSchema(result);
    } as T;

    return descriptor;
  };
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-32">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/git-detection.ts</div>
                <div class="file-content">
                    <pre>import { execSync } from &amp;#39;node:child_process&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import type { GitHubRepo } from &amp;#39;../types.js&amp;#39;;

export interface GitRemoteInfo {
  owner: string;
  repo: string;
  url: string;
  type: &amp;#39;https&amp;#39; | &amp;#39;ssh&amp;#39;;
}

export interface GitDetectionResult {
  detected: boolean;
  remote?: GitRemoteInfo;
  error?: string;
}

export interface RepositoryConflict {
  configRepo: GitHubRepo;
  detectedRepo: GitRemoteInfo;
  conflictType: &amp;#39;owner&amp;#39; | &amp;#39;repo&amp;#39; | &amp;#39;both&amp;#39;;
}

export interface ConflictResolution {
  useConfig: boolean;
  useDetected: boolean;
  updateConfig: boolean;
  selectedRepo: GitHubRepo;
}

/**
 * Auto-detect GitHub repository information from Git remote
 */
export function detectGitHubRepository(): GitDetectionResult {
  try {
    // Get the origin remote URL
    const remoteUrl &#x3D; execSync(&amp;#39;git remote get-url origin&amp;#39;, {
      encoding: &amp;#39;utf8&amp;#39;,
      stdio: [&amp;#39;pipe&amp;#39;, &amp;#39;pipe&amp;#39;, &amp;#39;ignore&amp;#39;], // Suppress stderr to avoid noise
    }).trim();

    // Parse GitHub URLs (both HTTPS and SSH formats)
    const remote &#x3D; parseGitHubUrl(remoteUrl);

    if (!remote) {
      return {
        detected: false,
        error: &amp;#39;Remote origin is not a GitHub repository&amp;#39;,
      };
    }

    return {
      detected: true,
      remote,
    };
  } catch (error) {
    return {
      detected: false,
      error: error instanceof Error ? error.message : &amp;#39;Failed to detect Git remote&amp;#39;,
    };
  }
}

/**
 * Parse a Git URL to extract GitHub repository information
 */
export function parseGitHubUrl(url: string): GitRemoteInfo | null {
  // HTTPS format: https://github.com/owner/repo.git
  const httpsMatch &#x3D; url.match(/https:\/\/github\.com\/([^/]+)\/([^/.]+)(?:\.git)?$/);
  if (httpsMatch) {
    const [, owner, repo] &#x3D; httpsMatch;
    return {
      owner,
      repo,
      url,
      type: &amp;#39;https&amp;#39;,
    };
  }

  // SSH format: git@github.com:owner/repo.git
  const sshMatch &#x3D; url.match(/git@github\.com:([^/]+)\/([^/.]+)(?:\.git)?$/);
  if (sshMatch) {
    const [, owner, repo] &#x3D; sshMatch;
    return {
      owner,
      repo,
      url,
      type: &amp;#39;ssh&amp;#39;,
    };
  }

  return null;
}

/**
 * Check for conflicts between configured and detected repository info
 */
export function detectRepositoryConflicts(
  configRepo: GitHubRepo,
  detectedRepo: GitRemoteInfo
): RepositoryConflict | null {
  const ownerConflict &#x3D; configRepo.owner !&#x3D;&#x3D; detectedRepo.owner;
  const repoConflict &#x3D; configRepo.repo !&#x3D;&#x3D; detectedRepo.repo;

  if (!ownerConflict &amp;amp;&amp;amp; !repoConflict) {
    return null; // No conflict
  }

  let conflictType: &amp;#39;owner&amp;#39; | &amp;#39;repo&amp;#39; | &amp;#39;both&amp;#39;;
  if (ownerConflict &amp;amp;&amp;amp; repoConflict) {
    conflictType &#x3D; &amp;#39;both&amp;#39;;
  } else if (ownerConflict) {
    conflictType &#x3D; &amp;#39;owner&amp;#39;;
  } else {
    conflictType &#x3D; &amp;#39;repo&amp;#39;;
  }

  return {
    configRepo,
    detectedRepo,
    conflictType,
  };
}

/**
 * Display a conflict resolution prompt and get user choice
 */
export function displayConflictResolution(conflict: RepositoryConflict): void {
  console.log(chalk.yellow(&amp;#39;\nâš ï¸  Repository Configuration Conflict&amp;#39;));
  console.log(chalk.dim(&amp;#39;Found different repository information in config vs Git remote:\n&amp;#39;));

  // Display comparison table
  const configInfo &#x3D; &#x60;${conflict.configRepo.owner}/${conflict.configRepo.repo}&#x60;;
  const detectedInfo &#x3D; &#x60;${conflict.detectedRepo.owner}/${conflict.detectedRepo.repo}&#x60;;

  console.log(&amp;#39;â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”&amp;#39;);
  console.log(&amp;#39;â”‚ Source          â”‚ Repository                  â”‚&amp;#39;);
  console.log(&amp;#39;â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤&amp;#39;);
  console.log(&#x60;â”‚ Config file     â”‚ ${configInfo.padEnd(27)} â”‚&#x60;);
  console.log(&#x60;â”‚ Git remote      â”‚ ${detectedInfo.padEnd(27)} â”‚&#x60;);
  console.log(&amp;#39;â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜&amp;#39;);

  console.log(chalk.cyan(&amp;#39;\nOptions:&amp;#39;));
  console.log(chalk.dim(&amp;#39;  1. Use config file values (keep current configuration)&amp;#39;));
  console.log(chalk.dim(&amp;#39;  2. Use Git remote values (auto-detected from repository)&amp;#39;));
  console.log(chalk.dim(&amp;#39;  3. Use Git remote and update config file&amp;#39;));

  console.log(chalk.dim(&amp;#39;\nFor non-interactive use:&amp;#39;));
  console.log(chalk.dim(&amp;#39;  --use-config      Use config file values&amp;#39;));
  console.log(chalk.dim(&amp;#39;  --use-git-remote  Use Git remote values&amp;#39;));
}

/**
 * Resolve repository selection based on options
 */
export function resolveRepositorySelection(
  conflict: RepositoryConflict,
  options: {
    useConfig?: boolean;
    useGitRemote?: boolean;
  }
): ConflictResolution {
  if (options.useConfig) {
    return {
      useConfig: true,
      useDetected: false,
      updateConfig: false,
      selectedRepo: conflict.configRepo,
    };
  }

  if (options.useGitRemote) {
    return {
      useConfig: false,
      useDetected: true,
      updateConfig: false,
      selectedRepo: {
        owner: conflict.detectedRepo.owner,
        repo: conflict.detectedRepo.repo,
        baseUrl: conflict.configRepo.baseUrl,
        tokenEnv: conflict.configRepo.tokenEnv,
      },
    };
  }

  // Default to using Git remote without updating config (safest option)
  return {
    useConfig: false,
    useDetected: true,
    updateConfig: false,
    selectedRepo: {
      owner: conflict.detectedRepo.owner,
      repo: conflict.detectedRepo.repo,
      baseUrl: conflict.configRepo.baseUrl,
      tokenEnv: conflict.configRepo.tokenEnv,
    },
  };
}

/**
 * Smart repository configuration that combines config and Git detection
 */
export function getSmartRepositoryConfig(
  configRepo?: GitHubRepo,
  options: {
    useConfig?: boolean;
    useGitRemote?: boolean;
    verbose?: boolean;
  } &#x3D; {}
): { repo: GitHubRepo; source: &amp;#39;config&amp;#39; | &amp;#39;detected&amp;#39; | &amp;#39;merged&amp;#39; } | null {
  const detection &#x3D; detectGitHubRepository();

  // If Git detection failed
  if (!detection.detected) {
    if (options.verbose) {
      console.log(chalk.dim(&amp;#39;Git detection failed:&amp;#39;, detection.error));
    }

    if (configRepo) {
      if (options.verbose) {
        console.log(chalk.dim(&amp;#39;Using repository from config file&amp;#39;));
      }
      return { repo: configRepo, source: &amp;#39;config&amp;#39; };
    }

    return null;
  }

  // If no config repo, use detected
  if (!configRepo) {
    if (options.verbose) {
      console.log(
        chalk.dim(
          &#x60;Auto-detected GitHub repository: ${detection.remote?.owner}/${detection.remote?.repo}&#x60;
        )
      );
    }
    return {
      repo: {
        owner: detection.remote?.owner,
        repo: detection.remote?.repo,
      },
      source: &amp;#39;detected&amp;#39;,
    };
  }

  // Check for conflicts
  const conflict &#x3D; detectRepositoryConflicts(configRepo, detection.remote!);

  if (!conflict) {
    // No conflict - config and detected match
    if (options.verbose) {
      console.log(
        chalk.dim(&#x60;Repository configuration validated: ${configRepo.owner}/${configRepo.repo}&#x60;)
      );
    }
    return { repo: configRepo, source: &amp;#39;config&amp;#39; };
  }

  // Handle conflict
  if (options.verbose) {
    displayConflictResolution(conflict);
  }

  const resolution &#x3D; resolveRepositorySelection(conflict, options);

  return {
    repo: resolution.selectedRepo,
    source: resolution.useConfig ? &amp;#39;config&amp;#39; : &amp;#39;detected&amp;#39;,
  };
}

/**
 * Create repository configuration with intelligent defaults
 */
export function createRepositoryConfig(
  owner: string,
  repo: string,
  baseConfig?: Partial&amp;lt;GitHubRepo&amp;gt;
): GitHubRepo {
  return {
    owner,
    repo,
    baseUrl: baseConfig?.baseUrl,
    tokenEnv: baseConfig?.tokenEnv || &amp;#39;GITHUB_TOKEN&amp;#39;,
  };
}

/**
 * Validate repository configuration and suggest fixes
 */
export function validateRepositoryConfig(repo: GitHubRepo): {
  valid: boolean;
  errors: string[];
  suggestions: string[];
} {
  const errors: string[] &#x3D; [];
  const suggestions: string[] &#x3D; [];

  if (!repo.owner) {
    errors.push(&amp;#39;Repository owner is required&amp;#39;);
  }

  if (!repo.repo) {
    errors.push(&amp;#39;Repository name is required&amp;#39;);
  }

  if (repo.baseUrl &amp;amp;&amp;amp; !repo.baseUrl.startsWith(&amp;#39;https://&amp;#39;)) {
    errors.push(&amp;#39;Base URL must start with https://&amp;#39;);
  }

  // Check for common owner/repo format issues
  if (repo.owner?.includes(&amp;#39;/&amp;#39;)) {
    errors.push(&amp;#39;Owner should not contain forward slashes&amp;#39;);
    suggestions.push(
      &#x60;Did you mean owner: &amp;quot;${repo.owner.split(&amp;#39;/&amp;#39;)[0]}&amp;quot;, repo: &amp;quot;${repo.owner.split(&amp;#39;/&amp;#39;)[1]}&amp;quot;?&#x60;
    );
  }

  if (repo.repo?.includes(&amp;#39;/&amp;#39;)) {
    errors.push(&amp;#39;Repository name should not contain forward slashes&amp;#39;);
  }

  if (repo.repo?.endsWith(&amp;#39;.git&amp;#39;)) {
    suggestions.push(
      &#x60;Repository name should not include .git extension: &amp;quot;${repo.repo.replace(&amp;#39;.git&amp;#39;, &amp;#39;&amp;#39;)}&amp;quot;&#x60;
    );
  }

  return {
    valid: errors.length &#x3D;&#x3D;&#x3D; 0,
    errors,
    suggestions,
  };
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-33">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/file-based-template-manager.ts</div>
                <div class="file-content">
                    <pre>/**
 * File-Based GitHub Template Manager
 *
 * This module provides file-based template loading with inheritance support
 * for GitHub issue templates using Handlebars.
 */

import path from &amp;#39;node:path&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import Handlebars from &amp;#39;handlebars&amp;#39;;
import type {
  GitHubFileTemplateRef,
  GitHubTemplateConfig,
  GitHubTemplateOptions,
  GitHubTemplateSet,
  GitHubTemplateSetSource,
  GitHubTemplatesConfig,
  IssueSpec,
} from &amp;#39;../types.js&amp;#39;;
import { validateIssue } from &amp;#39;../types.js&amp;#39;;
import type { Epic, Task } from &amp;#39;./sharded-storage.js&amp;#39;;

/** Generated template following exact issue schema specification */
export interface GeneratedTemplate extends IssueSpec {
  /** Additional GitHub-specific fields */
  assignees?: string[];
  milestone?: number;
  projects?: number[];
}

export interface TemplateLoadResult {
  content: string;
  metadata?: {
    name?: string;
    description?: string;
    labels?: string[];
    assignees?: string[];
    inherits?: string;
  };
}

export interface TemplateDiscoveryResult {
  templatePath: string;
  metadata: TemplateLoadResult[&amp;#39;metadata&amp;#39;];
}

/**
 * File-based template manager with inheritance support
 */
export class FileBasedTemplateManager {
  private config: GitHubTemplatesConfig;
  private templateCache: Map&amp;lt;string, TemplateLoadResult&amp;gt; &#x3D; new Map();
  private compiledTemplateCache: Map&amp;lt;string, HandlebarsTemplateDelegate&amp;gt; &#x3D; new Map();
  private baseDir: string;

  constructor(config: GitHubTemplatesConfig, baseDir: string &#x3D; process.cwd()) {
    this.config &#x3D; config;
    this.baseDir &#x3D; baseDir;
    this.registerHelpers();
  }

  private isFileReference(value: unknown): value is GitHubFileTemplateRef {
    return typeof value &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp; value !&#x3D;&#x3D; null &amp;amp;&amp;amp; &amp;#39;file&amp;#39; in value;
  }

  private isTemplateSet(value: unknown): value is GitHubTemplateSet {
    return (
      typeof value &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp;
      value !&#x3D;&#x3D; null &amp;amp;&amp;amp;
      &amp;#39;sections&amp;#39; in value &amp;amp;&amp;amp;
      typeof (value as GitHubTemplateSet).sections?.description &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39;
    );
  }

  private isTemplateConfigCandidate(value: unknown): value is GitHubTemplateConfig {
    if (typeof value !&#x3D;&#x3D; &amp;#39;object&amp;#39; || value &#x3D;&#x3D;&#x3D; null) return false;
    if (this.isFileReference(value)) return false;

    return (
      &amp;#39;templateFile&amp;#39; in value || &amp;#39;sections&amp;#39; in value || &amp;#39;title&amp;#39; in value || &amp;#39;description&amp;#39; in value
    );
  }

  /**
   * Generate epic template from file
   */
  async generateEpicTemplate(
    epic: Epic,
    options: GitHubTemplateOptions &#x3D; {}
  ): Promise&amp;lt;GeneratedTemplate&amp;gt; {
    const templateRef &#x3D; this.config.epic;
    if (!templateRef) {
      throw new Error(&amp;#39;Epic template not configured&amp;#39;);
    }

    const template &#x3D; await this.loadTemplate(templateRef);
    const context &#x3D; this.createTemplateContext(epic, options);

    return await this.renderTemplate(template, context, templateRef);
  }

  /**
   * Generate task template from file
   */
  async generateTaskTemplate(
    task: Task,
    epic: Epic,
    options: GitHubTemplateOptions &#x3D; {}
  ): Promise&amp;lt;GeneratedTemplate&amp;gt; {
    const templateRef &#x3D; this.config.task;
    if (!templateRef) {
      throw new Error(&amp;#39;Task template not configured&amp;#39;);
    }

    const template &#x3D; await this.loadTemplate(templateRef);
    const context &#x3D; this.createTemplateContext({ ...task, epic }, options);

    return await this.renderTemplate(template, context, templateRef);
  }

  /**
   * Generate bug report template from file
   */
  async generateBugReportTemplate(
    bugData: any,
    options: GitHubTemplateOptions &#x3D; {}
  ): Promise&amp;lt;GeneratedTemplate&amp;gt; {
    const templateRef &#x3D; this.config.bugReport;
    if (!templateRef) {
      throw new Error(&amp;#39;Bug report template not configured&amp;#39;);
    }

    const template &#x3D; await this.loadTemplate(templateRef);
    const context &#x3D; this.createTemplateContext(bugData, options);

    return await this.renderTemplate(template, context, templateRef);
  }

  /**
   * Generate feature request template from file
   */
  async generateFeatureRequestTemplate(
    featureData: any,
    options: GitHubTemplateOptions &#x3D; {}
  ): Promise&amp;lt;GeneratedTemplate&amp;gt; {
    const templateRef &#x3D; this.config.featureRequest;
    if (!templateRef) {
      throw new Error(&amp;#39;Feature request template not configured&amp;#39;);
    }

    const template &#x3D; await this.loadTemplate(templateRef);
    const context &#x3D; this.createTemplateContext(featureData, options);

    return await this.renderTemplate(template, context, templateRef);
  }

  /**
   * Load template from file or config
   */
  private async loadTemplate(
    templateRef: GitHubTemplateConfig | GitHubFileTemplateRef | GitHubTemplateSetSource
  ): Promise&amp;lt;TemplateLoadResult&amp;gt; {
    // Check if it&amp;#39;s a file reference
    if (this.isFileReference(templateRef)) {
      return await this.loadTemplateFromFile(templateRef);
    }

    if (this.isTemplateSet(templateRef)) {
      const config: GitHubTemplateConfig &#x3D; {
        name: templateRef.name,
        description: templateRef.description,
        sections: templateRef.sections,
        labels: templateRef.labels,
        validation: templateRef.validation,
      };

      return this.createInlineTemplate(config);
    }

    if (!this.isTemplateConfigCandidate(templateRef)) {
      throw new Error(&amp;#39;Unsupported template reference type for file-based templates&amp;#39;);
    }

    // Handle inline template config with possible file reference
    const config &#x3D; templateRef as GitHubTemplateConfig;
    if (config.templateFile) {
      const fileRef: GitHubFileTemplateRef &#x3D; {
        file: config.templateFile,
        inherits: config.inherits,
        metadata: {
          name: config.name,
          description: config.description,
          labels: config.labels,
          assignees: config.assignees,
        },
      };
      return await this.loadTemplateFromFile(fileRef);
    }

    // Fallback to inline template generation
    return this.createInlineTemplate(config);
  }

  /**
   * Load template from file with inheritance support
   */
  private async loadTemplateFromFile(
    templateRef: GitHubFileTemplateRef
  ): Promise&amp;lt;TemplateLoadResult&amp;gt; {
    const filePath &#x3D; await this.resolveTemplatePath(templateRef.file);

    // Check cache first
    const cacheKey &#x3D; filePath;
    if (this.templateCache.has(cacheKey)) {
      return this.templateCache.get(cacheKey)!;
    }

    if (!(await fs.pathExists(filePath))) {
      throw new Error(&#x60;Template file not found: ${filePath}&#x60;);
    }

    let content &#x3D; await fs.readFile(filePath, &amp;#39;utf-8&amp;#39;);
    const metadata &#x3D; this.extractTemplateMetadata(content);

    // Merge metadata from reference and file
    const combinedMetadata &#x3D; {
      ...metadata,
      ...templateRef.metadata,
      inherits: templateRef.inherits || metadata.inherits,
    };

    // Handle inheritance
    if (combinedMetadata.inherits) {
      const baseTemplate &#x3D; await this.loadInheritedTemplate(combinedMetadata.inherits);
      content &#x3D; this.mergeTemplateContent(baseTemplate.content, content);
    }

    const result: TemplateLoadResult &#x3D; {
      content,
      metadata: combinedMetadata,
    };

    // Cache the result
    this.templateCache.set(cacheKey, result);
    return result;
  }

  /**
   * Load inherited template
   */
  private async loadInheritedTemplate(inheritsRef: string): Promise&amp;lt;TemplateLoadResult&amp;gt; {
    // Check if it&amp;#39;s a file path
    if (inheritsRef.includes(&amp;#39;.&amp;#39;)) {
      const fileRef: GitHubFileTemplateRef &#x3D; { file: inheritsRef };
      return await this.loadTemplateFromFile(fileRef);
    }

    // Check if it&amp;#39;s a template name in config
    const baseTemplates &#x3D; [&amp;#39;base&amp;#39;, &amp;#39;epic&amp;#39;, &amp;#39;task&amp;#39;, &amp;#39;bugReport&amp;#39;, &amp;#39;featureRequest&amp;#39;] as const;
    for (const templateName of baseTemplates) {
      const templateRef &#x3D; this.config[templateName];
      if (!templateRef) continue;

      if (this.isFileReference(templateRef)) {
        if (templateRef.metadata?.name &#x3D;&#x3D;&#x3D; inheritsRef) {
          return await this.loadTemplate(templateRef);
        }
        continue;
      }

      if (this.isTemplateSet(templateRef)) {
        if (templateRef.name &#x3D;&#x3D;&#x3D; inheritsRef) {
          return await this.loadTemplate(templateRef);
        }
        continue;
      }

      if (this.isTemplateConfigCandidate(templateRef) &amp;amp;&amp;amp; templateRef.name &#x3D;&#x3D;&#x3D; inheritsRef) {
        return await this.loadTemplate(templateRef);
      }
    }

    throw new Error(&#x60;Inherited template not found: ${inheritsRef}&#x60;);
  }

  /**
   * Merge base template content with child template content
   */
  private mergeTemplateContent(baseContent: string, childContent: string): string {
    // Simple merge strategy: if child has &amp;quot;{{&amp;gt; base}}&amp;quot; or similar, replace it with base content
    // Otherwise, prepend base content
    if (childContent.includes(&amp;#39;{{&amp;gt; base}}&amp;#39;)) {
      return childContent.replace(&amp;#39;{{&amp;gt; base}}&amp;#39;, baseContent);
    }

    // Look for @inherits comment and replace
    const inheritMatch &#x3D; childContent.match(/{{!--\s*@inherits:\s*([^\s]+)\s*--}}/);
    if (inheritMatch) {
      return childContent.replace(inheritMatch[0], baseContent);
    }

    // Fallback: prepend base content
    return &#x60;${baseContent}\n\n${childContent}&#x60;;
  }

  /**
   * Extract metadata from template file comments
   */
  private extractTemplateMetadata(content: string): TemplateLoadResult[&amp;#39;metadata&amp;#39;] {
    const metadata: TemplateLoadResult[&amp;#39;metadata&amp;#39;] &#x3D; {};

    // Extract @inherits
    const inheritMatch &#x3D; content.match(/{{!--\s*@inherits:\s*([^\s]+)\s*--}}/);
    if (inheritMatch) {
      metadata.inherits &#x3D; inheritMatch[1];
    }

    // Extract @name
    const nameMatch &#x3D; content.match(/{{!--\s*@name:\s*([^-]+?)\s*--}}/);
    if (nameMatch) {
      metadata.name &#x3D; nameMatch[1].trim();
    }

    // Extract @description
    const descriptionMatch &#x3D; content.match(/{{!--\s*@description:\s*([^-]+?)\s*--}}/);
    if (descriptionMatch) {
      metadata.description &#x3D; descriptionMatch[1].trim();
    }

    // Extract @labels
    const labelsMatch &#x3D; content.match(/{{!--\s*@labels:\s*\[([^\]]+)\]\s*--}}/);
    if (labelsMatch) {
      metadata.labels &#x3D; labelsMatch[1].split(&amp;#39;,&amp;#39;).map(l &#x3D;&amp;gt; l.trim().replace(/[&amp;#39;&amp;quot;]/g, &amp;#39;&amp;#39;));
    }

    return metadata;
  }

  /**
   * Resolve template file path with discovery paths
   */
  private async resolveTemplatePath(templateFile: string): Promise&amp;lt;string&amp;gt; {
    // If absolute path, use as-is
    if (path.isAbsolute(templateFile)) {
      return templateFile;
    }

    // Try discovery paths
    const discoveryPaths &#x3D; this.config.discoveryPaths || [&amp;#39;.arbiter/templates/github&amp;#39;];

    for (const discoveryPath of discoveryPaths) {
      const resolvedDiscoveryPath &#x3D; this.resolveDiscoveryPath(discoveryPath);
      let candidatePath &#x3D; path.join(resolvedDiscoveryPath, templateFile);

      // Add extension if not present
      if (!path.extname(candidatePath) &amp;amp;&amp;amp; this.config.defaultExtension) {
        candidatePath +&#x3D; &#x60;.${this.config.defaultExtension}&#x60;;
      }

      if (await fs.pathExists(candidatePath)) {
        return candidatePath;
      }
    }

    // Fallback to relative to base directory
    let fallbackPath &#x3D; path.join(this.baseDir, templateFile);
    if (!path.extname(fallbackPath) &amp;amp;&amp;amp; this.config.defaultExtension) {
      fallbackPath +&#x3D; &#x60;.${this.config.defaultExtension}&#x60;;
    }

    return fallbackPath;
  }

  /**
   * Resolve discovery path (handle ~ for home directory)
   */
  private resolveDiscoveryPath(discoveryPath: string): string {
    if (discoveryPath.startsWith(&amp;#39;~&amp;#39;)) {
      const homeDir &#x3D; process.env.HOME || process.env.USERPROFILE;
      if (!homeDir) {
        throw new Error(&amp;#39;Could not resolve home directory for template path&amp;#39;);
      }
      return path.join(homeDir, discoveryPath.slice(1));
    }

    if (path.isAbsolute(discoveryPath)) {
      return discoveryPath;
    }

    return path.join(this.baseDir, discoveryPath);
  }

  /**
   * Create inline template from config (fallback)
   */
  private createInlineTemplate(config: GitHubTemplateConfig): TemplateLoadResult {
    let content &#x3D; &amp;#39;&amp;#39;;

    if (config.sections?.description) {
      content +&#x3D; &#x60;${config.sections.description}\n\n&#x60;;
    }

    if (config.sections?.acceptanceCriteria) {
      content +&#x3D; &#x60;${config.sections.acceptanceCriteria}\n\n&#x60;;
    }

    if (config.sections?.dependencies) {
      content +&#x3D; &#x60;${config.sections.dependencies}\n\n&#x60;;
    }

    if (config.sections?.additional) {
      Object.values(config.sections.additional).forEach(section &#x3D;&amp;gt; {
        content +&#x3D; &#x60;${section}\n\n&#x60;;
      });
    }

    return {
      content: content.trim(),
      metadata: {
        name: config.name,
        description: config.description,
        labels: config.labels,
        assignees: config.assignees,
      },
    };
  }

  /**
   * Render template with context
   */
  private async renderTemplate(
    template: TemplateLoadResult,
    context: Record&amp;lt;string, any&amp;gt;,
    templateRef: GitHubTemplateConfig | GitHubFileTemplateRef
  ): Promise&amp;lt;GeneratedTemplate&amp;gt; {
    // Compile template if not cached
    const cacheKey &#x3D; template.content;
    let compiledTemplate &#x3D; this.compiledTemplateCache.get(cacheKey);

    if (!compiledTemplate) {
      compiledTemplate &#x3D; Handlebars.compile(template.content);
      this.compiledTemplateCache.set(cacheKey, compiledTemplate);
    }

    // Render content
    const body &#x3D; compiledTemplate(context);

    // Extract title - prefer context data or use template metadata
    let title &#x3D; context.name || context.title || template.metadata?.name || &amp;#39;Untitled&amp;#39;;

    // Ensure title length limit
    if (title.length &amp;gt; 255) {
      title &#x3D; &#x60;${title.substring(0, 252)}...&#x60;;
    }

    // Process labels (semantic labels that map to GitHub/GitLab)
    const labels &#x3D; this.processLabels(template.metadata?.labels || [], context);

    // Process assignees (GitHub-specific)
    const assignees &#x3D; this.processAssignees(template.metadata?.assignees || [], context);

    // Extract acceptance criteria from context
    const acceptance_criteria &#x3D; context.acceptanceCriteria || context.acceptance_criteria || [];

    // Extract checklist items from context
    const checklist &#x3D; this.createChecklistFromContext(context);

    // Extract links from context
    const links &#x3D; context.links || [];

    // Create the issue following exact schema specification
    const issue: GeneratedTemplate &#x3D; {
      title,
      body,
      labels,
      acceptance_criteria,
      checklist,
      links,
      // GitHub-specific fields
      assignees: assignees.length &amp;gt; 0 ? assignees : undefined,
    };

    // Validate against issue schema
    const validation &#x3D; validateIssue(issue);
    if (!validation.valid) {
      throw new Error(&#x60;Generated template validation failed: ${validation.errors.join(&amp;#39;, &amp;#39;)}&#x60;);
    }

    return issue;
  }

  /**
   * Process labels with context substitution
   */
  private processLabels(labelTemplates: string[], context: Record&amp;lt;string, any&amp;gt;): string[] {
    return labelTemplates
      .map(template &#x3D;&amp;gt; {
        const compiled &#x3D; Handlebars.compile(template);
        return compiled(context);
      })
      .filter(label &#x3D;&amp;gt; label.length &amp;gt; 0);
  }

  /**
   * Process assignees with context substitution
   */
  private processAssignees(assigneeTemplates: string[], context: Record&amp;lt;string, any&amp;gt;): string[] {
    const assignees: string[] &#x3D; [];

    // Add assignees from context
    if (context.assignee) {
      assignees.push(context.assignee);
    }

    if (context.owner &amp;amp;&amp;amp; context.owner !&#x3D;&#x3D; context.assignee) {
      assignees.push(context.owner);
    }

    // Add assignees from template
    assigneeTemplates.forEach(template &#x3D;&amp;gt; {
      const compiled &#x3D; Handlebars.compile(template);
      const assignee &#x3D; compiled(context);
      if (assignee &amp;amp;&amp;amp; assignee.length &amp;gt; 0) {
        assignees.push(assignee);
      }
    });

    return [...new Set(assignees)]; // Remove duplicates
  }

  /**
   * Create template context from data
   */
  private createTemplateContext(data: any, options: GitHubTemplateOptions): Record&amp;lt;string, any&amp;gt; {
    return {
      ...data,
      ...options.customFields,
      // Helper functions for templates
      helpers: {
        capitalize: (str: string) &#x3D;&amp;gt; str.charAt(0).toUpperCase() + str.slice(1),
        formatDate: (date: string) &#x3D;&amp;gt; new Date(date).toLocaleDateString(),
        statusEmoji: (status: string) &#x3D;&amp;gt; this.getStatusEmoji(status),
      },
    };
  }

  /**
   * Register Handlebars helpers
   */
  private registerHelpers(): void {
    // Equality helper
    Handlebars.registerHelper(&amp;#39;eq&amp;#39;, (a, b) &#x3D;&amp;gt; a &#x3D;&#x3D;&#x3D; b);

    // If helper for conditional rendering
    Handlebars.registerHelper(&amp;#39;ifEquals&amp;#39;, function (arg1, arg2, options) {
      return arg1 &#x3D;&#x3D;&#x3D; arg2 ? options.fn(this) : options.inverse(this);
    });

    // Status emoji helper
    Handlebars.registerHelper(&amp;#39;statusEmoji&amp;#39;, (status: string) &#x3D;&amp;gt; {
      return this.getStatusEmoji(status);
    });

    // Capitalize helper
    Handlebars.registerHelper(&amp;#39;capitalize&amp;#39;, (str: string) &#x3D;&amp;gt; {
      return str ? str.charAt(0).toUpperCase() + str.slice(1) : &amp;#39;&amp;#39;;
    });

    // Format date helper
    Handlebars.registerHelper(&amp;#39;formatDate&amp;#39;, (date: string) &#x3D;&amp;gt; {
      return date ? new Date(date).toLocaleDateString() : &amp;#39;&amp;#39;;
    });
  }

  /**
   * Get status emoji for display
   */
  private getStatusEmoji(status: string): string {
    const emojis: Record&amp;lt;string, string&amp;gt; &#x3D; {
      todo: &amp;#39;ğŸ“‹&amp;#39;,
      planning: &amp;#39;ğŸ“‹&amp;#39;,
      in_progress: &amp;#39;ğŸš§&amp;#39;,
      review: &amp;#39;ğŸ‘€&amp;#39;,
      testing: &amp;#39;ğŸ§ª&amp;#39;,
      completed: &amp;#39;âœ…&amp;#39;,
      cancelled: &amp;#39;âŒ&amp;#39;,
    };
    return emojis[status] || &amp;#39;â“&amp;#39;;
  }

  /**
   * Discover available templates in discovery paths
   */
  async discoverTemplates(): Promise&amp;lt;TemplateDiscoveryResult[]&amp;gt; {
    const discovered: TemplateDiscoveryResult[] &#x3D; [];
    const discoveryPaths: string[] &#x3D; this.config.discoveryPaths ?? [&amp;#39;.arbiter/templates/github&amp;#39;];

    for (const discoveryPath of discoveryPaths) {
      try {
        const resolvedPath &#x3D; this.resolveDiscoveryPath(discoveryPath);
        if (!(await fs.pathExists(resolvedPath))) {
          continue;
        }

        const files &#x3D; await fs.readdir(resolvedPath);
        const templateFiles &#x3D; files.filter(file &#x3D;&amp;gt; {
          const ext &#x3D; path.extname(file);
          return ext &#x3D;&#x3D;&#x3D; &amp;#39;.hbs&amp;#39; || ext &#x3D;&#x3D;&#x3D; &amp;#39;.md&amp;#39; || ext &#x3D;&#x3D;&#x3D; &amp;#39;.handlebars&amp;#39;;
        });

        for (const file of templateFiles) {
          const templatePath &#x3D; path.join(resolvedPath, file);
          const content &#x3D; await fs.readFile(templatePath, &amp;#39;utf-8&amp;#39;);
          const metadata &#x3D; this.extractTemplateMetadata(content);

          discovered.push({
            templatePath,
            metadata,
          });
        }
      } catch (error) {}
    }

    return discovered;
  }

  /**
   * Validate template configuration
   */
  async validateTemplateConfig(): Promise&amp;lt;Array&amp;lt;{ field: string; message: string }&amp;gt;&amp;gt; {
    const errors: Array&amp;lt;{ field: string; message: string }&amp;gt; &#x3D; [];

    // Validate template file references
    const templateRefs &#x3D; [
      { name: &amp;#39;base&amp;#39;, ref: this.config.base },
      { name: &amp;#39;epic&amp;#39;, ref: this.config.epic },
      { name: &amp;#39;task&amp;#39;, ref: this.config.task },
      { name: &amp;#39;bugReport&amp;#39;, ref: this.config.bugReport },
      { name: &amp;#39;featureRequest&amp;#39;, ref: this.config.featureRequest },
    ];

    for (const { name, ref } of templateRefs) {
      if (!ref) continue;

      try {
        if (this.isFileReference(ref)) {
          const filePath &#x3D; await this.resolveTemplatePath(ref.file);
          if (!(await fs.pathExists(filePath))) {
            errors.push({
              field: &#x60;${name}.file&#x60;,
              message: &#x60;Template file not found: ${filePath}&#x60;,
            });
          }
        } else if (this.isTemplateConfigCandidate(ref) &amp;amp;&amp;amp; ref.templateFile) {
          const filePath &#x3D; await this.resolveTemplatePath(ref.templateFile);
          if (!(await fs.pathExists(filePath))) {
            errors.push({
              field: &#x60;${name}.templateFile&#x60;,
              message: &#x60;Template file not found: ${filePath}&#x60;,
            });
          }
        }
      } catch (error) {
        errors.push({
          field: &#x60;${name}&#x60;,
          message: &#x60;Error validating template: ${error instanceof Error ? error.message : String(error)}&#x60;,
        });
      }
    }

    return errors;
  }

  /**
   * Create checklist items from context data
   */
  private createChecklistFromContext(
    context: Record&amp;lt;string, any&amp;gt;
  ): Array&amp;lt;{ id: string; text: string; done?: boolean }&amp;gt; {
    const checklist &#x3D; [];

    // Add task-specific checklist items
    if (context.tasks &amp;amp;&amp;amp; Array.isArray(context.tasks)) {
      context.tasks.forEach((task: any, index: number) &#x3D;&amp;gt; {
        checklist.push({
          id: &#x60;task-${index}&#x60;,
          text: task.name || task.description || &#x60;Task ${index + 1}&#x60;,
          done: task.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39;,
        });
      });
    }

    // Add acceptance criteria as checklist items
    if (context.acceptanceCriteria &amp;amp;&amp;amp; Array.isArray(context.acceptanceCriteria)) {
      context.acceptanceCriteria.forEach((criteria: string, index: number) &#x3D;&amp;gt; {
        checklist.push({
          id: &#x60;criteria-${index}&#x60;,
          text: criteria,
          done: false,
        });
      });
    }

    // Add any custom checklist items from context
    if (context.checklist &amp;amp;&amp;amp; Array.isArray(context.checklist)) {
      context.checklist.forEach((item: any, index: number) &#x3D;&amp;gt; {
        if (typeof item &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39;) {
          checklist.push({
            id: &#x60;custom-${index}&#x60;,
            text: item,
            done: false,
          });
        } else if (item &amp;amp;&amp;amp; typeof item &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39;) {
          checklist.push({
            id: item.id || &#x60;custom-${index}&#x60;,
            text: item.text || item.description || &amp;#39;&amp;#39;,
            done: !!item.done,
          });
        }
      });
    }

    return checklist;
  }

  /**
   * Clear template cache
   */
  clearCache(): void {
    this.templateCache.clear();
    this.compiledTemplateCache.clear();
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-34">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/smart-naming.ts</div>
                <div class="file-content">
                    <pre>/**
 * Smart Naming Strategy for Generated Files
 *
 * This module provides intelligent file naming based on project context,
 * user preferences, and input files. It addresses the feedback that files
 * were being generated with generic names like &amp;quot;arbiter.assembly.cue&amp;quot;
 * instead of project-specific names.
 */

import fs from &amp;#39;node:fs&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import { glob } from &amp;#39;glob&amp;#39;;

// Standard file extensions and their default naming patterns
export const FILE_PATTERNS &#x3D; {
  assembly: { extension: &amp;#39;.assembly.cue&amp;#39;, default: &amp;#39;arbiter.assembly.cue&amp;#39; },
  surface: { extension: &amp;#39;.json&amp;#39;, default: &amp;#39;surface.json&amp;#39; },
  versionPlan: { extension: &amp;#39;.json&amp;#39;, default: &amp;#39;version_plan.json&amp;#39; },
  apiSurface: { extension: &amp;#39;.json&amp;#39;, default: &amp;#39;api-surface.json&amp;#39; },
  docs: { extension: &amp;#39;.md&amp;#39;, default: &amp;#39;README.md&amp;#39; },
  html: { extension: &amp;#39;.html&amp;#39;, default: &amp;#39;arbiter.html&amp;#39; },
} as const;

export type FileType &#x3D; keyof typeof FILE_PATTERNS;

export interface NamingOptions {
  /** Explicit output filename override */
  output?: string;
  /** Output directory for generated files */
  outputDir?: string;
  /** Base name to use for generating filenames */
  baseName?: string;
  /** Project name detected or specified */
  projectName?: string;
  /** Input file that triggered the generation */
  inputFile?: string;
  /** Whether to maintain backward compatibility with generic names */
  useGenericNames?: boolean;
}

export interface ProjectContext {
  name?: string;
  directory: string;
  packageJsonPath?: string;
  assemblyFile?: string;
  configFiles: string[];
}

/**
 * Detects project context from the current directory and its metadata
 */
export async function detectProjectContext(
  workingDir: string &#x3D; process.cwd()
): Promise&amp;lt;ProjectContext&amp;gt; {
  const context: ProjectContext &#x3D; {
    directory: workingDir,
    configFiles: [],
  };

  // Check for package.json
  const packageJsonPath &#x3D; path.join(workingDir, &amp;#39;package.json&amp;#39;);
  if (fs.existsSync(packageJsonPath)) {
    context.packageJsonPath &#x3D; packageJsonPath;
    try {
      const packageJson &#x3D; JSON.parse(fs.readFileSync(packageJsonPath, &amp;#39;utf-8&amp;#39;));
      context.name &#x3D; packageJson.name;
    } catch (error) {
      console.warn(&#x60;Warning: Could not parse package.json: ${error}&#x60;);
    }
  }

  // Check for existing assembly files
  const assemblyFiles &#x3D; await glob(&amp;#39;*.assembly.cue&amp;#39;, { cwd: workingDir });
  if (assemblyFiles.length &amp;gt; 0) {
    context.assemblyFile &#x3D; path.join(workingDir, assemblyFiles[0]);

    // Try to extract project name from assembly file
    if (!context.name) {
      try {
        const assemblyContent &#x3D; fs.readFileSync(context.assemblyFile, &amp;#39;utf-8&amp;#39;);
        const nameMatch &#x3D; assemblyContent.match(/name:\s*&amp;quot;([^&amp;quot;]+)&amp;quot;/);
        if (nameMatch) {
          context.name &#x3D; nameMatch[1];
        }
      } catch (error) {
        console.warn(&#x60;Warning: Could not parse assembly file: ${error}&#x60;);
      }
    }
  }

  // Check for other config files that might contain project names
  const configPatterns &#x3D; [
    &amp;#39;pyproject.toml&amp;#39;,
    &amp;#39;Cargo.toml&amp;#39;,
    &amp;#39;go.mod&amp;#39;,
    &amp;#39;composer.json&amp;#39;,
    &amp;#39;.arbiter/config.json&amp;#39;,
    &amp;#39;.arbiter/config.yaml&amp;#39;,
    &amp;#39;.arbiter.json&amp;#39;,
    &amp;#39;.arbiter.yaml&amp;#39;,
  ];

  for (const pattern of configPatterns) {
    const configPath &#x3D; path.join(workingDir, pattern);
    if (fs.existsSync(configPath)) {
      context.configFiles.push(configPath);

      // Try to extract name if not already found
      if (!context.name) {
        try {
          const content &#x3D; fs.readFileSync(configPath, &amp;#39;utf-8&amp;#39;);
          context.name &#x3D; extractProjectNameFromConfig(content, pattern);
        } catch (_error) {
          // Silently continue - not all config files are parseable
        }
      }
    }
  }

  // Fallback to directory name if no project name found
  if (!context.name) {
    context.name &#x3D; path.basename(workingDir);
  }

  return context;
}

/**
 * Extract project name from various config file formats
 */
function extractProjectNameFromConfig(content: string, filename: string): string | undefined {
  switch (path.extname(filename)) {
    case &amp;#39;.toml&amp;#39;: {
      // Cargo.toml or pyproject.toml
      const tomlNameMatch &#x3D; content.match(/name\s*&#x3D;\s*[&amp;quot;&amp;#39;]([^&amp;quot;&amp;#39;]+)[&amp;quot;&amp;#39;]/);
      return tomlNameMatch?.[1];
    }

    case &amp;#39;.mod&amp;#39;: {
      // go.mod
      const goModMatch &#x3D; content.match(/module\s+([^\s]+)/);
      return goModMatch?.[1]?.split(&amp;#39;/&amp;#39;).pop(); // Get last part of module path
    }

    case &amp;#39;.json&amp;#39;:
    case &amp;#39;.yaml&amp;#39;:
    case &amp;#39;.yml&amp;#39;:
      try {
        const parsed &#x3D; JSON.parse(content);
        return parsed.name;
      } catch {
        // Try YAML parsing if JSON fails (simplified)
        const yamlNameMatch &#x3D; content.match(/name:\s*[&amp;quot;&amp;#39;]?([^&amp;quot;&amp;#39;\n]+)[&amp;quot;&amp;#39;]?/);
        return yamlNameMatch?.[1];
      }

    default:
      return undefined;
  }
}

/**
 * Generate a smart filename based on project context and options
 */
export function generateSmartFilename(
  fileType: FileType,
  options: NamingOptions &#x3D; {},
  context?: ProjectContext
): string {
  // Handle explicit output or generic names early
  if (options.output) {
    return options.output;
  }

  if (options.useGenericNames) {
    return FILE_PATTERNS[fileType].default;
  }

  // Resolve and sanitize the base name
  const baseName &#x3D; resolveBaseName(options, context);
  const sanitizedBaseName &#x3D; sanitizeBaseName(baseName);

  // Generate filename based on file type
  return generateFilenameForType(fileType, sanitizedBaseName);
}

/**
 * Resolve base name from various sources
 */
function resolveBaseName(options: NamingOptions, context?: ProjectContext): string {
  // Try explicit options first
  let baseName &#x3D; options.baseName || options.projectName || context?.name;

  // Generate from input file if available
  if (!baseName &amp;amp;&amp;amp; options.inputFile) {
    baseName &#x3D; deriveBaseNameFromFile(options.inputFile);
  }

  // Fallback to context or current directory
  if (!baseName) {
    baseName &#x3D; context?.name || path.basename(context?.directory || process.cwd());
  }

  return baseName;
}

/**
 * Derive base name from input file
 */
function deriveBaseNameFromFile(inputFile: string): string | undefined {
  const inputBaseName &#x3D; path.basename(inputFile, path.extname(inputFile));
  return inputBaseName &#x3D;&#x3D;&#x3D; &amp;#39;requirements&amp;#39; ? undefined : inputBaseName;
}

/**
 * Sanitize base name for filename use
 */
function sanitizeBaseName(baseName: string): string {
  return baseName
    .toLowerCase()
    .replace(/[^a-z0-9-_]/g, &amp;#39;-&amp;#39;)
    .replace(/-+/g, &amp;#39;-&amp;#39;)
    .replace(/^-|-$/g, &amp;#39;&amp;#39;);
}

/**
 * Generate filename for specific file type
 */
function generateFilenameForType(fileType: FileType, sanitizedBaseName: string): string {
  const fileTypeTemplates: Record&amp;lt;FileType, string&amp;gt; &#x3D; {
    assembly: &#x60;${sanitizedBaseName}.assembly.cue&#x60;,
    surface: &#x60;${sanitizedBaseName}-surface.json&#x60;,
    versionPlan: &#x60;${sanitizedBaseName}-version-plan.json&#x60;,
    apiSurface: &#x60;${sanitizedBaseName}-api-surface.json&#x60;,
    docs: &#x60;${sanitizedBaseName}-docs.md&#x60;,
    html: &#x60;${sanitizedBaseName}.html&#x60;,
  };

  if (fileType in fileTypeTemplates) {
    return fileTypeTemplates[fileType];
  }

  // Fallback to pattern extension
  const pattern &#x3D; FILE_PATTERNS[fileType];
  return &#x60;${sanitizedBaseName}${pattern.extension}&#x60;;
}

/**
 * Generate full output path including directory
 */
export function generateOutputPath(
  fileType: FileType,
  options: NamingOptions &#x3D; {},
  context?: ProjectContext
): string {
  const filename &#x3D; generateSmartFilename(fileType, options, context);
  const outputDir &#x3D; options.outputDir || context?.directory || process.cwd();
  return path.resolve(outputDir, filename);
}

/**
 * Auto-detect naming preferences from existing files
 */
export async function detectNamingPreferences(workingDir: string &#x3D; process.cwd()): Promise&amp;lt;{
  usesProjectNames: boolean;
  existingPatterns: Array&amp;lt;{ type: FileType; filename: string }&amp;gt;;
}&amp;gt; {
  const patterns: Array&amp;lt;{ type: FileType; filename: string }&amp;gt; &#x3D; [];
  let usesProjectNames &#x3D; false;

  // Check for existing files that match our patterns
  const allFiles &#x3D; await glob(&amp;#39;*.{json,cue,html,md}&amp;#39;, { cwd: workingDir });

  for (const file of allFiles) {
    const lowerFile &#x3D; file.toLowerCase();

    if (lowerFile.includes(&amp;#39;assembly&amp;#39;) &amp;amp;&amp;amp; lowerFile.endsWith(&amp;#39;.cue&amp;#39;)) {
      patterns.push({ type: &amp;#39;assembly&amp;#39;, filename: file });
      if (!lowerFile.startsWith(&amp;#39;arbiter.&amp;#39;)) {
        usesProjectNames &#x3D; true;
      }
    } else if (lowerFile.includes(&amp;#39;surface&amp;#39;) &amp;amp;&amp;amp; lowerFile.endsWith(&amp;#39;.json&amp;#39;)) {
      patterns.push({ type: &amp;#39;surface&amp;#39;, filename: file });
      if (lowerFile !&#x3D;&#x3D; &amp;#39;surface.json&amp;#39;) {
        usesProjectNames &#x3D; true;
      }
    } else if (lowerFile.includes(&amp;#39;version&amp;#39;) &amp;amp;&amp;amp; lowerFile.includes(&amp;#39;plan&amp;#39;)) {
      patterns.push({ type: &amp;#39;versionPlan&amp;#39;, filename: file });
      if (lowerFile !&#x3D;&#x3D; &amp;#39;version_plan.json&amp;#39;) {
        usesProjectNames &#x3D; true;
      }
    }
  }

  return { usesProjectNames, existingPatterns: patterns };
}

/**
 * Smart naming resolver that combines all strategies
 */
export async function resolveSmartNaming(
  fileType: FileType,
  options: NamingOptions &#x3D; {}
): Promise&amp;lt;{
  filename: string;
  fullPath: string;
  context: ProjectContext;
  isGeneric: boolean;
}&amp;gt; {
  // Detect project context
  const context &#x3D; await detectProjectContext(options.outputDir);

  // Check existing naming preferences if not explicitly specified
  if (options.useGenericNames &#x3D;&#x3D;&#x3D; undefined) {
    const preferences &#x3D; await detectNamingPreferences(context.directory);
    options.useGenericNames &#x3D; !preferences.usesProjectNames;
  }

  // Generate the filename
  const filename &#x3D; generateSmartFilename(fileType, options, context);
  const fullPath &#x3D; generateOutputPath(fileType, options, context);
  const isGeneric &#x3D; filename &#x3D;&#x3D;&#x3D; FILE_PATTERNS[fileType].default;

  return {
    filename,
    fullPath,
    context,
    isGeneric,
  };
}

/**
 * Batch naming for multiple file types
 */
export async function resolveBatchNaming(
  fileTypes: FileType[],
  options: NamingOptions &#x3D; {}
): Promise&amp;lt;Record&amp;lt;FileType, { filename: string; fullPath: string }&amp;gt;&amp;gt; {
  const context &#x3D; await detectProjectContext(options.outputDir);
  const result &#x3D; {} as Record&amp;lt;FileType, { filename: string; fullPath: string }&amp;gt;;

  for (const fileType of fileTypes) {
    const filename &#x3D; generateSmartFilename(fileType, options, context);
    const fullPath &#x3D; generateOutputPath(fileType, options, context);
    result[fileType] &#x3D; { filename, fullPath };
  }

  return result;
}

/**
 * Validate filename conflicts and suggest alternatives
 */
export async function validateNaming(
  fileType: FileType,
  options: NamingOptions &#x3D; {}
): Promise&amp;lt;{
  isValid: boolean;
  conflicts: string[];
  suggestions: string[];
}&amp;gt; {
  const { filename, fullPath, context } &#x3D; await resolveSmartNaming(fileType, options);
  const conflicts: string[] &#x3D; [];
  const suggestions: string[] &#x3D; [];

  // Check if file already exists
  if (fs.existsSync(fullPath)) {
    conflicts.push(&#x60;File already exists: ${filename}&#x60;);

    // Generate alternative names
    const baseName &#x3D; path.basename(filename, path.extname(filename));
    const extension &#x3D; path.extname(filename);

    for (let i &#x3D; 1; i &amp;lt;&#x3D; 3; i++) {
      const alternative &#x3D; &#x60;${baseName}-${i}${extension}&#x60;;
      const alternativePath &#x3D; path.join(context.directory, alternative);
      if (!fs.existsSync(alternativePath)) {
        suggestions.push(alternative);
        break;
      }
    }

    // Suggest timestamped version
    const timestamp &#x3D; new Date().toISOString().slice(0, 19).replace(/[T:]/g, &amp;#39;-&amp;#39;);
    suggestions.push(&#x60;${baseName}-${timestamp}${extension}&#x60;);
  }

  return {
    isValid: conflicts.length &#x3D;&#x3D;&#x3D; 0,
    conflicts,
    suggestions,
  };
}

/**
 * Migration helper to rename existing generic files to project-specific names
 */
export async function migrateExistingFiles(
  workingDir: string &#x3D; process.cwd(),
  dryRun &#x3D; true
): Promise&amp;lt;Array&amp;lt;{ from: string; to: string; migrated: boolean }&amp;gt;&amp;gt; {
  const context &#x3D; await detectProjectContext(workingDir);
  const migrations: Array&amp;lt;{ from: string; to: string; migrated: boolean }&amp;gt; &#x3D; [];

  for (const [fileType, pattern] of Object.entries(FILE_PATTERNS)) {
    const genericPath &#x3D; path.join(workingDir, pattern.default);

    if (fs.existsSync(genericPath)) {
      const smartName &#x3D; generateSmartFilename(
        fileType as FileType,
        { useGenericNames: false },
        context
      );
      const targetPath &#x3D; path.join(workingDir, smartName);

      if (genericPath !&#x3D;&#x3D; targetPath) {
        let migrated &#x3D; false;

        if (!dryRun &amp;amp;&amp;amp; !fs.existsSync(targetPath)) {
          try {
            fs.renameSync(genericPath, targetPath);
            migrated &#x3D; true;
          } catch (error) {
            console.warn(&#x60;Failed to migrate ${genericPath}: ${error}&#x60;);
          }
        }

        migrations.push({
          from: pattern.default,
          to: smartName,
          migrated,
        });
      }
    }
  }

  return migrations;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-35">
                <div class="file-header">ğŸ“„ packages/shared/src/types.ts</div>
                <div class="file-content">
                    <pre>export * from &amp;#39;@arbiter/shared-types/cli&amp;#39;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-36">
                <div class="file-header">ğŸ“„ apps/api/src/server.ts</div>
                <div class="file-content">
                    <pre>/**
 * Refactored Bun HTTP server with modular architecture
 *
 * This version replaces the massive 111KB monolithic server with a clean,
 * modular architecture that separates concerns into dedicated modules:
 *
 * - routes/: API endpoints using Hono framework
 * - websocket/: WebSocket connection and message handling
 * - mcp/: Model Context Protocol tool handlers
 * - static/: Static file serving for frontend
 */
import type { ServerWebSocket } from &amp;#39;bun&amp;#39;;
import { Hono } from &amp;#39;hono&amp;#39;;
import { AuthService } from &amp;#39;./auth.ts&amp;#39;;
import { loadConfig } from &amp;#39;./config.ts&amp;#39;;
import { SpecWorkbenchDB } from &amp;#39;./db.ts&amp;#39;;
import { EventService } from &amp;#39;./events.ts&amp;#39;;
import { HandlerAPIController } from &amp;#39;./handlers/api.js&amp;#39;;
import { IRGenerator } from &amp;#39;./ir.ts&amp;#39;;
import { McpCliIntegration } from &amp;#39;./mcp-cli-integration.ts&amp;#39;;
import { SpecEngine } from &amp;#39;./specEngine.ts&amp;#39;;
import type { ServerConfig } from &amp;#39;./types.ts&amp;#39;;
import { TokenBucket, createProblemDetails, logger } from &amp;#39;./utils.ts&amp;#39;;
import { WebhookService } from &amp;#39;./webhooks.ts&amp;#39;;

import { McpService } from &amp;#39;./mcp/index.ts&amp;#39;;
// Import modular components
import { type Dependencies, createApiRouter } from &amp;#39;./routes/index.ts&amp;#39;;
import { StaticFileHandler } from &amp;#39;./static/index.ts&amp;#39;;
import { WebSocketHandler } from &amp;#39;./websocket/index.ts&amp;#39;;

export class SpecWorkbenchServer {
  private db: SpecWorkbenchDB;
  private auth: AuthService;
  private specEngine: SpecEngine;
  private irGenerator: IRGenerator;
  private events: EventService;
  private webhooks: WebhookService;
  private handlersApi: HandlerAPIController;
  private mcpCli: McpCliIntegration;
  private rateLimiter: TokenBucket;

  // Modular components
  private apiRouter: ReturnType&amp;lt;typeof createApiRouter&amp;gt;;
  private httpApp: Hono;
  private wsHandler: WebSocketHandler;
  private mcpService: McpService;
  private staticHandler: StaticFileHandler;

  constructor(private config: ServerConfig) {
    // Initialize core services
    this.db &#x3D; new SpecWorkbenchDB(config);
    this.auth &#x3D; new AuthService(config);
    this.specEngine &#x3D; new SpecEngine(config);
    this.irGenerator &#x3D; new IRGenerator();
    this.events &#x3D; new EventService(config);
    this.webhooks &#x3D; new WebhookService(config, this.events, this.db);
    this.handlersApi &#x3D; new HandlerAPIController(this.webhooks.getHandlerManager());
    this.mcpCli &#x3D; new McpCliIntegration();
    this.rateLimiter &#x3D; new TokenBucket(
      config.rate_limit.max_tokens,
      config.rate_limit.refill_rate,
      config.rate_limit.window_ms
    );

    // Initialize modular components
    const dependencies: Dependencies &#x3D; {
      db: this.db,
      specEngine: this.specEngine,
      events: this.events,
      auth: this.auth,
      webhooks: this.webhooks,
      handlersApi: this.handlersApi,
      config: this.config,
    };

    this.apiRouter &#x3D; createApiRouter(dependencies);
    this.httpApp &#x3D; new Hono();
    this.wsHandler &#x3D; new WebSocketHandler(this.auth, this.events, config.websocket);
    this.mcpService &#x3D; new McpService(this.auth, this.mcpCli);
    this.staticHandler &#x3D; new StaticFileHandler();

    this.httpApp.use(&amp;#39;*&amp;#39;, async (c, next) &#x3D;&amp;gt; {
      await next();

      if (c.res) {
        const corsHeaders &#x3D; this.getCorsHeaders();
        for (const [key, value] of Object.entries(corsHeaders)) {
          if (!c.res.headers.has(key)) {
            c.res.headers.set(key, value);
          }
        }
      }
    });

    this.httpApp.route(&amp;#39;/&amp;#39;, this.apiRouter);

    this.httpApp.all(&amp;#39;/mcp&amp;#39;, async c &#x3D;&amp;gt; {
      logger.info(&amp;#39;MCP request received&amp;#39;, {
        method: c.req.method,
        userAgent: c.req.header(&amp;#39;user-agent&amp;#39;),
        contentType: c.req.header(&amp;#39;content-type&amp;#39;),
      });
      const corsHeaders &#x3D; this.getCorsHeaders();
      return await this.mcpService.handleRequest(c.req.raw, corsHeaders);
    });

    this.httpApp.all(&amp;#39;/webhooks/*&amp;#39;, async c &#x3D;&amp;gt; {
      const corsHeaders &#x3D; this.getCorsHeaders();
      return await this.webhooks.handleRequest(c.req.raw, corsHeaders);
    });

    this.httpApp.notFound(async c &#x3D;&amp;gt; {
      const corsHeaders &#x3D; this.getCorsHeaders();
      const pathname &#x3D; new URL(c.req.url).pathname;

      if (this.staticHandler.shouldServeStaticFile(pathname)) {
        return await this.staticHandler.serveFile(pathname, corsHeaders);
      }

      return this.createNotFoundResponse(pathname, corsHeaders);
    });

    this.httpApp.onError((err, c) &#x3D;&amp;gt; {
      return this.handleRequestError(err, c.req.method, new URL(c.req.url).pathname);
    });

    // Clean up rate limiter buckets periodically
    setInterval(() &#x3D;&amp;gt; {
      this.rateLimiter.cleanup();
    }, 60000); // Every minute
  }

  /**
   * Start the server
   */
  async start(): Promise&amp;lt;void&amp;gt; {
    const self &#x3D; this;

    // Start OAuth service if enabled
    await this.auth.startOAuthService();

    const _server &#x3D; Bun.serve({
      port: this.config.port,
      hostname: this.config.host,

      async fetch(request, server) {
        return await self.handleRequest(request, server);
      },

      websocket: {
        message: async (ws, message) &#x3D;&amp;gt; {
          await self.wsHandler.handleMessage(
            ws as any,
            typeof message &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39; ? message : message.toString()
          );
        },

        open: ws &#x3D;&amp;gt; {
          self.wsHandler.handleOpen(ws as any);
        },

        close: ws &#x3D;&amp;gt; {
          self.wsHandler.handleClose(ws as any);
        },
      },
    });

    logger.info(&amp;#39;ğŸš€ Arbiter API server started&amp;#39;, {
      port: this.config.port,
      host: this.config.host,
      environment: process.env.NODE_ENV || &amp;#39;development&amp;#39;,
    });
  }

  /**
   * Get CORS headers
   */
  private getCorsHeaders(): Record&amp;lt;string, string&amp;gt; {
    return {
      &amp;#39;Access-Control-Allow-Origin&amp;#39;: &amp;#39;*&amp;#39;,
      &amp;#39;Access-Control-Allow-Methods&amp;#39;: &amp;#39;GET, POST, PUT, DELETE, PATCH, OPTIONS&amp;#39;,
      &amp;#39;Access-Control-Allow-Headers&amp;#39;:
        &amp;#39;Content-Type, Authorization, X-Requested-With, Accept, Origin, X-API-Key, &amp;#39; +
        &amp;#39;X-GitHub-Event, X-Hub-Signature-256, X-GitLab-Event, X-GitLab-Token&amp;#39;,
      &amp;#39;Access-Control-Expose-Headers&amp;#39;: &amp;#39;Content-Length, X-Request-ID&amp;#39;,
      &amp;#39;Access-Control-Allow-Credentials&amp;#39;: &amp;#39;true&amp;#39;,
      &amp;#39;Access-Control-Max-Age&amp;#39;: &amp;#39;86400&amp;#39;,
    };
  }

  /**
   * Handle preflight requests
   */
  private handlePreflightRequest(corsHeaders: Record&amp;lt;string, string&amp;gt;): Response {
    return new Response(null, {
      status: 204,
      headers: corsHeaders,
    });
  }

  /**
   * Check rate limiting
   */
  private checkRateLimit(request: Request, corsHeaders: Record&amp;lt;string, string&amp;gt;): Response | null {
    const clientId &#x3D; this.getClientId(request);

    if (!this.rateLimiter.consume(clientId)) {
      return new Response(
        JSON.stringify(createProblemDetails(429, &amp;#39;Too Many Requests&amp;#39;, &amp;#39;Rate limit exceeded&amp;#39;)),
        {
          status: 429,
          headers: {
            &amp;#39;Content-Type&amp;#39;: &amp;#39;application/problem+json&amp;#39;,
            &amp;#39;Retry-After&amp;#39;: &amp;#39;60&amp;#39;,
            ...corsHeaders,
          },
        }
      );
    }

    return null;
  }

  /**
   * Main request handler - routes to appropriate modules
   */
  private async handleRequest(request: Request, server: any): Promise&amp;lt;Response&amp;gt; {
    const url &#x3D; new URL(request.url);
    const method &#x3D; request.method;
    const pathname &#x3D; url.pathname;

    try {
      const corsHeaders &#x3D; this.getCorsHeaders();

      if (method &#x3D;&#x3D;&#x3D; &amp;#39;OPTIONS&amp;#39;) {
        return this.handlePreflightRequest(corsHeaders);
      }

      if (this.wsHandler.isWebSocketUpgrade(pathname, request)) {
        const upgradeResult &#x3D; await this.wsHandler.handleUpgrade(request, server);
        return upgradeResult.response || new Response(&amp;#39;WebSocket upgrade successful&amp;#39;);
      }

      const rateLimitResponse &#x3D; this.checkRateLimit(request, corsHeaders);
      if (rateLimitResponse) {
        return rateLimitResponse;
      }

      return await this.httpApp.fetch(request);
    } catch (error) {
      return this.handleRequestError(error, method, pathname);
    }
  }

  /**
   * Create 404 Not Found response
   */
  private createNotFoundResponse(pathname: string, corsHeaders: Record&amp;lt;string, string&amp;gt;): Response {
    return new Response(
      JSON.stringify(
        createProblemDetails(
          404,
          &amp;#39;Not Found&amp;#39;,
          &#x60;Route ${pathname} not found&#x60;,
          undefined, // type
          undefined, // instance
          {
            available_endpoints: [&amp;#39;/health&amp;#39;, &amp;#39;/status&amp;#39;, &amp;#39;/mcp&amp;#39;, &amp;#39;/api/*&amp;#39;, &amp;#39;/ws&amp;#39;],
          }
        )
      ),
      {
        status: 404,
        headers: {
          &amp;#39;Content-Type&amp;#39;: &amp;#39;application/problem+json&amp;#39;,
          ...corsHeaders,
        },
      }
    );
  }

  /**
   * Handle request errors
   */
  private handleRequestError(error: unknown, method: string, pathname: string): Response {
    logger.error(&amp;#39;Request handling error&amp;#39;, error instanceof Error ? error : undefined, {
      method,
      pathname,
    });

    return new Response(
      JSON.stringify(
        createProblemDetails(500, &amp;#39;Internal Server Error&amp;#39;, &amp;#39;An unexpected error occurred&amp;#39;)
      ),
      {
        status: 500,
        headers: {
          &amp;#39;Content-Type&amp;#39;: &amp;#39;application/problem+json&amp;#39;,
          &amp;#39;Access-Control-Allow-Origin&amp;#39;: &amp;#39;*&amp;#39;,
        },
      }
    );
  }

  /**
   * Get client ID for rate limiting
   */
  private getClientId(request: Request): string {
    const forwarded &#x3D; request.headers.get(&amp;#39;x-forwarded-for&amp;#39;);
    const realIp &#x3D; request.headers.get(&amp;#39;x-real-ip&amp;#39;);
    const cfConnectingIp &#x3D; request.headers.get(&amp;#39;cf-connecting-ip&amp;#39;);

    // Use the first available IP, preferring Cloudflare&amp;#39;s
    const ip &#x3D; cfConnectingIp || realIp || forwarded?.split(&amp;#39;,&amp;#39;)[0] || &amp;#39;unknown&amp;#39;;

    // Include user agent for better rate limiting granularity
    const userAgent &#x3D; request.headers.get(&amp;#39;user-agent&amp;#39;) || &amp;#39;unknown&amp;#39;;
    const authHeader &#x3D; request.headers.get(&amp;#39;authorization&amp;#39;);

    // If there&amp;#39;s an auth header, use that for rate limiting (per user)
    if (authHeader) {
      return &#x60;auth:${authHeader.substring(0, 32)}&#x60;;
    }

    // Otherwise use IP + User Agent
    return &#x60;ip:${ip}:${userAgent.substring(0, 32)}&#x60;;
  }

  /**
   * Graceful shutdown
   */
  async shutdown(): Promise&amp;lt;void&amp;gt; {
    logger.info(&amp;#39;Shutting down server...&amp;#39;);

    try {
      // Close database connections
      await this.db.close();

      // Stop OAuth service
      await this.auth.stopOAuthService();

      // Clean up any other resources
      this.rateLimiter.cleanup();

      logger.info(&amp;#39;Server shutdown complete&amp;#39;);
    } catch (error) {
      logger.error(&amp;#39;Error during shutdown&amp;#39;, error instanceof Error ? error : undefined);
    }
  }
}

// Export for external usage
export { createApiRouter, WebSocketHandler, McpService, StaticFileHandler };

let config: ServerConfig;

try {
  config &#x3D; loadConfig();
} catch (error) {
  logger.error(&amp;#39;Failed to load server configuration&amp;#39;, error instanceof Error ? error : undefined);
  process.exit(1);
}

// Start the server
const server &#x3D; new SpecWorkbenchServer(config);

// Handle graceful shutdown
process.on(&amp;#39;SIGINT&amp;#39;, async () &#x3D;&amp;gt; {
  console.log(&amp;#39;\nğŸ”¸ Received SIGINT, shutting down gracefully...&amp;#39;);
  await server.shutdown();
  process.exit(0);
});

process.on(&amp;#39;SIGTERM&amp;#39;, async () &#x3D;&amp;gt; {
  console.log(&amp;#39;\nğŸ”¸ Received SIGTERM, shutting down gracefully...&amp;#39;);
  await server.shutdown();
  process.exit(0);
});

// Start the server and handle startup errors
try {
  await server.start();
} catch (error) {
  logger.error(&amp;#39;Failed to start server&amp;#39;, error instanceof Error ? error : undefined);
  process.exit(1);
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-37">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/template.ts</div>
                <div class="file-content">
                    <pre>import fs from &amp;quot;node:fs/promises&amp;quot;;
import path from &amp;quot;node:path&amp;quot;;
import { fileURLToPath } from &amp;quot;node:url&amp;quot;;
import chalk from &amp;quot;chalk&amp;quot;;
import * as yaml from &amp;quot;yaml&amp;quot;;

const __filename &#x3D; fileURLToPath(import.meta.url);
const __dirname &#x3D; path.dirname(__filename);

export interface TemplateOptions {
  output?: string;
  format?: &amp;quot;cue&amp;quot; | &amp;quot;json&amp;quot;;
  list?: boolean;
  interactive?: boolean;
}

export interface TemplateMetadata {
  name: string;
  description: string;
  category: string;
  tags: string[];
  version: string;
  author: string;
  usage: string;
  parameters?: Array&amp;lt;{
    name: string;
    type: string;
    description: string;
    default?: any;
  }&amp;gt;;
  examples?: Array&amp;lt;{
    description: string;
    values: Record&amp;lt;string, any&amp;gt;;
  }&amp;gt;;
}

/**
 * Get the templates directory path
 */
function getTemplatesDir(): string {
  // Templates are in packages/cli/templates/
  return path.resolve(__dirname, &amp;quot;../../templates&amp;quot;);
}

/**
 * Load template metadata from YAML file
 */
async function loadTemplateMetadata(templateName: string): Promise&amp;lt;TemplateMetadata | null&amp;gt; {
  try {
    const templatesDir &#x3D; getTemplatesDir();
    const metadataPath &#x3D; path.join(templatesDir, &#x60;${templateName}.yaml&#x60;);
    const content &#x3D; await fs.readFile(metadataPath, &amp;quot;utf-8&amp;quot;);
    return yaml.parse(content) as TemplateMetadata;
  } catch (_error) {
    return null;
  }
}

/**
 * Load template CUE content
 */
async function loadTemplateContent(templateName: string): Promise&amp;lt;string | null&amp;gt; {
  try {
    const templatesDir &#x3D; getTemplatesDir();
    const cuePath &#x3D; path.join(templatesDir, &#x60;${templateName}.cue&#x60;);
    return await fs.readFile(cuePath, &amp;quot;utf-8&amp;quot;);
  } catch (_error) {
    return null;
  }
}

/**
 * Get list of available templates
 */
async function getAvailableTemplates(): Promise&amp;lt;TemplateMetadata[]&amp;gt; {
  try {
    const templatesDir &#x3D; getTemplatesDir();
    const files &#x3D; await fs.readdir(templatesDir);
    const yamlFiles &#x3D; files.filter((f) &#x3D;&amp;gt; f.endsWith(&amp;quot;.yaml&amp;quot;));

    const templates: TemplateMetadata[] &#x3D; [];
    for (const file of yamlFiles) {
      const templateName &#x3D; path.basename(file, &amp;quot;.yaml&amp;quot;);
      const metadata &#x3D; await loadTemplateMetadata(templateName);
      if (metadata) {
        templates.push(metadata);
      }
    }

    return templates.sort((a, b) &#x3D;&amp;gt; a.name.localeCompare(b.name));
  } catch (error) {
    console.error(
      chalk.red(&amp;quot;Error loading templates:&amp;quot;),
      error instanceof Error ? error.message : String(error),
    );
    return [];
  }
}

/**
 * List available templates
 */
export async function listTemplates(): Promise&amp;lt;void&amp;gt; {
  const templates &#x3D; await getAvailableTemplates();

  if (templates.length &#x3D;&#x3D;&#x3D; 0) {
    console.log(chalk.yellow(&amp;quot;No templates available&amp;quot;));
    return;
  }

  console.log(chalk.cyan(&amp;quot;Available Templates:&amp;quot;));
  console.log();

  // Group by category
  const categories &#x3D; new Map&amp;lt;string, TemplateMetadata[]&amp;gt;();
  for (const template of templates) {
    if (!categories.has(template.category)) {
      categories.set(template.category, []);
    }
    categories.get(template.category)?.push(template);
  }

  for (const [category, categoryTemplates] of categories.entries()) {
    console.log(chalk.bold(chalk.blue(&#x60;${category.replace(/_/g, &amp;quot; &amp;quot;).toUpperCase()}:&#x60;)));

    for (const template of categoryTemplates) {
      console.log(chalk.green(&#x60;  ${template.name}&#x60;) + chalk.dim(&#x60; (v${template.version})&#x60;));
      console.log(chalk.dim(&#x60;    ${template.description}&#x60;));

      if (template.tags &amp;amp;&amp;amp; template.tags.length &amp;gt; 0) {
        console.log(chalk.dim(&#x60;    Tags: ${template.tags.join(&amp;quot;, &amp;quot;)}&#x60;));
      }
      console.log();
    }
  }

  console.log(chalk.dim(&amp;quot;Use &#x60;arbiter template add &amp;lt;name&amp;gt;&#x60; to insert a template&amp;quot;));
  console.log(chalk.dim(&amp;quot;Use &#x60;arbiter template show &amp;lt;name&amp;gt;&#x60; to view template details&amp;quot;));
}

/**
 * Display template header information
 */
function displayTemplateHeader(metadata: any): void {
  console.log(chalk.cyan(&#x60;Template: ${metadata.name}&#x60;));
  console.log(chalk.dim(&#x60;Version: ${metadata.version} | Author: ${metadata.author}&#x60;));
  console.log();
}

/**
 * Display template description and category
 */
function displayTemplateInfo(metadata: any): void {
  console.log(chalk.bold(&amp;quot;Description:&amp;quot;));
  console.log(metadata.description);
  console.log();

  console.log(chalk.bold(&amp;quot;Category:&amp;quot;), metadata.category);
  if (metadata.tags &amp;amp;&amp;amp; metadata.tags.length &amp;gt; 0) {
    console.log(chalk.bold(&amp;quot;Tags:&amp;quot;), metadata.tags.join(&amp;quot;, &amp;quot;));
  }
  console.log();
}

/**
 * Display template usage if available
 */
function displayTemplateUsage(metadata: any): void {
  if (metadata.usage) {
    console.log(chalk.bold(&amp;quot;Usage:&amp;quot;));
    console.log(metadata.usage);
    console.log();
  }
}

/**
 * Display template parameters
 */
function displayTemplateParameters(metadata: any): void {
  if (metadata.parameters &amp;amp;&amp;amp; metadata.parameters.length &amp;gt; 0) {
    console.log(chalk.bold(&amp;quot;Parameters:&amp;quot;));
    for (const param of metadata.parameters) {
      console.log(&#x60;  ${chalk.green(param.name)} (${param.type}): ${param.description}&#x60;);
      if (param.default !&#x3D;&#x3D; undefined) {
        console.log(chalk.dim(&#x60;    Default: ${JSON.stringify(param.default)}&#x60;));
      }
    }
    console.log();
  }
}

/**
 * Display template examples
 */
function displayTemplateExamples(metadata: any): void {
  if (metadata.examples &amp;amp;&amp;amp; metadata.examples.length &amp;gt; 0) {
    console.log(chalk.bold(&amp;quot;Examples:&amp;quot;));
    for (const example of metadata.examples) {
      console.log(&#x60;  ${chalk.blue(&amp;quot;â€¢&amp;quot;)} ${example.description}&#x60;);
      if (example.values) {
        for (const [key, value] of Object.entries(example.values)) {
          console.log(&#x60;    ${key}: ${JSON.stringify(value)}&#x60;);
        }
      }
      console.log();
    }
  }
}

/**
 * Show template details
 */
export async function showTemplate(templateName: string): Promise&amp;lt;number&amp;gt; {
  const metadata &#x3D; await loadTemplateMetadata(templateName);
  if (!metadata) {
    console.error(chalk.red(&#x60;Template &amp;#39;${templateName}&amp;#39; not found&#x60;));
    return 1;
  }

  displayTemplateHeader(metadata);
  displayTemplateInfo(metadata);
  displayTemplateUsage(metadata);
  displayTemplateParameters(metadata);
  displayTemplateExamples(metadata);

  return 0;
}

/**
 * Add/insert template to current directory or specified file
 */
export async function addTemplate(templateName: string, options: TemplateOptions): Promise&amp;lt;number&amp;gt; {
  // Load template metadata and content
  const metadata &#x3D; await loadTemplateMetadata(templateName);
  const content &#x3D; await loadTemplateContent(templateName);

  if (!metadata || !content) {
    console.error(chalk.red(&#x60;Template &amp;#39;${templateName}&amp;#39; not found&#x60;));
    console.log(chalk.dim(&amp;quot;Use &#x60;arbiter template list&#x60; to see available templates&amp;quot;));
    return 1;
  }

  // Determine output file
  let outputPath: string;
  if (options.output) {
    outputPath &#x3D; options.output;
  } else {
    // Default to current directory with template name
    outputPath &#x3D; &#x60;${templateName}_constraint.cue&#x60;;
  }

  try {
    // Check if file exists
    try {
      await fs.access(outputPath);
      console.error(chalk.red(&#x60;File &amp;#39;${outputPath}&amp;#39; already exists&#x60;));
      console.log(
        chalk.dim(&amp;quot;Use --output to specify a different file, or remove the existing file&amp;quot;),
      );
      return 1;
    } catch {
      // File doesn&amp;#39;t exist, which is what we want
    }

    // Write template content to file
    await fs.writeFile(outputPath, content, &amp;quot;utf-8&amp;quot;);

    console.log(chalk.green(&#x60;âœ“ Template &amp;#39;${templateName}&amp;#39; added to &amp;#39;${outputPath}&amp;#39;&#x60;));
    console.log();

    console.log(chalk.bold(&amp;quot;Next steps:&amp;quot;));
    console.log(&#x60;1. Review and customize the template in ${chalk.blue(outputPath)}&#x60;);
    if (metadata.parameters &amp;amp;&amp;amp; metadata.parameters.length &amp;gt; 0) {
      console.log(&amp;quot;2. Adjust the following parameters for your use case:&amp;quot;);
      for (const param of metadata.parameters) {
        console.log(&#x60;   - ${chalk.green(param.name)}: ${param.description}&#x60;);
      }
    }
    console.log(&#x60;3. Validate your configuration with ${chalk.cyan(&amp;quot;arbiter validate&amp;quot;)}&#x60;);

    if (metadata.examples &amp;amp;&amp;amp; metadata.examples.length &amp;gt; 0) {
      console.log();
      console.log(
        chalk.dim(&amp;quot;Tip: Check the examples section in the template file for common configurations&amp;quot;),
      );
    }

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;quot;Error writing template:&amp;quot;),
      error instanceof Error ? error.message : String(error),
    );
    return 1;
  }
}

/**
 * Main template command handler
 */
export async function templateCommand(
  action: string,
  templateName?: string,
  options: TemplateOptions &#x3D; {},
): Promise&amp;lt;number&amp;gt; {
  switch (action) {
    case &amp;quot;list&amp;quot;:
      await listTemplates();
      return 0;

    case &amp;quot;show&amp;quot;:
      if (!templateName) {
        console.error(chalk.red(&amp;quot;Template name is required for show command&amp;quot;));
        return 1;
      }
      return await showTemplate(templateName);

    case &amp;quot;add&amp;quot;:
      if (!templateName) {
        console.error(chalk.red(&amp;quot;Template name is required for add command&amp;quot;));
        return 1;
      }
      return await addTemplate(templateName, options);

    default:
      console.error(chalk.red(&#x60;Unknown template action: ${action}&#x60;));
      console.log(chalk.dim(&amp;quot;Available actions: list, show, add&amp;quot;));
      return 1;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-38">
                <div class="file-header">ğŸ“„ apps/api/src/handlers/api.ts</div>
                <div class="file-content">
                    <pre>/**
 * API endpoints for custom webhook handlers management
 */

import type { CustomHandlerManager } from &amp;#39;./manager.js&amp;#39;;
import type {
  HandlerCreationOptions,
  HandlerExecution,
  HandlerResult,
  RegisteredHandler,
} from &amp;#39;./types.js&amp;#39;;

// Request/Response types for API endpoints
export interface ListHandlersRequest {
  provider?: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;;
  event?: string;
  enabled?: boolean;
}

export interface ListHandlersResponse {
  success: boolean;
  handlers: RegisteredHandler[];
  total: number;
}

export interface GetHandlerRequest {
  id: string;
}

export interface GetHandlerResponse {
  success: boolean;
  handler?: RegisteredHandler;
  message?: string;
}

export interface UpdateHandlerRequest {
  id: string;
  updates: Partial&amp;lt;RegisteredHandler&amp;gt;;
}

export interface UpdateHandlerResponse {
  success: boolean;
  handler?: RegisteredHandler;
  message: string;
}

export interface ToggleHandlerRequest {
  id: string;
  enabled: boolean;
}

export interface ToggleHandlerResponse {
  success: boolean;
  message: string;
}

export interface ValidateHandlerRequest {
  filePath: string;
}

export interface ValidateHandlerResponse {
  success: boolean;
  valid: boolean;
  errors: string[];
  warnings: string[];
}

export type CreateHandlerRequest &#x3D; HandlerCreationOptions;

export interface CreateHandlerResponse {
  success: boolean;
  handler?: RegisteredHandler;
  message: string;
}

export interface ExecutionHistoryRequest {
  handlerId?: string;
  projectId?: string;
  provider?: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;;
  event?: string;
  limit?: number;
  offset?: number;
}

export interface ExecutionHistoryResponse {
  success: boolean;
  executions: HandlerExecution[];
  total: number;
  hasMore: boolean;
}

export interface HandlerStatsResponse {
  success: boolean;
  stats: {
    totalHandlers: number;
    enabledHandlers: number;
    activeExecutions: number;
    totalExecutions: number;
    failedExecutions: number;
    executionsLast24h: number;
    avgExecutionTime: number;
    errorRate: number;
  };
}

/**
 * Handler API Controller
 */
export class HandlerAPIController {
  constructor(private handlerManager: CustomHandlerManager) {}

  /**
   * GET /api/handlers
   * List all registered handlers with optional filtering
   */
  async listHandlers(request: ListHandlersRequest): Promise&amp;lt;ListHandlersResponse&amp;gt; {
    try {
      let handlers &#x3D; this.handlerManager.getHandlers();

      // Apply filters
      if (request.provider) {
        handlers &#x3D; handlers.filter(h &#x3D;&amp;gt; h.provider &#x3D;&#x3D;&#x3D; request.provider);
      }

      if (request.event) {
        handlers &#x3D; handlers.filter(h &#x3D;&amp;gt; h.event &#x3D;&#x3D;&#x3D; request.event);
      }

      if (request.enabled !&#x3D;&#x3D; undefined) {
        handlers &#x3D; handlers.filter(h &#x3D;&amp;gt; h.enabled &#x3D;&#x3D;&#x3D; request.enabled);
      }

      return {
        success: true,
        handlers,
        total: handlers.length,
      };
    } catch (error) {
      return {
        success: false,
        handlers: [],
        total: 0,
      };
    }
  }

  /**
   * GET /api/handlers/:id
   * Get a specific handler by ID
   */
  async getHandler(request: GetHandlerRequest): Promise&amp;lt;GetHandlerResponse&amp;gt; {
    try {
      const handler &#x3D; this.handlerManager.getHandler(request.id);

      if (!handler) {
        return {
          success: false,
          message: &amp;#39;Handler not found&amp;#39;,
        };
      }

      return {
        success: true,
        handler,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
      };
    }
  }

  /**
   * PUT /api/handlers/:id
   * Update handler configuration
   */
  async updateHandler(request: UpdateHandlerRequest): Promise&amp;lt;UpdateHandlerResponse&amp;gt; {
    try {
      const success &#x3D; this.handlerManager.updateHandlerConfig(request.id, request.updates);

      if (!success) {
        return {
          success: false,
          message: &amp;#39;Handler not found or update failed&amp;#39;,
        };
      }

      const handler &#x3D; this.handlerManager.getHandler(request.id);
      return {
        success: true,
        handler,
        message: &amp;#39;Handler updated successfully&amp;#39;,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
      };
    }
  }

  /**
   * POST /api/handlers/:id/toggle
   * Enable or disable a handler
   */
  async toggleHandler(request: ToggleHandlerRequest): Promise&amp;lt;ToggleHandlerResponse&amp;gt; {
    try {
      const success &#x3D; this.handlerManager.setHandlerEnabled(request.id, request.enabled);

      if (!success) {
        return {
          success: false,
          message: &amp;#39;Handler not found&amp;#39;,
        };
      }

      return {
        success: true,
        message: &#x60;Handler ${request.enabled ? &amp;#39;enabled&amp;#39; : &amp;#39;disabled&amp;#39;} successfully&#x60;,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
      };
    }
  }

  /**
   * DELETE /api/handlers/:id
   * Remove a handler
   */
  async removeHandler(request: GetHandlerRequest): Promise&amp;lt;UpdateHandlerResponse&amp;gt; {
    try {
      const success &#x3D; this.handlerManager.removeHandler(request.id);

      return {
        success,
        message: success ? &amp;#39;Handler removed successfully&amp;#39; : &amp;#39;Handler not found&amp;#39;,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
      };
    }
  }

  /**
   * POST /api/handlers/:id/reload
   * Reload a handler from file
   */
  async reloadHandler(request: GetHandlerRequest): Promise&amp;lt;UpdateHandlerResponse&amp;gt; {
    try {
      const success &#x3D; await this.handlerManager.reloadHandler(request.id);

      return {
        success,
        message: success ? &amp;#39;Handler reloaded successfully&amp;#39; : &amp;#39;Handler not found or reload failed&amp;#39;,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
      };
    }
  }

  /**
   * POST /api/handlers/validate
   * Validate handler code
   */
  async validateHandler(request: ValidateHandlerRequest): Promise&amp;lt;ValidateHandlerResponse&amp;gt; {
    try {
      const validation &#x3D; await this.handlerManager.validateHandler(request.filePath);

      return {
        success: true,
        valid: validation.valid,
        errors: validation.errors,
        warnings: validation.warnings,
      };
    } catch (error) {
      return {
        success: false,
        valid: false,
        errors: [error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;],
        warnings: [],
      };
    }
  }

  /**
   * POST /api/handlers
   * Create a new handler
  */
  async createHandler(request: CreateHandlerRequest): Promise&amp;lt;CreateHandlerResponse&amp;gt; {
    try {
      const handler &#x3D; await this.handlerManager.createHandler(request);

      return {
        success: true,
        handler,
        message: &amp;#39;Handler created successfully&amp;#39;,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
      };
    }
  }

  /**
   * GET /api/handlers/executions
   * Get handler execution history
   */
  async getExecutionHistory(request: ExecutionHistoryRequest): Promise&amp;lt;ExecutionHistoryResponse&amp;gt; {
    try {
      let executions &#x3D; this.handlerManager.getExecutionHistory(request.limit || 100);

      // Apply filters
      if (request.handlerId) {
        executions &#x3D; executions.filter(e &#x3D;&amp;gt; e.handlerId &#x3D;&#x3D;&#x3D; request.handlerId);
      }

      if (request.projectId) {
        executions &#x3D; executions.filter(e &#x3D;&amp;gt; e.projectId &#x3D;&#x3D;&#x3D; request.projectId);
      }

      if (request.provider) {
        executions &#x3D; executions.filter(e &#x3D;&amp;gt; e.provider &#x3D;&#x3D;&#x3D; request.provider);
      }

      if (request.event) {
        executions &#x3D; executions.filter(e &#x3D;&amp;gt; e.event &#x3D;&#x3D;&#x3D; request.event);
      }

      // Apply pagination
      const offset &#x3D; request.offset || 0;
      const limit &#x3D; request.limit || 100;
      const paginatedExecutions &#x3D; executions.slice(offset, offset + limit);

      return {
        success: true,
        executions: paginatedExecutions,
        total: executions.length,
        hasMore: offset + limit &amp;lt; executions.length,
      };
    } catch (error) {
      return {
        success: false,
        executions: [],
        total: 0,
        hasMore: false,
      };
    }
  }

  /**
   * GET /api/handlers/stats
   * Get handler system statistics
   */
  async getHandlerStats(): Promise&amp;lt;HandlerStatsResponse&amp;gt; {
    try {
      const stats &#x3D; this.handlerManager.getHandlerStats();
      const executions &#x3D; this.handlerManager.getExecutionHistory();

      // Calculate additional statistics
      const now &#x3D; Date.now();
      const oneDayAgo &#x3D; now - 24 * 60 * 60 * 1000;

      const executionsLast24h &#x3D; executions.filter(
        e &#x3D;&amp;gt; new Date(e.startedAt).getTime() &amp;gt; oneDayAgo
      ).length;

      const completedExecutions &#x3D; executions.filter(e &#x3D;&amp;gt; e.result.duration);
      const avgExecutionTime &#x3D;
        completedExecutions.length &amp;gt; 0
          ? completedExecutions.reduce((sum, e) &#x3D;&amp;gt; sum + (e.result.duration || 0), 0) /
            completedExecutions.length
          : 0;

      const errorRate &#x3D;
        stats.totalExecutions &amp;gt; 0 ? (stats.failedExecutions / stats.totalExecutions) * 100 : 0;

      return {
        success: true,
        stats: {
          ...stats,
          executionsLast24h,
          avgExecutionTime: Math.round(avgExecutionTime),
          errorRate: Math.round(errorRate * 100) / 100,
        },
      };
    } catch (error) {
      return {
        success: false,
        stats: {
          totalHandlers: 0,
          enabledHandlers: 0,
          activeExecutions: 0,
          totalExecutions: 0,
          failedExecutions: 0,
          executionsLast24h: 0,
          avgExecutionTime: 0,
          errorRate: 0,
        },
      };
    }
  }

  /**
   * POST /api/handlers/init
   * Initialize handler directory structure
   */
  async initializeHandlerStructure(): Promise&amp;lt;{ success: boolean; message: string }&amp;gt; {
    try {
      await this.handlerManager.createHandlerStructure();
      return {
        success: true,
        message: &amp;#39;Handler directory structure created successfully&amp;#39;,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
      };
    }
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-39">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/import.ts</div>
                <div class="file-content">
                    <pre>import fs from &amp;#39;node:fs/promises&amp;#39;;
import os from &amp;#39;node:os&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;

export interface ImportOptions {
  global?: boolean;
  list?: boolean;
  remove?: boolean;
  validate?: boolean;
  allow?: string[];
}

export interface ImportRegistry {
  version: string;
  last_updated: string;
  allowed_imports: {
    [pattern: string]: {
      description?: string;
      added_date: string;
      added_by: string;
      versions?: string[];
      security_reviewed?: boolean;
    };
  };
  blocked_imports: {
    [pattern: string]: {
      reason: string;
      blocked_date: string;
      blocked_by: string;
    };
  };
}

/**
 * Get import registry file path
 */
function getRegistryPath(global &#x3D; false): string {
  if (global) {
    return path.join(os.homedir(), &amp;#39;.arbiter&amp;#39;, &amp;#39;imports.json&amp;#39;);
  }
  return path.join(process.cwd(), &amp;#39;.arbiter&amp;#39;, &amp;#39;imports.json&amp;#39;);
}

/**
 * Get registry directory path
 */
function getRegistryDir(global &#x3D; false): string {
  return path.dirname(getRegistryPath(global));
}

/**
 * Load import registry
 */
async function loadImportRegistry(global &#x3D; false): Promise&amp;lt;ImportRegistry&amp;gt; {
  const registryPath &#x3D; getRegistryPath(global);

  try {
    const content &#x3D; await fs.readFile(registryPath, &amp;#39;utf-8&amp;#39;);
    return JSON.parse(content) as ImportRegistry;
  } catch (_error) {
    // Return default registry if file doesn&amp;#39;t exist
    return {
      version: &amp;#39;1.0.0&amp;#39;,
      last_updated: new Date().toISOString(),
      allowed_imports: {},
      blocked_imports: {},
    };
  }
}

/**
 * Save import registry
 */
async function saveImportRegistry(registry: ImportRegistry, global &#x3D; false): Promise&amp;lt;void&amp;gt; {
  const registryPath &#x3D; getRegistryPath(global);
  const registryDir &#x3D; getRegistryDir(global);

  // Ensure directory exists
  await fs.mkdir(registryDir, { recursive: true });

  // Update timestamp
  registry.last_updated &#x3D; new Date().toISOString();

  // Save registry
  await fs.writeFile(registryPath, JSON.stringify(registry, null, 2), &amp;#39;utf-8&amp;#39;);
}

/**
 * Check if import pattern matches any allowed pattern
 */
function isImportAllowed(importPath: string, registry: ImportRegistry): boolean {
  // Check blocked imports first
  for (const blockedPattern of Object.keys(registry.blocked_imports)) {
    if (matchesPattern(importPath, blockedPattern)) {
      return false;
    }
  }

  // Check allowed imports
  for (const allowedPattern of Object.keys(registry.allowed_imports)) {
    if (matchesPattern(importPath, allowedPattern)) {
      return true;
    }
  }

  return false;
}

/**
 * Check if import path matches a pattern (supports wildcards)
 */
function matchesPattern(importPath: string, pattern: string): boolean {
  // Convert pattern to regex
  const regexPattern &#x3D; pattern.replace(/\*/g, &amp;#39;.*&amp;#39;).replace(/\?/g, &amp;#39;.&amp;#39;).replace(/\./g, &amp;#39;\\.&amp;#39;);

  const regex &#x3D; new RegExp(&#x60;^${regexPattern}$&#x60;);
  return regex.test(importPath);
}

/**
 * Parse import pattern with optional version
 */
function parseImportPattern(pattern: string): { name: string; version?: string } {
  const atIndex &#x3D; pattern.lastIndexOf(&amp;#39;@&amp;#39;);
  if (atIndex &amp;gt; 0 &amp;amp;&amp;amp; pattern.substring(0, atIndex).includes(&amp;#39;/&amp;#39;)) {
    // Pattern like @org/pkg@version
    return {
      name: pattern.substring(0, atIndex),
      version: pattern.substring(atIndex + 1),
    };
  }
  // Pattern without version
  return { name: pattern };
}

/**
 * List allowed imports
 */
export async function listImports(options: ImportOptions &#x3D; {}): Promise&amp;lt;number&amp;gt; {
  try {
    const registry &#x3D; await loadImportRegistry(options.global);

    console.log(chalk.cyan(&amp;#39;Import Registry&amp;#39;));
    console.log(chalk.dim(&#x60;Location: ${getRegistryPath(options.global)}&#x60;));
    console.log(chalk.dim(&#x60;Last updated: ${registry.last_updated}&#x60;));
    console.log();

    // Show allowed imports
    const allowedCount &#x3D; Object.keys(registry.allowed_imports).length;
    if (allowedCount &amp;gt; 0) {
      console.log(chalk.green(&#x60;âœ“ Allowed Imports (${allowedCount}):&#x60;));
      for (const [pattern, info] of Object.entries(registry.allowed_imports)) {
        console.log(&#x60;  ${chalk.green(pattern)}&#x60;);
        if (info.description) {
          console.log(chalk.dim(&#x60;    ${info.description}&#x60;));
        }
        if (info.versions &amp;amp;&amp;amp; info.versions.length &amp;gt; 0) {
          console.log(chalk.dim(&#x60;    Versions: ${info.versions.join(&amp;#39;, &amp;#39;)}&#x60;));
        }
        console.log(chalk.dim(&#x60;    Added: ${info.added_date} by ${info.added_by}&#x60;));
        if (info.security_reviewed) {
          console.log(chalk.dim(&#x60;    ${chalk.green(&amp;#39;âœ“&amp;#39;)} Security reviewed&#x60;));
        }
        console.log();
      }
    } else {
      console.log(chalk.yellow(&amp;#39;No allowed imports configured&amp;#39;));
      console.log(chalk.dim(&amp;#39;Use &#x60;arbiter import add &amp;lt;pattern&amp;gt;&#x60; to allow imports&amp;#39;));
    }

    // Show blocked imports
    const blockedCount &#x3D; Object.keys(registry.blocked_imports).length;
    if (blockedCount &amp;gt; 0) {
      console.log();
      console.log(chalk.red(&#x60;âœ— Blocked Imports (${blockedCount}):&#x60;));
      for (const [pattern, info] of Object.entries(registry.blocked_imports)) {
        console.log(&#x60;  ${chalk.red(pattern)}&#x60;);
        console.log(chalk.dim(&#x60;    Reason: ${info.reason}&#x60;));
        console.log(chalk.dim(&#x60;    Blocked: ${info.blocked_date} by ${info.blocked_by}&#x60;));
        console.log();
      }
    }

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Error listing imports:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Add allowed import
 */
export async function addImport(pattern: string, options: ImportOptions &#x3D; {}): Promise&amp;lt;number&amp;gt; {
  try {
    const registry &#x3D; await loadImportRegistry(options.global);
    const parsed &#x3D; parseImportPattern(pattern);
    const currentUser &#x3D; process.env.USER || process.env.USERNAME || &amp;#39;unknown&amp;#39;;

    // Check if already in blocked list
    if (registry.blocked_imports[parsed.name]) {
      console.error(
        chalk.red(
          &#x60;Import &amp;#39;${parsed.name}&amp;#39; is blocked: ${registry.blocked_imports[parsed.name].reason}&#x60;
        )
      );
      return 1;
    }

    // Add or update allowed import
    if (!registry.allowed_imports[parsed.name]) {
      registry.allowed_imports[parsed.name] &#x3D; {
        added_date: new Date().toISOString(),
        added_by: currentUser,
        versions: [],
      };
    }

    const importInfo &#x3D; registry.allowed_imports[parsed.name];

    // Add version if specified
    if (parsed.version &amp;amp;&amp;amp; !importInfo.versions?.includes(parsed.version)) {
      importInfo.versions &#x3D; importInfo.versions || [];
      importInfo.versions.push(parsed.version);
      importInfo.versions.sort();
    }

    // Save registry
    await saveImportRegistry(registry, options.global);

    console.log(chalk.green(&#x60;âœ“ Added allowed import: ${pattern}&#x60;));
    console.log(chalk.dim(&#x60;Registry: ${getRegistryPath(options.global)}&#x60;));

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Error adding import:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Remove allowed import
 */
export async function removeImport(pattern: string, options: ImportOptions &#x3D; {}): Promise&amp;lt;number&amp;gt; {
  try {
    const registry &#x3D; await loadImportRegistry(options.global);
    const parsed &#x3D; parseImportPattern(pattern);

    if (!registry.allowed_imports[parsed.name]) {
      console.error(chalk.yellow(&#x60;Import &amp;#39;${parsed.name}&amp;#39; is not in the allowed list&#x60;));
      return 1;
    }

    delete registry.allowed_imports[parsed.name];

    // Save registry
    await saveImportRegistry(registry, options.global);

    console.log(chalk.green(&#x60;âœ“ Removed allowed import: ${parsed.name}&#x60;));

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Error removing import:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Block an import pattern
 */
export async function blockImport(
  pattern: string,
  reason: string,
  options: ImportOptions &#x3D; {}
): Promise&amp;lt;number&amp;gt; {
  try {
    const registry &#x3D; await loadImportRegistry(options.global);
    const parsed &#x3D; parseImportPattern(pattern);
    const currentUser &#x3D; process.env.USER || process.env.USERNAME || &amp;#39;unknown&amp;#39;;

    // Remove from allowed list if present
    if (registry.allowed_imports[parsed.name]) {
      delete registry.allowed_imports[parsed.name];
    }

    // Add to blocked list
    registry.blocked_imports[parsed.name] &#x3D; {
      reason,
      blocked_date: new Date().toISOString(),
      blocked_by: currentUser,
    };

    // Save registry
    await saveImportRegistry(registry, options.global);

    console.log(chalk.red(&#x60;âœ— Blocked import: ${parsed.name}&#x60;));
    console.log(chalk.dim(&#x60;Reason: ${reason}&#x60;));

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Error blocking import:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Validate imports in CUE files
 */
export async function validateImports(
  files: string[],
  options: ImportOptions &#x3D; {}
): Promise&amp;lt;number&amp;gt; {
  try {
    const registry &#x3D; await loadImportRegistry(options.global);
    let hasErrors &#x3D; false;

    console.log(chalk.cyan(&amp;#39;Validating imports against registry...&amp;#39;));
    console.log(chalk.dim(&#x60;Registry: ${getRegistryPath(options.global)}&#x60;));
    console.log();

    for (const file of files) {
      try {
        const content &#x3D; await fs.readFile(file, &amp;#39;utf-8&amp;#39;);
        const imports &#x3D; extractImportsFromCue(content);

        console.log(chalk.bold(&#x60;${file}:&#x60;));

        if (imports.length &#x3D;&#x3D;&#x3D; 0) {
          console.log(chalk.dim(&amp;#39;  No imports found&amp;#39;));
          continue;
        }

        for (const importPath of imports) {
          const isAllowed &#x3D; isImportAllowed(importPath, registry);

          if (isAllowed) {
            console.log(&#x60;  ${chalk.green(&amp;#39;âœ“&amp;#39;)} ${importPath}&#x60;);
          } else {
            console.log(&#x60;  ${chalk.red(&amp;#39;âœ—&amp;#39;)} ${importPath} ${chalk.dim(&amp;#39;(not allowed)&amp;#39;)}&#x60;);
            hasErrors &#x3D; true;
          }
        }

        console.log();
      } catch (error) {
        console.error(
          &#x60;  ${chalk.red(&amp;#39;Error reading file:&amp;#39;)} ${error instanceof Error ? error.message : String(error)}&#x60;
        );
        hasErrors &#x3D; true;
      }
    }

    if (hasErrors) {
      console.log(chalk.red(&amp;#39;Import validation failed&amp;#39;));
      console.log(chalk.dim(&amp;#39;Use &#x60;arbiter import add &amp;lt;pattern&amp;gt;&#x60; to allow imports&amp;#39;));
      return 1;
    }
    console.log(chalk.green(&amp;#39;âœ“ All imports are allowed&amp;#39;));
    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Error validating imports:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Extract import statements from CUE content
 */
function extractImportsFromCue(content: string): string[] {
  const imports: string[] &#x3D; [];
  const lines &#x3D; content.split(&amp;#39;\n&amp;#39;);

  for (const line of lines) {
    const trimmed &#x3D; line.trim();

    // Match: import &amp;quot;package&amp;quot;
    const singleImport &#x3D; trimmed.match(/^import\s+&amp;quot;([^&amp;quot;]+)&amp;quot;$/);
    if (singleImport) {
      imports.push(singleImport[1]);
      continue;
    }

    // Match: import alias &amp;quot;package&amp;quot;
    const aliasImport &#x3D; trimmed.match(/^import\s+\w+\s+&amp;quot;([^&amp;quot;]+)&amp;quot;$/);
    if (aliasImport) {
      imports.push(aliasImport[1]);
      continue;
    }

    // Match imports in multi-line import blocks
    if (trimmed.startsWith(&amp;#39;&amp;quot;&amp;#39;) &amp;amp;&amp;amp; trimmed.endsWith(&amp;#39;&amp;quot;&amp;#39;)) {
      const importPath &#x3D; trimmed.slice(1, -1);
      if (importPath &amp;amp;&amp;amp; !importPath.includes(&amp;#39; &amp;#39;)) {
        imports.push(importPath);
      }
    }
  }

  return [...new Set(imports)]; // Remove duplicates
}

/**
 * Initialize default import registry with common safe patterns
 */
export async function initImportRegistry(options: ImportOptions &#x3D; {}): Promise&amp;lt;number&amp;gt; {
  try {
    const registryPath &#x3D; getRegistryPath(options.global);

    // Check if registry already exists
    try {
      await fs.access(registryPath);
      console.log(chalk.yellow(&#x60;Import registry already exists at ${registryPath}&#x60;));
      console.log(chalk.dim(&amp;#39;Use --force to overwrite&amp;#39;));
      return 1;
    } catch {
      // Registry doesn&amp;#39;t exist, proceed with creation
    }

    const currentUser &#x3D; process.env.USER || process.env.USERNAME || &amp;#39;system&amp;#39;;
    const defaultRegistry: ImportRegistry &#x3D; {
      version: &amp;#39;1.0.0&amp;#39;,
      last_updated: new Date().toISOString(),
      allowed_imports: {
        strings: {
          description: &amp;#39;CUE standard library - string manipulation&amp;#39;,
          added_date: new Date().toISOString(),
          added_by: currentUser,
          security_reviewed: true,
        },
        list: {
          description: &amp;#39;CUE standard library - list operations&amp;#39;,
          added_date: new Date().toISOString(),
          added_by: currentUser,
          security_reviewed: true,
        },
        math: {
          description: &amp;#39;CUE standard library - mathematical operations&amp;#39;,
          added_date: new Date().toISOString(),
          added_by: currentUser,
          security_reviewed: true,
        },
        &amp;#39;encoding/json&amp;#39;: {
          description: &amp;#39;CUE standard library - JSON encoding/decoding&amp;#39;,
          added_date: new Date().toISOString(),
          added_by: currentUser,
          security_reviewed: true,
        },
        &amp;#39;encoding/yaml&amp;#39;: {
          description: &amp;#39;CUE standard library - YAML encoding/decoding&amp;#39;,
          added_date: new Date().toISOString(),
          added_by: currentUser,
          security_reviewed: true,
        },
        time: {
          description: &amp;#39;CUE standard library - time and date operations&amp;#39;,
          added_date: new Date().toISOString(),
          added_by: currentUser,
          security_reviewed: true,
        },
        &amp;#39;@valhalla/*&amp;#39;: {
          description: &amp;#39;Valhalla project imports - trusted internal organization&amp;#39;,
          added_date: new Date().toISOString(),
          added_by: currentUser,
          security_reviewed: true,
        },
      },
      blocked_imports: {
        &amp;#39;unsafe/*&amp;#39;: {
          reason: &amp;#39;Potentially unsafe operations&amp;#39;,
          blocked_date: new Date().toISOString(),
          blocked_by: currentUser,
        },
      },
    };

    await saveImportRegistry(defaultRegistry, options.global);

    console.log(chalk.green(&amp;#39;âœ“ Import registry initialized&amp;#39;));
    console.log(chalk.dim(&#x60;Location: ${registryPath}&#x60;));
    console.log();
    console.log(chalk.bold(&amp;#39;Default allowed imports:&amp;#39;));
    for (const pattern of Object.keys(defaultRegistry.allowed_imports)) {
      console.log(&#x60;  ${chalk.green(&amp;#39;âœ“&amp;#39;)} ${pattern}&#x60;);
    }
    console.log();
    console.log(chalk.bold(&amp;#39;Default blocked imports:&amp;#39;));
    for (const pattern of Object.keys(defaultRegistry.blocked_imports)) {
      console.log(&#x60;  ${chalk.red(&amp;#39;âœ—&amp;#39;)} ${pattern}&#x60;);
    }

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Error initializing import registry:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Main import command handler
 */
export async function importCommand(
  action: string,
  pattern?: string,
  options: ImportOptions &#x3D; {}
): Promise&amp;lt;number&amp;gt; {
  switch (action) {
    case &amp;#39;init&amp;#39;:
      return await initImportRegistry(options);

    case &amp;#39;list&amp;#39;:
      return await listImports(options);

    case &amp;#39;add&amp;#39;:
      if (!pattern) {
        console.error(chalk.red(&amp;#39;Import pattern is required for add command&amp;#39;));
        return 1;
      }
      return await addImport(pattern, options);

    case &amp;#39;remove&amp;#39;:
      if (!pattern) {
        console.error(chalk.red(&amp;#39;Import pattern is required for remove command&amp;#39;));
        return 1;
      }
      return await removeImport(pattern, options);

    case &amp;#39;block&amp;#39;: {
      if (!pattern) {
        console.error(chalk.red(&amp;#39;Import pattern is required for block command&amp;#39;));
        return 1;
      }
      const reason &#x3D; options.allow?.[0] || &amp;#39;Security policy violation&amp;#39;;
      return await blockImport(pattern, reason, options);
    }

    case &amp;#39;validate&amp;#39;:
      if (!options.allow || options.allow.length &#x3D;&#x3D;&#x3D; 0) {
        console.error(chalk.red(&amp;#39;File patterns are required for validate command&amp;#39;));
        return 1;
      }
      return await validateImports(options.allow, options);

    default:
      console.error(chalk.red(&#x60;Unknown import action: ${action}&#x60;));
      console.log(chalk.dim(&amp;#39;Available actions: init, list, add, remove, block, validate&amp;#39;));
      return 1;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-40">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/types/architecture.ts</div>
                <div class="file-content">
                    <pre>/**
 * Architecture diagram types for CUE-driven diagram generation
 */

// Base architectural elements that can be extracted from CUE
export interface ArchitecturalElement {
  id: string;
  name: string;
  type: ElementType;
  description?: string;
  metadata?: Record&amp;lt;string, any&amp;gt;;
}

export type ElementType &#x3D;
  | &amp;#39;service&amp;#39;
  | &amp;#39;component&amp;#39;
  | &amp;#39;route&amp;#39;
  | &amp;#39;flow&amp;#39;
  | &amp;#39;capability&amp;#39;
  | &amp;#39;state_machine&amp;#39;
  | &amp;#39;api_endpoint&amp;#39;
  | &amp;#39;external_system&amp;#39;
  | &amp;#39;data_store&amp;#39;;

// Enhanced component model for diagram rendering
export interface DiagramComponent extends ArchitecturalElement {
  // Visual properties
  position: { x: number; y: number };
  size: { width: number; height: number };
  layer: DiagramLayer;

  // Technical details from CUE
  technology?: string;
  language?: string;
  framework?: string[];

  // Connection points
  ports?: DiagramPort[];

  // From CUE services
  serviceType?: &amp;#39;bespoke&amp;#39; | &amp;#39;prebuilt&amp;#39; | &amp;#39;external&amp;#39;;
  deploymentType?: &amp;#39;deployment&amp;#39; | &amp;#39;statefulset&amp;#39; | &amp;#39;daemonset&amp;#39;;
  replicas?: number;

  // From UI routes
  routePath?: string;
  capabilities?: string[];

  // From flows
  flowSteps?: FlowStep[];

  // From state machines
  states?: Record&amp;lt;string, any&amp;gt;;
  transitions?: Record&amp;lt;string, string&amp;gt;;
}

export interface DiagramPort {
  id: string;
  position: { x: number; y: number };
  type: &amp;#39;input&amp;#39; | &amp;#39;output&amp;#39; | &amp;#39;bidirectional&amp;#39;;
  protocol?: &amp;#39;http&amp;#39; | &amp;#39;websocket&amp;#39; | &amp;#39;grpc&amp;#39; | &amp;#39;database&amp;#39;;
}

export type DiagramLayer &#x3D;
  | &amp;#39;presentation&amp;#39; // UI routes, components
  | &amp;#39;application&amp;#39; // Flows, business logic
  | &amp;#39;service&amp;#39; // Services, APIs
  | &amp;#39;data&amp;#39; // Databases, storage
  | &amp;#39;external&amp;#39;; // External systems

// Connection types derived from CUE relationships
export interface DiagramConnection {
  id: string;
  from: { componentId: string; portId?: string };
  to: { componentId: string; portId?: string };
  type: ConnectionType;
  label?: string;
  metadata?: {
    // From flows
    userAction?: string;
    expectation?: any;

    // From API paths
    method?: string;
    path?: string;

    // From capabilities
    capability?: string;

    // From dependencies
    dependsOn?: string[];
  };
}

export type ConnectionType &#x3D;
  | &amp;#39;user_navigation&amp;#39; // UI route navigation
  | &amp;#39;user_interaction&amp;#39; // Flow steps (click, fill, etc.)
  | &amp;#39;api_call&amp;#39; // HTTP requests to services
  | &amp;#39;capability_usage&amp;#39; // Capability dependencies
  | &amp;#39;state_transition&amp;#39; // State machine transitions
  | &amp;#39;data_flow&amp;#39; // Data passing between components
  | &amp;#39;dependency&amp;#39;; // Service dependencies

// Flow analysis for generating connections
export interface FlowStep {
  id: string;
  type: &amp;#39;visit&amp;#39; | &amp;#39;click&amp;#39; | &amp;#39;fill&amp;#39; | &amp;#39;expect&amp;#39; | &amp;#39;expect_api&amp;#39;;
  target?: string;
  value?: string;
  expectation?: any;
}

// Layout configuration for different diagram types
export interface DiagramLayout {
  type: &amp;#39;layered&amp;#39; | &amp;#39;force_directed&amp;#39; | &amp;#39;hierarchical&amp;#39; | &amp;#39;circular&amp;#39;;
  direction: &amp;#39;top_down&amp;#39; | &amp;#39;left_right&amp;#39; | &amp;#39;bottom_up&amp;#39; | &amp;#39;right_left&amp;#39;;
  spacing: {
    component: { x: number; y: number };
    layer: number;
  };
  layers: DiagramLayer[];
}

// Complete diagram specification
export interface ArchitectureDiagram {
  id: string;
  name: string;
  description?: string;
  type: DiagramType;

  // Generated from CUE
  components: DiagramComponent[];
  connections: DiagramConnection[];

  // Visual configuration
  layout: DiagramLayout;
  viewport: { width: number; height: number };

  // Metadata about generation
  generatedFrom: {
    cuePath: string;
    timestamp: string;
    schemaVersion: &amp;#39;v1&amp;#39; | &amp;#39;v2&amp;#39;;
  };

  // Interactive features
  interactivity?: {
    clickableComponents: boolean;
    hoverDetails: boolean;
    zoomPan: boolean;
    layerToggle: boolean;
  };
}

export type DiagramType &#x3D;
  | &amp;#39;system_overview&amp;#39; // Complete system architecture
  | &amp;#39;service_topology&amp;#39; // Service interconnections
  | &amp;#39;user_journey&amp;#39; // Flow-based user paths
  | &amp;#39;capability_map&amp;#39; // Business capability relationships
  | &amp;#39;state_diagram&amp;#39; // State machine visualization
  | &amp;#39;api_surface&amp;#39;; // API endpoint mapping

// CUE parsing results
export interface CueArchitectureData {
  // v1 schema elements
  services?: Record&amp;lt;string, any&amp;gt;;
  deployment?: any;

  // v2 schema elements
  product?: any;
  ui?: { routes: any[] };
  flows?: any[];
  capabilities?: Record&amp;lt;string, any&amp;gt;;
  paths?: Record&amp;lt;string, any&amp;gt;;
  stateModels?: Record&amp;lt;string, any&amp;gt;;
  locators?: Record&amp;lt;string, string&amp;gt;;

  // Additional metadata
  metadata?: {
    name: string;
    version: string;
    apiVersion: string;
    kind: string;
  };
}

// Layout algorithms
export interface LayoutAlgorithm {
  name: string;
  calculate(
    components: DiagramComponent[],
    connections: DiagramConnection[]
  ): {
    components: DiagramComponent[];
    viewport: { width: number; height: number };
  };
}

// Theming for different diagram types
export interface DiagramTheme {
  name: string;
  layers: Record&amp;lt;
    DiagramLayer,
    {
      background: string;
      border: string;
      text: string;
    }
  &amp;gt;;
  connections: Record&amp;lt;
    ConnectionType,
    {
      color: string;
      width: number;
      style: &amp;#39;solid&amp;#39; | &amp;#39;dashed&amp;#39; | &amp;#39;dotted&amp;#39;;
    }
  &amp;gt;;
  components: {
    defaultSize: { width: number; height: number };
    minSize: { width: number; height: number };
    padding: number;
    borderRadius: number;
  };
}

// Export configuration
export interface DiagramExportOptions {
  format: &amp;#39;svg&amp;#39; | &amp;#39;png&amp;#39; | &amp;#39;pdf&amp;#39; | &amp;#39;mermaid&amp;#39; | &amp;#39;graphviz&amp;#39;;
  quality?: number;
  width?: number;
  height?: number;
  includeMetadata?: boolean;
  embedFonts?: boolean;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-41">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/design-system/tokens.ts</div>
                <div class="file-content">
                    <pre>/**
 * Design System Tokens - Graphite Theme
 * Professional minimal design for developer tools
 */

export const colors &#x3D; {
  // Graphite scale - Primary brand colors
  graphite: {
    50: &amp;quot;#f8fafc&amp;quot;, // Almost white, subtle bg
    100: &amp;quot;#f1f5f9&amp;quot;, // Light bg, panels
    200: &amp;quot;#e2e8f0&amp;quot;, // Subtle borders
    300: &amp;quot;#cbd5e1&amp;quot;, // Light borders, disabled text
    400: &amp;quot;#94a3b8&amp;quot;, // Placeholder text, icons
    500: &amp;quot;#64748b&amp;quot;, // Body text, secondary elements
    600: &amp;quot;#475569&amp;quot;, // Headers, strong text
    700: &amp;quot;#334155&amp;quot;, // Primary text, headings
    800: &amp;quot;#1e293b&amp;quot;, // Dark text, strong emphasis
    900: &amp;quot;#0f172a&amp;quot;, // Darkest, high contrast
  },

  // Semantic colors - Complete scales for professional UI
  semantic: {
    // Success - Emerald scale
    success: {
      50: &amp;quot;#ecfdf5&amp;quot;,
      100: &amp;quot;#d1fae5&amp;quot;,
      200: &amp;quot;#a7f3d0&amp;quot;,
      300: &amp;quot;#6ee7b7&amp;quot;,
      400: &amp;quot;#34d399&amp;quot;,
      500: &amp;quot;#10b981&amp;quot;,
      600: &amp;quot;#059669&amp;quot;,
      700: &amp;quot;#047857&amp;quot;,
      800: &amp;quot;#065f46&amp;quot;,
      900: &amp;quot;#064e3b&amp;quot;,
    },

    // Warning - Amber scale
    warning: {
      50: &amp;quot;#fffbeb&amp;quot;,
      100: &amp;quot;#fef3c7&amp;quot;,
      200: &amp;quot;#fde68a&amp;quot;,
      300: &amp;quot;#fcd34d&amp;quot;,
      400: &amp;quot;#fbbf24&amp;quot;,
      500: &amp;quot;#f59e0b&amp;quot;,
      600: &amp;quot;#d97706&amp;quot;,
      700: &amp;quot;#b45309&amp;quot;,
      800: &amp;quot;#92400e&amp;quot;,
      900: &amp;quot;#78350f&amp;quot;,
    },

    // Error - Red scale
    error: {
      50: &amp;quot;#fef2f2&amp;quot;,
      100: &amp;quot;#fee2e2&amp;quot;,
      200: &amp;quot;#fecaca&amp;quot;,
      300: &amp;quot;#fca5a5&amp;quot;,
      400: &amp;quot;#f87171&amp;quot;,
      500: &amp;quot;#ef4444&amp;quot;,
      600: &amp;quot;#dc2626&amp;quot;,
      700: &amp;quot;#b91c1c&amp;quot;,
      800: &amp;quot;#991b1b&amp;quot;,
      900: &amp;quot;#7f1d1d&amp;quot;,
    },

    // Info - Blue scale
    info: {
      50: &amp;quot;#eff6ff&amp;quot;,
      100: &amp;quot;#dbeafe&amp;quot;,
      200: &amp;quot;#bfdbfe&amp;quot;,
      300: &amp;quot;#93c5fd&amp;quot;,
      400: &amp;quot;#60a5fa&amp;quot;,
      500: &amp;quot;#3b82f6&amp;quot;,
      600: &amp;quot;#2563eb&amp;quot;,
      700: &amp;quot;#1d4ed8&amp;quot;,
      800: &amp;quot;#1e40af&amp;quot;,
      900: &amp;quot;#1e3a8a&amp;quot;,
    },
  },

  // Accent colors for interactive elements
  accent: {
    primary: &amp;quot;#3b82f6&amp;quot;, // Blue - primary actions
    primaryHover: &amp;quot;#2563eb&amp;quot;,
    primaryActive: &amp;quot;#1d4ed8&amp;quot;,
    primaryFocus: &amp;quot;#3b82f6&amp;quot;,

    secondary: &amp;quot;#64748b&amp;quot;, // Graphite - secondary actions
    secondaryHover: &amp;quot;#475569&amp;quot;,
    secondaryActive: &amp;quot;#334155&amp;quot;,
    secondaryFocus: &amp;quot;#64748b&amp;quot;,

    ghost: &amp;quot;transparent&amp;quot;, // Ghost - subtle actions
    ghostHover: &amp;quot;#f1f5f9&amp;quot;,
    ghostActive: &amp;quot;#e2e8f0&amp;quot;,
    ghostFocus: &amp;quot;#3b82f6&amp;quot;,
  },

  // Background colors
  background: {
    primary: &amp;quot;#ffffff&amp;quot;, // Main background
    secondary: &amp;quot;#f8fafc&amp;quot;, // Panel backgrounds
    tertiary: &amp;quot;#f1f5f9&amp;quot;, // Card backgrounds
    overlay: &amp;quot;rgba(15, 23, 42, 0.4)&amp;quot;, // Modal overlays
  },

  // Border colors
  border: {
    subtle: &amp;quot;#e2e8f0&amp;quot;, // Light borders
    default: &amp;quot;#cbd5e1&amp;quot;, // Standard borders
    strong: &amp;quot;#94a3b8&amp;quot;, // Emphasized borders
    focus: &amp;quot;#3b82f6&amp;quot;, // Focus rings
    error: &amp;quot;#f87171&amp;quot;, // Error borders
    success: &amp;quot;#34d399&amp;quot;, // Success borders
    warning: &amp;quot;#fbbf24&amp;quot;, // Warning borders
    info: &amp;quot;#60a5fa&amp;quot;, // Info borders
  },

  // Text colors
  text: {
    primary: &amp;quot;#0f172a&amp;quot;, // Primary text
    secondary: &amp;quot;#334155&amp;quot;, // Secondary text
    tertiary: &amp;quot;#64748b&amp;quot;, // Subtle text
    quaternary: &amp;quot;#94a3b8&amp;quot;, // Very subtle text
    inverse: &amp;quot;#ffffff&amp;quot;, // Text on dark backgrounds
    link: &amp;quot;#3b82f6&amp;quot;, // Links
    linkHover: &amp;quot;#2563eb&amp;quot;, // Link hover
    success: &amp;quot;#047857&amp;quot;, // Success text
    warning: &amp;quot;#b45309&amp;quot;, // Warning text
    error: &amp;quot;#b91c1c&amp;quot;, // Error text
    info: &amp;quot;#1d4ed8&amp;quot;, // Info text
  },

  // Interactive state colors for advanced interactions
  interactive: {
    // Hover overlays
    hover: {
      primary: &amp;quot;rgba(59, 130, 246, 0.1)&amp;quot;,
      secondary: &amp;quot;rgba(100, 116, 139, 0.1)&amp;quot;,
      ghost: &amp;quot;rgba(100, 116, 139, 0.05)&amp;quot;,
      danger: &amp;quot;rgba(239, 68, 68, 0.1)&amp;quot;,
    },

    // Active/pressed states
    active: {
      primary: &amp;quot;rgba(59, 130, 246, 0.2)&amp;quot;,
      secondary: &amp;quot;rgba(100, 116, 139, 0.15)&amp;quot;,
      ghost: &amp;quot;rgba(100, 116, 139, 0.1)&amp;quot;,
      danger: &amp;quot;rgba(239, 68, 68, 0.15)&amp;quot;,
    },

    // Focus ring system
    focus: {
      ring: &amp;quot;#3b82f6&amp;quot;,
      ringOffset: &amp;quot;#ffffff&amp;quot;,
      ringWidth: &amp;quot;2px&amp;quot;,
      ringOpacity: &amp;quot;0.5&amp;quot;,
    },
  },

  // Code editor specific colors
  code: {
    background: &amp;quot;#0f172a&amp;quot;,
    text: &amp;quot;#f8fafc&amp;quot;,
    comment: &amp;quot;#64748b&amp;quot;,
    keyword: &amp;quot;#3b82f6&amp;quot;,
    string: &amp;quot;#10b981&amp;quot;,
    number: &amp;quot;#f59e0b&amp;quot;,
    function: &amp;quot;#8b5cf6&amp;quot;,
    variable: &amp;quot;#f8fafc&amp;quot;,
    selection: &amp;quot;rgba(59, 130, 246, 0.3)&amp;quot;,
  },
} as const;

export const typography &#x3D; {
  fontFamily: {
    sans: [
      &amp;quot;ui-sans-serif&amp;quot;,
      &amp;quot;system-ui&amp;quot;,
      &amp;quot;-apple-system&amp;quot;,
      &amp;quot;BlinkMacSystemFont&amp;quot;,
      &amp;#39;&amp;quot;Segoe UI&amp;quot;&amp;#39;,
      &amp;quot;Roboto&amp;quot;,
      &amp;#39;&amp;quot;Helvetica Neue&amp;quot;&amp;#39;,
      &amp;quot;Arial&amp;quot;,
      &amp;quot;sans-serif&amp;quot;,
    ].join(&amp;quot;, &amp;quot;),
    mono: [
      &amp;quot;ui-monospace&amp;quot;,
      &amp;quot;SFMono-Regular&amp;quot;,
      &amp;#39;&amp;quot;SF Mono&amp;quot;&amp;#39;,
      &amp;quot;Monaco&amp;quot;,
      &amp;quot;Inconsolata&amp;quot;,
      &amp;#39;&amp;quot;Liberation Mono&amp;quot;&amp;#39;,
      &amp;#39;&amp;quot;Fira Code&amp;quot;&amp;#39;,
      &amp;#39;&amp;quot;Roboto Mono&amp;quot;&amp;#39;,
      &amp;quot;monospace&amp;quot;,
    ].join(&amp;quot;, &amp;quot;),
  },

  fontSize: {
    xs: [&amp;quot;0.75rem&amp;quot;, { lineHeight: &amp;quot;1rem&amp;quot; }], // 12px
    sm: [&amp;quot;0.875rem&amp;quot;, { lineHeight: &amp;quot;1.25rem&amp;quot; }], // 14px
    base: [&amp;quot;1rem&amp;quot;, { lineHeight: &amp;quot;1.5rem&amp;quot; }], // 16px
    lg: [&amp;quot;1.125rem&amp;quot;, { lineHeight: &amp;quot;1.75rem&amp;quot; }], // 18px
    xl: [&amp;quot;1.25rem&amp;quot;, { lineHeight: &amp;quot;1.75rem&amp;quot; }], // 20px
    &amp;quot;2xl&amp;quot;: [&amp;quot;1.5rem&amp;quot;, { lineHeight: &amp;quot;2rem&amp;quot; }], // 24px
    &amp;quot;3xl&amp;quot;: [&amp;quot;1.875rem&amp;quot;, { lineHeight: &amp;quot;2.25rem&amp;quot; }], // 30px
    &amp;quot;4xl&amp;quot;: [&amp;quot;2.25rem&amp;quot;, { lineHeight: &amp;quot;2.5rem&amp;quot; }], // 36px
  },

  fontWeight: {
    normal: &amp;quot;400&amp;quot;,
    medium: &amp;quot;500&amp;quot;,
    semibold: &amp;quot;600&amp;quot;,
    bold: &amp;quot;700&amp;quot;,
  },
} as const;

export const spacing &#x3D; {
  px: &amp;quot;1px&amp;quot;,
  0: &amp;quot;0&amp;quot;,
  0.5: &amp;quot;0.125rem&amp;quot;, // 2px
  1: &amp;quot;0.25rem&amp;quot;, // 4px
  1.5: &amp;quot;0.375rem&amp;quot;, // 6px
  2: &amp;quot;0.5rem&amp;quot;, // 8px
  2.5: &amp;quot;0.625rem&amp;quot;, // 10px
  3: &amp;quot;0.75rem&amp;quot;, // 12px
  3.5: &amp;quot;0.875rem&amp;quot;, // 14px
  4: &amp;quot;1rem&amp;quot;, // 16px
  5: &amp;quot;1.25rem&amp;quot;, // 20px
  6: &amp;quot;1.5rem&amp;quot;, // 24px
  7: &amp;quot;1.75rem&amp;quot;, // 28px
  8: &amp;quot;2rem&amp;quot;, // 32px
  10: &amp;quot;2.5rem&amp;quot;, // 40px
  12: &amp;quot;3rem&amp;quot;, // 48px
  16: &amp;quot;4rem&amp;quot;, // 64px
  20: &amp;quot;5rem&amp;quot;, // 80px
  24: &amp;quot;6rem&amp;quot;, // 96px
} as const;

export const borderRadius &#x3D; {
  none: &amp;quot;0&amp;quot;,
  sm: &amp;quot;0.125rem&amp;quot;, // 2px
  DEFAULT: &amp;quot;0.25rem&amp;quot;, // 4px
  md: &amp;quot;0.375rem&amp;quot;, // 6px
  lg: &amp;quot;0.5rem&amp;quot;, // 8px
  xl: &amp;quot;0.75rem&amp;quot;, // 12px
  &amp;quot;2xl&amp;quot;: &amp;quot;1rem&amp;quot;, // 16px
  full: &amp;quot;9999px&amp;quot;,
} as const;

export const shadows &#x3D; {
  sm: &amp;quot;0 1px 2px 0 rgb(0 0 0 / 0.05)&amp;quot;,
  DEFAULT: &amp;quot;0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&amp;quot;,
  md: &amp;quot;0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&amp;quot;,
  lg: &amp;quot;0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&amp;quot;,
  xl: &amp;quot;0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)&amp;quot;,
  inner: &amp;quot;inset 0 2px 4px 0 rgb(0 0 0 / 0.05)&amp;quot;,
  none: &amp;quot;none&amp;quot;,
} as const;

export const zIndex &#x3D; {
  auto: &amp;quot;auto&amp;quot;,
  0: &amp;quot;0&amp;quot;,
  10: &amp;quot;10&amp;quot;,
  20: &amp;quot;20&amp;quot;,
  30: &amp;quot;30&amp;quot;,
  40: &amp;quot;40&amp;quot;,
  50: &amp;quot;50&amp;quot;,
  dropdown: &amp;quot;1000&amp;quot;,
  sticky: &amp;quot;1020&amp;quot;,
  fixed: &amp;quot;1030&amp;quot;,
  modal: &amp;quot;1040&amp;quot;,
  popover: &amp;quot;1050&amp;quot;,
  tooltip: &amp;quot;1060&amp;quot;,
  toast: &amp;quot;1070&amp;quot;,
} as const;

export const breakpoints &#x3D; {
  sm: &amp;quot;640px&amp;quot;,
  md: &amp;quot;768px&amp;quot;,
  lg: &amp;quot;1024px&amp;quot;,
  xl: &amp;quot;1280px&amp;quot;,
  &amp;quot;2xl&amp;quot;: &amp;quot;1536px&amp;quot;,
} as const;

export const transitions &#x3D; {
  all: &amp;quot;all 150ms cubic-bezier(0.4, 0, 0.2, 1)&amp;quot;,
  colors:
    &amp;quot;color 150ms cubic-bezier(0.4, 0, 0.2, 1), background-color 150ms cubic-bezier(0.4, 0, 0.2, 1), border-color 150ms cubic-bezier(0.4, 0, 0.2, 1)&amp;quot;,
  opacity: &amp;quot;opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)&amp;quot;,
  shadow: &amp;quot;box-shadow 150ms cubic-bezier(0.4, 0, 0.2, 1)&amp;quot;,
  transform: &amp;quot;transform 150ms cubic-bezier(0.4, 0, 0.2, 1)&amp;quot;,
} as const;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-42">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/generate.ts</div>
                <div class="file-content">
                    <pre>/**
 * Generate command - Core code generation based on assembly.cue configuration
 *
 * This is the primary command for generating project files, CI workflows,
 * language-specific configurations, and other artifacts based on the
 * specification stored in the .arbiter/ directory.
 */

import { spawn } from &amp;#39;node:child_process&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import { promisify } from &amp;#39;node:util&amp;#39;;
import type {
  AppSpec,
  AssemblyConfig,
  ConfigWithVersion,
  DeploymentConfig,
  ServiceConfig as DeploymentServiceConfig,
  DeploymentTarget,
  EnhancedGenerateOptions,
  SchemaVersion,
  TestCase,
  TestCompositionResult,
  TestSuite,
} from &amp;#39;@arbiter/shared&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import { ApiClient } from &amp;#39;../api-client.js&amp;#39;;
import {
  generateComponent,
  generateService,
  initializeProject,
  registry as languageRegistry,
} from &amp;#39;../language-plugins/index.js&amp;#39;;
import type {
  ProjectConfig as LanguageProjectConfig,
  ServiceConfig as LanguageServiceConfig,
} from &amp;#39;../language-plugins/index.js&amp;#39;;
import { extractVariablesFromCue, templateManager } from &amp;#39;../templates/index.js&amp;#39;;
import type { CLIConfig } from &amp;#39;../types.js&amp;#39;;
import {
  createRepositoryConfig,
  getSmartRepositoryConfig,
  validateRepositoryConfig,
} from &amp;#39;../utils/git-detection.js&amp;#39;;
import { GitHubSyncClient } from &amp;#39;../utils/github-sync.js&amp;#39;;
import { ShardedCUEStorage } from &amp;#39;../utils/sharded-storage.js&amp;#39;;
import { formatWarnings, validateSpecification } from &amp;#39;../validation/warnings.js&amp;#39;;

export interface GenerateOptions {
  output?: string;
  outputDir?: string;
  includeCi?: boolean;
  force?: boolean;
  dryRun?: boolean;
  verbose?: boolean;
  format?: &amp;#39;auto&amp;#39; | &amp;#39;json&amp;#39; | &amp;#39;yaml&amp;#39; | &amp;#39;typescript&amp;#39; | &amp;#39;python&amp;#39; | &amp;#39;rust&amp;#39; | &amp;#39;go&amp;#39; | &amp;#39;shell&amp;#39;;
  spec?: string; // New: specify which spec to use
  syncGithub?: boolean; // New: sync epics and tasks to GitHub
  githubDryRun?: boolean; // New: preview GitHub sync without changes
  useConfig?: boolean; // New: use config repository in case of conflicts
  useGitRemote?: boolean; // New: use Git remote repository in case of conflicts
}

// Simple command execution for CUE evaluation
async function executeCommand(
  command: string,
  args: string[],
  options: { cwd?: string; timeout?: number } &#x3D; {}
): Promise&amp;lt;{ success: boolean; stdout: string; stderr: string }&amp;gt; {
  return new Promise(resolve &#x3D;&amp;gt; {
    const proc &#x3D; spawn(command, args, {
      cwd: options.cwd || process.cwd(),
      stdio: [&amp;#39;ignore&amp;#39;, &amp;#39;pipe&amp;#39;, &amp;#39;pipe&amp;#39;],
    });

    let stdout &#x3D; &amp;#39;&amp;#39;;
    let stderr &#x3D; &amp;#39;&amp;#39;;

    proc.stdout?.on(&amp;#39;data&amp;#39;, data &#x3D;&amp;gt; (stdout +&#x3D; data.toString()));
    proc.stderr?.on(&amp;#39;data&amp;#39;, data &#x3D;&amp;gt; (stderr +&#x3D; data.toString()));

    const timeout &#x3D; setTimeout(() &#x3D;&amp;gt; {
      proc.kill();
      resolve({ success: false, stdout, stderr: &amp;#39;Command timed out&amp;#39; });
    }, options.timeout || 10000);

    proc.on(&amp;#39;close&amp;#39;, code &#x3D;&amp;gt; {
      clearTimeout(timeout);
      resolve({
        success: code &#x3D;&#x3D;&#x3D; 0,
        stdout: stdout.trim(),
        stderr: stderr.trim(),
      });
    });

    proc.on(&amp;#39;error&amp;#39;, error &#x3D;&amp;gt; {
      clearTimeout(timeout);
      resolve({ success: false, stdout, stderr: error.message });
    });
  });
}

/**
 * Discover available specs in .arbiter/ directories
 */
function discoverSpecs(): Array&amp;lt;{ name: string; path: string }&amp;gt; {
  const specs: Array&amp;lt;{ name: string; path: string }&amp;gt; &#x3D; [];

  if (fs.existsSync(&amp;#39;.arbiter&amp;#39;)) {
    const specDirs &#x3D; fs
      .readdirSync(&amp;#39;.arbiter&amp;#39;, { withFileTypes: true })
      .filter(dirent &#x3D;&amp;gt; dirent.isDirectory())
      .map(dirent &#x3D;&amp;gt; dirent.name);

    for (const specName of specDirs) {
      const assemblyPath &#x3D; path.join(&amp;#39;.arbiter&amp;#39;, specName, &amp;#39;assembly.cue&amp;#39;);
      if (fs.existsSync(assemblyPath)) {
        specs.push({ name: specName, path: assemblyPath });
      }
    }
  }

  return specs;
}

/**
 * Handle GitHub synchronization for epics and tasks
 */
async function handleGitHubSync(options: GenerateOptions, config: CLIConfig): Promise&amp;lt;void&amp;gt; {
  if (options.verbose) {
    console.log(chalk.dim(&amp;#39;ğŸ”„ Starting GitHub sync handler...&amp;#39;));
  }

  try {
    // Smart repository configuration with Git auto-detection
    const smartRepoConfig &#x3D; getSmartRepositoryConfig(config.github?.repository, {
      useConfig: options.useConfig,
      useGitRemote: options.useGitRemote,
      verbose: options.verbose,
    });

    // Handle case where no repository info could be determined
    if (!smartRepoConfig) {
      console.error(chalk.red(&amp;#39;âŒ No GitHub repository configuration found&amp;#39;));
      console.log(chalk.dim(&amp;#39;Options to fix this:&amp;#39;));
      console.log(
        chalk.dim(
          &amp;#39;  1. Initialize Git and add GitHub remote: git remote add origin https://github.com/owner/repo.git&amp;#39;
        )
      );
      console.log(chalk.dim(&amp;#39;  2. Or add GitHub configuration to your .arbiter/config.json:&amp;#39;));
      console.log(
        chalk.dim(&#x60;{
  &amp;quot;github&amp;quot;: {
    &amp;quot;repository&amp;quot;: {
      &amp;quot;owner&amp;quot;: &amp;quot;your-org&amp;quot;,
      &amp;quot;repo&amp;quot;: &amp;quot;your-repo&amp;quot;
    },
    &amp;quot;mapping&amp;quot;: {
      &amp;quot;epicPrefix&amp;quot;: &amp;quot;[Epic]&amp;quot;,
      &amp;quot;taskPrefix&amp;quot;: &amp;quot;[Task]&amp;quot;,
      &amp;quot;defaultLabels&amp;quot;: [&amp;quot;arbiter-generated&amp;quot;]
    },
    &amp;quot;behavior&amp;quot;: {
      &amp;quot;createMilestones&amp;quot;: true,
      &amp;quot;autoClose&amp;quot;: true,
      &amp;quot;syncAcceptanceCriteria&amp;quot;: true,
      &amp;quot;syncAssignees&amp;quot;: false
    }
  }
}&#x60;)
      );
      console.log(chalk.dim(&amp;#39;\\nAnd set your GitHub token as an environment variable:&amp;#39;));
      console.log(chalk.dim(&amp;#39;  export GITHUB_TOKEN&#x3D;your_github_personal_access_token&amp;#39;));
      return;
    }

    const finalRepo &#x3D; smartRepoConfig.repo;

    // Validate the final repository configuration
    const validation &#x3D; validateRepositoryConfig(finalRepo);
    if (!validation.valid) {
      console.error(chalk.red(&amp;#39;âŒ Invalid repository configuration:&amp;#39;));
      validation.errors.forEach(error &#x3D;&amp;gt; {
        console.log(chalk.red(&#x60;  â€¢ ${error}&#x60;));
      });
      if (validation.suggestions.length &amp;gt; 0) {
        console.log(chalk.dim(&amp;#39;\\nSuggestions:&amp;#39;));
        validation.suggestions.forEach(suggestion &#x3D;&amp;gt; {
          console.log(chalk.dim(&#x60;  â€¢ ${suggestion}&#x60;));
        });
      }
      return;
    }

    // Ensure we have owner and repo from somewhere
    if (!finalRepo.owner || !finalRepo.repo) {
      console.error(chalk.red(&amp;#39;âŒ Repository owner and name are required&amp;#39;));
      console.log(
        chalk.dim(
          &amp;#39;Either configure them in .arbiter/config.json or ensure your Git remote is set correctly&amp;#39;
        )
      );
      return;
    }

    // Create GitHub configuration with the resolved repository info
    const githubConfig &#x3D; {
      repository: finalRepo,
      mapping: config.github?.mapping || {
        epicPrefix: &amp;#39;[Epic]&amp;#39;,
        taskPrefix: &amp;#39;[Task]&amp;#39;,
        defaultLabels: [&amp;#39;arbiter-generated&amp;#39;],
      },
      behavior: config.github?.behavior || {
        createMilestones: true,
        autoClose: true,
        syncAcceptanceCriteria: true,
        syncAssignees: false,
      },
    };

    // Display repository info
    if (options.verbose || smartRepoConfig.source !&#x3D;&#x3D; &amp;#39;config&amp;#39;) {
      const sourceInfo &#x3D;
        smartRepoConfig.source &#x3D;&#x3D;&#x3D; &amp;#39;detected&amp;#39;
          ? &amp;#39;auto-detected from Git remote&amp;#39;
          : smartRepoConfig.source &#x3D;&#x3D;&#x3D; &amp;#39;merged&amp;#39;
            ? &amp;#39;merged from config and Git remote&amp;#39;
            : &amp;#39;from configuration&amp;#39;;

      console.log(chalk.dim(&#x60;ğŸ“ Repository: ${finalRepo.owner}/${finalRepo.repo} (${sourceInfo})&#x60;));
    }

    // Load epics from the project
    console.log(chalk.blue(&amp;#39;ğŸ“‹ Loading epics and tasks...&amp;#39;));
    const storage &#x3D; new ShardedCUEStorage();
    await storage.initialize();
    const epics &#x3D; await storage.listEpics();

    if (epics.length &#x3D;&#x3D;&#x3D; 0) {
      console.log(chalk.yellow(&amp;#39;âš ï¸  No epics found to sync&amp;#39;));
      console.log(chalk.dim(&amp;#39;Create epics with: arbiter epic create &amp;lt;name&amp;gt;&amp;#39;));
      return;
    }

    console.log(
      chalk.dim(
        &#x60;Found ${epics.length} epics with ${epics.reduce((sum, epic) &#x3D;&amp;gt; sum + epic.tasks.length, 0)} total tasks&#x60;
      )
    );

    // Create GitHub sync client
    const githubClient &#x3D; new GitHubSyncClient(githubConfig);

    // Determine if this is a dry run
    const isDryRun &#x3D; options.githubDryRun || options.dryRun;

    if (isDryRun) {
      console.log(chalk.blue(&amp;#39;ğŸ” GitHub Sync Preview (dry run)&amp;#39;));

      // Generate preview
      const preview &#x3D; await githubClient.generateSyncPreview(epics);

      // Display preview results
      console.log(chalk.green(&amp;#39;\\nğŸ“Š Sync Preview:&amp;#39;));

      // Epics
      if (preview.epics.create.length &amp;gt; 0) {
        console.log(chalk.cyan(&#x60;\\n  ğŸ“ Epics to create: ${preview.epics.create.length}&#x60;));
        preview.epics.create.forEach(epic &#x3D;&amp;gt; {
          console.log(chalk.dim(&#x60;    â€¢ ${epic.name}&#x60;));
        });
      }

      if (preview.epics.update.length &amp;gt; 0) {
        console.log(chalk.yellow(&#x60;\\n  ğŸ“ Epics to update: ${preview.epics.update.length}&#x60;));
        preview.epics.update.forEach(({ epic }) &#x3D;&amp;gt; {
          console.log(chalk.dim(&#x60;    â€¢ ${epic.name}&#x60;));
        });
      }

      if (preview.epics.close.length &amp;gt; 0) {
        console.log(chalk.red(&#x60;\\n  ğŸ“ Epics to close: ${preview.epics.close.length}&#x60;));
        preview.epics.close.forEach(({ epic }) &#x3D;&amp;gt; {
          console.log(chalk.dim(&#x60;    â€¢ ${epic.name} (${epic.status})&#x60;));
        });
      }

      // Tasks
      if (preview.tasks.create.length &amp;gt; 0) {
        console.log(chalk.cyan(&#x60;\\n  ğŸ”§ Tasks to create: ${preview.tasks.create.length}&#x60;));
        preview.tasks.create.forEach(task &#x3D;&amp;gt; {
          console.log(chalk.dim(&#x60;    â€¢ ${task.name} (${task.type})&#x60;));
        });
      }

      if (preview.tasks.update.length &amp;gt; 0) {
        console.log(chalk.yellow(&#x60;\\n  ğŸ”§ Tasks to update: ${preview.tasks.update.length}&#x60;));
        preview.tasks.update.forEach(({ task }) &#x3D;&amp;gt; {
          console.log(chalk.dim(&#x60;    â€¢ ${task.name} (${task.type})&#x60;));
        });
      }

      if (preview.tasks.close.length &amp;gt; 0) {
        console.log(chalk.red(&#x60;\\n  ğŸ”§ Tasks to close: ${preview.tasks.close.length}&#x60;));
        preview.tasks.close.forEach(({ task }) &#x3D;&amp;gt; {
          console.log(chalk.dim(&#x60;    â€¢ ${task.name} (${task.status})&#x60;));
        });
      }

      // Milestones
      if (preview.milestones.create.length &amp;gt; 0) {
        console.log(
          chalk.cyan(&#x60;\\n  ğŸ¯ Milestones to create: ${preview.milestones.create.length}&#x60;)
        );
        preview.milestones.create.forEach(epic &#x3D;&amp;gt; {
          console.log(chalk.dim(&#x60;    â€¢ Epic: ${epic.name}&#x60;));
        });
      }

      if (preview.milestones.update.length &amp;gt; 0) {
        console.log(
          chalk.yellow(&#x60;\\n  ğŸ¯ Milestones to update: ${preview.milestones.update.length}&#x60;)
        );
        preview.milestones.update.forEach(({ epic }) &#x3D;&amp;gt; {
          console.log(chalk.dim(&#x60;    â€¢ Epic: ${epic.name}&#x60;));
        });
      }

      if (preview.milestones.close.length &amp;gt; 0) {
        console.log(chalk.red(&#x60;\\n  ğŸ¯ Milestones to close: ${preview.milestones.close.length}&#x60;));
        preview.milestones.close.forEach(({ epic }) &#x3D;&amp;gt; {
          console.log(chalk.dim(&#x60;    â€¢ Epic: ${epic.name} (${epic.status})&#x60;));
        });
      }

      const totalChanges &#x3D;
        preview.epics.create.length +
        preview.epics.update.length +
        preview.epics.close.length +
        preview.tasks.create.length +
        preview.tasks.update.length +
        preview.tasks.close.length +
        preview.milestones.create.length +
        preview.milestones.update.length +
        preview.milestones.close.length;

      if (totalChanges &#x3D;&#x3D;&#x3D; 0) {
        console.log(chalk.green(&amp;#39;\\nâœ… No changes needed - everything is already in sync&amp;#39;));
      } else {
        console.log(
          chalk.blue(&amp;#39;\\nğŸ’¡ Run without --github-dry-run or --dry-run to apply these changes&amp;#39;)
        );
      }
    } else {
      console.log(chalk.blue(&amp;#39;ğŸš€ Syncing to GitHub...&amp;#39;));

      // Perform actual sync
      const syncResults &#x3D; await githubClient.syncToGitHub(epics, false);

      // Group and display results
      const created &#x3D; syncResults.filter(r &#x3D;&amp;gt; r.action &#x3D;&#x3D;&#x3D; &amp;#39;created&amp;#39;);
      const updated &#x3D; syncResults.filter(r &#x3D;&amp;gt; r.action &#x3D;&#x3D;&#x3D; &amp;#39;updated&amp;#39;);
      const closed &#x3D; syncResults.filter(r &#x3D;&amp;gt; r.action &#x3D;&#x3D;&#x3D; &amp;#39;closed&amp;#39;);
      const skipped &#x3D; syncResults.filter(r &#x3D;&amp;gt; r.action &#x3D;&#x3D;&#x3D; &amp;#39;skipped&amp;#39;);

      console.log(chalk.green(&amp;#39;\\nâœ… GitHub Sync Complete:&amp;#39;));

      if (created.length &amp;gt; 0) {
        console.log(chalk.cyan(&#x60;  ğŸ“ Created: ${created.length} items&#x60;));
        created.forEach(result &#x3D;&amp;gt; {
          if (result.githubNumber) {
            console.log(
              chalk.dim(&#x60;    â€¢ ${result.type} #${result.githubNumber}: ${result.details}&#x60;)
            );
          } else {
            console.log(chalk.dim(&#x60;    â€¢ ${result.type}: ${result.details}&#x60;));
          }
        });
      }

      if (updated.length &amp;gt; 0) {
        console.log(chalk.yellow(&#x60;  ğŸ“ Updated: ${updated.length} items&#x60;));
        updated.forEach(result &#x3D;&amp;gt; {
          if (result.githubNumber) {
            console.log(
              chalk.dim(&#x60;    â€¢ ${result.type} #${result.githubNumber}: ${result.details}&#x60;)
            );
          } else {
            console.log(chalk.dim(&#x60;    â€¢ ${result.type}: ${result.details}&#x60;));
          }
        });
      }

      if (closed.length &amp;gt; 0) {
        console.log(chalk.red(&#x60;  ğŸ“ Closed: ${closed.length} items&#x60;));
        closed.forEach(result &#x3D;&amp;gt; {
          if (result.githubNumber) {
            console.log(
              chalk.dim(&#x60;    â€¢ ${result.type} #${result.githubNumber}: ${result.details}&#x60;)
            );
          } else {
            console.log(chalk.dim(&#x60;    â€¢ ${result.type}: ${result.details}&#x60;));
          }
        });
      }

      if (skipped.length &amp;gt; 0 &amp;amp;&amp;amp; options.verbose) {
        console.log(chalk.dim(&#x60;  â­ï¸  Skipped: ${skipped.length} items (no changes needed)&#x60;));
      }

      console.log(
        chalk.green(
          &#x60;\\nğŸ”— Check your GitHub repository: https://github.com/${finalRepo.owner}/${finalRepo.repo}/issues&#x60;
        )
      );
    }
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;âŒ GitHub sync failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    if (options.verbose) {
      console.error(chalk.dim(&amp;#39;Full error:&amp;#39;), error);
    }

    console.log(chalk.dim(&amp;#39;\\nTroubleshooting tips:&amp;#39;));
    console.log(
      chalk.dim(&amp;#39;  â€¢ Ensure GITHUB_TOKEN environment variable is set with proper permissions&amp;#39;)
    );
    console.log(chalk.dim(&amp;quot;  â€¢ Verify your GitHub token has &amp;#39;repo&amp;#39; or &amp;#39;issues:write&amp;#39; permission&amp;quot;));
    console.log(chalk.dim(&amp;#39;  â€¢ Check that the repository owner/name is correct&amp;#39;));
    console.log(chalk.dim(&amp;#39;  â€¢ Ensure Git remote origin points to the correct GitHub repository&amp;#39;));
    console.log(chalk.dim(&amp;#39;  â€¢ Use --verbose for more error details&amp;#39;));
    console.log(
      chalk.dim(&amp;#39;  â€¢ Use --use-config or --use-git-remote to resolve repository conflicts&amp;#39;)
    );
  }
}

/**
 * Main generate command implementation
 */
export async function generateCommand(
  options: GenerateOptions,
  config: CLIConfig,
  specName?: string
): Promise&amp;lt;number&amp;gt; {
  if (options.verbose) {
    console.log(chalk.dim(&amp;#39;ğŸ”§ Generate options:&amp;#39;), JSON.stringify(options, null, 2));
  }
  try {
    console.log(chalk.blue(&amp;#39;ğŸ—ï¸  Generating project artifacts from assembly.cue...&amp;#39;));

    // First, try to emit the CUE file from stored specification in service
    await emitSpecificationFromService(config);

    let assemblyPath: string;
    let assemblyContent: string;

    // Determine which assembly file to use
    if (specName || options.spec) {
      // Use specified spec name
      const targetSpec &#x3D; specName || options.spec!;
      assemblyPath &#x3D; path.join(&amp;#39;.arbiter&amp;#39;, targetSpec, &amp;#39;assembly.cue&amp;#39;);

      if (!fs.existsSync(assemblyPath)) {
        console.error(chalk.red(&#x60;âŒ Spec &amp;quot;${targetSpec}&amp;quot; not found at ${assemblyPath}&#x60;));

        // Show available specs
        const availableSpecs &#x3D; discoverSpecs();
        if (availableSpecs.length &amp;gt; 0) {
          console.log(chalk.yellow(&amp;#39;\nğŸ“‹ Available specs:&amp;#39;));
          availableSpecs.forEach(spec &#x3D;&amp;gt; {
            console.log(chalk.cyan(&#x60;  â€¢ ${spec.name}&#x60;));
          });
          console.log(chalk.dim(&#x60;\nğŸ’¡ Usage: arbiter generate ${availableSpecs[0].name}&#x60;));
        } else {
          console.log(chalk.dim(&amp;#39;No specs found in .arbiter/ directory&amp;#39;));
        }
        return 1;
      }

      console.log(chalk.dim(&#x60;ğŸ“ Using spec: ${targetSpec}&#x60;));
    } else {
      // Auto-discover approach
      const availableSpecs &#x3D; discoverSpecs();

      if (availableSpecs.length &#x3D;&#x3D;&#x3D; 0) {
        // Check for assembly.cue in .arbiter directory first
        const arbiterPath &#x3D; path.resolve(&amp;#39;.arbiter&amp;#39;, &amp;#39;assembly.cue&amp;#39;);

        if (fs.existsSync(arbiterPath)) {
          assemblyPath &#x3D; arbiterPath;
          console.log(chalk.dim(&amp;#39;ğŸ“ Using .arbiter/assembly.cue&amp;#39;));
        } else {
          console.error(chalk.red(&amp;#39;âŒ No assembly specifications found&amp;#39;));
          console.log(chalk.dim(&amp;#39;Create a spec with: arbiter add service &amp;lt;name&amp;gt;&amp;#39;));
          console.log(chalk.dim(&amp;#39;Or initialize with: arbiter init&amp;#39;));
          return 1;
        }
      } else if (availableSpecs.length &#x3D;&#x3D;&#x3D; 1) {
        // Use the single available spec
        assemblyPath &#x3D; availableSpecs[0].path;
        console.log(chalk.green(&#x60;âœ… Auto-detected spec: ${availableSpecs[0].name}&#x60;));
      } else {
        // Multiple specs found - require user to specify
        console.error(chalk.red(&amp;#39;âŒ Multiple specs found. Please specify which one to use:&amp;#39;));
        console.log(chalk.yellow(&amp;#39;\nğŸ“‹ Available specs:&amp;#39;));
        availableSpecs.forEach(spec &#x3D;&amp;gt; {
          console.log(chalk.cyan(&#x60;  â€¢ arbiter generate ${spec.name}&#x60;));
        });
        return 1;
      }
    }

    assemblyContent &#x3D; fs.readFileSync(assemblyPath, &amp;#39;utf-8&amp;#39;);
    const configWithVersion &#x3D; await parseAssemblyFile(assemblyPath);

    if (options.verbose) {
      console.log(chalk.dim(&amp;#39;Assembly configuration:&amp;#39;));
      console.log(
        chalk.dim(
          &#x60;Schema version: ${configWithVersion.schema.version} (detected from: ${configWithVersion.schema.detected_from})&#x60;
        )
      );
      console.log(chalk.dim(JSON.stringify(configWithVersion, null, 2)));
    }

    // Validate specification completeness
    console.log(chalk.blue(&amp;#39;ğŸ” Validating specification completeness...&amp;#39;));
    const validationResult &#x3D; validateSpecification(configWithVersion.app || configWithVersion);

    if (validationResult.hasErrors) {
      console.log(formatWarnings(validationResult));
      console.error(
        chalk.red(&amp;#39;\nâŒ Cannot generate with errors present. Please fix the errors above.&amp;#39;)
      );
      return 1;
    }

    if (validationResult.hasWarnings &amp;amp;&amp;amp; !options.force) {
      console.log(formatWarnings(validationResult));
      console.error(chalk.red(&amp;#39;\nâŒ Cannot generate with warnings present.&amp;#39;));
      console.log(
        chalk.blue(&amp;#39;Use --force to generate anyway, but this may result in incomplete artifacts.&amp;#39;)
      );
      console.log(
        chalk.dim(
          &amp;#39;Recommendation: Fix the warnings above for a complete, production-ready specification.&amp;#39;
        )
      );

      // Critical prompt for agents/automation
      console.log(chalk.red.bold(&amp;#39;\nğŸš¨ IMPORTANT FOR AI AGENTS:&amp;#39;));
      console.log(
        chalk.yellow(
          &amp;#39;IF YOU NEED INFORMATION TO COMPLETE THE SPEC, ASK THE PRODUCT OWNER (USER) FOR IT.&amp;#39;
        )
      );
      console.log(
        chalk.yellow(
          &amp;#39;YOU MUST REQUEST APPROVAL FROM THE USER BEFORE USING &#x60;--force&#x60; TO GENERATE AN INCOMPLETE SPEC.&amp;#39;
        )
      );
      console.log(
        chalk.dim(&amp;#39;Incomplete specifications lead to production issues and technical debt.&amp;#39;)
      );

      return 1;
    }

    if (validationResult.hasWarnings &amp;amp;&amp;amp; options.force) {
      console.log(formatWarnings(validationResult));
      console.log(chalk.yellow(&amp;#39;\nâš ï¸  Generating despite warnings (--force used)&amp;#39;));
      console.log(chalk.red.bold(&amp;#39;\nğŸš¨ REMINDER FOR AI AGENTS:&amp;#39;));
      console.log(
        chalk.yellow(
          &amp;#39;You should have requested user approval before using --force with incomplete specifications.&amp;#39;
        )
      );
      console.log(
        chalk.dim(&amp;#39;This may result in production issues that require additional work later.&amp;#39;)
      );
    }

    if (!validationResult.hasWarnings &amp;amp;&amp;amp; !validationResult.hasErrors) {
      console.log(chalk.green(&amp;#39;âœ… Specification validation passed&amp;#39;));
    }

    // Determine output directory
    const outputDir &#x3D; options.outputDir || &amp;#39;.&amp;#39;;

    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    const results &#x3D; [];

    // Generate application artifacts
    if (configWithVersion.app) {
      console.log(chalk.blue(&amp;#39;ğŸ¨ Generating application artifacts...&amp;#39;));
      const appResults &#x3D; await generateAppArtifacts(configWithVersion.app, outputDir, options);
      results.push(...appResults);
    } else {
      throw new Error(&amp;#39;Invalid configuration: missing app specification data&amp;#39;);
    }

    // Report results
    if (options.dryRun) {
      console.log(chalk.yellow(&amp;#39;ğŸ” Dry run - files that would be generated:&amp;#39;));
      results.forEach(file &#x3D;&amp;gt; console.log(chalk.dim(&#x60;  ${file}&#x60;)));
    } else {
      console.log(chalk.green(&#x60;âœ… Generated ${results.length} files:&#x60;));
      results.forEach(file &#x3D;&amp;gt; console.log(chalk.dim(&#x60;  âœ“ ${file}&#x60;)));
    }

    // Handle GitHub synchronization if requested
    if (options.syncGithub || options.githubDryRun) {
      await handleGitHubSync(options, config);
    }

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;âŒ Generate failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Parse assembly.cue file and extract configuration with schema version detection
 */
async function parseAssemblyFile(assemblyPath: string): Promise&amp;lt;ConfigWithVersion&amp;gt; {
  try {
    // Use CUE to evaluate and export as JSON
    const result &#x3D; await executeCommand(&amp;#39;cue&amp;#39;, [&amp;#39;eval&amp;#39;, &amp;#39;--out&amp;#39;, &amp;#39;json&amp;#39;, assemblyPath], {
      timeout: 10000,
    });

    if (!result.success) {
      console.error(&amp;#39;CUE evaluation failed:&amp;#39;, result.stderr);
      return fallbackParseAssembly(assemblyPath);
    }

    const cueData &#x3D; JSON.parse(result.stdout);

    // Detect schema version based on structure
    const schemaVersion &#x3D; detectSchemaVersion(cueData);

    // Parse app schema
    return parseAppSchema(cueData, schemaVersion);
  } catch (error) {
    console.error(&amp;#39;Error parsing CUE file:&amp;#39;, error);
    return fallbackParseAssembly(assemblyPath);
  }
}

/**
 * Detect schema version based on CUE data structure
 */
function detectSchemaVersion(cueData: any): SchemaVersion {
  // Always use app schema - it&amp;#39;s the primary and only supported schema now
  return {
    version: &amp;#39;app&amp;#39;,
    detected_from: &amp;#39;metadata&amp;#39;,
  };
}

/**
 * Parse App Specification schema
 */
function parseAppSchema(cueData: any, schemaVersion: SchemaVersion): ConfigWithVersion {
  const appSpec: AppSpec &#x3D; {
    product: cueData.product || {
      name: &amp;#39;Unknown App&amp;#39;,
    },
    config: cueData.config,
    ui: cueData.ui || {
      routes: [],
    },
    locators: cueData.locators || {},
    flows: cueData.flows || [],
    services: cueData.services,
    domain: cueData.domain,
    components: cueData.components,
    paths: cueData.paths,
    testability: cueData.testability,
    ops: cueData.ops,
    stateModels: cueData.stateModels,
  };

  return {
    schema: schemaVersion,
    app: appSpec,
  };
}

// Fallback to file-based regex parsing if CUE evaluation fails
async function fallbackParseAssembly(assemblyPath: string): Promise&amp;lt;ConfigWithVersion&amp;gt; {
  const content &#x3D; await fs.readFile(assemblyPath, &amp;#39;utf-8&amp;#39;);

  // Always use app schema
  const schemaVersion: SchemaVersion &#x3D; { version: &amp;#39;app&amp;#39;, detected_from: &amp;#39;default&amp;#39; };

  console.warn(&amp;#39;âš ï¸  CUE evaluation failed - using limited fallback parsing&amp;#39;);

  // Extract basic information from the CUE file
  const nameMatch &#x3D; content.match(/name:\s*&amp;quot;([^&amp;quot;]+)&amp;quot;/);
  const languageMatch &#x3D; content.match(/language:\s*&amp;quot;([^&amp;quot;]+)&amp;quot;/);
  const productName &#x3D; nameMatch ? nameMatch[1] : &amp;#39;Unknown App&amp;#39;;
  const language &#x3D; languageMatch ? languageMatch[1] : &amp;#39;typescript&amp;#39;;

  const appSpec: AppSpec &#x3D; {
    product: { name: productName },
    config: { language },
    ui: { routes: [] },
    locators: {},
    flows: [],
  };

  return {
    schema: schemaVersion,
    app: appSpec,
  };
}

/**
 * Generate app-centric artifacts from app specification
 */
async function generateAppArtifacts(
  appSpec: AppSpec,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  console.log(chalk.green(&#x60;ğŸ“± Generating artifacts for: ${appSpec.product.name}&#x60;));

  // Generate app structure based on routes and flows
  if (appSpec.ui.routes.length &amp;gt; 0) {
    const routeFiles &#x3D; await generateUIComponents(appSpec, outputDir, options);
    files.push(...routeFiles);
  }

  // Generate test cases from flows
  if (appSpec.flows.length &amp;gt; 0) {
    const testFiles &#x3D; await generateFlowBasedTests(appSpec, outputDir, options);
    files.push(...testFiles);
  }

  // Generate API specs from components and paths
  if (appSpec.components || appSpec.paths) {
    const apiFiles &#x3D; await generateAPISpecifications(appSpec, outputDir, options);
    files.push(...apiFiles);
  }

  // Generate locator definitions for UI testing
  if (Object.keys(appSpec.locators).length &amp;gt; 0) {
    const locatorFiles &#x3D; await generateLocatorDefinitions(appSpec, outputDir, options);
    files.push(...locatorFiles);
  }

  // Generate service structures
  if (appSpec.services &amp;amp;&amp;amp; Object.keys(appSpec.services).length &amp;gt; 0) {
    const serviceFiles &#x3D; await generateServiceStructures(appSpec, outputDir, options);
    files.push(...serviceFiles);
  }

  // Generate basic project structure
  const structFiles &#x3D; await generateProjectStructure(appSpec, outputDir, options);
  files.push(...structFiles);

  return files;
}

/**
 * Generate UI components from app spec routes
 */
async function generateUIComponents(
  appSpec: AppSpec,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  // Determine language from options or app config
  const language &#x3D; options.format || appSpec.config?.language || &amp;#39;typescript&amp;#39;;

  console.log(chalk.blue(&#x60;ğŸ¨ Generating ${language} UI components from routes...&#x60;));

  // Check if language plugin supports components
  const plugin &#x3D; languageRegistry.get(language);
  if (!plugin?.capabilities?.components) {
    console.log(
      chalk.yellow(&#x60;âš ï¸  Language &amp;#39;${language}&amp;#39; doesn&amp;#39;t support UI components, skipping...&#x60;)
    );
    return files;
  }

  // Generate components for each route using language plugin
  for (const route of appSpec.ui.routes) {
    const componentName &#x3D; route.id
      .split(&amp;#39;:&amp;#39;)
      .map(part &#x3D;&amp;gt; part.charAt(0).toUpperCase() + part.slice(1))
      .join(&amp;#39;&amp;#39;);

    try {
      const result &#x3D; await generateComponent(language, {
        name: componentName,
        type: &amp;#39;page&amp;#39;,
        props: (route.capabilities || []).map(capability &#x3D;&amp;gt; ({
          name: capability,
          type: &amp;#39;boolean&amp;#39;,
          required: false,
        })),
        styles: true,
        tests: true,
      });

      if (!options.dryRun) {
        for (const file of result.files) {
          const fullPath &#x3D; path.join(outputDir, file.path);
          await fs.ensureDir(path.dirname(fullPath));
          await fs.writeFile(fullPath, file.content);
        }
      }

      files.push(...result.files.map(file &#x3D;&amp;gt; file.path));
    } catch (error) {
      console.error(chalk.red(&#x60;âŒ Failed to generate component ${componentName}:&#x60;), error);
    }
  }

  return files;
}

/**
 * Generate test cases based on app flows
 */
async function generateFlowBasedTests(
  appSpec: AppSpec,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  console.log(chalk.blue(&amp;#39;ğŸ§ª Generating tests from flows...&amp;#39;));

  // Determine language for test generation
  const language &#x3D; appSpec.config?.language || &amp;#39;typescript&amp;#39;;
  const plugin &#x3D; languageRegistry.get(language);

  if (!plugin) {
    console.log(
      chalk.yellow(&#x60;âš ï¸  No plugin available for ${language}, using default Playwright tests&#x60;)
    );
  }

  const testsDir &#x3D; path.join(outputDir, &amp;#39;tests&amp;#39;, &amp;#39;flows&amp;#39;);
  if (!fs.existsSync(testsDir) &amp;amp;&amp;amp; !options.dryRun) {
    fs.mkdirSync(testsDir, { recursive: true });
  }

  for (const flow of appSpec.flows) {
    // Use plugin-specific test generation if available, otherwise fallback to default
    let testContent: string;

    if (plugin?.capabilities?.testing) {
      // Generate using language plugin
      const testConfig &#x3D; {
        name: flow.id,
        type: &amp;#39;e2e&amp;#39;,
        framework: &amp;#39;playwright&amp;#39;,
        flow: flow,
        locators: appSpec.locators,
      };

      try {
        // Note: This would need to be implemented in each language plugin
        testContent &#x3D; &#x60;// ${flow.id} flow test - Generated by Arbiter (${plugin.name})
// TODO: Implement plugin-specific test generation
import { test, expect } from &amp;#39;@playwright/test&amp;#39;;&#x60;;
      } catch (error) {
        console.warn(
          chalk.yellow(&#x60;âš ï¸  Plugin test generation failed, using default: ${error.message}&#x60;)
        );
        testContent &#x3D; generateDefaultFlowTest(flow, appSpec.locators);
      }
    } else {
      testContent &#x3D; generateDefaultFlowTest(flow, appSpec.locators);
    }

    const testPath &#x3D; path.join(testsDir, &#x60;${flow.id.replace(/:/g, &amp;#39;_&amp;#39;)}.test.ts&#x60;);
    if (!options.dryRun) {
      fs.writeFileSync(testPath, testContent);
    }
    files.push(&#x60;tests/flows/${flow.id.replace(/:/g, &amp;#39;_&amp;#39;)}.test.ts&#x60;);
  }

  return files;
}

/**
 * Generate default Playwright test content
 */
function generateDefaultFlowTest(flow: any, locators: any): string {
  const preconditionsCode &#x3D; flow.preconditions
    ? &#x60;
  test.beforeEach(async ({ page }) &#x3D;&amp;gt; {
    // Setup preconditions
    ${flow.preconditions.role ? &#x60;// Role: ${flow.preconditions.role}&#x60; : &amp;#39;&amp;#39;}
    ${flow.preconditions.env ? &#x60;// Environment: ${flow.preconditions.env}&#x60; : &amp;#39;&amp;#39;}
    ${
      flow.preconditions.seed
        ? flow.preconditions.seed
            .map((seed: any) &#x3D;&amp;gt; &#x60;// Seed: ${seed.factory} as ${seed.as}&#x60;)
            .join(&amp;#39;\n    &amp;#39;)
        : &amp;#39;&amp;#39;
    }
  });
  &#x60;
    : &amp;#39;&amp;#39;;

  const stepsCode &#x3D; flow.steps
    .map((step: any, index: number) &#x3D;&amp;gt; {
      if (step.visit) {
        return &#x60;// Step ${index + 1}: Visit ${step.visit}
    await page.goto(&amp;#39;${typeof step.visit &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39; ? step.visit : &#x60;/${step.visit.replace(&amp;#39;:&amp;#39;, &amp;#39;/&amp;#39;)}&#x60;}&amp;#39;);&#x60;;
      }
      if (step.click) {
        const locator &#x3D; locators[step.click];
        return &#x60;// Step ${index + 1}: Click ${step.click}
    await page.click(&amp;#39;${locator || step.click}&amp;#39;);&#x60;;
      }
      if (step.fill) {
        const locator &#x3D; locators[step.fill.locator];
        return &#x60;// Step ${index + 1}: Fill ${step.fill.locator} with &amp;quot;${step.fill.value}&amp;quot;
    await page.fill(&amp;#39;${locator || step.fill.locator}&amp;#39;, &amp;#39;${step.fill.value}&amp;#39;);&#x60;;
      }
      if (step.expect) {
        const locator &#x3D; locators[step.expect.locator];
        return &#x60;// Step ${index + 1}: Expect ${step.expect.locator} to be ${step.expect.state || &amp;#39;visible&amp;#39;}
    await expect(page.locator(&amp;#39;${locator || step.expect.locator}&amp;#39;)).${step.expect.state &#x3D;&#x3D;&#x3D; &amp;#39;visible&amp;#39; ? &amp;#39;toBeVisible&amp;#39; : &#x60;toHaveAttribute(&amp;#39;data-state&amp;#39;, &amp;#39;${step.expect.state}&amp;#39;)&#x60;}();&#x60;;
      }
      if (step.expect_api) {
        return &#x60;// Step ${index + 1}: Expect API ${step.expect_api.method} ${step.expect_api.path} to return ${step.expect_api.status}
    // TODO: Implement API expectation&#x60;;
      }
      return &#x60;// Step ${index + 1}: Unknown step type&#x60;;
    })
    .join(&amp;#39;\n    &amp;#39;);

  const variantsCode &#x3D; flow.variants
    ? flow.variants
        .map(
          (variant: any) &#x3D;&amp;gt; &#x60;
  test(&amp;#39;${flow.id} - ${variant.name} variant&amp;#39;, async ({ page }) &#x3D;&amp;gt; {
    // TODO: Implement variant testing with override: ${JSON.stringify(variant.override)}
  });&#x60;
        )
        .join(&amp;#39;&amp;#39;)
    : &amp;#39;&amp;#39;;

  return &#x60;// ${flow.id} flow test - Generated by Arbiter
import { test, expect } from &amp;#39;@playwright/test&amp;#39;;

test.describe(&amp;#39;${flow.id} flow&amp;#39;, () &#x3D;&amp;gt; {${preconditionsCode}
  
  test(&amp;#39;${flow.id} - main flow&amp;#39;, async ({ page }) &#x3D;&amp;gt; {
    ${stepsCode}
  });${variantsCode}
});
&#x60;;
}

/**
 * Generate API specifications from components and paths
 */
async function generateAPISpecifications(
  appSpec: AppSpec,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  console.log(chalk.blue(&amp;#39;ğŸ“‹ Generating API specifications...&amp;#39;));

  // Determine language for API generation
  const language &#x3D; appSpec.config?.language || &amp;#39;typescript&amp;#39;;
  const plugin &#x3D; languageRegistry.get(language);

  const apiDir &#x3D; path.join(outputDir, &amp;#39;api&amp;#39;);
  if (!fs.existsSync(apiDir) &amp;amp;&amp;amp; !options.dryRun) {
    fs.mkdirSync(apiDir, { recursive: true });
  }

  // Generate API services using language plugin if available
  if (plugin?.capabilities?.api &amp;amp;&amp;amp; appSpec.components) {
    console.log(chalk.blue(&#x60;ğŸš€ Generating ${language} API services using ${plugin.name}...&#x60;));

    // Generate services for each component that has API methods
    for (const [componentName, component] of Object.entries(appSpec.components || {})) {
      if (component.methods &amp;amp;&amp;amp; component.methods.length &amp;gt; 0) {
        const serviceConfig: LanguageServiceConfig &#x3D; {
          name: componentName,
          type: &amp;#39;api&amp;#39;,
          methods: component.methods,
          validation: true,
        };

        try {
          const result &#x3D; await generateService(language, serviceConfig);

          // Write all generated files
          for (const file of result.files) {
            const fullPath &#x3D; path.join(apiDir, file.path.replace(/^src\//i, &amp;#39;&amp;#39;));
            const dir &#x3D; path.dirname(fullPath);

            if (!fs.existsSync(dir) &amp;amp;&amp;amp; !options.dryRun) {
              fs.mkdirSync(dir, { recursive: true });
            }

            if (!options.dryRun) {
              fs.writeFileSync(fullPath, file.content);
            }

            files.push(&#x60;api/${file.path.replace(/^src\//i, &amp;#39;&amp;#39;)}&#x60;);
          }
        } catch (error) {
          console.error(
            chalk.red(&#x60;âŒ Failed to generate ${language} service for ${componentName}:&#x60;),
            error.message
          );
        }
      }
    }
  }

  // Generate OpenAPI spec if paths are defined (universal, not language-specific)
  if (appSpec.paths) {
    const openApiSpec &#x3D; {
      openapi: &amp;#39;3.0.3&amp;#39;,
      info: {
        title: appSpec.product.name,
        version: &amp;#39;1.0.0&amp;#39;,
        description: appSpec.product.goals?.join(&amp;#39;; &amp;#39;) || &amp;#39;Generated API specification&amp;#39;,
      },
      paths: {} as Record&amp;lt;string, any&amp;gt;,
      components: { schemas: {} as Record&amp;lt;string, any&amp;gt; },
    };

    // Add component schemas if available
    if (appSpec.components?.schemas) {
      openApiSpec.components.schemas &#x3D; Object.fromEntries(
        Object.entries(appSpec.components.schemas).map(([name, schema]) &#x3D;&amp;gt; [
          name,
          {
            type: &amp;#39;object&amp;#39;,
            example: schema.example,
            ...(schema.examples &amp;amp;&amp;amp; { examples: schema.examples }),
          },
        ])
      );
    }

    // Convert paths to OpenAPI format
    for (const [pathKey, pathSpec] of Object.entries(appSpec.paths)) {
      openApiSpec.paths[pathKey] &#x3D; {};

      for (const [method, operation] of Object.entries(pathSpec)) {
        openApiSpec.paths[pathKey][method] &#x3D; {
          summary: &#x60;${method.toUpperCase()} ${pathKey}&#x60;,
          ...(operation.request &amp;amp;&amp;amp; {
            requestBody: {
              content: {
                &amp;#39;application/json&amp;#39;: {
                  schema: operation.request.$ref ? { $ref: operation.request.$ref } : {},
                  example: operation.request.example,
                },
              },
            },
          }),
          responses: {
            [operation.status || (method &#x3D;&#x3D;&#x3D; &amp;#39;get&amp;#39; ? 200 : 201)]: {
              description: &amp;#39;Success&amp;#39;,
              content: {
                &amp;#39;application/json&amp;#39;: {
                  schema: operation.response?.$ref ? { $ref: operation.response.$ref } : {},
                  example: operation.response?.example,
                },
              },
            },
          },
        };
      }
    }

    const specPath &#x3D; path.join(apiDir, &amp;#39;openapi.json&amp;#39;);
    if (!options.dryRun) {
      fs.writeFileSync(specPath, JSON.stringify(openApiSpec, null, 2));
    }
    files.push(&amp;#39;api/openapi.json&amp;#39;);
  }

  return files;
}

/**
 * Generate locator definitions for UI testing
 */
async function generateLocatorDefinitions(
  appSpec: AppSpec,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  console.log(chalk.blue(&amp;#39;ğŸ¯ Generating locator definitions...&amp;#39;));

  const locatorsContent &#x3D; &#x60;// UI Locators - Generated by Arbiter
// These locators provide a stable contract between tests and UI implementation

export const locators &#x3D; {
${Object.entries(appSpec.locators)
  .map(([token, selector]) &#x3D;&amp;gt; &#x60;  &amp;#39;${token}&amp;#39;: &amp;#39;${selector}&amp;#39;,&#x60;)
  .join(&amp;#39;\n&amp;#39;)}
} as const;

export type LocatorToken &#x3D; keyof typeof locators;

// Helper function to get locator by token
export function getLocator(token: LocatorToken): string {
  return locators[token];
}

// Type-safe locator access
export function loc(token: LocatorToken): string {
  return locators[token];
}
&#x60;;

  const locatorsPath &#x3D; path.join(outputDir, &amp;#39;src&amp;#39;, &amp;#39;test-utils&amp;#39;, &amp;#39;locators.ts&amp;#39;);
  const locatorsDir &#x3D; path.dirname(locatorsPath);

  if (!fs.existsSync(locatorsDir) &amp;amp;&amp;amp; !options.dryRun) {
    fs.mkdirSync(locatorsDir, { recursive: true });
  }

  if (!options.dryRun) {
    fs.writeFileSync(locatorsPath, locatorsContent);
  }
  files.push(&amp;#39;src/test-utils/locators.ts&amp;#39;);

  return files;
}

/**
 * Generate project structure
 */
async function generateProjectStructure(
  appSpec: AppSpec,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  // Determine language from app spec config
  const language &#x3D; appSpec.config?.language || &amp;#39;typescript&amp;#39;;
  const plugin &#x3D; languageRegistry.get(language);

  if (plugin) {
    console.log(chalk.blue(&#x60;ğŸ“¦ Initializing ${language} project using ${plugin.name}...&#x60;));

    // Create project configuration for the language plugin
    const projectConfig: LanguageProjectConfig &#x3D; {
      name: appSpec.product.name.toLowerCase().replace(/\s+/g, &amp;#39;-&amp;#39;),
      description: appSpec.product.goals?.join(&amp;#39;; &amp;#39;) || &amp;#39;Generated by Arbiter&amp;#39;,
      features: [],
      testing: true,
    };

    try {
      const result &#x3D; await initializeProject(language, projectConfig);

      // Write all generated files from the language plugin
      for (const file of result.files) {
        const fullPath &#x3D; path.join(outputDir, file.path);
        const dir &#x3D; path.dirname(fullPath);

        if (!fs.existsSync(dir) &amp;amp;&amp;amp; !options.dryRun) {
          fs.mkdirSync(dir, { recursive: true });
        }

        if (!options.dryRun) {
          fs.writeFileSync(fullPath, file.content);
        }

        files.push(file.path);
      }

      // Log additional setup instructions from the language plugin
      if (result.instructions) {
        result.instructions.forEach(instruction &#x3D;&amp;gt; console.log(chalk.green(&#x60;âœ… ${instruction}&#x60;)));
      }
    } catch (error) {
      console.error(chalk.red(&#x60;âŒ Failed to initialize ${language} project:&#x60;), error.message);
      return files;
    }
  } else {
    console.log(
      chalk.yellow(&#x60;âš ï¸  No language plugin available for &amp;#39;${language}&amp;#39;, using minimal structure&#x60;)
    );

    // Fallback: create minimal project structure
    const packageJson &#x3D; {
      name: appSpec.product.name.toLowerCase().replace(/\s+/g, &amp;#39;-&amp;#39;),
      version: &amp;#39;1.0.0&amp;#39;,
      description: appSpec.product.goals?.join(&amp;#39;; &amp;#39;) || &amp;#39;Generated by Arbiter&amp;#39;,
    };

    const packagePath &#x3D; path.join(outputDir, &amp;#39;package.json&amp;#39;);
    if (!options.dryRun) {
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2));
    }
    files.push(&amp;#39;package.json&amp;#39;);
  }

  // Generate README
  const readmeContent &#x3D; &#x60;# ${appSpec.product.name}

Generated by Arbiter from app specification.

## Overview

${appSpec.product.goals ? appSpec.product.goals.map(goal &#x3D;&amp;gt; &#x60;- ${goal}&#x60;).join(&amp;#39;\n&amp;#39;) : &amp;#39;No goals specified&amp;#39;}

${
  appSpec.product.constraints
    ? &#x60;
## Constraints

${appSpec.product.constraints.map(constraint &#x3D;&amp;gt; &#x60;- ${constraint}&#x60;).join(&amp;#39;\n&amp;#39;)}
&#x60;
    : &amp;#39;&amp;#39;
}

## Routes

${appSpec.ui.routes.map(route &#x3D;&amp;gt; &#x60;- **${route.path}** (${route.id}): ${route.capabilities.join(&amp;#39;, &amp;#39;)}&#x60;).join(&amp;#39;\n&amp;#39;)}

## Flows

${appSpec.flows.map(flow &#x3D;&amp;gt; &#x60;- **${flow.id}**: ${flow.steps.length} steps&#x60;).join(&amp;#39;\n&amp;#39;)}

## Development

\&#x60;\&#x60;\&#x60;bash
npm install
npm run dev
\&#x60;\&#x60;\&#x60;

## Testing

\&#x60;\&#x60;\&#x60;bash
npm run test        # Playwright tests
npm run test:unit   # Unit tests
\&#x60;\&#x60;\&#x60;

## Build

\&#x60;\&#x60;\&#x60;bash
npm run build
\&#x60;\&#x60;\&#x60;
&#x60;;

  const readmePath &#x3D; path.join(outputDir, &amp;#39;README.md&amp;#39;);
  if (!options.dryRun) {
    fs.writeFileSync(readmePath, readmeContent);
  }
  files.push(&amp;#39;README.md&amp;#39;);

  return files;
}

/**
 * Generate service structures from app specification
 */
async function generateServiceStructures(
  appSpec: AppSpec,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  if (!appSpec.services || Object.keys(appSpec.services).length &#x3D;&#x3D;&#x3D; 0) {
    return files;
  }

  console.log(chalk.blue(&amp;#39;ğŸ”§ Generating service structures...&amp;#39;));

  // Process each service
  for (const [serviceName, service] of Object.entries(appSpec.services)) {
    if (service.serviceType &#x3D;&#x3D;&#x3D; &amp;#39;bespoke&amp;#39; &amp;amp;&amp;amp; service.sourceDirectory) {
      const serviceDir &#x3D; path.join(outputDir, service.sourceDirectory);

      console.log(
        chalk.dim(&#x60;  â€¢ ${serviceName} (${service.language}) -&amp;gt; ${service.sourceDirectory}&#x60;)
      );

      // Create service directory
      if (!fs.existsSync(serviceDir) &amp;amp;&amp;amp; !options.dryRun) {
        fs.mkdirSync(serviceDir, { recursive: true });
      }

      // Generate language-specific project structure
      if (service.language &#x3D;&#x3D;&#x3D; &amp;#39;rust&amp;#39;) {
        const rustFiles &#x3D; await generateRustFiles(
          { name: serviceName, version: &amp;#39;1.0.0&amp;#39; },
          serviceDir,
          options
        );
        files.push(...rustFiles.map(file &#x3D;&amp;gt; path.join(service.sourceDirectory, file)));
      } else if (service.language &#x3D;&#x3D;&#x3D; &amp;#39;typescript&amp;#39;) {
        const tsFiles &#x3D; await generateTypeScriptFiles(
          { name: serviceName, version: &amp;#39;1.0.0&amp;#39; },
          serviceDir,
          options
        );
        files.push(...tsFiles.map(file &#x3D;&amp;gt; path.join(service.sourceDirectory, file)));
      } else if (service.language &#x3D;&#x3D;&#x3D; &amp;#39;go&amp;#39;) {
        const goFiles &#x3D; await generateGoFiles(
          { name: serviceName, version: &amp;#39;1.0.0&amp;#39; },
          serviceDir,
          options
        );
        files.push(...goFiles.map(file &#x3D;&amp;gt; path.join(service.sourceDirectory, file)));
      } else if (service.language &#x3D;&#x3D;&#x3D; &amp;#39;python&amp;#39;) {
        const pythonFiles &#x3D; await generatePythonFiles(
          { name: serviceName, version: &amp;#39;1.0.0&amp;#39; },
          serviceDir,
          options
        );
        files.push(...pythonFiles.map(file &#x3D;&amp;gt; path.join(service.sourceDirectory, file)));
      }
    }
  }

  return files;
}

/**
 * Generate language-specific files
 */
async function generateLanguageFiles(
  config: any,
  outputDir: string,
  options: GenerateOptions,
  assemblyConfig?: any
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  // Use language plugin system for code generation
  const language &#x3D; config.language || &amp;#39;typescript&amp;#39;;
  const plugin &#x3D; languageRegistry.get(language);

  if (plugin) {
    console.log(chalk.blue(&#x60;ğŸ“¦ Generating ${language} project using ${plugin.name}...&#x60;));

    // Initialize project using the language plugin
    const projectConfig: LanguageProjectConfig &#x3D; {
      name: config.name,
      description: config.description,
      features: config.features || [],
      testing: config.testing !&#x3D;&#x3D; false,
    };

    try {
      const result &#x3D; await initializeProject(language, projectConfig);

      // Write all generated files
      for (const file of result.files) {
        const fullPath &#x3D; path.join(outputDir, file.path);
        const dir &#x3D; path.dirname(fullPath);

        if (!fs.existsSync(dir) &amp;amp;&amp;amp; !options.dryRun) {
          fs.mkdirSync(dir, { recursive: true });
        }

        if (!options.dryRun) {
          fs.writeFileSync(fullPath, file.content);
        }

        files.push(file.path);
      }

      // Log additional setup instructions
      if (result.instructions) {
        result.instructions.forEach(instruction &#x3D;&amp;gt; console.log(chalk.green(&#x60;âœ… ${instruction}&#x60;)));
      }
    } catch (error) {
      console.error(chalk.red(&#x60;âŒ Failed to generate ${language} project:&#x60;), error.message);
      // Fallback to legacy generation for unsupported languages
      if (language &#x3D;&#x3D;&#x3D; &amp;#39;shell&amp;#39; || language &#x3D;&#x3D;&#x3D; &amp;#39;bash&amp;#39;) {
        files.push(...(await generateShellFiles(config, outputDir, options)));
      }
    }
  } else {
    console.log(chalk.yellow(&#x60;âš ï¸  No plugin available for language: ${language}&#x60;));
    // Fallback for unsupported languages
    if (language &#x3D;&#x3D;&#x3D; &amp;#39;shell&amp;#39; || language &#x3D;&#x3D;&#x3D; &amp;#39;bash&amp;#39;) {
      files.push(...(await generateShellFiles(config, outputDir, options)));
    }
  }

  // Generate deployment artifacts based on deployment target
  if (config.deploymentTarget) {
    switch (config.deploymentTarget) {
      case &amp;#39;kubernetes&amp;#39;:
      case &amp;#39;k8s&amp;#39;:
        console.log(chalk.blue(&amp;#39;ğŸš€ Generating Kubernetes deployment (Terraform)...&amp;#39;));
        files.push(
          ...(await generateTerraformKubernetes(config, outputDir, assemblyConfig, options))
        );
        break;
      case &amp;#39;aws&amp;#39;:
        console.log(chalk.blue(&amp;#39;ğŸš€ Generating AWS deployment...&amp;#39;));
        // AWS-specific deployment logic would go here
        files.push(
          ...(await generateTerraformKubernetes(config, outputDir, assemblyConfig, options))
        );
        break;
      case &amp;#39;gcp&amp;#39;:
        console.log(chalk.blue(&amp;#39;ğŸš€ Generating GCP deployment...&amp;#39;));
        // GCP-specific deployment logic would go here
        files.push(
          ...(await generateTerraformKubernetes(config, outputDir, assemblyConfig, options))
        );
        break;
      default:
        console.log(
          chalk.yellow(
            &#x60;âš ï¸  Unknown deployment target: ${config.deploymentTarget}. Defaulting to Kubernetes.&#x60;
          )
        );
        files.push(
          ...(await generateTerraformKubernetes(config, outputDir, assemblyConfig, options))
        );
    }
  }

  // Generate testing artifacts (Docker Compose for local development)
  const cueData &#x3D; assemblyConfig._fullCueData?.arbiterSpec;
  const testingArtifacts &#x3D; cueData?.deployment?.testing?.artifacts || [];

  if (testingArtifacts.includes(&amp;#39;compose&amp;#39;) || cueData?.deployment?.testing?.localDevelopment) {
    console.log(chalk.green(&amp;#39;ğŸ§ª Generating Docker Compose for local testing and development...&amp;#39;));
    files.push(...(await generateDockerCompose(config, outputDir, assemblyConfig, options)));
  }

  return files;
}

/**
 * Generate TypeScript project files
 */
async function generateTypeScriptFiles(
  config: any,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  // package.json
  const packageJson &#x3D; {
    name: config.name,
    version: config.version,
    type: &amp;#39;module&amp;#39;,
    scripts: {
      build: config.buildTool &#x3D;&#x3D;&#x3D; &amp;#39;bun&amp;#39; ? &amp;#39;bun build&amp;#39; : &amp;#39;npm run build&amp;#39;,
      test: config.buildTool &#x3D;&#x3D;&#x3D; &amp;#39;bun&amp;#39; ? &amp;#39;bun test&amp;#39; : &amp;#39;npm test&amp;#39;,
      lint: &amp;#39;eslint src/**/*.ts&amp;#39;,
      typecheck: &amp;#39;tsc --noEmit&amp;#39;,
    },
    devDependencies: {
      &amp;#39;@types/node&amp;#39;: &amp;#39;^20.0.0&amp;#39;,
      typescript: &amp;#39;^5.0.0&amp;#39;,
      eslint: &amp;#39;^8.0.0&amp;#39;,
    },
  };

  const packagePath &#x3D; path.join(outputDir, &amp;#39;package.json&amp;#39;);
  if (!options.dryRun) {
    fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2));
  }
  files.push(&amp;#39;package.json&amp;#39;);

  // tsconfig.json
  const tsconfigJson &#x3D; {
    compilerOptions: {
      target: &amp;#39;ES2022&amp;#39;,
      module: &amp;#39;ESNext&amp;#39;,
      moduleResolution: &amp;#39;bundler&amp;#39;,
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
      outDir: &amp;#39;./dist&amp;#39;,
      rootDir: &amp;#39;./src&amp;#39;,
    },
    include: [&amp;#39;src/**/*&amp;#39;],
    exclude: [&amp;#39;node_modules&amp;#39;, &amp;#39;dist&amp;#39;, &amp;#39;tests&amp;#39;],
  };

  const tsconfigPath &#x3D; path.join(outputDir, &amp;#39;tsconfig.json&amp;#39;);
  if (!options.dryRun) {
    fs.writeFileSync(tsconfigPath, JSON.stringify(tsconfigJson, null, 2));
  }
  files.push(&amp;#39;tsconfig.json&amp;#39;);

  // Create src directory and basic file
  const srcDir &#x3D; path.join(outputDir, &amp;#39;src&amp;#39;);
  if (!fs.existsSync(srcDir) &amp;amp;&amp;amp; !options.dryRun) {
    fs.mkdirSync(srcDir, { recursive: true });
  }

  const indexContent &#x3D; &#x60;/**
 * ${config.name} - Generated by Arbiter
 * Version: ${config.version}
 */

export function main(): void {
  console.log(&amp;#39;Hello from ${config.name}!&amp;#39;);
}

// Auto-run if this file is executed directly
if (import.meta.url &#x3D;&#x3D;&#x3D; \&#x60;file://\${process.argv[1]}\&#x60;) {
  main();
}
&#x60;;

  const indexPath &#x3D; path.join(srcDir, &amp;#39;index.ts&amp;#39;);
  if (!options.dryRun) {
    fs.writeFileSync(indexPath, indexContent);
  }
  files.push(&amp;#39;src/index.ts&amp;#39;);

  // Create tests directory
  const testsDir &#x3D; path.join(outputDir, &amp;#39;tests&amp;#39;);
  if (!fs.existsSync(testsDir) &amp;amp;&amp;amp; !options.dryRun) {
    fs.mkdirSync(testsDir, { recursive: true });
  }
  files.push(&amp;#39;tests/&amp;#39;);

  return files;
}

/**
 * Generate Python project files
 */
async function generatePythonFiles(
  config: any,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  // pyproject.toml
  const pyprojectToml &#x3D; &#x60;[build-system]
requires &#x3D; [&amp;quot;setuptools&amp;gt;&#x3D;45&amp;quot;, &amp;quot;wheel&amp;quot;]
build-backend &#x3D; &amp;quot;setuptools.build_meta&amp;quot;

[project]
name &#x3D; &amp;quot;${config.name}&amp;quot;
version &#x3D; &amp;quot;${config.version}&amp;quot;
description &#x3D; &amp;quot;Generated by Arbiter&amp;quot;
requires-python &#x3D; &amp;quot;&amp;gt;&#x3D;3.8&amp;quot;

[project.scripts]
${config.name} &#x3D; &amp;quot;${config.name}.main:main&amp;quot;

[tool.pytest.ini_options]
testpaths &#x3D; [&amp;quot;tests&amp;quot;]
python_files &#x3D; [&amp;quot;test_*.py&amp;quot;]
&#x60;;

  const pyprojectPath &#x3D; path.join(outputDir, &amp;#39;pyproject.toml&amp;#39;);
  if (!options.dryRun) {
    fs.writeFileSync(pyprojectPath, pyprojectToml);
  }
  files.push(&amp;#39;pyproject.toml&amp;#39;);

  // requirements.txt
  const requirementsContent &#x3D; &#x60;# Generated by Arbiter
pytest&amp;gt;&#x3D;7.0.0
&#x60;;

  const requirementsPath &#x3D; path.join(outputDir, &amp;#39;requirements.txt&amp;#39;);
  if (!options.dryRun) {
    fs.writeFileSync(requirementsPath, requirementsContent);
  }
  files.push(&amp;#39;requirements.txt&amp;#39;);

  // Create src directory
  const srcDir &#x3D; path.join(outputDir, &amp;#39;src&amp;#39;, config.name);
  if (!fs.existsSync(srcDir) &amp;amp;&amp;amp; !options.dryRun) {
    fs.mkdirSync(srcDir, { recursive: true });
  }

  const initContent &#x3D; &#x60;&amp;quot;&amp;quot;&amp;quot;
${config.name} - Generated by Arbiter
Version: ${config.version}
&amp;quot;&amp;quot;&amp;quot;

__version__ &#x3D; &amp;quot;${config.version}&amp;quot;
&#x60;;

  if (!options.dryRun) {
    fs.writeFileSync(path.join(srcDir, &amp;#39;__init__.py&amp;#39;), initContent);
  }
  files.push(&#x60;src/${config.name}/__init__.py&#x60;);

  const mainContent &#x3D; &#x60;&amp;quot;&amp;quot;&amp;quot;Main entry point for ${config.name}&amp;quot;&amp;quot;&amp;quot;

def main():
    &amp;quot;&amp;quot;&amp;quot;Main function&amp;quot;&amp;quot;&amp;quot;
    print(f&amp;quot;Hello from ${config.name}!&amp;quot;)

if __name__ &#x3D;&#x3D; &amp;quot;__main__&amp;quot;:
    main()
&#x60;;

  if (!options.dryRun) {
    fs.writeFileSync(path.join(srcDir, &amp;#39;main.py&amp;#39;), mainContent);
  }
  files.push(&#x60;src/${config.name}/main.py&#x60;);

  // Create tests directory
  const testsDir &#x3D; path.join(outputDir, &amp;#39;tests&amp;#39;);
  if (!fs.existsSync(testsDir) &amp;amp;&amp;amp; !options.dryRun) {
    fs.mkdirSync(testsDir, { recursive: true });
  }
  files.push(&amp;#39;tests/&amp;#39;);

  return files;
}

/**
 * Generate Rust project files
 */
async function generateRustFiles(
  config: any,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  // Cargo.toml
  const cargoToml &#x3D; &#x60;[package]
name &#x3D; &amp;quot;${config.name}&amp;quot;
version &#x3D; &amp;quot;${config.version}&amp;quot;
edition &#x3D; &amp;quot;2021&amp;quot;

[dependencies]

[dev-dependencies]
&#x60;;

  const cargoPath &#x3D; path.join(outputDir, &amp;#39;Cargo.toml&amp;#39;);
  if (!options.dryRun) {
    fs.writeFileSync(cargoPath, cargoToml);
  }
  files.push(&amp;#39;Cargo.toml&amp;#39;);

  // Create src directory
  const srcDir &#x3D; path.join(outputDir, &amp;#39;src&amp;#39;);
  if (!fs.existsSync(srcDir) &amp;amp;&amp;amp; !options.dryRun) {
    fs.mkdirSync(srcDir, { recursive: true });
  }

  const libContent &#x3D; &#x60;//! ${config.name} - Generated by Arbiter
//! Version: ${config.version}

pub fn main() {
    println!(&amp;quot;Hello from ${config.name}!&amp;quot;);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_main() {
        main(); // Should not panic
    }
}
&#x60;;

  if (!options.dryRun) {
    fs.writeFileSync(path.join(srcDir, &amp;#39;lib.rs&amp;#39;), libContent);
  }
  files.push(&amp;#39;src/lib.rs&amp;#39;);

  // Create tests directory
  const testsDir &#x3D; path.join(outputDir, &amp;#39;tests&amp;#39;);
  if (!fs.existsSync(testsDir) &amp;amp;&amp;amp; !options.dryRun) {
    fs.mkdirSync(testsDir, { recursive: true });
  }
  files.push(&amp;#39;tests/&amp;#39;);

  return files;
}

/**
 * Generate Go project files
 */
async function generateGoFiles(
  config: any,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  // go.mod
  const goMod &#x3D; &#x60;module ${config.name}

go 1.21

require ()
&#x60;;

  const goModPath &#x3D; path.join(outputDir, &amp;#39;go.mod&amp;#39;);
  if (!options.dryRun) {
    fs.writeFileSync(goModPath, goMod);
  }
  files.push(&amp;#39;go.mod&amp;#39;);

  // main.go
  const mainGo &#x3D; &#x60;// ${config.name} - Generated by Arbiter
// Version: ${config.version}
package main

import &amp;quot;fmt&amp;quot;

func main() {
    fmt.Println(&amp;quot;Hello from ${config.name}!&amp;quot;)
}
&#x60;;

  const mainGoPath &#x3D; path.join(outputDir, &amp;#39;main.go&amp;#39;);
  if (!options.dryRun) {
    fs.writeFileSync(mainGoPath, mainGo);
  }
  files.push(&amp;#39;main.go&amp;#39;);

  // Create test directory
  const testDir &#x3D; path.join(outputDir, &amp;#39;test&amp;#39;);
  if (!fs.existsSync(testDir) &amp;amp;&amp;amp; !options.dryRun) {
    fs.mkdirSync(testDir, { recursive: true });
  }
  files.push(&amp;#39;test/&amp;#39;);

  return files;
}

/**
 * Generate Shell/Bash project files
 */
async function generateShellFiles(
  config: any,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  // Makefile
  const makefile &#x3D; &#x60;# ${config.name} - Generated by Arbiter
# Version: ${config.version}

.PHONY: test install clean

test:
\tbash test/run_tests.sh

install:
\tcp src/${config.name} /usr/local/bin/

clean:
\trm -f *.log *.tmp
&#x60;;

  const makefilePath &#x3D; path.join(outputDir, &amp;#39;Makefile&amp;#39;);
  if (!options.dryRun) {
    fs.writeFileSync(makefilePath, makefile);
  }
  files.push(&amp;#39;Makefile&amp;#39;);

  // Create src directory
  const srcDir &#x3D; path.join(outputDir, &amp;#39;src&amp;#39;);
  if (!fs.existsSync(srcDir) &amp;amp;&amp;amp; !options.dryRun) {
    fs.mkdirSync(srcDir, { recursive: true });
  }

  const mainScript &#x3D; &#x60;#!/bin/bash
# ${config.name} - Generated by Arbiter  
# Version: ${config.version}

set -euo pipefail

main() {
    echo &amp;quot;Hello from ${config.name}!&amp;quot;
}

# Run main if script is executed directly
if [[ &amp;quot;\${BASH_SOURCE[0]}&amp;quot; &#x3D;&#x3D; &amp;quot;\${0}&amp;quot; ]]; then
    main &amp;quot;$@&amp;quot;
fi
&#x60;;

  const scriptPath &#x3D; path.join(srcDir, config.name);
  if (!options.dryRun) {
    fs.writeFileSync(scriptPath, mainScript);
    fs.chmodSync(scriptPath, 0o755); // Make executable
  }
  files.push(&#x60;src/${config.name}&#x60;);

  // Create tests directory
  const testsDir &#x3D; path.join(outputDir, &amp;#39;tests&amp;#39;);
  if (!fs.existsSync(testsDir) &amp;amp;&amp;amp; !options.dryRun) {
    fs.mkdirSync(testsDir, { recursive: true });
  }
  files.push(&amp;#39;tests/&amp;#39;);

  return files;
}

/**
 * Generate CI/CD workflows
 */
async function generateCIWorkflows(
  config: any,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  // GitHub Actions workflow
  const workflowDir &#x3D; path.join(outputDir, &amp;#39;.github&amp;#39;, &amp;#39;workflows&amp;#39;);
  if (!fs.existsSync(workflowDir) &amp;amp;&amp;amp; !options.dryRun) {
    fs.mkdirSync(workflowDir, { recursive: true });
  }

  const workflow &#x3D; &#x60;# ${config.name} CI/CD - Generated by Arbiter
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup ${config.language}
      uses: ${getSetupAction(config.language)}
      ${getSetupActionConfig(config.language)}
    
    - name: Install dependencies
      run: ${getInstallCommand(config.language, config.buildTool)}
    
    - name: Lint
      run: ${getLintCommand(config.language, config.buildTool)}
    
    - name: Test  
      run: ${getTestCommand(config.language, config.buildTool)}
    
    - name: Build
      run: ${getBuildCommand(config.language, config.buildTool)}
&#x60;;

  const workflowPath &#x3D; path.join(workflowDir, &amp;#39;ci.yml&amp;#39;);
  if (!options.dryRun) {
    fs.writeFileSync(workflowPath, workflow);
  }
  files.push(&amp;#39;.github/workflows/ci.yml&amp;#39;);

  return files;
}

/**
 * Generate documentation
 */
async function generateDocumentation(
  _config: any,
  _outputDir: string,
  _options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  // Documentation generation will be handled by the docs command
  return [];
}

// Helper functions for CI workflow generation
function getSetupAction(language: string): string {
  switch (language) {
    case &amp;#39;typescript&amp;#39;:
      return &amp;#39;actions/setup-node@v4&amp;#39;;
    case &amp;#39;python&amp;#39;:
      return &amp;#39;actions/setup-python@v4&amp;#39;;
    case &amp;#39;rust&amp;#39;:
      return &amp;#39;actions-rs/toolchain@v1&amp;#39;;
    case &amp;#39;go&amp;#39;:
      return &amp;#39;actions/setup-go@v4&amp;#39;;
    default:
      return &amp;#39;actions/setup-node@v4&amp;#39;;
  }
}

function getSetupActionConfig(language: string): string {
  switch (language) {
    case &amp;#39;typescript&amp;#39;:
      return &amp;quot;with:\n        node-version: &amp;#39;20&amp;#39;&amp;quot;;
    case &amp;#39;python&amp;#39;:
      return &amp;quot;with:\n        python-version: &amp;#39;3.11&amp;#39;&amp;quot;;
    case &amp;#39;rust&amp;#39;:
      return &amp;#39;with:\n        toolchain: stable&amp;#39;;
    case &amp;#39;go&amp;#39;:
      return &amp;quot;with:\n        go-version: &amp;#39;1.21&amp;#39;&amp;quot;;
    default:
      return &amp;quot;with:\n        node-version: &amp;#39;20&amp;#39;&amp;quot;;
  }
}

function getPrerequisites(language: string, buildTool?: string): string {
  switch (language) {
    case &amp;#39;typescript&amp;#39;:
      return buildTool &#x3D;&#x3D;&#x3D; &amp;#39;bun&amp;#39;
        ? &amp;#39;- [Bun](https://bun.sh) v1.0+&amp;#39;
        : &amp;#39;- [Node.js](https://nodejs.org) v18+\n- [npm](https://npmjs.com) or [yarn](https://yarnpkg.com)&amp;#39;;
    case &amp;#39;python&amp;#39;:
      return &amp;#39;- [Python](https://python.org) 3.8+\n- [pip](https://pip.pypa.io)&amp;#39;;
    case &amp;#39;rust&amp;#39;:
      return &amp;#39;- [Rust](https://rustup.rs) 1.70+&amp;#39;;
    case &amp;#39;go&amp;#39;:
      return &amp;#39;- [Go](https://golang.org) 1.21+&amp;#39;;
    case &amp;#39;shell&amp;#39;:
      return &amp;#39;- [Bash](https://www.gnu.org/software/bash/) 4.0+&amp;#39;;
    default:
      return &#x60;- Development environment for ${language}&#x60;;
  }
}

function getInstallCommand(language: string, buildTool?: string): string {
  switch (language) {
    case &amp;#39;typescript&amp;#39;:
      return buildTool &#x3D;&#x3D;&#x3D; &amp;#39;bun&amp;#39; ? &amp;#39;bun install&amp;#39; : &amp;#39;npm install&amp;#39;;
    case &amp;#39;python&amp;#39;:
      return &amp;#39;pip install -e .&amp;#39;;
    case &amp;#39;rust&amp;#39;:
      return &amp;#39;cargo build&amp;#39;;
    case &amp;#39;go&amp;#39;:
      return &amp;#39;go mod tidy&amp;#39;;
    case &amp;#39;shell&amp;#39;:
      return &amp;#39;make install&amp;#39;;
    default:
      return &amp;#39;echo &amp;quot;Install command not defined&amp;quot;&amp;#39;;
  }
}

function getRunCommand(language: string, buildTool?: string): string {
  switch (language) {
    case &amp;#39;typescript&amp;#39;:
      return buildTool &#x3D;&#x3D;&#x3D; &amp;#39;bun&amp;#39; ? &amp;#39;bun run src/index.ts&amp;#39; : &amp;#39;npm start&amp;#39;;
    case &amp;#39;python&amp;#39;:
      return &amp;#39;python -m &amp;#39; + &amp;#39;PLACEHOLDER&amp;#39;;
    case &amp;#39;rust&amp;#39;:
      return &amp;#39;cargo run&amp;#39;;
    case &amp;#39;go&amp;#39;:
      return &amp;#39;go run main.go&amp;#39;;
    case &amp;#39;shell&amp;#39;:
      return &amp;#39;./src/PLACEHOLDER&amp;#39;;
    default:
      return &amp;#39;echo &amp;quot;Run command not defined&amp;quot;&amp;#39;;
  }
}

function getTestCommand(language: string, buildTool?: string): string {
  switch (language) {
    case &amp;#39;typescript&amp;#39;:
      return buildTool &#x3D;&#x3D;&#x3D; &amp;#39;bun&amp;#39; ? &amp;#39;bun test&amp;#39; : &amp;#39;npm test&amp;#39;;
    case &amp;#39;python&amp;#39;:
      return &amp;#39;pytest&amp;#39;;
    case &amp;#39;rust&amp;#39;:
      return &amp;#39;cargo test&amp;#39;;
    case &amp;#39;go&amp;#39;:
      return &amp;#39;go test ./...&amp;#39;;
    case &amp;#39;shell&amp;#39;:
      return &amp;#39;make test&amp;#39;;
    default:
      return &amp;#39;echo &amp;quot;Test command not defined&amp;quot;&amp;#39;;
  }
}

function getBuildCommand(language: string, buildTool?: string): string {
  switch (language) {
    case &amp;#39;typescript&amp;#39;:
      return buildTool &#x3D;&#x3D;&#x3D; &amp;#39;bun&amp;#39; ? &amp;#39;bun build&amp;#39; : &amp;#39;npm run build&amp;#39;;
    case &amp;#39;python&amp;#39;:
      return &amp;#39;python -m build&amp;#39;;
    case &amp;#39;rust&amp;#39;:
      return &amp;#39;cargo build --release&amp;#39;;
    case &amp;#39;go&amp;#39;:
      return &amp;#39;go build&amp;#39;;
    case &amp;#39;shell&amp;#39;:
      return &amp;#39;echo &amp;quot;No build step needed&amp;quot;&amp;#39;;
    default:
      return &amp;#39;echo &amp;quot;Build command not defined&amp;quot;&amp;#39;;
  }
}

function getLintCommand(language: string, buildTool?: string): string {
  switch (language) {
    case &amp;#39;typescript&amp;#39;:
      return buildTool &#x3D;&#x3D;&#x3D; &amp;#39;bun&amp;#39; ? &amp;#39;bun run lint&amp;#39; : &amp;#39;npm run lint&amp;#39;;
    case &amp;#39;python&amp;#39;:
      return &amp;#39;ruff check . &amp;amp;&amp;amp; mypy .&amp;#39;;
    case &amp;#39;rust&amp;#39;:
      return &amp;#39;cargo clippy -- -D warnings&amp;#39;;
    case &amp;#39;go&amp;#39;:
      return &amp;#39;golangci-lint run&amp;#39;;
    case &amp;#39;shell&amp;#39;:
      return &amp;#39;shellcheck src/*&amp;#39;;
    default:
      return &amp;#39;echo &amp;quot;Lint command not defined&amp;quot;&amp;#39;;
  }
}

// Terraform + Kubernetes generation
async function generateTerraformKubernetes(
  config: any,
  outputDir: string,
  assemblyConfig: any,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];
  await fs.ensureDir(path.join(outputDir, &amp;#39;terraform&amp;#39;));

  // Parse assembly to extract services and cluster references
  const { services, cluster } &#x3D; parseDeploymentServices(assemblyConfig);

  // Generate main.tf with provider configuration
  const mainTf &#x3D; generateTerraformMain(cluster, config.name);
  const mainPath &#x3D; path.join(outputDir, &amp;#39;terraform&amp;#39;, &amp;#39;main.tf&amp;#39;);
  if (!options.dryRun) {
    await fs.writeFile(mainPath, mainTf);
  }
  files.push(&amp;#39;terraform/main.tf&amp;#39;);

  // Generate variables.tf
  const variablesTf &#x3D; generateTerraformVariables(services, cluster);
  const variablesPath &#x3D; path.join(outputDir, &amp;#39;terraform&amp;#39;, &amp;#39;variables.tf&amp;#39;);
  if (!options.dryRun) {
    await fs.writeFile(variablesPath, variablesTf);
  }
  files.push(&amp;#39;terraform/variables.tf&amp;#39;);

  // Generate services.tf with Kubernetes resources
  const servicesTf &#x3D; generateTerraformServices(services, config.name);
  const servicesPath &#x3D; path.join(outputDir, &amp;#39;terraform&amp;#39;, &amp;#39;services.tf&amp;#39;);
  if (!options.dryRun) {
    await fs.writeFile(servicesPath, servicesTf);
  }
  files.push(&amp;#39;terraform/services.tf&amp;#39;);

  // Generate outputs.tf
  const outputsTf &#x3D; generateTerraformOutputs(services, config.name);
  const outputsPath &#x3D; path.join(outputDir, &amp;#39;terraform&amp;#39;, &amp;#39;outputs.tf&amp;#39;);
  if (!options.dryRun) {
    await fs.writeFile(outputsPath, outputsTf);
  }
  files.push(&amp;#39;terraform/outputs.tf&amp;#39;);

  // Generate README for Terraform deployment
  const readme &#x3D; generateTerraformReadme(services, cluster, config.name);
  const readmePath &#x3D; path.join(outputDir, &amp;#39;terraform&amp;#39;, &amp;#39;README.md&amp;#39;);
  if (!options.dryRun) {
    await fs.writeFile(readmePath, readme);
  }
  files.push(&amp;#39;terraform/README.md&amp;#39;);

  return files;
}

function parseDeploymentServices(assemblyConfig: any): {
  services: DeploymentService[];
  cluster: ClusterConfig | null;
} {
  const services: DeploymentService[] &#x3D; [];
  let cluster: ClusterConfig | null &#x3D; null;

  // Use the full CUE data if available
  const cueData &#x3D; assemblyConfig._fullCueData || assemblyConfig;

  // Extract cluster configuration
  if (cueData?.deployment?.cluster) {
    cluster &#x3D; {
      name: cueData.deployment.cluster.name || &amp;#39;default&amp;#39;,
      provider: cueData.deployment.cluster.provider || &amp;#39;kubernetes&amp;#39;,
      context: cueData.deployment.cluster.context,
      namespace: cueData.deployment.cluster.namespace || &amp;#39;default&amp;#39;,
      config: cueData.deployment.cluster.config || {},
    };
  }

  // Extract services from properly parsed CUE configuration
  if (cueData?.services) {
    for (const [serviceName, serviceConfig] of Object.entries(cueData.services)) {
      const service &#x3D; parseDeploymentServiceConfig(serviceName, serviceConfig as any);
      if (service) {
        services.push(service);
      }
    }
  }

  return { services, cluster };
}

interface DeploymentService {
  name: string;
  language: string;
  serviceType: &amp;#39;bespoke&amp;#39; | &amp;#39;prebuilt&amp;#39; | &amp;#39;external&amp;#39;;
  type: &amp;#39;deployment&amp;#39; | &amp;#39;statefulset&amp;#39; | &amp;#39;daemonset&amp;#39; | &amp;#39;job&amp;#39; | &amp;#39;cronjob&amp;#39;;
  image?: string;
  sourceDirectory?: string;
  buildContext?: {
    dockerfile?: string;
    target?: string;
    buildArgs?: Record&amp;lt;string, string&amp;gt;;
  };
  ports?: Array&amp;lt;{ name: string; port: number; targetPort?: number; protocol?: string }&amp;gt;;
  env?: Record&amp;lt;string, string&amp;gt;;
  volumes?: Array&amp;lt;{
    name: string;
    path: string;
    size?: string;
    type?: &amp;#39;persistentVolumeClaim&amp;#39; | &amp;#39;configMap&amp;#39; | &amp;#39;secret&amp;#39;;
  }&amp;gt;;
  config?: {
    files?: Array&amp;lt;{ name: string; content: string | Record&amp;lt;string, any&amp;gt; }&amp;gt;;
    [key: string]: any;
  };
  replicas?: number;
  resources?: {
    requests?: { cpu?: string; memory?: string };
    limits?: { cpu?: string; memory?: string };
  };
  labels?: Record&amp;lt;string, string&amp;gt;;
  annotations?: Record&amp;lt;string, string&amp;gt;;
  healthCheck?: {
    path?: string;
    port?: number;
    initialDelay?: number;
    periodSeconds?: number;
  };
}

interface ClusterConfig {
  name: string;
  provider: &amp;#39;kubernetes&amp;#39; | &amp;#39;eks&amp;#39; | &amp;#39;gke&amp;#39; | &amp;#39;aks&amp;#39;;
  context?: string;
  namespace: string;
  config: Record&amp;lt;string, any&amp;gt;;
}

function parseDeploymentServiceConfig(name: string, config: any): DeploymentService | null {
  // Determine service type based on configuration
  let serviceType: &amp;#39;bespoke&amp;#39; | &amp;#39;prebuilt&amp;#39; | &amp;#39;external&amp;#39; &#x3D; &amp;#39;prebuilt&amp;#39;;

  if (
    config.sourceDirectory ||
    (config.language &amp;amp;&amp;amp; config.language !&#x3D;&#x3D; &amp;#39;container&amp;#39; &amp;amp;&amp;amp; !config.image)
  ) {
    serviceType &#x3D; &amp;#39;bespoke&amp;#39;;
  } else if (config.image &amp;amp;&amp;amp; (config.language &#x3D;&#x3D;&#x3D; &amp;#39;container&amp;#39; || !config.language)) {
    serviceType &#x3D; &amp;#39;prebuilt&amp;#39;;
  } else if (config.external) {
    serviceType &#x3D; &amp;#39;external&amp;#39;;
  }

  const service: DeploymentService &#x3D; {
    name: name,
    language: config.language || &amp;#39;container&amp;#39;,
    serviceType: serviceType,
    type: config.type || &amp;#39;deployment&amp;#39;,
    replicas: config.replicas || 1,
  };

  // Service configuration
  if (config.image) service.image &#x3D; config.image;
  if (config.sourceDirectory) service.sourceDirectory &#x3D; config.sourceDirectory;
  if (config.buildContext) service.buildContext &#x3D; config.buildContext;
  if (config.ports) service.ports &#x3D; config.ports;
  if (config.env) service.env &#x3D; config.env;
  if (config.volumes) {
    service.volumes &#x3D; config.volumes.map((vol: any) &#x3D;&amp;gt; ({
      ...vol,
      type: vol.type || &amp;#39;persistentVolumeClaim&amp;#39;,
    }));
  }
  if (config.resources) service.resources &#x3D; config.resources;
  if (config.labels) service.labels &#x3D; config.labels;
  if (config.annotations) service.annotations &#x3D; config.annotations;
  if (config.config) service.config &#x3D; config.config;
  if (config.healthCheck) service.healthCheck &#x3D; config.healthCheck;

  return service;
}

// Terraform generation functions
function generateTerraformMain(cluster: ClusterConfig | null, projectName: string): string {
  const clusterName &#x3D; cluster?.name || &amp;#39;default&amp;#39;;
  const namespace &#x3D; cluster?.namespace || projectName.toLowerCase();

  return &#x60;terraform {
  required_version &#x3D; &amp;quot;&amp;gt;&#x3D; 1.0&amp;quot;
  required_providers {
    kubernetes &#x3D; {
      source  &#x3D; &amp;quot;hashicorp/kubernetes&amp;quot;
      version &#x3D; &amp;quot;~&amp;gt; 2.23&amp;quot;
    }
  }
}

provider &amp;quot;kubernetes&amp;quot; {
  # Configuration will be loaded from kubeconfig by default
  # Override these values via terraform.tfvars if needed
  config_path    &#x3D; var.kubeconfig_path
  config_context &#x3D; var.cluster_context
}

# Create namespace if it doesn&amp;#39;t exist
resource &amp;quot;kubernetes_namespace&amp;quot; &amp;quot;${namespace.replace(/-/g, &amp;#39;_&amp;#39;)}&amp;quot; {
  metadata {
    name &#x3D; &amp;quot;${namespace}&amp;quot;
    labels &#x3D; {
      name    &#x3D; &amp;quot;${namespace}&amp;quot;
      project &#x3D; &amp;quot;${projectName.toLowerCase()}&amp;quot;
    }
  }
}
&#x60;;
}

function generateTerraformVariables(
  services: DeploymentService[],
  cluster: ClusterConfig | null
): string {
  const clusterName &#x3D; cluster?.name || &amp;#39;default&amp;#39;;

  return &#x60;variable &amp;quot;kubeconfig_path&amp;quot; {
  description &#x3D; &amp;quot;Path to the kubeconfig file&amp;quot;
  type        &#x3D; string
  default     &#x3D; &amp;quot;~/.kube/config&amp;quot;
}

variable &amp;quot;cluster_context&amp;quot; {
  description &#x3D; &amp;quot;Kubernetes cluster context to use&amp;quot;
  type        &#x3D; string
  default     &#x3D; &amp;quot;${cluster?.context || clusterName}&amp;quot;
}

variable &amp;quot;namespace&amp;quot; {
  description &#x3D; &amp;quot;Kubernetes namespace for deployment&amp;quot;
  type        &#x3D; string
  default     &#x3D; &amp;quot;${cluster?.namespace || &amp;#39;default&amp;#39;}&amp;quot;
}

variable &amp;quot;image_tag&amp;quot; {
  description &#x3D; &amp;quot;Docker image tag for services&amp;quot;
  type        &#x3D; string
  default     &#x3D; &amp;quot;latest&amp;quot;
}

${services
  .map(service &#x3D;&amp;gt; {
    const serviceName &#x3D; service.name.replace(/-/g, &amp;#39;_&amp;#39;);
    return &#x60;variable &amp;quot;${serviceName}_replicas&amp;quot; {
  description &#x3D; &amp;quot;Number of replicas for ${service.name}&amp;quot;
  type        &#x3D; number
  default     &#x3D; ${service.replicas || 1}
}&#x60;;
  })
  .join(&amp;#39;\n\n&amp;#39;)}
&#x60;;
}

function generateTerraformServices(services: DeploymentService[], projectName: string): string {
  return services.map(service &#x3D;&amp;gt; generateTerraformService(service, projectName)).join(&amp;#39;\n\n&amp;#39;);
}

function generateTerraformService(service: DeploymentService, projectName: string): string {
  const serviceName &#x3D; service.name.replace(/-/g, &amp;#39;_&amp;#39;);
  const namespace &#x3D; projectName.toLowerCase();

  let terraform &#x3D; &#x60;# ${service.name} ${service.type}
resource &amp;quot;kubernetes_${service.type}&amp;quot; &amp;quot;${serviceName}&amp;quot; {
  metadata {
    name      &#x3D; &amp;quot;${service.name}&amp;quot;
    namespace &#x3D; kubernetes_namespace.${namespace.replace(/-/g, &amp;#39;_&amp;#39;)}.metadata[0].name
    labels &#x3D; {
      app     &#x3D; &amp;quot;${service.name}&amp;quot;
      project &#x3D; &amp;quot;${projectName.toLowerCase()}&amp;quot;${
        service.labels
          ? Object.entries(service.labels)
              .map(([k, v]) &#x3D;&amp;gt; &#x60;\n      ${k} &#x3D; &amp;quot;${v}&amp;quot;&#x60;)
              .join(&amp;#39;&amp;#39;)
          : &amp;#39;&amp;#39;
      }
    }${
      service.annotations
        ? &#x60;
    annotations &#x3D; {${Object.entries(service.annotations)
      .map(([k, v]) &#x3D;&amp;gt; &#x60;\n      &amp;quot;${k}&amp;quot; &#x3D; &amp;quot;${v}&amp;quot;&#x60;)
      .join(&amp;#39;&amp;#39;)}
    }&#x60;
        : &amp;#39;&amp;#39;
    }
  }

  spec {
    replicas &#x3D; var.${serviceName}_replicas
    
    selector {
      match_labels &#x3D; {
        app &#x3D; &amp;quot;${service.name}&amp;quot;
      }
    }

    template {
      metadata {
        labels &#x3D; {
          app     &#x3D; &amp;quot;${service.name}&amp;quot;
          project &#x3D; &amp;quot;${projectName.toLowerCase()}&amp;quot;
        }
      }

      spec {
        container {
          name  &#x3D; &amp;quot;${service.name}&amp;quot;
          image &#x3D; &amp;quot;${service.image || &#x60;${service.name}:\${var.image_tag}&#x60;}&amp;quot;
&#x60;;

  // Add ports
  if (service.ports &amp;amp;&amp;amp; service.ports.length &amp;gt; 0) {
    service.ports.forEach(port &#x3D;&amp;gt; {
      terraform +&#x3D; &#x60;
          port {
            name           &#x3D; &amp;quot;${port.name}&amp;quot;
            container_port &#x3D; ${port.targetPort || port.port}
            protocol       &#x3D; &amp;quot;${port.protocol || &amp;#39;TCP&amp;#39;}&amp;quot;
          }&#x60;;
    });
  }

  // Add environment variables
  if (service.env &amp;amp;&amp;amp; Object.keys(service.env).length &amp;gt; 0) {
    Object.entries(service.env).forEach(([key, value]) &#x3D;&amp;gt; {
      terraform +&#x3D; &#x60;
          env {
            name  &#x3D; &amp;quot;${key}&amp;quot;
            value &#x3D; &amp;quot;${value}&amp;quot;
          }&#x60;;
    });
  }

  // Add resources
  if (service.resources) {
    terraform +&#x3D; &#x60;
          resources {&#x60;;
    if (service.resources.requests) {
      terraform +&#x3D; &#x60;
            requests &#x3D; {&#x60;;
      if (service.resources.requests.cpu)
        terraform +&#x3D; &#x60;
              cpu    &#x3D; &amp;quot;${service.resources.requests.cpu}&amp;quot;&#x60;;
      if (service.resources.requests.memory)
        terraform +&#x3D; &#x60;
              memory &#x3D; &amp;quot;${service.resources.requests.memory}&amp;quot;&#x60;;
      terraform +&#x3D; &#x60;
            }&#x60;;
    }
    if (service.resources.limits) {
      terraform +&#x3D; &#x60;
            limits &#x3D; {&#x60;;
      if (service.resources.limits.cpu)
        terraform +&#x3D; &#x60;
              cpu    &#x3D; &amp;quot;${service.resources.limits.cpu}&amp;quot;&#x60;;
      if (service.resources.limits.memory)
        terraform +&#x3D; &#x60;
              memory &#x3D; &amp;quot;${service.resources.limits.memory}&amp;quot;&#x60;;
      terraform +&#x3D; &#x60;
            }&#x60;;
    }
    terraform +&#x3D; &#x60;
          }&#x60;;
  }

  // Add volume mounts
  if (service.volumes &amp;amp;&amp;amp; service.volumes.length &amp;gt; 0) {
    service.volumes.forEach(volume &#x3D;&amp;gt; {
      terraform +&#x3D; &#x60;
          volume_mount {
            name       &#x3D; &amp;quot;${volume.name}&amp;quot;
            mount_path &#x3D; &amp;quot;${volume.path}&amp;quot;
          }&#x60;;
    });
  }

  terraform +&#x3D; &#x60;
        }&#x60;;

  // Add volumes
  if (service.volumes &amp;amp;&amp;amp; service.volumes.length &amp;gt; 0) {
    service.volumes.forEach(volume &#x3D;&amp;gt; {
      terraform +&#x3D; &#x60;
        volume {
          name &#x3D; &amp;quot;${volume.name}&amp;quot;
          persistent_volume_claim {
            claim_name &#x3D; kubernetes_persistent_volume_claim.${serviceName}_${volume.name.replace(/-/g, &amp;#39;_&amp;#39;)}.metadata[0].name
          }
        }&#x60;;
    });
  }

  terraform +&#x3D; &#x60;
      }
    }
  }
}&#x60;;

  // Generate Service resource if has ports
  if (service.ports &amp;amp;&amp;amp; service.ports.length &amp;gt; 0) {
    terraform +&#x3D; &#x60;

resource &amp;quot;kubernetes_service&amp;quot; &amp;quot;${serviceName}&amp;quot; {
  metadata {
    name      &#x3D; &amp;quot;${service.name}&amp;quot;
    namespace &#x3D; kubernetes_namespace.${namespace.replace(/-/g, &amp;#39;_&amp;#39;)}.metadata[0].name
    labels &#x3D; {
      app     &#x3D; &amp;quot;${service.name}&amp;quot;
      project &#x3D; &amp;quot;${projectName.toLowerCase()}&amp;quot;
    }
  }

  spec {
    selector &#x3D; {
      app &#x3D; &amp;quot;${service.name}&amp;quot;
    }

${service.ports
  .map(
    port &#x3D;&amp;gt; &#x60;    port {
      name        &#x3D; &amp;quot;${port.name}&amp;quot;
      port        &#x3D; ${port.port}
      target_port &#x3D; ${port.targetPort || port.port}
      protocol    &#x3D; &amp;quot;${port.protocol || &amp;#39;TCP&amp;#39;}&amp;quot;
    }&#x60;
  )
  .join(&amp;#39;\n&amp;#39;)}
  }
}&#x60;;
  }

  // Generate PVCs for volumes
  if (service.volumes &amp;amp;&amp;amp; service.volumes.length &amp;gt; 0) {
    service.volumes.forEach(volume &#x3D;&amp;gt; {
      terraform +&#x3D; &#x60;

resource &amp;quot;kubernetes_persistent_volume_claim&amp;quot; &amp;quot;${serviceName}_${volume.name.replace(/-/g, &amp;#39;_&amp;#39;)}&amp;quot; {
  metadata {
    name      &#x3D; &amp;quot;${service.name}-${volume.name}&amp;quot;
    namespace &#x3D; kubernetes_namespace.${namespace.replace(/-/g, &amp;#39;_&amp;#39;)}.metadata[0].name
  }

  spec {
    access_modes &#x3D; [&amp;quot;ReadWriteOnce&amp;quot;]
    resources {
      requests &#x3D; {
        storage &#x3D; &amp;quot;${volume.size || &amp;#39;10Gi&amp;#39;}&amp;quot;
      }
    }
  }
}&#x60;;
    });
  }

  return terraform;
}

function generateTerraformOutputs(services: DeploymentService[], projectName: string): string {
  const outputs &#x3D; services
    .filter(service &#x3D;&amp;gt; service.ports &amp;amp;&amp;amp; service.ports.length &amp;gt; 0)
    .map(service &#x3D;&amp;gt; {
      const serviceName &#x3D; service.name.replace(/-/g, &amp;#39;_&amp;#39;);
      return &#x60;output &amp;quot;${serviceName}_service_ip&amp;quot; {
  description &#x3D; &amp;quot;Cluster IP of the ${service.name} service&amp;quot;
  value       &#x3D; kubernetes_service.${serviceName}.spec[0].cluster_ip
}

output &amp;quot;${serviceName}_ports&amp;quot; {
  description &#x3D; &amp;quot;Ports exposed by ${service.name} service&amp;quot;
  value       &#x3D; [${service.ports?.map(p &#x3D;&amp;gt; &#x60;&amp;quot;${p.port}&amp;quot;&#x60;).join(&amp;#39;, &amp;#39;)}]
}&#x60;;
    });

  return &#x60;output &amp;quot;namespace&amp;quot; {
  description &#x3D; &amp;quot;Kubernetes namespace&amp;quot;
  value       &#x3D; kubernetes_namespace.${projectName.toLowerCase().replace(/-/g, &amp;#39;_&amp;#39;)}.metadata[0].name
}

${outputs.join(&amp;#39;\n\n&amp;#39;)}
&#x60;;
}

function generateTerraformReadme(
  services: DeploymentService[],
  cluster: ClusterConfig | null,
  projectName: string
): string {
  const clusterName &#x3D; cluster?.name || &amp;#39;default&amp;#39;;
  const namespace &#x3D; cluster?.namespace || projectName.toLowerCase();

  return &#x60;# ${projectName} - Terraform Kubernetes Deployment

This directory contains Terraform configurations for deploying ${projectName} to Kubernetes.

## Prerequisites

- [Terraform](https://terraform.io) &amp;gt;&#x3D; 1.0
- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) configured with cluster access
- Kubernetes cluster accessible via kubeconfig

## Configuration

### Cluster Configuration
- **Cluster**: ${clusterName}
- **Namespace**: ${namespace}
- **Context**: ${cluster?.context || clusterName}

## Services

${services
  .map(
    service &#x3D;&amp;gt; &#x60;### ${service.name}
- **Language**: ${service.language}
- **Type**: ${service.type}
- **Image**: ${service.image || &#x60;${service.name}:latest&#x60;}${
      service.ports
        ? &#x60;
- **Ports**: ${service.ports.map(p &#x3D;&amp;gt; &#x60;${p.port}/${p.protocol || &amp;#39;TCP&amp;#39;} (${p.name})&#x60;).join(&amp;#39;, &amp;#39;)}&#x60;
        : &amp;#39;&amp;#39;
    }
- **Replicas**: ${service.replicas || 1}${
      service.volumes
        ? &#x60;
- **Storage**: ${service.volumes.map(v &#x3D;&amp;gt; &#x60;${v.name} â†’ ${v.path} (${v.size || &amp;#39;10Gi&amp;#39;})&#x60;).join(&amp;#39;, &amp;#39;)}&#x60;
        : &amp;#39;&amp;#39;
    }&#x60;
  )
  .join(&amp;#39;\n\n&amp;#39;)}

## Deployment

### 1. Initialize Terraform
\&#x60;\&#x60;\&#x60;bash
terraform init
\&#x60;\&#x60;\&#x60;

### 2. Review the Plan
\&#x60;\&#x60;\&#x60;bash
terraform plan
\&#x60;\&#x60;\&#x60;

### 3. Apply Configuration
\&#x60;\&#x60;\&#x60;bash
terraform apply
\&#x60;\&#x60;\&#x60;

### 4. Verify Deployment
\&#x60;\&#x60;\&#x60;bash
kubectl get all -n ${namespace}
\&#x60;\&#x60;\&#x60;

## Customization

Create a \&#x60;terraform.tfvars\&#x60; file to customize deployment:

\&#x60;\&#x60;\&#x60;hcl
# Cluster configuration
kubeconfig_path &#x3D; &amp;quot;~/.kube/config&amp;quot;
cluster_context &#x3D; &amp;quot;${cluster?.context || clusterName}&amp;quot;
namespace       &#x3D; &amp;quot;${namespace}&amp;quot;

# Image configuration  
image_tag &#x3D; &amp;quot;v1.0.0&amp;quot;

# Service scaling
${services.map(service &#x3D;&amp;gt; &#x60;${service.name.replace(/-/g, &amp;#39;_&amp;#39;)}_replicas &#x3D; ${service.replicas || 1}&#x60;).join(&amp;#39;\n&amp;#39;)}
\&#x60;\&#x60;\&#x60;

## Access Services

${services
  .filter(s &#x3D;&amp;gt; s.ports &amp;amp;&amp;amp; s.ports.length &amp;gt; 0)
  .map(
    service &#x3D;&amp;gt; &#x60;### ${service.name}
\&#x60;\&#x60;\&#x60;bash
kubectl port-forward -n ${namespace} service/${service.name} ${service.ports?.[0].port}:${service.ports?.[0].port}
\&#x60;\&#x60;\&#x60;
Access at: http://localhost:${service.ports?.[0].port}
&#x60;
  )
  .join(&amp;#39;\n&amp;#39;)}

## State Management

This configuration uses local state. For production deployments, configure remote state:

\&#x60;\&#x60;\&#x60;hcl
terraform {
  backend &amp;quot;s3&amp;quot; {
    bucket &#x3D; &amp;quot;your-terraform-state&amp;quot;
    key    &#x3D; &amp;quot;${projectName}/terraform.tfstate&amp;quot;
    region &#x3D; &amp;quot;us-west-2&amp;quot;
  }
}
\&#x60;\&#x60;\&#x60;

## Cleanup

\&#x60;\&#x60;\&#x60;bash
terraform destroy
\&#x60;\&#x60;\&#x60;

## Troubleshooting

### Check pod status
\&#x60;\&#x60;\&#x60;bash
kubectl get pods -n ${namespace}
kubectl describe pod &amp;lt;pod-name&amp;gt; -n ${namespace}
\&#x60;\&#x60;\&#x60;

### View logs
\&#x60;\&#x60;\&#x60;bash
kubectl logs -f &amp;lt;pod-name&amp;gt; -n ${namespace}
\&#x60;\&#x60;\&#x60;

### Apply changes
After modifying Terraform files:
\&#x60;\&#x60;\&#x60;bash
terraform plan
terraform apply
\&#x60;\&#x60;\&#x60;
&#x60;;
}

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// DOCKER COMPOSE GENERATION
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Generate Docker Compose files for the given services
 */
async function generateDockerCompose(
  config: any,
  outputDir: string,
  assemblyConfig: any,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];
  await fs.ensureDir(path.join(outputDir, &amp;#39;compose&amp;#39;));

  // Parse assembly to extract services and deployment configuration
  const { services, deployment } &#x3D; parseDockerComposeServices(assemblyConfig);

  // Generate docker-compose.yml
  const composeYml &#x3D; generateDockerComposeFile(services, deployment, config.name);
  const composePath &#x3D; path.join(outputDir, &amp;#39;compose&amp;#39;, &amp;#39;docker-compose.yml&amp;#39;);
  if (!options.dryRun) {
    await fs.writeFile(composePath, composeYml);
  }
  files.push(&amp;#39;compose/docker-compose.yml&amp;#39;);

  // Generate .env template
  const envTemplate &#x3D; generateComposeEnvTemplate(services, config.name);
  const envPath &#x3D; path.join(outputDir, &amp;#39;compose&amp;#39;, &amp;#39;.env.template&amp;#39;);
  if (!options.dryRun) {
    await fs.writeFile(envPath, envTemplate);
  }
  files.push(&amp;#39;compose/.env.template&amp;#39;);

  // Generate build contexts for bespoke services
  const buildFiles &#x3D; await generateBuildContexts(services, outputDir, options);
  files.push(...buildFiles);

  // Generate compose README
  const readme &#x3D; generateComposeReadme(services, deployment, config.name);
  const readmePath &#x3D; path.join(outputDir, &amp;#39;compose&amp;#39;, &amp;#39;README.md&amp;#39;);
  if (!options.dryRun) {
    await fs.writeFile(readmePath, readme);
  }
  files.push(&amp;#39;compose/README.md&amp;#39;);

  return files;
}

function parseDockerComposeServices(assemblyConfig: any): {
  services: DeploymentServiceConfig[];
  deployment: DeploymentConfig;
} {
  const services: DeploymentServiceConfig[] &#x3D; [];
  const cueData &#x3D; assemblyConfig._fullCueData || assemblyConfig;

  // Extract deployment configuration
  const deployment: DeploymentConfig &#x3D; {
    target: cueData?.deployment?.target || &amp;#39;compose&amp;#39;,
    compose: {
      version: cueData?.deployment?.compose?.version || &amp;#39;3.8&amp;#39;,
      networks: cueData?.deployment?.compose?.networks || {},
      volumes: cueData?.deployment?.compose?.volumes || {},
      profiles: cueData?.deployment?.compose?.profiles || [],
      environment: cueData?.deployment?.compose?.environment || {},
    },
  };

  // Parse services with enhanced schema
  if (cueData?.services) {
    for (const [serviceName, serviceConfig] of Object.entries(cueData.services)) {
      const service &#x3D; parseServiceForCompose(serviceName, serviceConfig as any);
      if (service) {
        services.push(service);
      }
    }
  }

  return { services, deployment };
}

function parseServiceForCompose(name: string, config: any): DeploymentServiceConfig | null {
  // Detect service type based on configuration
  let serviceType: &amp;#39;bespoke&amp;#39; | &amp;#39;prebuilt&amp;#39; | &amp;#39;external&amp;#39; &#x3D; &amp;#39;prebuilt&amp;#39;;

  if (config.sourceDirectory) {
    serviceType &#x3D; &amp;#39;bespoke&amp;#39;;
  } else if (config.image) {
    serviceType &#x3D; &amp;#39;prebuilt&amp;#39;;
  } else if (config.language &amp;amp;&amp;amp; !config.image) {
    // Language specified but no image - likely bespoke
    serviceType &#x3D; &amp;#39;bespoke&amp;#39;;
  }

  const service: DeploymentServiceConfig &#x3D; {
    name: name,
    serviceType: serviceType,
    language: config.language || &amp;#39;container&amp;#39;,
    type: config.type || &amp;#39;deployment&amp;#39;,
    replicas: config.replicas || 1,
    image: config.image,
    sourceDirectory: config.sourceDirectory,
    buildContext: config.buildContext,
    ports: config.ports,
    env: config.env,
    volumes: config.volumes,
    resources: config.resources,
    config: config.config,
    labels: config.labels,
    annotations: config.annotations,
  };

  return service;
}

function generateDockerComposeFile(
  services: DeploymentServiceConfig[],
  deployment: DeploymentConfig,
  projectName: string
): string {
  const version &#x3D; deployment.compose?.version || &amp;#39;3.8&amp;#39;;

  let compose &#x3D; &#x60;version: &amp;quot;${version}&amp;quot;

services:
${services.map(service &#x3D;&amp;gt; generateComposeService(service, projectName)).join(&amp;#39;\n&amp;#39;)}&#x60;;

  // Add networks if specified
  if (deployment.compose?.networks &amp;amp;&amp;amp; Object.keys(deployment.compose.networks).length &amp;gt; 0) {
    compose +&#x3D; &#x60;

networks:
${Object.entries(deployment.compose.networks)
  .map(
    ([name, config]) &#x3D;&amp;gt;
      &#x60;  ${name}:
${Object.entries(config as any)
  .map(([k, v]) &#x3D;&amp;gt; &#x60;    ${k}: ${typeof v &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; ? JSON.stringify(v) : v}&#x60;)
  .join(&amp;#39;\n&amp;#39;)}&#x60;
  )
  .join(&amp;#39;\n&amp;#39;)}&#x60;;
  }

  // Add named volumes if any services use them
  const namedVolumes &#x3D; services.flatMap(s &#x3D;&amp;gt;
    (s.volumes || [])
      .filter(v &#x3D;&amp;gt; v.type &#x3D;&#x3D;&#x3D; &amp;#39;persistentVolumeClaim&amp;#39;)
      .map(v &#x3D;&amp;gt; &#x60;${s.name}_${v.name}&#x60;)
  );

  if (namedVolumes.length &amp;gt; 0) {
    compose +&#x3D; &#x60;

volumes:
${namedVolumes.map(volume &#x3D;&amp;gt; &#x60;  ${volume}:&#x60;).join(&amp;#39;\n&amp;#39;)}&#x60;;
  }

  return compose;
}

function generateComposeService(service: DeploymentServiceConfig, projectName: string): string {
  const serviceName &#x3D; service.name;
  let serviceConfig &#x3D; &#x60;  ${serviceName}:&#x60;;

  // Image or build configuration
  if (service.serviceType &#x3D;&#x3D;&#x3D; &amp;#39;bespoke&amp;#39;) {
    // Build from source
    if (service.sourceDirectory) {
      serviceConfig +&#x3D; &#x60;
    build:
      context: ../${service.sourceDirectory}&#x60;;

      if (service.buildContext?.dockerfile) {
        serviceConfig +&#x3D; &#x60;
      dockerfile: ${service.buildContext.dockerfile}&#x60;;
      }

      if (service.buildContext?.target) {
        serviceConfig +&#x3D; &#x60;
      target: ${service.buildContext.target}&#x60;;
      }

      if (service.buildContext?.buildArgs) {
        serviceConfig +&#x3D; &#x60;
      args:
${Object.entries(service.buildContext.buildArgs)
  .map(([k, v]) &#x3D;&amp;gt; &#x60;        ${k}: ${v}&#x60;)
  .join(&amp;#39;\n&amp;#39;)}&#x60;;
      }
    } else {
      // Fallback to image for bespoke without sourceDirectory
      serviceConfig +&#x3D; &#x60;
    image: ${service.image || &#x60;${serviceName}:latest&#x60;}&#x60;;
    }
  } else {
    // Use pre-built image
    serviceConfig +&#x3D; &#x60;
    image: ${service.image}&#x60;;
  }

  // Container name
  serviceConfig +&#x3D; &#x60;
    container_name: ${projectName}_${serviceName}&#x60;;

  // Restart policy
  serviceConfig +&#x3D; &#x60;
    restart: unless-stopped&#x60;;

  // Ports
  if (service.ports &amp;amp;&amp;amp; service.ports.length &amp;gt; 0) {
    serviceConfig +&#x3D; &#x60;
    ports:
${service.ports.map(p &#x3D;&amp;gt; &#x60;      - &amp;quot;${p.port}:${p.targetPort || p.port}&amp;quot;&#x60;).join(&amp;#39;\n&amp;#39;)}&#x60;;
  }

  // Environment variables
  if (service.env &amp;amp;&amp;amp; Object.keys(service.env).length &amp;gt; 0) {
    serviceConfig +&#x3D; &#x60;
    environment:
${Object.entries(service.env)
  .map(([k, v]) &#x3D;&amp;gt; &#x60;      ${k}: ${v}&#x60;)
  .join(&amp;#39;\n&amp;#39;)}&#x60;;
  }

  // Volumes
  if (service.volumes &amp;amp;&amp;amp; service.volumes.length &amp;gt; 0) {
    serviceConfig +&#x3D; &#x60;
    volumes:&#x60;;

    service.volumes.forEach(volume &#x3D;&amp;gt; {
      if (volume.type &#x3D;&#x3D;&#x3D; &amp;#39;persistentVolumeClaim&amp;#39;) {
        serviceConfig +&#x3D; &#x60;
      - ${serviceName}_${volume.name}:${volume.path}&#x60;;
      } else if (volume.type &#x3D;&#x3D;&#x3D; &amp;#39;configMap&amp;#39; &amp;amp;&amp;amp; service.config?.files) {
        // Handle config files
        const configFile &#x3D; service.config.files.find(f &#x3D;&amp;gt; f.name &#x3D;&#x3D;&#x3D; volume.name);
        if (configFile) {
          serviceConfig +&#x3D; &#x60;
      - ./config/${serviceName}/${configFile.name}:${volume.path}:ro&#x60;;
        }
      } else {
        // Default to bind mount or volume
        serviceConfig +&#x3D; &#x60;
      - ${volume.name}:${volume.path}&#x60;;
      }
    });
  }

  // Labels
  const labels &#x3D; {
    project: projectName,
    service: serviceName,
    &amp;#39;service-type&amp;#39;: service.serviceType,
    ...service.labels,
  };

  serviceConfig +&#x3D; &#x60;
    labels:
${Object.entries(labels)
  .map(([k, v]) &#x3D;&amp;gt; &#x60;      ${k}: &amp;quot;${v}&amp;quot;&#x60;)
  .join(&amp;#39;\n&amp;#39;)}&#x60;;

  // Health check (basic)
  if (service.ports &amp;amp;&amp;amp; service.ports.length &amp;gt; 0) {
    const httpPort &#x3D; service.ports.find(p &#x3D;&amp;gt; p.name &#x3D;&#x3D;&#x3D; &amp;#39;http&amp;#39; || p.name &#x3D;&#x3D;&#x3D; &amp;#39;web&amp;#39;);
    if (httpPort) {
      serviceConfig +&#x3D; &#x60;
    healthcheck:
      test: [&amp;quot;CMD&amp;quot;, &amp;quot;curl&amp;quot;, &amp;quot;-f&amp;quot;, &amp;quot;http://localhost:${httpPort.targetPort || httpPort.port}&amp;quot;]
      interval: 30s
      timeout: 10s
      retries: 3&#x60;;
    }
  }

  // Resource limits (if specified)
  if (service.resources?.limits) {
    const limits &#x3D; service.resources.limits;
    if (limits.memory) {
      serviceConfig +&#x3D; &#x60;
    mem_limit: ${limits.memory.replace(&amp;#39;Mi&amp;#39;, &amp;#39;m&amp;#39;).replace(&amp;#39;Gi&amp;#39;, &amp;#39;g&amp;#39;)}&#x60;;
    }
    if (limits.cpu) {
      const cpuLimit &#x3D; limits.cpu.replace(&amp;#39;m&amp;#39;, &amp;#39;&amp;#39;);
      const cpuFloat &#x3D; (Number.parseInt(cpuLimit) / 1000).toFixed(2);
      serviceConfig +&#x3D; &#x60;
    cpus: &amp;quot;${cpuFloat}&amp;quot;&#x60;;
    }
  }

  return serviceConfig;
}

function generateComposeEnvTemplate(
  services: DeploymentServiceConfig[],
  projectName: string
): string {
  const envVars &#x3D; new Set&amp;lt;string&amp;gt;();

  // Collect all environment variables from services
  services.forEach(service &#x3D;&amp;gt; {
    if (service.env) {
      Object.keys(service.env).forEach(key &#x3D;&amp;gt; envVars.add(key));
    }
  });

  let envContent &#x3D; &#x60;# Environment variables for ${projectName}
# Copy this to .env and customize values

# Project Configuration
COMPOSE_PROJECT_NAME&#x3D;${projectName}
COMPOSE_FILE&#x3D;docker-compose.yml

# Image Tags (for pre-built services)
IMAGE_TAG&#x3D;latest

&#x60;;

  // Add service-specific environment variables
  services.forEach(service &#x3D;&amp;gt; {
    if (service.env &amp;amp;&amp;amp; Object.keys(service.env).length &amp;gt; 0) {
      envContent +&#x3D; &#x60;# ${service.name} Service
&#x60;;
      Object.entries(service.env).forEach(([key, value]) &#x3D;&amp;gt; {
        envContent +&#x3D; &#x60;${key}&#x3D;${value}
&#x60;;
      });
      envContent +&#x3D; &amp;#39;\n&amp;#39;;
    }
  });

  return envContent;
}

async function generateBuildContexts(
  services: DeploymentServiceConfig[],
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];

  for (const service of services) {
    if (service.serviceType &#x3D;&#x3D;&#x3D; &amp;#39;bespoke&amp;#39; &amp;amp;&amp;amp; service.config?.files) {
      // Generate config files for bespoke services
      const configDir &#x3D; path.join(outputDir, &amp;#39;compose&amp;#39;, &amp;#39;config&amp;#39;, service.name);
      if (!fs.existsSync(configDir) &amp;amp;&amp;amp; !options.dryRun) {
        await fs.mkdirSync(configDir, { recursive: true });
      }

      for (const configFile of service.config.files) {
        const content &#x3D;
          typeof configFile.content &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39;
            ? configFile.content
            : JSON.stringify(configFile.content, null, 2);

        const filePath &#x3D; path.join(configDir, configFile.name);
        if (!options.dryRun) {
          await fs.writeFile(filePath, content);
        }
        files.push(&#x60;compose/config/${service.name}/${configFile.name}&#x60;);
      }
    }
  }

  return files;
}

function generateComposeReadme(
  services: DeploymentServiceConfig[],
  deployment: DeploymentConfig,
  projectName: string
): string {
  return &#x60;# ${projectName} - Docker Compose Deployment

This directory contains Docker Compose configurations for running ${projectName} locally.

## Prerequisites

- [Docker](https://docker.com) with Compose plugin
- [Docker Compose](https://docs.docker.com/compose/) v2.0+

## Services

${services
  .map(
    service &#x3D;&amp;gt; &#x60;### ${service.name} (${service.serviceType})
- **Language**: ${service.language}
- **Type**: ${service.type}
${
  service.serviceType &#x3D;&#x3D;&#x3D; &amp;#39;bespoke&amp;#39;
    ? &#x60;- **Source**: ${service.sourceDirectory || &amp;#39;Built from local source&amp;#39;}&#x60;
    : &#x60;- **Image**: ${service.image}&#x60;
}${
      service.ports
        ? &#x60;
- **Ports**: ${service.ports.map(p &#x3D;&amp;gt; &#x60;${p.port}:${p.targetPort || p.port}&#x60;).join(&amp;#39;, &amp;#39;)}&#x60;
        : &amp;#39;&amp;#39;
    }${
      service.volumes
        ? &#x60;
- **Volumes**: ${service.volumes.map(v &#x3D;&amp;gt; &#x60;${v.name} â†’ ${v.path}&#x60;).join(&amp;#39;, &amp;#39;)}&#x60;
        : &amp;#39;&amp;#39;
    }&#x60;
  )
  .join(&amp;#39;\n\n&amp;#39;)}

## Quick Start

### 1. Setup Environment
\&#x60;\&#x60;\&#x60;bash
cp .env.template .env
# Edit .env with your configuration
\&#x60;\&#x60;\&#x60;

### 2. Build and Start Services
\&#x60;\&#x60;\&#x60;bash
docker compose up --build -d
\&#x60;\&#x60;\&#x60;

### 3. View Logs
\&#x60;\&#x60;\&#x60;bash
docker compose logs -f
\&#x60;\&#x60;\&#x60;

### 4. Stop Services
\&#x60;\&#x60;\&#x60;bash
docker compose down
\&#x60;\&#x60;\&#x60;

## Service Management

### Build specific service
\&#x60;\&#x60;\&#x60;bash
${services
  .filter(s &#x3D;&amp;gt; s.serviceType &#x3D;&#x3D;&#x3D; &amp;#39;bespoke&amp;#39;)
  .map(s &#x3D;&amp;gt; &#x60;docker compose build ${s.name}&#x60;)
  .join(&amp;#39;\n&amp;#39;)}
\&#x60;\&#x60;\&#x60;

### Access services
${services
  .filter(s &#x3D;&amp;gt; s.ports &amp;amp;&amp;amp; s.ports.length &amp;gt; 0)
  .map(
    service &#x3D;&amp;gt; &#x60;
**${service.name}**: http://localhost:${service.ports?.[0].port}&#x60;
  )
  .join(&amp;#39;&amp;#39;)}

### Scale services
\&#x60;\&#x60;\&#x60;bash
${services.map(s &#x3D;&amp;gt; &#x60;docker compose up -d --scale ${s.name}&#x3D;${s.replicas || 1}&#x60;).join(&amp;#39;\n&amp;#39;)}
\&#x60;\&#x60;\&#x60;

## Development Workflow

### For bespoke services
1. Make code changes in source directories
2. Rebuild specific services: \&#x60;docker compose build &amp;lt;service&amp;gt;\&#x60;
3. Restart: \&#x60;docker compose up -d &amp;lt;service&amp;gt;\&#x60;

### For configuration changes
1. Update files in \&#x60;./config/\&#x60; directories
2. Restart affected services: \&#x60;docker compose restart &amp;lt;service&amp;gt;\&#x60;

## Debugging

### Check service status
\&#x60;\&#x60;\&#x60;bash
docker compose ps
\&#x60;\&#x60;\&#x60;

### View service logs
\&#x60;\&#x60;\&#x60;bash
docker compose logs &amp;lt;service-name&amp;gt;
docker compose logs -f &amp;lt;service-name&amp;gt;  # Follow logs
\&#x60;\&#x60;\&#x60;

### Execute commands in containers
\&#x60;\&#x60;\&#x60;bash
docker compose exec &amp;lt;service-name&amp;gt; sh
\&#x60;\&#x60;\&#x60;

### Inspect networks and volumes
\&#x60;\&#x60;\&#x60;bash
docker network ls | grep ${projectName}
docker volume ls | grep ${projectName}
\&#x60;\&#x60;\&#x60;

## Production Considerations

This Docker Compose setup is designed for development and testing. For production:

1. **Security**: Remove development ports and debugging tools
2. **Secrets**: Use Docker secrets or external secret management
3. **Persistence**: Configure proper volume management and backups
4. **Monitoring**: Add health checks and monitoring services
5. **Scaling**: Consider using Docker Swarm or Kubernetes for production

## Cleanup

### Stop and remove containers
\&#x60;\&#x60;\&#x60;bash
docker compose down
\&#x60;\&#x60;\&#x60;

### Remove volumes (âš ï¸  destroys data)
\&#x60;\&#x60;\&#x60;bash
docker compose down -v
\&#x60;\&#x60;\&#x60;

### Clean up everything including images
\&#x60;\&#x60;\&#x60;bash
docker compose down --rmi all -v
\&#x60;\&#x60;\&#x60;

## Troubleshooting

### Port conflicts
If ports are already in use, edit the \&#x60;.env\&#x60; file or \&#x60;docker-compose.yml\&#x60; to use different ports.

### Build failures
Check that all source directories exist and contain proper build files (Dockerfile, etc.).

### Service won&amp;#39;t start
Check logs with \&#x60;docker compose logs &amp;lt;service&amp;gt;\&#x60; and verify configuration files.

### Network issues
Services communicate using service names as hostnames (e.g., \&#x60;http://${services.length &amp;gt; 1 ? services[1].name : &amp;#39;api&amp;#39;}:${services.find(s &#x3D;&amp;gt; s.ports)?.ports?.[0]?.port || &amp;#39;3000&amp;#39;}\&#x60;).
&#x60;;
}

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// TEST COMPOSITION AND INTELLIGENT NAMESPACING
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Test composition engine for merging existing and generated tests
 */
class TestCompositionEngine {
  private specName: string;
  private namespace: string;

  constructor(specName: string, baseNamespace?: string) {
    this.specName &#x3D; specName;
    this.namespace &#x3D; baseNamespace || this.generateBaseNamespace(specName);
  }

  /**
   * Discover existing test files in the project
   */
  async discoverExistingTests(outputDir: string): Promise&amp;lt;TestSuite[]&amp;gt; {
    const testSuites: TestSuite[] &#x3D; [];
    const testDirs &#x3D; [&amp;#39;tests&amp;#39;, &amp;#39;test&amp;#39;, &amp;#39;__tests__&amp;#39;, &amp;#39;spec&amp;#39;];

    for (const testDir of testDirs) {
      const fullPath &#x3D; path.join(outputDir, testDir);
      if (fs.existsSync(fullPath)) {
        const testFiles &#x3D; await this.findTestFiles(fullPath);
        for (const testFile of testFiles) {
          const suite &#x3D; await this.parseTestFile(testFile);
          if (suite) {
            testSuites.push(suite);
          }
        }
      }
    }

    return testSuites;
  }

  /**
   * Generate namespace for new tests based on spec and service
   */
  generateTestNamespace(serviceName: string): string {
    return &#x60;${this.namespace}.${serviceName}&#x60;.toLowerCase().replace(/[^a-z0-9.]/g, &amp;#39;_&amp;#39;);
  }

  /**
   * Merge existing and new test suites intelligently
   */
  mergeTestSuites(existing: TestSuite[], newSuites: TestSuite[]): TestCompositionResult {
    const result: TestCompositionResult &#x3D; {
      merged: [],
      conflicts: [],
      generated: [],
      preserved: [],
    };

    // Create a map of existing tests by namespace
    const existingMap &#x3D; new Map&amp;lt;string, TestSuite&amp;gt;();
    existing.forEach(suite &#x3D;&amp;gt; existingMap.set(suite.namespace, suite));

    // Process new test suites
    for (const newSuite of newSuites) {
      const existingSuite &#x3D; existingMap.get(newSuite.namespace);

      if (!existingSuite) {
        // No conflict - add new suite as-is
        result.merged.push(newSuite);
        result.generated.push(...newSuite.cases);
      } else {
        // Conflict exists - merge intelligently
        const merged &#x3D; this.mergeConflictingSuites(existingSuite, newSuite);
        result.merged.push(merged.suite);
        result.conflicts.push(...merged.conflicts);
        result.generated.push(...merged.generated);
        result.preserved.push(...merged.preserved);

        // Remove from existing map so we don&amp;#39;t duplicate
        existingMap.delete(newSuite.namespace);
      }
    }

    // Add remaining existing suites (no conflicts)
    existingMap.forEach(suite &#x3D;&amp;gt; {
      result.merged.push(suite);
      result.preserved.push(...suite.cases);
    });

    return result;
  }

  /**
   * Safely merge two conflicting test suites
   */
  private mergeConflictingSuites(
    existing: TestSuite,
    newSuite: TestSuite
  ): {
    suite: TestSuite;
    conflicts: Array&amp;lt;{ test: string; reason: string; resolution: &amp;#39;skip&amp;#39; | &amp;#39;merge&amp;#39; | &amp;#39;replace&amp;#39; }&amp;gt;;
    generated: TestCase[];
    preserved: TestCase[];
  } {
    const result &#x3D; {
      suite: { ...existing },
      conflicts: [] as Array&amp;lt;{
        test: string;
        reason: string;
        resolution: &amp;#39;skip&amp;#39; | &amp;#39;merge&amp;#39; | &amp;#39;replace&amp;#39;;
      }&amp;gt;,
      generated: [] as TestCase[],
      preserved: [...existing.cases] as TestCase[],
    };

    // Create a map of existing test cases by name
    const existingCases &#x3D; new Map&amp;lt;string, TestCase&amp;gt;();
    existing.cases.forEach(testCase &#x3D;&amp;gt; existingCases.set(testCase.name, testCase));

    // Process new test cases
    for (const newCase of newSuite.cases) {
      const existingCase &#x3D; existingCases.get(newCase.name);

      if (!existingCase) {
        // No conflict - add new case
        result.suite.cases.push(newCase);
        result.generated.push(newCase);
      } else if (this.isGeneratedTest(existingCase)) {
        // Existing test is generated - safe to replace
        const index &#x3D; result.suite.cases.findIndex(c &#x3D;&amp;gt; c.name &#x3D;&#x3D;&#x3D; newCase.name);
        if (index &amp;gt;&#x3D; 0) {
          result.suite.cases[index] &#x3D; newCase;
          result.generated.push(newCase);
          result.conflicts.push({
            test: newCase.name,
            reason: &amp;#39;Generated test updated&amp;#39;,
            resolution: &amp;#39;replace&amp;#39;,
          });
        }
      } else {
        // Existing test is custom - preserve and rename new test
        const renamedCase &#x3D; {
          ...newCase,
          name: &#x60;${newCase.name}_generated&#x60;,
          namespace: &#x60;${newCase.namespace}.generated&#x60;,
        };
        result.suite.cases.push(renamedCase);
        result.generated.push(renamedCase);
        result.conflicts.push({
          test: newCase.name,
          reason: &amp;#39;Custom test exists&amp;#39;,
          resolution: &amp;#39;skip&amp;#39;,
        });
      }
    }

    return result;
  }

  /**
   * Check if a test case was generated (vs. custom written)
   */
  private isGeneratedTest(testCase: TestCase): boolean {
    return (
      testCase.metadata?.generated &#x3D;&#x3D;&#x3D; true ||
      testCase.metadata?.source &#x3D;&#x3D;&#x3D; &amp;#39;arbiter&amp;#39; ||
      testCase.namespace.includes(&amp;#39;generated&amp;#39;)
    );
  }

  /**
   * Generate base namespace from spec name
   */
  private generateBaseNamespace(specName: string): string {
    return &#x60;arbiter.${specName}&#x60;.toLowerCase().replace(/[^a-z0-9.]/g, &amp;#39;_&amp;#39;);
  }

  /**
   * Find test files recursively in a directory
   */
  private async findTestFiles(dir: string): Promise&amp;lt;string[]&amp;gt; {
    const files: string[] &#x3D; [];
    const entries &#x3D; fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath &#x3D; path.join(dir, entry.name);
      if (entry.isDirectory()) {
        files.push(...(await this.findTestFiles(fullPath)));
      } else if (this.isTestFile(entry.name)) {
        files.push(fullPath);
      }
    }

    return files;
  }

  /**
   * Check if a file is a test file based on naming conventions
   */
  private isTestFile(filename: string): boolean {
    const testPatterns &#x3D; [
      /\.test\.(js|ts|py|rs|go)$/,
      /\.spec\.(js|ts|py|rs|go)$/,
      /_test\.(js|ts|py|rs|go)$/,
      /test_.*\.(py)$/,
    ];

    return testPatterns.some(pattern &#x3D;&amp;gt; pattern.test(filename));
  }

  /**
   * Parse a test file and extract test cases (simplified parser)
   */
  private async parseTestFile(filePath: string): Promise&amp;lt;TestSuite | null&amp;gt; {
    try {
      const content &#x3D; await fs.readFile(filePath, &amp;#39;utf-8&amp;#39;);
      const ext &#x3D; path.extname(filePath);

      // Basic parsing - in real implementation would use proper AST parsing
      const testCases: TestCase[] &#x3D; [];

      if (ext &#x3D;&#x3D;&#x3D; &amp;#39;.js&amp;#39; || ext &#x3D;&#x3D;&#x3D; &amp;#39;.ts&amp;#39;) {
        // JavaScript/TypeScript test parsing
        const testMatches &#x3D; content.match(/(?:test|it)\s*\(\s*[&amp;#39;&amp;quot;&#x60;]([^&amp;#39;&amp;quot;&#x60;]+)[&amp;#39;&amp;quot;&#x60;]/g);
        testMatches?.forEach((match, index) &#x3D;&amp;gt; {
          const nameMatch &#x3D; match.match(/[&amp;#39;&amp;quot;&#x60;]([^&amp;#39;&amp;quot;&#x60;]+)[&amp;#39;&amp;quot;&#x60;]/);
          if (nameMatch) {
            testCases.push({
              name: nameMatch[1],
              namespace: this.extractNamespaceFromFile(filePath),
              steps: [], // Would extract from test body in real implementation
              metadata: {
                generated: false,
                source: &amp;#39;existing&amp;#39;,
                lastModified: new Date().toISOString(),
              },
            });
          }
        });
      } else if (ext &#x3D;&#x3D;&#x3D; &amp;#39;.py&amp;#39;) {
        // Python test parsing
        const testMatches &#x3D; content.match(/def\s+(test_\w+)/g);
        testMatches?.forEach(match &#x3D;&amp;gt; {
          const nameMatch &#x3D; match.match(/def\s+(test_\w+)/);
          if (nameMatch) {
            testCases.push({
              name: nameMatch[1],
              namespace: this.extractNamespaceFromFile(filePath),
              steps: [],
              metadata: {
                generated: false,
                source: &amp;#39;existing&amp;#39;,
                lastModified: new Date().toISOString(),
              },
            });
          }
        });
      }

      if (testCases.length &amp;gt; 0) {
        return {
          name: path.basename(filePath, path.extname(filePath)),
          namespace: this.extractNamespaceFromFile(filePath),
          cases: testCases,
          setup: [],
          teardown: [],
        };
      }
    } catch (error) {
      console.warn(&#x60;Warning: Could not parse test file ${filePath}:&#x60;, error);
    }

    return null;
  }

  /**
   * Extract namespace from file path
   */
  private extractNamespaceFromFile(filePath: string): string {
    const relativePath &#x3D; path.relative(process.cwd(), filePath);
    const parts &#x3D; relativePath.split(path.sep);

    // Remove file extension and test suffix
    const fileName &#x3D; path.basename(filePath, path.extname(filePath));
    const cleanFileName &#x3D; fileName.replace(/\.(test|spec)$/, &amp;#39;&amp;#39;);

    // Build namespace from path
    const namespaceParts &#x3D; [...parts.slice(0, -1), cleanFileName];
    return namespaceParts
      .join(&amp;#39;.&amp;#39;)
      .toLowerCase()
      .replace(/[^a-z0-9.]/g, &amp;#39;_&amp;#39;);
  }
}

/**
 * Generate test cases for services based on their configuration
 */
function generateServiceTests(services: DeploymentServiceConfig[], specName: string): TestSuite[] {
  const testSuites: TestSuite[] &#x3D; [];
  const engine &#x3D; new TestCompositionEngine(specName);

  for (const service of services) {
    const namespace &#x3D; engine.generateTestNamespace(service.name);

    const testCases: TestCase[] &#x3D; [];

    // Generate basic service tests
    if (service.ports &amp;amp;&amp;amp; service.ports.length &amp;gt; 0) {
      // Health check test
      testCases.push({
        name: &#x60;${service.name}_health_check&#x60;,
        namespace: namespace,
        description: &#x60;Health check for ${service.name} service&#x60;,
        steps: [
          {
            action: &amp;#39;http_request&amp;#39;,
            params: {
              method: &amp;#39;GET&amp;#39;,
              url: &#x60;http://localhost:${service.ports[0].port}/health&#x60;,
              timeout: 5000,
            },
            expected: { status: 200 },
          },
        ],
        metadata: {
          generated: true,
          source: &amp;#39;arbiter&amp;#39;,
          lastModified: new Date().toISOString(),
        },
      });

      // Port connectivity test
      for (const port of service.ports) {
        testCases.push({
          name: &#x60;${service.name}_port_${port.port}_connectivity&#x60;,
          namespace: namespace,
          description: &#x60;Test ${port.name || port.port} port connectivity&#x60;,
          steps: [
            {
              action: &amp;#39;tcp_connect&amp;#39;,
              params: {
                host: &amp;#39;localhost&amp;#39;,
                port: port.port,
                timeout: 3000,
              },
              expected: { connected: true },
            },
          ],
          metadata: {
            generated: true,
            source: &amp;#39;arbiter&amp;#39;,
            lastModified: new Date().toISOString(),
          },
        });
      }
    }

    // Generate environment variable tests
    if (service.env &amp;amp;&amp;amp; Object.keys(service.env).length &amp;gt; 0) {
      testCases.push({
        name: &#x60;${service.name}_environment_variables&#x60;,
        namespace: namespace,
        description: &#x60;Verify environment variables for ${service.name}&#x60;,
        steps: [
          {
            action: &amp;#39;check_environment&amp;#39;,
            params: {
              service: service.name,
              variables: Object.keys(service.env),
            },
            expected: { all_present: true },
          },
        ],
        metadata: {
          generated: true,
          source: &amp;#39;arbiter&amp;#39;,
          lastModified: new Date().toISOString(),
        },
      });
    }

    // Generate volume tests
    if (service.volumes &amp;amp;&amp;amp; service.volumes.length &amp;gt; 0) {
      for (const volume of service.volumes) {
        testCases.push({
          name: &#x60;${service.name}_volume_${volume.name}_mounted&#x60;,
          namespace: namespace,
          description: &#x60;Verify ${volume.name} volume is mounted at ${volume.path}&#x60;,
          steps: [
            {
              action: &amp;#39;check_volume_mount&amp;#39;,
              params: {
                service: service.name,
                path: volume.path,
                volume: volume.name,
              },
              expected: { mounted: true, writable: true },
            },
          ],
          metadata: {
            generated: true,
            source: &amp;#39;arbiter&amp;#39;,
            lastModified: new Date().toISOString(),
          },
        });
      }
    }

    // Generate service-type specific tests
    if (service.serviceType &#x3D;&#x3D;&#x3D; &amp;#39;prebuilt&amp;#39;) {
      // Test for pre-built services (like ClickHouse, Redis)
      testCases.push({
        name: &#x60;${service.name}_image_version&#x60;,
        namespace: namespace,
        description: &#x60;Verify ${service.name} is running expected image&#x60;,
        steps: [
          {
            action: &amp;#39;check_image&amp;#39;,
            params: {
              service: service.name,
              expectedImage: service.image,
            },
            expected: { image_matches: true },
          },
        ],
        metadata: {
          generated: true,
          source: &amp;#39;arbiter&amp;#39;,
          lastModified: new Date().toISOString(),
        },
      });
    }

    if (testCases.length &amp;gt; 0) {
      testSuites.push({
        name: &#x60;${service.name}_tests&#x60;,
        namespace: namespace,
        cases: testCases,
        setup: [
          {
            action: &amp;#39;wait_for_service&amp;#39;,
            params: {
              service: service.name,
              timeout: 30000,
            },
          },
        ],
        teardown: [],
      });
    }
  }

  return testSuites;
}

/**
 * Write test composition results to files
 */
async function writeTestFiles(
  testResult: TestCompositionResult,
  outputDir: string,
  language: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];
  const testsDir &#x3D; path.join(outputDir, &amp;#39;tests&amp;#39;);

  if (!fs.existsSync(testsDir) &amp;amp;&amp;amp; !options.dryRun) {
    await fs.mkdir(testsDir, { recursive: true });
  }

  // Write test suites based on language
  for (const suite of testResult.merged) {
    const fileName &#x3D; &#x60;${suite.name}.${getTestFileExtension(language)}&#x60;;
    const filePath &#x3D; path.join(testsDir, fileName);

    const content &#x3D; generateTestFileContent(suite, language);

    if (!options.dryRun) {
      await fs.writeFile(filePath, content);
    }
    files.push(&#x60;tests/${fileName}&#x60;);
  }

  // Write test composition report
  const reportPath &#x3D; path.join(testsDir, &amp;#39;composition_report.json&amp;#39;);
  const report &#x3D; {
    timestamp: new Date().toISOString(),
    summary: {
      totalTests: testResult.merged.reduce((sum, suite) &#x3D;&amp;gt; sum + suite.cases.length, 0),
      generatedTests: testResult.generated.length,
      preservedTests: testResult.preserved.length,
      conflicts: testResult.conflicts.length,
    },
    details: {
      conflicts: testResult.conflicts,
      generated: testResult.generated.map(t &#x3D;&amp;gt; ({ name: t.name, namespace: t.namespace })),
      preserved: testResult.preserved.map(t &#x3D;&amp;gt; ({ name: t.name, namespace: t.namespace })),
    },
  };

  if (!options.dryRun) {
    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
  }
  files.push(&amp;#39;tests/composition_report.json&amp;#39;);

  return files;
}

function getTestFileExtension(language: string): string {
  switch (language) {
    case &amp;#39;typescript&amp;#39;:
      return &amp;#39;test.ts&amp;#39;;
    case &amp;#39;javascript&amp;#39;:
      return &amp;#39;test.js&amp;#39;;
    case &amp;#39;python&amp;#39;:
      return &amp;#39;test.py&amp;#39;;
    case &amp;#39;rust&amp;#39;:
      return &amp;#39;rs&amp;#39;;
    case &amp;#39;go&amp;#39;:
      return &amp;#39;go&amp;#39;;
    default:
      return &amp;#39;test.js&amp;#39;;
  }
}

function generateTestFileContent(suite: TestSuite, language: string): string {
  switch (language) {
    case &amp;#39;typescript&amp;#39;:
    case &amp;#39;javascript&amp;#39;:
      return generateJavaScriptTestContent(suite);
    case &amp;#39;python&amp;#39;:
      return generatePythonTestContent(suite);
    case &amp;#39;rust&amp;#39;:
      return generateRustTestContent(suite);
    case &amp;#39;go&amp;#39;:
      return generateGoTestContent(suite);
    default:
      return generateJavaScriptTestContent(suite);
  }
}

function generateJavaScriptTestContent(suite: TestSuite): string {
  return &#x60;// ${suite.name} - Generated by Arbiter
// Namespace: ${suite.namespace}
// Generated: ${new Date().toISOString()}

import { describe, test, expect, beforeAll, afterAll } from &amp;#39;@jest/globals&amp;#39;;

describe(&amp;#39;${suite.name}&amp;#39;, () &#x3D;&amp;gt; {
${
  suite.setup &amp;amp;&amp;amp; suite.setup.length &amp;gt; 0
    ? &#x60;  beforeAll(async () &#x3D;&amp;gt; {
${suite.setup.map(step &#x3D;&amp;gt; &#x60;    // ${step.action}: ${JSON.stringify(step.params)}&#x60;).join(&amp;#39;\n&amp;#39;)}
  });

&#x60;
    : &amp;#39;&amp;#39;
}${suite.cases
    .map(
      testCase &#x3D;&amp;gt; &#x60;  test(&amp;#39;${testCase.name}&amp;#39;, async () &#x3D;&amp;gt; {
    // ${testCase.description || &amp;#39;Generated test&amp;#39;}
${testCase.steps
  .map(
    step &#x3D;&amp;gt; &#x60;    // ${step.action}: ${JSON.stringify(step.params)}
    // Expected: ${JSON.stringify(step.expected)}&#x60;
  )
  .join(&amp;#39;\n&amp;#39;)}
    
    // TODO: Implement test logic
    expect(true).toBe(true); // Placeholder
  });&#x60;
    )
    .join(&amp;#39;\n\n&amp;#39;)}
${
  suite.teardown &amp;amp;&amp;amp; suite.teardown.length &amp;gt; 0
    ? &#x60;
  afterAll(async () &#x3D;&amp;gt; {
${suite.teardown.map(step &#x3D;&amp;gt; &#x60;    // ${step.action}: ${JSON.stringify(step.params)}&#x60;).join(&amp;#39;\n&amp;#39;)}
  });&#x60;
    : &amp;#39;&amp;#39;
}
});
&#x60;;
}

function generatePythonTestContent(suite: TestSuite): string {
  return &#x60;&amp;quot;&amp;quot;&amp;quot;${suite.name} - Generated by Arbiter
Namespace: ${suite.namespace}
Generated: ${new Date().toISOString()}
&amp;quot;&amp;quot;&amp;quot;

import pytest
import asyncio
from typing import Dict, Any


class Test${suite.name.replace(/_/g, &amp;#39;&amp;#39;)}:
    &amp;quot;&amp;quot;&amp;quot;Test suite for ${suite.name}&amp;quot;&amp;quot;&amp;quot;
${
  suite.setup &amp;amp;&amp;amp; suite.setup.length &amp;gt; 0
    ? &#x60;
    @pytest.fixture(scope&#x3D;&amp;quot;class&amp;quot;, autouse&#x3D;True)
    async def setup_class(self):
        &amp;quot;&amp;quot;&amp;quot;Setup for test class&amp;quot;&amp;quot;&amp;quot;
${suite.setup.map(step &#x3D;&amp;gt; &#x60;        # ${step.action}: ${JSON.stringify(step.params)}&#x60;).join(&amp;#39;\n&amp;#39;)}
        pass
&#x60;
    : &amp;#39;&amp;#39;
}
${suite.cases
  .map(
    testCase &#x3D;&amp;gt; &#x60;    async def test_${testCase.name.toLowerCase().replace(/[^a-z0-9]/g, &amp;#39;_&amp;#39;)}(self):
        &amp;quot;&amp;quot;&amp;quot;${testCase.description || &amp;#39;Generated test&amp;#39;}&amp;quot;&amp;quot;&amp;quot;
${testCase.steps
  .map(
    step &#x3D;&amp;gt; &#x60;        # ${step.action}: ${JSON.stringify(step.params)}
        # Expected: ${JSON.stringify(step.expected)}&#x60;
  )
  .join(&amp;#39;\n&amp;#39;)}
        
        # TODO: Implement test logic
        assert True  # Placeholder&#x60;
  )
  .join(&amp;#39;\n\n&amp;#39;)}
${
  suite.teardown &amp;amp;&amp;amp; suite.teardown.length &amp;gt; 0
    ? &#x60;
    @pytest.fixture(scope&#x3D;&amp;quot;class&amp;quot;, autouse&#x3D;True)
    async def teardown_class(self):
        &amp;quot;&amp;quot;&amp;quot;Teardown for test class&amp;quot;&amp;quot;&amp;quot;
${suite.teardown.map(step &#x3D;&amp;gt; &#x60;        # ${step.action}: ${JSON.stringify(step.params)}&#x60;).join(&amp;#39;\n&amp;#39;)}
        pass&#x60;
    : &amp;#39;&amp;#39;
}
&#x60;;
}

function generateRustTestContent(suite: TestSuite): string {
  return &#x60;// ${suite.name} - Generated by Arbiter
// Namespace: ${suite.namespace}
// Generated: ${new Date().toISOString()}

#[cfg(test)]
mod ${suite.name.replace(/-/g, &amp;#39;_&amp;#39;)} {
    use super::*;
    use tokio_test;

${suite.cases
  .map(
    testCase &#x3D;&amp;gt; &#x60;    #[tokio::test]
    async fn ${testCase.name.toLowerCase().replace(/[^a-z0-9]/g, &amp;#39;_&amp;#39;)}() {
        // ${testCase.description || &amp;#39;Generated test&amp;#39;}
${testCase.steps
  .map(
    step &#x3D;&amp;gt; &#x60;        // ${step.action}: ${JSON.stringify(step.params)}
        // Expected: ${JSON.stringify(step.expected)}&#x60;
  )
  .join(&amp;#39;\n&amp;#39;)}
        
        // TODO: Implement test logic
        assert!(true); // Placeholder
    }&#x60;
  )
  .join(&amp;#39;\n\n&amp;#39;)}
}
&#x60;;
}

function generateGoTestContent(suite: TestSuite): string {
  return &#x60;// ${suite.name} - Generated by Arbiter
// Namespace: ${suite.namespace}
// Generated: ${new Date().toISOString()}

package main

import (
    &amp;quot;testing&amp;quot;
    &amp;quot;context&amp;quot;
    &amp;quot;time&amp;quot;
)

${suite.cases
  .map(
    testCase &#x3D;&amp;gt; &#x60;func Test${testCase.name.replace(/[^a-zA-Z0-9]/g, &amp;#39;&amp;#39;)}(t *testing.T) {
    // ${testCase.description || &amp;#39;Generated test&amp;#39;}
${testCase.steps
  .map(
    step &#x3D;&amp;gt; &#x60;    // ${step.action}: ${JSON.stringify(step.params)}
    // Expected: ${JSON.stringify(step.expected)}&#x60;
  )
  .join(&amp;#39;\n&amp;#39;)}
    
    // TODO: Implement test logic
    if true !&#x3D; true { // Placeholder
        t.Errorf(&amp;quot;Test failed&amp;quot;)
    }
}&#x60;
  )
  .join(&amp;#39;\n\n&amp;#39;)}
&#x60;;
}

/**
 * Main function to generate and compose tests with existing test suites
 */
async function generateAndComposeTests(
  assemblyConfig: any,
  outputDir: string,
  options: GenerateOptions
): Promise&amp;lt;string[]&amp;gt; {
  try {
    const testConfig &#x3D; extractTestConfiguration(assemblyConfig);
    const testComposition &#x3D; await composeTestSuites(testConfig, outputDir);
    const files &#x3D; await writeTestFiles(
      testComposition.result,
      outputDir,
      testConfig.language,
      options
    );

    if (options.verbose) {
      reportTestComposition(testComposition.result);
    }

    return files;
  } catch (error) {
    return handleTestGenerationError(error);
  }
}

/**
 * Extract test configuration from assembly config
 */
function extractTestConfiguration(assemblyConfig: any) {
  const { services } &#x3D; parseDockerComposeServices(assemblyConfig);
  const specName &#x3D; assemblyConfig?.metadata?.name || &amp;#39;default&amp;#39;;
  const language &#x3D; assemblyConfig?.config?.language || &amp;#39;typescript&amp;#39;;

  return { services, specName, language };
}

/**
 * Compose test suites by merging existing and new tests
 */
async function composeTestSuites(
  config: { services: any; specName: string; language: string },
  outputDir: string
) {
  const engine &#x3D; new TestCompositionEngine(config.specName);

  const existingTests &#x3D; await engine.discoverExistingTests(outputDir);
  const newTestSuites &#x3D; generateServiceTests(config.services, config.specName);
  const result &#x3D; engine.mergeTestSuites(existingTests, newTestSuites);

  return { engine, result };
}

/**
 * Report test composition results
 */
function reportTestComposition(testResult: any): void {
  console.log(chalk.blue(&amp;#39;\nğŸ“‹ Test Composition Summary:&amp;#39;));
  console.log(chalk.dim(&#x60;  Generated: ${testResult.generated.length} test cases&#x60;));
  console.log(chalk.dim(&#x60;  Preserved: ${testResult.preserved.length} existing test cases&#x60;));
  console.log(chalk.dim(&#x60;  Conflicts: ${testResult.conflicts.length} resolved&#x60;));

  if (testResult.conflicts.length &amp;gt; 0) {
    reportTestConflicts(testResult.conflicts);
  }
}

/**
 * Report test conflict resolution details
 */
function reportTestConflicts(conflicts: any[]): void {
  console.log(chalk.yellow(&amp;#39;\nâš ï¸  Test Conflicts Resolved:&amp;#39;));
  conflicts.forEach(conflict &#x3D;&amp;gt; {
    console.log(chalk.dim(&#x60;  â€¢ ${conflict.test}: ${conflict.reason} (${conflict.resolution})&#x60;));
  });
}

/**
 * Handle test generation errors
 */
function handleTestGenerationError(error: unknown): string[] {
  console.warn(
    chalk.yellow(
      &#x60;âš ï¸  Test generation failed: ${error instanceof Error ? error.message : String(error)}&#x60;
    )
  );
  return [];
}

/**
 * Emit sharded CUE specifications from service to .arbiter directory before generation
 */
async function emitSpecificationFromService(config: CLIConfig): Promise&amp;lt;void&amp;gt; {
  try {
    const apiClient &#x3D; new ApiClient(config);

    // Ensure .arbiter directory exists
    await fs.ensureDir(&amp;#39;.arbiter&amp;#39;);

    // Try to get the stored specifications from service (sharded)
    const assemblyPath &#x3D; path.resolve(&amp;#39;.arbiter&amp;#39;, &amp;#39;assembly.cue&amp;#39;);
    const storedSpec &#x3D; await apiClient.getSpecification(&amp;#39;assembly&amp;#39;, assemblyPath);

    if (storedSpec.success &amp;amp;&amp;amp; storedSpec.data &amp;amp;&amp;amp; storedSpec.data.content) {
      // Emit the main assembly CUE file to .arbiter directory
      await fs.writeFile(assemblyPath, storedSpec.data.content, &amp;#39;utf-8&amp;#39;);
      console.log(
        chalk.green(&amp;#39;ğŸ“„ Emitted CUE specification from service to .arbiter/assembly.cue&amp;#39;)
      );

      // Also try to get any sharded specification files
      await emitShardedSpecifications(apiClient);
    } else {
      console.log(chalk.dim(&amp;#39;ğŸ’¡ No stored specification found, using existing CUE files&amp;#39;));
    }
  } catch (error) {
    // Service unavailable, continue with existing file-based workflow
    console.log(chalk.dim(&amp;#39;ğŸ’¡ Service unavailable, using existing CUE files&amp;#39;));
  }
}

/**
 * Emit additional sharded CUE files from service
 */
async function emitShardedSpecifications(apiClient: ApiClient): Promise&amp;lt;void&amp;gt; {
  try {
    // Try to get any additional sharded files (services, endpoints, etc.)
    const shardTypes &#x3D; [&amp;#39;services&amp;#39;, &amp;#39;endpoints&amp;#39;, &amp;#39;schemas&amp;#39;, &amp;#39;flows&amp;#39;];

    for (const shardType of shardTypes) {
      const shardPath &#x3D; path.resolve(&amp;#39;.arbiter&amp;#39;, &#x60;${shardType}.cue&#x60;);
      const shardSpec &#x3D; await apiClient.getSpecification(shardType, shardPath);

      if (shardSpec.success &amp;amp;&amp;amp; shardSpec.data &amp;amp;&amp;amp; shardSpec.data.content) {
        await fs.writeFile(shardPath, shardSpec.data.content, &amp;#39;utf-8&amp;#39;);
        console.log(chalk.dim(&#x60;  ğŸ“„ Emitted ${shardType} shard to .arbiter/${shardType}.cue&#x60;));
      }
    }
  } catch (error) {
    // Sharded files are optional, continue silently
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-43">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/check.ts</div>
                <div class="file-content">
                    <pre>import path from &amp;#39;node:path&amp;#39;;
import { translateCueErrors } from &amp;#39;@arbiter/shared&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import { glob } from &amp;#39;glob&amp;#39;;
import { ApiClient } from &amp;#39;../api-client.js&amp;#39;;
import type { CLIConfig, CheckOptions, ValidationResult } from &amp;#39;../types.js&amp;#39;;
import {
  formatErrorDetails,
  formatFileSize,
  formatJson,
  formatSummary,
  formatValidationTable,
  formatWarningDetails,
} from &amp;#39;../utils/formatting.js&amp;#39;;
import { withProgress } from &amp;#39;../utils/progress.js&amp;#39;;

/**
 * Check command implementation
 * Validates CUE files in the current directory with pretty output and proper exit codes
 */
export async function checkCommand(
  patterns: string[],
  options: CheckOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  try {
    // Use default pattern if none provided
    if (patterns.length &#x3D;&#x3D;&#x3D; 0) {
      patterns &#x3D; [&amp;#39;**/*.cue&amp;#39;];
    }

    // Find all matching files
    const files &#x3D; await findCueFiles(patterns, {
      recursive: options.recursive ?? true,
      cwd: config.projectDir,
    });

    if (files.length &#x3D;&#x3D;&#x3D; 0) {
      console.log(chalk.yellow(&amp;#39;No CUE files found&amp;#39;));
      return 0;
    }

    console.log(chalk.dim(&#x60;Found ${files.length} CUE files&#x60;));

    // Validate files
    const results &#x3D; await validateFiles(files, config, options);

    // Format and display results
    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      console.log(formatJson(results, config.color));
    } else {
      displayResults(results, options, config);
    }

    // Determine exit code
    const hasErrors &#x3D; results.some(r &#x3D;&amp;gt; r.status &#x3D;&#x3D;&#x3D; &amp;#39;invalid&amp;#39; || r.status &#x3D;&#x3D;&#x3D; &amp;#39;error&amp;#39;);
    return hasErrors ? 1 : 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Check command failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 2;
  }
}

/**
 * Find CUE files matching the given patterns
 */
async function findCueFiles(
  patterns: string[],
  options: {
    recursive: boolean;
    cwd: string;
  }
): Promise&amp;lt;string[]&amp;gt; {
  const allFiles: string[] &#x3D; [];

  for (const pattern of patterns) {
    const files &#x3D; await glob(pattern, {
      cwd: options.cwd,
      absolute: true,
      ignore: [&amp;#39;**/node_modules/**&amp;#39;, &amp;#39;**/.git/**&amp;#39;, &amp;#39;**/dist/**&amp;#39;, &amp;#39;**/build/**&amp;#39;],
    });

    allFiles.push(...files);
  }

  // Remove duplicates and sort
  return [...new Set(allFiles)].sort();
}

/**
 * Validate multiple files with progress tracking
 */
async function validateFiles(
  files: string[],
  config: CLIConfig,
  options: CheckOptions
): Promise&amp;lt;ValidationResult[]&amp;gt; {
  const apiClient &#x3D; await initializeApiClient(config);

  return await executeValidationWithProgress(files, config, apiClient, options);
}

/**
 * Initialize API client with health check
 */
async function initializeApiClient(config: CLIConfig): Promise&amp;lt;ApiClient&amp;gt; {
  const apiClient &#x3D; new ApiClient(config);

  const healthCheck &#x3D; await apiClient.health();
  if (!healthCheck.success) {
    throw new Error(&#x60;Cannot connect to Arbiter server: ${healthCheck.error}&#x60;);
  }

  return apiClient;
}

/**
 * Execute validation with progress tracking
 */
async function executeValidationWithProgress(
  files: string[],
  config: CLIConfig,
  apiClient: ApiClient,
  options: CheckOptions
): Promise&amp;lt;ValidationResult[]&amp;gt; {
  const progressText &#x3D; &#x60;Validating ${files.length} files...&#x60;;

  return withProgress({ text: progressText, color: &amp;#39;blue&amp;#39; }, async () &#x3D;&amp;gt; {
    return await processFilesInChunks(files, config, apiClient, options);
  });
}

/**
 * Process files in chunks with concurrency control
 */
async function processFilesInChunks(
  files: string[],
  config: CLIConfig,
  apiClient: ApiClient,
  options: CheckOptions
): Promise&amp;lt;ValidationResult[]&amp;gt; {
  const results: ValidationResult[] &#x3D; [];
  const concurrency &#x3D; 5; // Limit concurrent requests
  const chunks &#x3D; chunkArray(files, concurrency);

  for (const chunk of chunks) {
    const chunkResults &#x3D; await processFileChunk(chunk, config, apiClient, options);
    results.push(...chunkResults);

    if (shouldStopProcessing(options, chunkResults)) {
      break;
    }
  }

  return results;
}

/**
 * Process a single chunk of files
 */
async function processFileChunk(
  chunk: string[],
  config: CLIConfig,
  apiClient: ApiClient,
  options: CheckOptions
): Promise&amp;lt;ValidationResult[]&amp;gt; {
  return await Promise.all(
    chunk.map(async file &#x3D;&amp;gt; {
      const result &#x3D; await validateFile(file, apiClient, options);

      if (options.verbose) {
        logFileValidationResult(file, result, config);
      }

      return result;
    })
  );
}

/**
 * Log validation result for a file
 */
function logFileValidationResult(file: string, result: ValidationResult, config: CLIConfig): void {
  const status &#x3D; getStatusIcon(result.status);
  console.log(&#x60;${status} ${path.relative(config.projectDir, file)}&#x60;);
}

/**
 * Get status icon for validation result
 */
function getStatusIcon(status: string): string {
  switch (status) {
    case &amp;#39;valid&amp;#39;:
      return chalk.green(&amp;#39;âœ“&amp;#39;);
    case &amp;#39;invalid&amp;#39;:
      return chalk.red(&amp;#39;âœ—&amp;#39;);
    default:
      return chalk.yellow(&amp;#39;!&amp;#39;);
  }
}

/**
 * Determine if processing should stop based on fail-fast option
 */
function shouldStopProcessing(options: CheckOptions, chunkResults: ValidationResult[]): boolean {
  return options.failFast &amp;amp;&amp;amp; chunkResults.some(r &#x3D;&amp;gt; r.status !&#x3D;&#x3D; &amp;#39;valid&amp;#39;);
}

/**
 * Validate a single file
 */
async function validateFile(
  filePath: string,
  apiClient: ApiClient,
  _options: CheckOptions
): Promise&amp;lt;ValidationResult&amp;gt; {
  const startTime &#x3D; Date.now();

  try {
    // Check if file exists and is readable
    const stats &#x3D; await fs.stat(filePath);
    if (!stats.isFile()) {
      return {
        file: path.basename(filePath),
        status: &amp;#39;error&amp;#39;,
        errors: [
          {
            line: 0,
            column: 0,
            message: &amp;#39;Not a file&amp;#39;,
            severity: &amp;#39;error&amp;#39; as const,
            category: &amp;#39;system&amp;#39;,
          },
        ],
        warnings: [],
        processingTime: Date.now() - startTime,
      };
    }

    // Check file size (limit to reasonable size for performance)
    const maxSize &#x3D; 10 * 1024 * 1024; // 10MB
    if (stats.size &amp;gt; maxSize) {
      return {
        file: path.basename(filePath),
        status: &amp;#39;error&amp;#39;,
        errors: [
          {
            line: 0,
            column: 0,
            message: &#x60;File too large (${formatFileSize(stats.size)}), maximum allowed: ${formatFileSize(maxSize)}&#x60;,
            severity: &amp;#39;error&amp;#39; as const,
            category: &amp;#39;system&amp;#39;,
          },
        ],
        warnings: [],
        processingTime: Date.now() - startTime,
      };
    }

    // Read file content
    const content &#x3D; await fs.readFile(filePath, &amp;#39;utf-8&amp;#39;);

    // Validate using API
    const validationResult &#x3D; await apiClient.validate(content);

    if (!validationResult.success || !validationResult.data) {
      return {
        file: path.basename(filePath),
        status: &amp;#39;error&amp;#39;,
        errors: [
          {
            line: 0,
            column: 0,
            message: validationResult.error || &amp;#39;Unknown validation error&amp;#39;,
            severity: &amp;#39;error&amp;#39; as const,
            category: &amp;#39;api&amp;#39;,
          },
        ],
        warnings: [],
        processingTime: Date.now() - startTime,
      };
    }

    const data &#x3D; validationResult.data;

    // Process errors with enhanced translation
    const errors &#x3D;
      data.errors?.map(error &#x3D;&amp;gt; {
        const translated &#x3D; translateCueErrors(error.message);
        return {
          line: error.line || 0,
          column: error.column || 0,
          message: translated[0]?.friendlyMessage || error.message,
          severity: &amp;#39;error&amp;#39; as const,
          category: translated[0]?.category || &amp;#39;validation&amp;#39;,
        };
      }) || [];

    // Process warnings
    const warnings &#x3D;
      data.warnings?.map(warning &#x3D;&amp;gt; ({
        line: warning.line || 0,
        column: warning.column || 0,
        message: warning.message,
        category: &amp;#39;validation&amp;#39;,
      })) || [];

    const status &#x3D; data.success ? &amp;#39;valid&amp;#39; : &amp;#39;invalid&amp;#39;;

    return {
      file: path.basename(filePath),
      status,
      errors,
      warnings,
      processingTime: Date.now() - startTime,
    };
  } catch (error) {
    return {
      file: path.basename(filePath),
      status: &amp;#39;error&amp;#39;,
      errors: [
        {
          line: 0,
          column: 0,
          message: error instanceof Error ? error.message : String(error),
          severity: &amp;#39;error&amp;#39; as const,
          category: &amp;#39;system&amp;#39;,
        },
      ],
      warnings: [],
      processingTime: Date.now() - startTime,
    };
  }
}

/**
 * Display validation results with proper formatting
 */
function displayResults(
  results: ValidationResult[],
  options: CheckOptions,
  _config: CLIConfig
): void {
  // Show table
  console.log(&#x60;\n${formatValidationTable(results)}&#x60;);

  // Show detailed errors if present
  if (options.verbose || results.some(r &#x3D;&amp;gt; r.errors.length &amp;gt; 0)) {
    const errorDetails &#x3D; formatErrorDetails(results);
    if (errorDetails) {
      console.log(errorDetails);
    }
  }

  // Show warnings if verbose or if there are warnings
  if (options.verbose || results.some(r &#x3D;&amp;gt; r.warnings.length &amp;gt; 0)) {
    const warningDetails &#x3D; formatWarningDetails(results);
    if (warningDetails) {
      console.log(warningDetails);
    }
  }

  // Show summary
  console.log(formatSummary(results));
}

/**
 * Utility to chunk array for batch processing
 */
function chunkArray&amp;lt;T&amp;gt;(array: T[], size: number): T[][] {
  const chunks: T[][] &#x3D; [];
  for (let i &#x3D; 0; i &amp;lt; array.length; i +&#x3D; size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-44">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/create.ts</div>
                <div class="file-content">
                    <pre>import fs from &amp;#39;node:fs/promises&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import { fileURLToPath } from &amp;#39;node:url&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import inquirer from &amp;#39;inquirer&amp;#39;;

const __filename &#x3D; fileURLToPath(import.meta.url);
const __dirname &#x3D; path.dirname(__filename);

export interface CreateOptions {
  interactive?: boolean;
  template?: string;
  output?: string;
  name?: string;
}

export interface SchemaConfig {
  systemType: &amp;#39;api&amp;#39; | &amp;#39;microservice&amp;#39; | &amp;#39;agent_framework&amp;#39; | &amp;#39;data_pipeline&amp;#39; | &amp;#39;web_app&amp;#39; | &amp;#39;cli_tool&amp;#39;;
  projectName: string;
  hasBudgetConstraints: boolean;
  budgetLimit?: number;
  budgetCurrency?: string;
  budgetPeriod?: string;
  hasQualityGates: boolean;
  qualityThresholds?: {
    testCoverage?: number;
    performanceTarget?: string;
    securityLevel?: string;
  };
  hasSelectionRubric: boolean;
  selectionCriteria?: string[];
  hasDependencyChain: boolean;
  dependencySteps?: string[];
  customConstraints?: string[];
  outputPath: string;
}

/**
 * Get templates directory path
 */
function getTemplatesDir(): string {
  return path.resolve(__dirname, &amp;#39;../../templates&amp;#39;);
}

/**
 * Load template content
 */
async function loadTemplateContent(templateName: string): Promise&amp;lt;string | null&amp;gt; {
  try {
    const templatesDir &#x3D; getTemplatesDir();
    const cuePath &#x3D; path.join(templatesDir, &#x60;${templateName}.cue&#x60;);
    return await fs.readFile(cuePath, &amp;#39;utf-8&amp;#39;);
  } catch (_error) {
    return null;
  }
}

/**
 * Interactive schema configuration prompts
 */
/**
 * Display welcome message for interactive schema builder
 */
function displayWelcomeMessage(): void {
  console.log(chalk.cyan(&amp;#39;ğŸš€ Arbiter Interactive Schema Builder&amp;#39;));
  console.log(
    chalk.dim(&amp;#39;Answer a few questions to generate a tailored CUE schema with constraints\n&amp;#39;)
  );
}

/**
 * Collect basic project information
 */
async function collectBasicProjectInfo(): Promise&amp;lt;any&amp;gt; {
  return await inquirer.prompt([
    {
      type: &amp;#39;input&amp;#39;,
      name: &amp;#39;projectName&amp;#39;,
      message: &amp;#39;What is your project name?&amp;#39;,
      default: &amp;#39;my-project&amp;#39;,
      validate: (input: string) &#x3D;&amp;gt; {
        if (!input.trim()) return &amp;#39;Project name is required&amp;#39;;
        if (!/^[a-z][a-z0-9-_]*$/.test(input)) {
          return &amp;#39;Project name must start with lowercase letter and contain only lowercase letters, numbers, hyphens, and underscores&amp;#39;;
        }
        return true;
      },
    },
    {
      type: &amp;#39;list&amp;#39;,
      name: &amp;#39;systemType&amp;#39;,
      message: &amp;#39;What type of system are you building?&amp;#39;,
      choices: [
        { name: &amp;#39;ğŸŒ API/REST Service&amp;#39;, value: &amp;#39;api&amp;#39; },
        { name: &amp;#39;ğŸ”§ Microservice&amp;#39;, value: &amp;#39;microservice&amp;#39; },
        { name: &amp;#39;ğŸ¤– Agent Framework&amp;#39;, value: &amp;#39;agent_framework&amp;#39; },
        { name: &amp;#39;ğŸ“Š Data Pipeline&amp;#39;, value: &amp;#39;data_pipeline&amp;#39; },
        { name: &amp;#39;ğŸ’» Web Application&amp;#39;, value: &amp;#39;web_app&amp;#39; },
        { name: &amp;#39;âš¡ CLI Tool&amp;#39;, value: &amp;#39;cli_tool&amp;#39; },
      ],
    },
    {
      type: &amp;#39;confirm&amp;#39;,
      name: &amp;#39;hasBudgetConstraints&amp;#39;,
      message: &amp;#39;Do you need budget/resource constraints?&amp;#39;,
      default: false,
    },
  ]);
}

/**
 * Collect budget configuration if needed
 */
async function collectBudgetConfig(hasBudgetConstraints: boolean): Promise&amp;lt;any&amp;gt; {
  if (!hasBudgetConstraints) {
    return {};
  }

  return await inquirer.prompt([
    {
      type: &amp;#39;number&amp;#39;,
      name: &amp;#39;budgetLimit&amp;#39;,
      message: &amp;#39;What is your budget limit?&amp;#39;,
      default: 1000,
      validate: (input: number) &#x3D;&amp;gt; input &amp;gt; 0 || &amp;#39;Budget must be greater than 0&amp;#39;,
    },
    {
      type: &amp;#39;list&amp;#39;,
      name: &amp;#39;budgetCurrency&amp;#39;,
      message: &amp;#39;What currency/unit?&amp;#39;,
      choices: [&amp;#39;USD&amp;#39;, &amp;#39;EUR&amp;#39;, &amp;#39;credits&amp;#39;, &amp;#39;GB&amp;#39;, &amp;#39;CPU hours&amp;#39;, &amp;#39;API calls&amp;#39;],
      default: &amp;#39;USD&amp;#39;,
    },
    {
      type: &amp;#39;list&amp;#39;,
      name: &amp;#39;budgetPeriod&amp;#39;,
      message: &amp;#39;What time period?&amp;#39;,
      choices: [&amp;#39;hourly&amp;#39;, &amp;#39;daily&amp;#39;, &amp;#39;weekly&amp;#39;, &amp;#39;monthly&amp;#39;, &amp;#39;yearly&amp;#39;],
      default: &amp;#39;monthly&amp;#39;,
    },
  ]);
}

/**
 * Ask if user wants quality gates
 */
async function askForQualityGates(): Promise&amp;lt;boolean&amp;gt; {
  const answers &#x3D; await inquirer.prompt([
    {
      type: &amp;#39;confirm&amp;#39;,
      name: &amp;#39;hasQualityGates&amp;#39;,
      message: &amp;#39;Do you want quality gates (performance, testing, security)?&amp;#39;,
      default: true,
    },
  ]);
  return answers.hasQualityGates;
}

/**
 * Collect quality thresholds configuration
 */
async function collectQualityThresholds(): Promise&amp;lt;any&amp;gt; {
  return await inquirer.prompt([
    {
      type: &amp;#39;number&amp;#39;,
      name: &amp;#39;testCoverage&amp;#39;,
      message: &amp;#39;Minimum test coverage percentage?&amp;#39;,
      default: 80,
      validate: (input: number) &#x3D;&amp;gt;
        (input &amp;gt;&#x3D; 0 &amp;amp;&amp;amp; input &amp;lt;&#x3D; 100) || &amp;#39;Coverage must be between 0 and 100&amp;#39;,
    },
    {
      type: &amp;#39;input&amp;#39;,
      name: &amp;#39;performanceTarget&amp;#39;,
      message: &amp;#39;Performance target (e.g., &amp;quot;&amp;lt; 200ms&amp;quot;, &amp;quot;1000 RPS&amp;quot;)?&amp;#39;,
      default: &amp;#39;&amp;lt; 200ms&amp;#39;,
    },
    {
      type: &amp;#39;list&amp;#39;,
      name: &amp;#39;securityLevel&amp;#39;,
      message: &amp;#39;Security level requirement?&amp;#39;,
      choices: [&amp;#39;basic&amp;#39;, &amp;#39;standard&amp;#39;, &amp;#39;high&amp;#39;, &amp;#39;critical&amp;#39;],
      default: &amp;#39;standard&amp;#39;,
    },
  ]);
}

/**
 * Collect quality configuration if needed
 */
async function collectQualityConfig(hasQualityGates: boolean): Promise&amp;lt;any&amp;gt; {
  if (!hasQualityGates) {
    return {};
  }

  const thresholds &#x3D; await collectQualityThresholds();
  return { qualityThresholds: thresholds };
}

/**
 * Ask if user wants selection rubric
 */
async function askForSelectionRubric(): Promise&amp;lt;boolean&amp;gt; {
  const answers &#x3D; await inquirer.prompt([
    {
      type: &amp;#39;confirm&amp;#39;,
      name: &amp;#39;hasSelectionRubric&amp;#39;,
      message: &amp;#39;Do you need a selection/evaluation rubric?&amp;#39;,
      default: false,
    },
  ]);
  return answers.hasSelectionRubric;
}

/**
 * Collect selection criteria
 */
async function collectSelectionCriteria(): Promise&amp;lt;any&amp;gt; {
  return await inquirer.prompt([
    {
      type: &amp;#39;checkbox&amp;#39;,
      name: &amp;#39;selectionCriteria&amp;#39;,
      message: &amp;#39;Select evaluation criteria:&amp;#39;,
      choices: [
        &amp;#39;Performance&amp;#39;,
        &amp;#39;Cost&amp;#39;,
        &amp;#39;Reliability&amp;#39;,
        &amp;#39;Security&amp;#39;,
        &amp;#39;Scalability&amp;#39;,
        &amp;#39;Maintainability&amp;#39;,
        &amp;#39;User Experience&amp;#39;,
        &amp;#39;Documentation&amp;#39;,
      ],
      validate: (input: string[]) &#x3D;&amp;gt; input.length &amp;gt; 0 || &amp;#39;Select at least one criteria&amp;#39;,
    },
  ]);
}

/**
 * Collect selection configuration if needed
 */
async function collectSelectionConfig(hasSelectionRubric: boolean): Promise&amp;lt;any&amp;gt; {
  if (!hasSelectionRubric) {
    return {};
  }

  return await collectSelectionCriteria();
}

/**
 * Ask if user has complex dependencies
 */
async function askForDependencyChain(): Promise&amp;lt;boolean&amp;gt; {
  const answers &#x3D; await inquirer.prompt([
    {
      type: &amp;#39;confirm&amp;#39;,
      name: &amp;#39;hasDependencyChain&amp;#39;,
      message: &amp;#39;Do you have complex dependencies/workflows to model?&amp;#39;,
      default: false,
    },
  ]);
  return answers.hasDependencyChain;
}

/**
 * Collect dependency workflow steps
 */
async function collectDependencySteps(): Promise&amp;lt;any&amp;gt; {
  return await inquirer.prompt([
    {
      type: &amp;#39;input&amp;#39;,
      name: &amp;#39;dependencySteps&amp;#39;,
      message: &amp;#39;Enter main workflow steps (comma-separated):&amp;#39;,
      default: &amp;#39;validate,build,test,deploy&amp;#39;,
      filter: (input: string) &#x3D;&amp;gt; input.split(&amp;#39;,&amp;#39;).map(s &#x3D;&amp;gt; s.trim()),
      validate: (input: string[]) &#x3D;&amp;gt; input.length &amp;gt; 0 || &amp;#39;Enter at least one step&amp;#39;,
    },
  ]);
}

/**
 * Collect dependency configuration if needed
 */
async function collectDependencyConfig(hasDependencyChain: boolean): Promise&amp;lt;any&amp;gt; {
  if (!hasDependencyChain) {
    return {};
  }

  return await collectDependencySteps();
}

/**
 * Collect output configuration
 */
async function collectOutputConfig(projectName: string): Promise&amp;lt;any&amp;gt; {
  return await inquirer.prompt([
    {
      type: &amp;#39;input&amp;#39;,
      name: &amp;#39;outputPath&amp;#39;,
      message: &amp;#39;Output file path:&amp;#39;,
      default: &#x60;${projectName}-schema.cue&#x60;,
      validate: (input: string) &#x3D;&amp;gt; {
        if (!input.trim()) return &amp;#39;Output path is required&amp;#39;;
        if (!input.endsWith(&amp;#39;.cue&amp;#39;)) return &amp;#39;File must have .cue extension&amp;#39;;
        return true;
      },
    },
  ]);
}

async function interactiveSchemaConfig(): Promise&amp;lt;SchemaConfig&amp;gt; {
  displayWelcomeMessage();

  // Collect basic project information
  const basicAnswers &#x3D; await collectBasicProjectInfo();

  // Collect budget configuration if needed
  const budgetConfig &#x3D; await collectBudgetConfig(basicAnswers.hasBudgetConstraints);

  // Collect quality configuration
  const hasQualityGates &#x3D; await askForQualityGates();
  const qualityConfig &#x3D; await collectQualityConfig(hasQualityGates);

  // Collect selection configuration
  const hasSelectionRubric &#x3D; await askForSelectionRubric();
  const selectionConfig &#x3D; await collectSelectionConfig(hasSelectionRubric);

  // Collect dependency configuration
  const hasDependencyChain &#x3D; await askForDependencyChain();
  const dependencyConfig &#x3D; await collectDependencyConfig(hasDependencyChain);

  // Collect output configuration
  const outputConfig &#x3D; await collectOutputConfig(basicAnswers.projectName);

  // Combine all configurations
  return {
    ...basicAnswers,
    ...budgetConfig,
    ...qualityConfig,
    ...selectionConfig,
    ...dependencyConfig,
    ...outputConfig,
  };
}

/**
 * Generate CUE schema from configuration
 */
async function generateSchemaFromConfig(config: SchemaConfig): Promise&amp;lt;string&amp;gt; {
  const templates &#x3D; [];

  // Load and customize templates based on configuration
  if (config.hasBudgetConstraints) {
    const budgetTemplate &#x3D; await loadTemplateContent(&amp;#39;budget_constraint&amp;#39;);
    if (budgetTemplate) {
      templates.push(budgetTemplate);
    }
  }

  if (config.hasSelectionRubric) {
    const rubricTemplate &#x3D; await loadTemplateContent(&amp;#39;selection_rubric&amp;#39;);
    if (rubricTemplate) {
      templates.push(rubricTemplate);
    }
  }

  if (config.hasDependencyChain) {
    const dependencyTemplate &#x3D; await loadTemplateContent(&amp;#39;dependency_chain&amp;#39;);
    if (dependencyTemplate) {
      templates.push(dependencyTemplate);
    }
  }

  // Generate the main schema
  let schema &#x3D; &#x60;// ${config.projectName} - Generated Schema
// System Type: ${config.systemType}
// Generated: ${new Date().toISOString()}

package ${config.projectName.replace(/-/g, &amp;#39;_&amp;#39;)}

import &amp;quot;strings&amp;quot;
import &amp;quot;list&amp;quot;

// Project metadata
#ProjectInfo: {
	name:        &amp;quot;${config.projectName}&amp;quot;
	system_type: &amp;quot;${config.systemType}&amp;quot;
	version:     &amp;quot;1.0.0&amp;quot;
	generated:   &amp;quot;${new Date().toISOString()}&amp;quot;
}

// System configuration
#SystemConfig: {
	project: #ProjectInfo
	
	// System-specific constraints
	constraints: {&#x60;;

  // Add budget constraints if enabled
  if (config.hasBudgetConstraints) {
    schema +&#x3D; &#x60;
		// Budget constraints
		budget: {
			limit:    ${config.budgetLimit}
			currency: &amp;quot;${config.budgetCurrency}&amp;quot;
			period:   &amp;quot;${config.budgetPeriod}&amp;quot;
		}&#x60;;
  }

  // Add quality gates if enabled
  if (config.hasQualityGates &amp;amp;&amp;amp; config.qualityThresholds) {
    schema +&#x3D; &#x60;
		// Quality gates
		quality: {
			test_coverage:      ${config.qualityThresholds.testCoverage}
			performance_target: &amp;quot;${config.qualityThresholds.performanceTarget}&amp;quot;
			security_level:     &amp;quot;${config.qualityThresholds.securityLevel}&amp;quot;
		}&#x60;;
  }

  // Add selection criteria if enabled
  if (config.hasSelectionRubric &amp;amp;&amp;amp; config.selectionCriteria) {
    schema +&#x3D; &#x60;
		// Selection criteria
		selection_criteria: [${config.selectionCriteria?.map(c &#x3D;&amp;gt; &#x60;&amp;quot;${c}&amp;quot;&#x60;).join(&amp;#39;, &amp;#39;)}]&#x60;;
  }

  // Add dependency steps if enabled
  if (config.hasDependencyChain &amp;amp;&amp;amp; config.dependencySteps) {
    schema +&#x3D; &#x60;
		// Workflow dependencies
		workflow_steps: [${config.dependencySteps?.map(s &#x3D;&amp;gt; &#x60;&amp;quot;${s}&amp;quot;&#x60;).join(&amp;#39;, &amp;#39;)}]&#x60;;
  }

  schema +&#x3D; &#x60;
	}
	
	// Validation rules
	validation: {
		// All fields are required
		project.name:        string &amp;amp; !&#x3D;&amp;quot;&amp;quot;
		project.system_type: string &amp;amp; !&#x3D;&amp;quot;&amp;quot;
		project.version:     string &amp;amp; !&#x3D;&amp;quot;&amp;quot;&#x60;;

  if (config.hasBudgetConstraints) {
    schema +&#x3D; &#x60;
		
		// Budget validation
		constraints.budget.limit: number &amp;amp; &amp;gt;0
		constraints.budget.currency: string &amp;amp; !&#x3D;&amp;quot;&amp;quot;&#x60;;
  }

  if (config.hasQualityGates &amp;amp;&amp;amp; config.qualityThresholds) {
    schema +&#x3D; &#x60;
		
		// Quality validation
		constraints.quality.test_coverage: number &amp;amp; &amp;gt;&#x3D;0 &amp;amp; &amp;lt;&#x3D;100&#x60;;
  }

  schema +&#x3D; &#x60;
	}
}

// Default instance
default_config: #SystemConfig &amp;amp; {
	project: {
		name:        &amp;quot;${config.projectName}&amp;quot;
		system_type: &amp;quot;${config.systemType}&amp;quot;
		version:     &amp;quot;1.0.0&amp;quot;
	}
}&#x60;;

  // Add template content if any templates were loaded
  if (templates.length &amp;gt; 0) {
    schema +&#x3D; &amp;#39;\n\n// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Template Includes &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&amp;#39;;
    schema +&#x3D; templates.join(&amp;#39;\n\n&amp;#39;);
  }

  return schema;
}

/**
 * Generate user guide content
 */
function generateUserGuide(config: SchemaConfig): string {
  return &#x60;# ${config.projectName} Schema Guide

This schema was generated by Arbiter&amp;#39;s Interactive Schema Builder.

## Schema Overview

- **System Type**: ${config.systemType}
- **Project Name**: ${config.projectName}
${config.hasBudgetConstraints ? &#x60;- **Budget Constraints**: ${config.budgetLimit} ${config.budgetCurrency} per ${config.budgetPeriod}&#x60; : &amp;#39;&amp;#39;}
${config.hasQualityGates ? &amp;#39;- **Quality Gates**: Enabled&amp;#39; : &amp;#39;&amp;#39;}
${config.hasSelectionRubric ? &amp;#39;- **Selection Rubric**: Enabled&amp;#39; : &amp;#39;&amp;#39;}
${config.hasDependencyChain ? &amp;#39;- **Dependency Chain**: Enabled&amp;#39; : &amp;#39;&amp;#39;}

## Next Steps

1. **Review the Schema**: Open \&#x60;${config.outputPath}\&#x60; and review the generated constraints
2. **Customize Values**: Adjust the default values to match your specific requirements
3. **Add Custom Constraints**: Extend the schema with your domain-specific rules
4. **Validate**: Run \&#x60;arbiter validate ${config.outputPath}\&#x60; to check your schema
5. **Export**: Use \&#x60;arbiter export ${config.outputPath} --format typescript,k8s\&#x60; to generate artifacts

## Schema Structure

The generated schema includes:

- \&#x60;#ProjectInfo\&#x60;: Basic project metadata
- \&#x60;#SystemConfig\&#x60;: Main configuration with constraints
- \&#x60;default_config\&#x60;: A working configuration instance
${config.hasBudgetConstraints ? &amp;#39;- Budget constraint templates with cost models and monitoring&amp;#39; : &amp;#39;&amp;#39;}
${config.hasSelectionRubric ? &amp;#39;- Selection rubric templates with weighted criteria&amp;#39; : &amp;#39;&amp;#39;}
${config.hasDependencyChain ? &amp;#39;- Dependency chain templates with workflow management&amp;#39; : &amp;#39;&amp;#39;}

## Validation Rules

The schema enforces:
${config.hasBudgetConstraints ? &amp;#39;- Budget limits and currency validation&amp;#39; : &amp;#39;&amp;#39;}
${config.hasQualityGates ? &#x60;- Quality thresholds (${config.qualityThresholds?.testCoverage}% test coverage, ${config.qualityThresholds?.performanceTarget} performance)&#x60; : &amp;#39;&amp;#39;}
- Required project metadata
- System type consistency

## Template Integration

${templates_included(config)}

## Support

For help with CUE syntax and Arbiter features:
- Run \&#x60;arbiter template list\&#x60; to see available constraint templates
- Run \&#x60;arbiter --help\&#x60; for CLI command reference
- Check the generated comments in your schema file for inline guidance
&#x60;;

  function templates_included(config: SchemaConfig): string {
    const included &#x3D; [];
    if (config.hasBudgetConstraints) included.push(&amp;#39;Budget Constraint Template&amp;#39;);
    if (config.hasSelectionRubric) included.push(&amp;#39;Selection Rubric Template&amp;#39;);
    if (config.hasDependencyChain) included.push(&amp;#39;Dependency Chain Template&amp;#39;);

    if (included.length &#x3D;&#x3D;&#x3D; 0) {
      return &amp;#39;No templates were included. You can add them later with &#x60;arbiter template add &amp;lt;name&amp;gt;&#x60;.&amp;#39;;
    }

    return &#x60;The following templates are included:\n${included.map(t &#x3D;&amp;gt; &#x60;- ${t}&#x60;).join(&amp;#39;\n&amp;#39;)}&#x60;;
  }
}

/**
 * Create schema command - Interactive schema builder
 */
export async function createCommand(type &#x3D; &amp;#39;schema&amp;#39;, options: CreateOptions &#x3D; {}): Promise&amp;lt;number&amp;gt; {
  if (type !&#x3D;&#x3D; &amp;#39;schema&amp;#39;) {
    console.error(chalk.red(&#x60;Unknown create type: ${type}&#x60;));
    console.log(chalk.dim(&amp;#39;Available types: schema&amp;#39;));
    return 1;
  }

  try {
    let config: SchemaConfig;

    if (options.interactive !&#x3D;&#x3D; false) {
      // Interactive mode (default)
      config &#x3D; await interactiveSchemaConfig();
    } else {
      // Non-interactive mode - use provided options
      if (!options.name) {
        console.error(chalk.red(&amp;#39;Project name is required in non-interactive mode&amp;#39;));
        return 1;
      }

      config &#x3D; {
        systemType: &amp;#39;api&amp;#39;, // default
        projectName: options.name,
        hasBudgetConstraints: false,
        hasQualityGates: true,
        hasSelectionRubric: false,
        hasDependencyChain: false,
        outputPath: options.output || &#x60;${options.name}-schema.cue&#x60;,
      };
    }

    // Generate schema
    console.log(chalk.dim(&amp;#39;Generating schema...&amp;#39;));
    const schema &#x3D; await generateSchemaFromConfig(config);

    // Write schema file
    await fs.writeFile(config.outputPath, schema, &amp;#39;utf-8&amp;#39;);

    // Generate and write user guide
    const guideContent &#x3D; generateUserGuide(config);
    const guidePath &#x3D; config.outputPath.replace(&amp;#39;.cue&amp;#39;, &amp;#39;-guide.md&amp;#39;);
    await fs.writeFile(guidePath, guideContent, &amp;#39;utf-8&amp;#39;);

    // Success message
    console.log();
    console.log(chalk.green(&amp;#39;âœ“ Schema created successfully!&amp;#39;));
    console.log();
    console.log(chalk.bold(&amp;#39;Files generated:&amp;#39;));
    console.log(&#x60;  ${chalk.blue(config.outputPath)} - Your CUE schema&#x60;);
    console.log(&#x60;  ${chalk.blue(guidePath)} - Setup guide and documentation&#x60;);
    console.log();

    console.log(chalk.bold(&amp;#39;Next steps:&amp;#39;));
    console.log(&#x60;1. Review your schema: ${chalk.cyan(&#x60;cat ${config.outputPath}&#x60;)}&#x60;);
    console.log(&#x60;2. Read the guide: ${chalk.cyan(&#x60;cat ${guidePath}&#x60;)}&#x60;);
    console.log(&#x60;3. Validate schema: ${chalk.cyan(&#x60;arbiter validate ${config.outputPath}&#x60;)}&#x60;);
    if (config.hasBudgetConstraints || config.hasSelectionRubric || config.hasDependencyChain) {
      console.log(&#x60;4. Customize templates: Edit the template sections in ${config.outputPath}&#x60;);
    }
    console.log();

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Error creating schema:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-45">
                <div class="file-header">ğŸ“„ apps/api/src/utils.ts</div>
                <div class="file-content">
                    <pre>/**
 * Utility functions for Spec Workbench backend
 */
import { createHash } from &amp;#39;node:crypto&amp;#39;;
import { isAbsolute, normalize, resolve, sep } from &amp;#39;node:path&amp;#39;;
import type { ExternalToolResult, ProblemDetails, RateLimitBucket } from &amp;#39;./types.ts&amp;#39;;

/**
 * Generate a unique ID using crypto.randomUUID()
 */
export function generateId(): string {
  return crypto.randomUUID();
}

/**
 * Compute SHA256 hash of a string
 */
export function computeSpecHash(content: string): string {
  return createHash(&amp;#39;sha256&amp;#39;).update(content).digest(&amp;#39;hex&amp;#39;);
}

/**
 * Execute external command with timeout and proper error handling
 */
export async function executeCommand(
  command: string,
  args: string[],
  options: {
    cwd?: string;
    timeout?: number;
    env?: Record&amp;lt;string, string&amp;gt;;
  } &#x3D; {}
): Promise&amp;lt;ExternalToolResult&amp;gt; {
  const startTime &#x3D; Date.now();
  const timeoutMs &#x3D; options.timeout ?? 10000; // 10s default

  try {
    const proc &#x3D; Bun.spawn([command, ...args], {
      cwd: options.cwd,
      env: { ...process.env, ...options.env },
      stdout: &amp;#39;pipe&amp;#39;,
      stderr: &amp;#39;pipe&amp;#39;,
    });

    // Set up timeout
    const timeoutPromise &#x3D; new Promise&amp;lt;never&amp;gt;((_, reject) &#x3D;&amp;gt; {
      setTimeout(() &#x3D;&amp;gt; {
        proc.kill();
        reject(new Error(&#x60;Command timed out after ${timeoutMs}ms&#x60;));
      }, timeoutMs);
    });

    // Wait for process to complete or timeout
    const _result &#x3D; await Promise.race([proc.exited, timeoutPromise]);

    const stdout &#x3D; await new Response(proc.stdout).text();
    const stderr &#x3D; await new Response(proc.stderr).text();
    const exitCode &#x3D; proc.exitCode ?? 1;
    const duration &#x3D; Date.now() - startTime;

    return {
      success: exitCode &#x3D;&#x3D;&#x3D; 0,
      stdout: stdout.trim(),
      stderr: stderr.trim(),
      exit_code: exitCode,
      duration_ms: duration,
    };
  } catch (error) {
    const duration &#x3D; Date.now() - startTime;
    return {
      success: false,
      stdout: &amp;#39;&amp;#39;,
      stderr: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
      exit_code: -1,
      duration_ms: duration,
    };
  }
}

/**
 * Format CUE content using cue fmt command
 */
export async function formatCUE(
  content: string,
  cueBinaryPath &#x3D; &amp;#39;cue&amp;#39;
): Promise&amp;lt;{ formatted: string; success: boolean; error?: string }&amp;gt; {
  // Write content to temporary file
  const tempFile &#x3D; &#x60;/tmp/temp_${generateId()}.cue&#x60;;

  try {
    await Bun.write(tempFile, content);

    const result &#x3D; await executeCommand(cueBinaryPath, [&amp;#39;fmt&amp;#39;, tempFile], {
      timeout: 5000,
    });

    if (result.success) {
      const formatted &#x3D; await Bun.file(tempFile).text();
      return { formatted, success: true };
    }
    return {
      formatted: content,
      success: false,
      error: result.stderr || &amp;#39;Failed to format CUE content&amp;#39;,
    };
  } catch (error) {
    return {
      formatted: content,
      success: false,
      error: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
    };
  } finally {
    // Clean up temp file
    try {
      (await Bun.file(tempFile).exists()) &amp;amp;&amp;amp; (await Bun.write(tempFile, &amp;#39;&amp;#39;));
    } catch {
      // Ignore cleanup errors
    }
  }
}

/**
 * Create RFC 7807 Problem Details error response
 */
export function createProblemDetails(
  status: number,
  title: string,
  detail?: string,
  type?: string,
  instance?: string,
  extensions?: Record&amp;lt;string, unknown&amp;gt;
): ProblemDetails {
  return {
    type: type ?? &#x60;https://httpstatuses.com/${status}&#x60;,
    title,
    status,
    ...(detail &amp;amp;&amp;amp; { detail }),
    ...(instance &amp;amp;&amp;amp; { instance }),
    ...extensions,
  };
}

/**
 * Token bucket rate limiter implementation
 */
export class TokenBucket {
  private buckets &#x3D; new Map&amp;lt;string, RateLimitBucket&amp;gt;();

  constructor(
    private maxTokens &#x3D; 10,
    private refillRate &#x3D; 1, // tokens per second
    private windowMs &#x3D; 10000 // 10 seconds
  ) {}

  /**
   * Check if request is allowed and consume a token
   */
  consume(identifier: string): boolean {
    const now &#x3D; Date.now();
    let bucket &#x3D; this.buckets.get(identifier);

    if (!bucket) {
      bucket &#x3D; {
        tokens: this.maxTokens - 1, // consume one token
        last_refill: now,
        max_tokens: this.maxTokens,
        refill_rate: this.refillRate,
      };
      this.buckets.set(identifier, bucket);
      return true;
    }

    // Calculate tokens to add based on time passed
    const timePassed &#x3D; now - bucket.last_refill;
    const tokensToAdd &#x3D; Math.floor((timePassed / 1000) * this.refillRate);

    if (tokensToAdd &amp;gt; 0) {
      bucket.tokens &#x3D; Math.min(bucket.max_tokens, bucket.tokens + tokensToAdd);
      bucket.last_refill &#x3D; now;
    }

    // Check if we have tokens available
    if (bucket.tokens &amp;gt; 0) {
      bucket.tokens--;
      return true;
    }

    return false;
  }

  /**
   * Get current token count for identifier
   */
  getTokenCount(identifier: string): number {
    const bucket &#x3D; this.buckets.get(identifier);
    if (!bucket) return this.maxTokens;

    // Calculate current tokens
    const now &#x3D; Date.now();
    const timePassed &#x3D; now - bucket.last_refill;
    const tokensToAdd &#x3D; Math.floor((timePassed / 1000) * this.refillRate);

    return Math.min(bucket.max_tokens, bucket.tokens + tokensToAdd);
  }

  /**
   * Clean up old buckets to prevent memory leaks
   */
  cleanup(): void {
    const now &#x3D; Date.now();
    const cutoff &#x3D; now - this.windowMs * 2; // Keep buckets for 2x window size

    for (const [key, bucket] of this.buckets.entries()) {
      if (bucket.last_refill &amp;lt; cutoff) {
        this.buckets.delete(key);
      }
    }
  }
}

/**
 * Ensure directory exists, create if it doesn&amp;#39;t
 */
export async function ensureDir(path: string): Promise&amp;lt;void&amp;gt; {
  try {
    const stat &#x3D; await Bun.file(path).exists();
    if (!stat) {
      await Bun.spawn([&amp;#39;mkdir&amp;#39;, &amp;#39;-p&amp;#39;, path]).exited;
    }
  } catch (error) {
    throw new Error(&#x60;Failed to create directory ${path}: ${error}&#x60;);
  }
}

/**
 * Safe JSON parsing with error handling
 */
export function safeJsonParse&amp;lt;T &#x3D; any&amp;gt;(
  json: string
): { success: true; data: T } | { success: false; error: string } {
  try {
    const data &#x3D; JSON.parse(json);
    return { success: true, data };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : &amp;#39;Invalid JSON&amp;#39;,
    };
  }
}

/**
 * Validate that a string is a valid file path (security check)
 */
export function validatePath(targetPath: string, baseDir: string &#x3D; process.cwd()): boolean {
  if (!targetPath) {
    return false;
  }

  if (targetPath.includes(&amp;#39;\0&amp;#39;)) {
    return false;
  }

  const sanitised &#x3D; targetPath.replace(/\\+/g, &amp;#39;/&amp;#39;);
  const normalisedInput &#x3D; normalize(sanitised).replace(/\\+/g, &amp;#39;/&amp;#39;);

  // Reject absolute paths or attempts to traverse up the directory tree
  if (
    isAbsolute(normalisedInput) ||
    normalisedInput.startsWith(&amp;#39;..&amp;#39;) ||
    normalisedInput.includes(&amp;#39;/../&amp;#39;)
  ) {
    return false;
  }

  // Only allow a conservative character set
  const pathRegex &#x3D; /^[a-zA-Z0-9._/\-]+$/;
  if (!pathRegex.test(normalisedInput)) {
    return false;
  }

  const resolvedBase &#x3D; resolve(baseDir);
  const resolvedTarget &#x3D; resolve(resolvedBase, normalisedInput);
  const baseWithSep &#x3D; resolvedBase.endsWith(sep) ? resolvedBase : &#x60;${resolvedBase}${sep}&#x60;;

  return resolvedTarget &#x3D;&#x3D;&#x3D; resolvedBase || resolvedTarget.startsWith(baseWithSep);
}

/**
 * Get current timestamp in ISO format
 */
export function getCurrentTimestamp(): string {
  return new Date().toISOString();
}

/**
 * Simple logger with structured output
 */
export const logger &#x3D; {
  info: (message: string, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
    console.log(
      JSON.stringify({
        level: &amp;#39;info&amp;#39;,
        message,
        timestamp: getCurrentTimestamp(),
        ...meta,
      })
    );
  },

  warn: (message: string, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
    console.warn(
      JSON.stringify({
        level: &amp;#39;warn&amp;#39;,
        message,
        timestamp: getCurrentTimestamp(),
        ...meta,
      })
    );
  },

  error: (message: string, error?: Error, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
    console.error(
      JSON.stringify({
        level: &amp;#39;error&amp;#39;,
        message,
        error: error?.message,
        stack: error?.stack,
        timestamp: getCurrentTimestamp(),
        ...meta,
      })
    );
  },

  debug: (message: string, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
    if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &amp;#39;development&amp;#39;) {
      console.debug(
        JSON.stringify({
          level: &amp;#39;debug&amp;#39;,
          message,
          timestamp: getCurrentTimestamp(),
          ...meta,
        })
      );
    }
  },
};

/**
 * Parse bearer token from Authorization header
 */
export function parseBearerToken(authHeader: string | undefined): string | null {
  if (!authHeader || !authHeader.startsWith(&amp;#39;Bearer &amp;#39;)) {
    return null;
  }
  return authHeader.slice(7).trim();
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-46">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/services/api.ts</div>
                <div class="file-content">
                    <pre>/**
 * API service for backend communication
 */

import type {
  CreateFragmentRequest,
  CreateFragmentResponse,
  CreateHandlerRequest,
  Fragment,
  FreezeRequest,
  FreezeResponse,
  GapSet,
  HandlerExecution,
  HandlerStats,
  IRKind,
  IRResponse,
  ProblemDetails,
  Project,
  ResolvedSpecResponse,
  UpdateHandlerRequest,
  ValidationRequest,
  ValidationResponse,
  WebhookHandler,
} from &amp;#39;../types/api&amp;#39;;
import { createLogger } from &amp;#39;../utils/logger&amp;#39;;

const log &#x3D; createLogger(&amp;#39;API&amp;#39;);

export class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public details?: ProblemDetails
  ) {
    super(message);
    this.name &#x3D; &amp;#39;ApiError&amp;#39;;
  }
}

class ApiService {
  private baseUrl &#x3D; &amp;#39;http://localhost:5050&amp;#39;;
  private defaultHeaders: Record&amp;lt;string, string&amp;gt; &#x3D; {
    &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;,
  };

  private buildRequestConfig(
    endpoint: string,
    options: RequestInit &#x3D; {}
  ): { url: string; config: RequestInit } {
    const url &#x3D; &#x60;${this.baseUrl}${endpoint}&#x60;;
    const config: RequestInit &#x3D; {
      ...options,
      headers: {
        ...this.defaultHeaders,
        ...options.headers,
      },
    };
    return { url, config };
  }

  private async parseErrorDetails(response: Response): Promise&amp;lt;ProblemDetails | undefined&amp;gt; {
    try {
      return await response.json();
    } catch {
      // Ignore JSON parsing errors for error details
      return undefined;
    }
  }

  private createApiError(response: Response, errorDetails?: ProblemDetails): ApiError {
    return new ApiError(
      errorDetails?.detail || &#x60;HTTP ${response.status}: ${response.statusText}&#x60;,
      response.status,
      errorDetails
    );
  }

  private shouldReturnEmptyResponse(response: Response): boolean {
    return response.status &#x3D;&#x3D;&#x3D; 204 || response.headers.get(&amp;#39;content-length&amp;#39;) &#x3D;&#x3D;&#x3D; &amp;#39;0&amp;#39;;
  }

  private async handleErrorResponse(response: Response): Promise&amp;lt;never&amp;gt; {
    const errorDetails &#x3D; await this.parseErrorDetails(response);
    throw this.createApiError(response, errorDetails);
  }

  private async parseResponseData&amp;lt;T&amp;gt;(response: Response): Promise&amp;lt;T&amp;gt; {
    if (this.shouldReturnEmptyResponse(response)) {
      return {} as T;
    }
    return await response.json();
  }

  private handleNetworkError(error: unknown): never {
    if (error instanceof ApiError) {
      throw error;
    }
    throw new ApiError(
      &#x60;Network error: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;,
      0
    );
  }

  private async request&amp;lt;T&amp;gt;(endpoint: string, options: RequestInit &#x3D; {}): Promise&amp;lt;T&amp;gt; {
    const { url, config } &#x3D; this.buildRequestConfig(endpoint, options);

    try {
      const response &#x3D; await fetch(url, config);

      if (!response.ok) {
        return await this.handleErrorResponse(response);
      }

      return await this.parseResponseData&amp;lt;T&amp;gt;(response);
    } catch (error) {
      return this.handleNetworkError(error);
    }
  }

  // Project endpoints
  async getProjects(): Promise&amp;lt;Project[]&amp;gt; {
    return this.request&amp;lt;Project[]&amp;gt;(&amp;#39;/api/projects&amp;#39;);
  }

  async getProject(projectId: string): Promise&amp;lt;Project&amp;gt; {
    return this.request&amp;lt;Project&amp;gt;(&#x60;/api/projects/${projectId}&#x60;);
  }

  async createProject(name: string): Promise&amp;lt;Project&amp;gt; {
    return this.request&amp;lt;Project&amp;gt;(&amp;#39;/api/projects&amp;#39;, {
      method: &amp;#39;POST&amp;#39;,
      body: JSON.stringify({ name }),
    });
  }

  async deleteProject(projectId: string): Promise&amp;lt;void&amp;gt; {
    await this.request&amp;lt;void&amp;gt;(&#x60;/api/projects/${projectId}&#x60;, {
      method: &amp;#39;DELETE&amp;#39;,
    });
  }

  // Fragment endpoints
  async getFragments(projectId: string): Promise&amp;lt;Fragment[]&amp;gt; {
    return this.request&amp;lt;Fragment[]&amp;gt;(&#x60;/api/fragments?projectId&#x3D;${projectId}&#x60;);
  }

  async getFragment(projectId: string, fragmentId: string): Promise&amp;lt;Fragment&amp;gt; {
    return this.request&amp;lt;Fragment&amp;gt;(&#x60;/api/fragments/${fragmentId}?projectId&#x3D;${projectId}&#x60;);
  }

  async createFragment(
    projectId: string,
    request: CreateFragmentRequest
  ): Promise&amp;lt;CreateFragmentResponse&amp;gt; {
    return this.request&amp;lt;CreateFragmentResponse&amp;gt;(&#x60;/api/fragments?projectId&#x3D;${projectId}&#x60;, {
      method: &amp;#39;POST&amp;#39;,
      body: JSON.stringify(request),
    });
  }

  async updateFragment(projectId: string, fragmentId: string, content: string): Promise&amp;lt;Fragment&amp;gt; {
    return this.request&amp;lt;Fragment&amp;gt;(&#x60;/api/fragments/${fragmentId}?projectId&#x3D;${projectId}&#x60;, {
      method: &amp;#39;PUT&amp;#39;,
      body: JSON.stringify({ content }),
    });
  }

  async deleteFragment(projectId: string, fragmentId: string): Promise&amp;lt;void&amp;gt; {
    await this.request&amp;lt;void&amp;gt;(&#x60;/api/fragments/${fragmentId}?projectId&#x3D;${projectId}&#x60;, {
      method: &amp;#39;DELETE&amp;#39;,
    });
  }

  // Validation endpoints
  async validateProject(
    projectId: string,
    request: ValidationRequest &#x3D; {}
  ): Promise&amp;lt;ValidationResponse&amp;gt; {
    return this.request&amp;lt;ValidationResponse&amp;gt;(&amp;#39;/api/validate&amp;#39;, {
      method: &amp;#39;POST&amp;#39;,
      body: JSON.stringify({ projectId, ...request }),
    });
  }

  // Resolved spec endpoints
  async getResolvedSpec(projectId: string): Promise&amp;lt;ResolvedSpecResponse&amp;gt; {
    const response &#x3D; await this.request&amp;lt;{
      projectId: string;
      specHash: string;
      updatedAt: string;
      json: Record&amp;lt;string, unknown&amp;gt;;
    }&amp;gt;(&#x60;/api/resolved?projectId&#x3D;${projectId}&#x60;);

    // Transform response to match expected interface
    return {
      spec_hash: response.specHash,
      resolved: response.json,
      last_updated: response.updatedAt,
    };
  }

  // Gap analysis endpoints
  async getGaps(projectId: string): Promise&amp;lt;GapSet&amp;gt; {
    return this.request&amp;lt;GapSet&amp;gt;(&#x60;/api/gaps?projectId&#x3D;${projectId}&#x60;);
  }

  // IR (Intermediate Representation) endpoints
  async getIR(projectId: string, kind: IRKind): Promise&amp;lt;IRResponse&amp;gt; {
    return this.request&amp;lt;IRResponse&amp;gt;(&#x60;/api/ir/${kind}?projectId&#x3D;${projectId}&#x60;);
  }

  async getAllIRs(projectId: string): Promise&amp;lt;Record&amp;lt;IRKind, IRResponse&amp;gt;&amp;gt; {
    const kinds: IRKind[] &#x3D; [&amp;#39;flow&amp;#39;, &amp;#39;fsm&amp;#39;, &amp;#39;view&amp;#39;, &amp;#39;site&amp;#39;];
    const irs: Record&amp;lt;string, IRResponse&amp;gt; &#x3D; {};

    // Sequential requests with small delays to avoid rate limiting
    for (let i &#x3D; 0; i &amp;lt; kinds.length; i++) {
      const kind &#x3D; kinds[i];
      try {
        const ir &#x3D; await this.getIR(projectId, kind);
        irs[kind] &#x3D; ir;
      } catch (error) {
        log.warn(&#x60;Failed to load IR for ${kind}:&#x60;, error);
      }

      // Add small delay between requests to avoid overwhelming rate limiter
      if (i &amp;lt; kinds.length - 1) {
        await new Promise(resolve &#x3D;&amp;gt; setTimeout(resolve, 50));
      }
    }

    return irs as Record&amp;lt;IRKind, IRResponse&amp;gt;;
  }

  // Version freezing endpoints
  async freezeVersion(projectId: string, request: FreezeRequest): Promise&amp;lt;FreezeResponse&amp;gt; {
    return this.request&amp;lt;FreezeResponse&amp;gt;(&amp;#39;/api/freeze&amp;#39;, {
      method: &amp;#39;POST&amp;#39;,
      body: JSON.stringify({ projectId, ...request }),
    });
  }

  // Webhook Handler endpoints
  async getHandlers(): Promise&amp;lt;WebhookHandler[]&amp;gt; {
    return this.request&amp;lt;WebhookHandler[]&amp;gt;(&amp;#39;/api/handlers&amp;#39;);
  }

  async getHandler(handlerId: string): Promise&amp;lt;WebhookHandler&amp;gt; {
    return this.request&amp;lt;WebhookHandler&amp;gt;(&#x60;/api/handlers/${handlerId}&#x60;);
  }

  async createHandler(request: CreateHandlerRequest): Promise&amp;lt;WebhookHandler&amp;gt; {
    return this.request&amp;lt;WebhookHandler&amp;gt;(&amp;#39;/api/handlers&amp;#39;, {
      method: &amp;#39;POST&amp;#39;,
      body: JSON.stringify(request),
    });
  }

  async updateHandler(handlerId: string, request: UpdateHandlerRequest): Promise&amp;lt;WebhookHandler&amp;gt; {
    return this.request&amp;lt;WebhookHandler&amp;gt;(&#x60;/api/handlers/${handlerId}&#x60;, {
      method: &amp;#39;PUT&amp;#39;,
      body: JSON.stringify(request),
    });
  }

  async deleteHandler(handlerId: string): Promise&amp;lt;void&amp;gt; {
    await this.request&amp;lt;void&amp;gt;(&#x60;/api/handlers/${handlerId}&#x60;, {
      method: &amp;#39;DELETE&amp;#39;,
    });
  }

  async toggleHandler(handlerId: string, enabled: boolean): Promise&amp;lt;WebhookHandler&amp;gt; {
    return this.request&amp;lt;WebhookHandler&amp;gt;(&#x60;/api/handlers/${handlerId}/toggle&#x60;, {
      method: &amp;#39;POST&amp;#39;,
      body: JSON.stringify({ enabled }),
    });
  }

  async getHandlerStats(handlerId: string): Promise&amp;lt;HandlerStats&amp;gt; {
    return this.request&amp;lt;HandlerStats&amp;gt;(&#x60;/api/handlers/${handlerId}/stats&#x60;);
  }

  async getHandlerExecutions(handlerId: string, limit?: number): Promise&amp;lt;HandlerExecution[]&amp;gt; {
    const params &#x3D; limit ? &#x60;?limit&#x3D;${limit}&#x60; : &amp;#39;&amp;#39;;
    return this.request&amp;lt;HandlerExecution[]&amp;gt;(&#x60;/api/handlers/${handlerId}/executions${params}&#x60;);
  }

  async testHandler(
    handlerId: string,
    payload: Record&amp;lt;string, unknown&amp;gt;
  ): Promise&amp;lt;{
    status: &amp;#39;success&amp;#39; | &amp;#39;error&amp;#39;;
    result?: Record&amp;lt;string, unknown&amp;gt;;
    error?: string;
    duration_ms: number;
  }&amp;gt; {
    return this.request(&#x60;/api/handlers/${handlerId}/test&#x60;, {
      method: &amp;#39;POST&amp;#39;,
      body: JSON.stringify({ payload }),
    });
  }

  // Health check
  async healthCheck(): Promise&amp;lt;{ status: string; timestamp: string }&amp;gt; {
    return this.request&amp;lt;{ status: string; timestamp: string }&amp;gt;(&amp;#39;/health&amp;#39;);
  }

  // Set authentication token
  setAuthToken(token: string) {
    this.defaultHeaders.Authorization &#x3D; &#x60;Bearer ${token}&#x60;;
  }

  // Remove authentication token
  clearAuthToken() {
    this.defaultHeaders.Authorization &#x3D; undefined;
  }
}

// Export singleton instance
export const apiService &#x3D; new ApiService();

// Export utilities
export { ApiService };
</pre>
                </div>
            </div>
            <div class="file-section" id="file-47">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/ux-polish.ts</div>
                <div class="file-content">
                    <pre>#!/usr/bin/env node

import chalk from &amp;quot;chalk&amp;quot;;

/**
 * UX Polish utilities for beautiful CLI experience
 */

/**
 * Format beautiful error messages with helpful suggestions
 */
export function formatError(error: Error | string, context?: string): void {
  const message &#x3D; error instanceof Error ? error.message : error;

  console.log();
  console.log(chalk.red.bold(&amp;quot;âŒ Error&amp;quot;));
  console.log(chalk.red(&#x60;   ${message}&#x60;));

  if (context) {
    console.log(chalk.gray(&#x60;   Context: ${context}&#x60;));
  }

  // Add contextual help based on common error patterns
  if (message.includes(&amp;quot;ENOENT&amp;quot;) || message.includes(&amp;quot;not found&amp;quot;)) {
    showFileNotFoundHelp(message);
  } else if (message.includes(&amp;quot;EACCES&amp;quot;) || message.includes(&amp;quot;permission&amp;quot;)) {
    showPermissionHelp();
  } else if (message.includes(&amp;quot;Connection refused&amp;quot;) || message.includes(&amp;quot;ECONNREFUSED&amp;quot;)) {
    showConnectionHelp();
  } else if (message.includes(&amp;quot;arbiter.assembly.cue&amp;quot;)) {
    showAssemblyHelp();
  } else if (message.includes(&amp;quot;Invalid&amp;quot;) || message.includes(&amp;quot;validation&amp;quot;)) {
    showValidationHelp();
  }

  console.log();
}

/**
 * Show next-step hints after successful commands
 */
export function showNextSteps(command: string, context?: Record&amp;lt;string, any&amp;gt;): void {
  const steps &#x3D; getNextSteps(command, context);

  if (steps.length &#x3D;&#x3D;&#x3D; 0) return;

  console.log();
  console.log(chalk.blue.bold(&amp;quot;ğŸ¯ Next steps:&amp;quot;));

  for (let i &#x3D; 0; i &amp;lt; steps.length; i++) {
    console.log(chalk.dim(&#x60;   ${i + 1}. ${steps[i]}&#x60;));
  }

  console.log();
}

/**
 * Get contextual next steps based on command
 */
function getNextSteps(command: string, context?: Record&amp;lt;string, any&amp;gt;): string[] {
  const steps: string[] &#x3D; [];

  switch (command) {
    case &amp;quot;init&amp;quot;:
      steps.push(&amp;quot;Edit arbiter.assembly.cue to customize your project&amp;quot;);
      steps.push(&amp;#39;Run &amp;quot;arbiter check&amp;quot; to validate configuration&amp;#39;);
      steps.push(&amp;#39;Use &amp;quot;arbiter explain&amp;quot; to understand your setup&amp;#39;);
      steps.push(&amp;#39;Generate examples with &amp;quot;arbiter examples profile&amp;quot;&amp;#39;);
      break;

    case &amp;quot;check&amp;quot;:
      if (context?.success) {
        steps.push(&amp;#39;Generate API surface with &amp;quot;arbiter surface &amp;lt;language&amp;gt;&amp;quot;&amp;#39;);
        steps.push(&amp;#39;Set up development workflow with &amp;quot;arbiter watch&amp;quot;&amp;#39;);
        steps.push(&amp;#39;Create tests with &amp;quot;arbiter tests scaffold&amp;quot;&amp;#39;);
      } else {
        steps.push(&amp;quot;Fix validation errors above&amp;quot;);
        steps.push(&amp;#39;Use &amp;quot;arbiter explain&amp;quot; to understand configuration&amp;#39;);
        steps.push(&amp;#39;Check examples with &amp;quot;arbiter examples profile&amp;quot;&amp;#39;);
      }
      break;

    case &amp;quot;surface&amp;quot;:
      steps.push(&amp;#39;Plan version changes with &amp;quot;arbiter version plan&amp;quot;&amp;#39;);
      steps.push(&amp;#39;Generate documentation with &amp;quot;arbiter docs schema&amp;quot;&amp;#39;);
      steps.push(&amp;#39;Set up continuous validation with &amp;quot;arbiter watch&amp;quot;&amp;#39;);
      break;

    case &amp;quot;watch&amp;quot;:
      steps.push(&amp;quot;Keep this running during development&amp;quot;);
      steps.push(&amp;quot;Open another terminal for other arbiter commands&amp;quot;);
      steps.push(&amp;quot;Press Ctrl+C to stop watching&amp;quot;);
      break;

    case &amp;quot;docs&amp;quot;:
      steps.push(&amp;quot;Share documentation with your team&amp;quot;);
      steps.push(&amp;quot;Set up automated regeneration in CI&amp;quot;);
      steps.push(&amp;quot;Consider serving docs locally or on GitHub Pages&amp;quot;);
      break;

    case &amp;quot;examples&amp;quot;:
      steps.push(&amp;quot;Browse generated examples in the output directory&amp;quot;);
      steps.push(&amp;quot;Copy useful patterns to your project&amp;quot;);
      steps.push(&amp;#39;Run &amp;quot;arbiter init&amp;quot; in example directories to try them&amp;#39;);
      break;

    case &amp;quot;explain&amp;quot;:
      steps.push(&amp;quot;Follow the recommendations above&amp;quot;);
      steps.push(&amp;quot;Address any potential issues listed&amp;quot;);
      steps.push(&amp;#39;Use &amp;quot;arbiter docs schema&amp;quot; for detailed documentation&amp;#39;);
      break;

    case &amp;quot;tests&amp;quot;:
      steps.push(&amp;quot;Run generated tests to verify they work&amp;quot;);
      steps.push(&amp;quot;Customize test cases for your specific needs&amp;quot;);
      steps.push(&amp;#39;Check coverage with &amp;quot;arbiter tests cover&amp;quot;&amp;#39;);
      break;

    case &amp;quot;version&amp;quot;:
      steps.push(&amp;quot;Review version plan carefully&amp;quot;);
      steps.push(&amp;quot;Update CHANGELOG.md if needed&amp;quot;);
      steps.push(&amp;#39;Run &amp;quot;arbiter version release --apply&amp;quot; when ready&amp;#39;);
      break;

    case &amp;quot;integrate&amp;quot;:
      steps.push(&amp;quot;Review generated CI/CD workflows&amp;quot;);
      steps.push(&amp;quot;Customize for your specific needs&amp;quot;);
      steps.push(&amp;quot;Commit and push to activate workflows&amp;quot;);
      break;

    case &amp;quot;sync&amp;quot;:
      steps.push(&amp;quot;Verify manifest updates are correct&amp;quot;);
      steps.push(&amp;quot;Test that build tools still work&amp;quot;);
      steps.push(&amp;quot;Update any custom build scripts if needed&amp;quot;);
      break;

    default:
      steps.push(&amp;#39;Run &amp;quot;arbiter --help&amp;quot; for more commands&amp;#39;);
      steps.push(&amp;#39;Use &amp;quot;arbiter explain&amp;quot; to understand your project&amp;#39;);
      steps.push(&amp;#39;Check &amp;quot;arbiter health&amp;quot; if having issues&amp;#39;);
  }

  return steps;
}

/**
 * Show contextual help for file not found errors
 */
function showFileNotFoundHelp(message: string): void {
  console.log();
  console.log(chalk.yellow.bold(&amp;quot;ğŸ’¡ Common solutions:&amp;quot;));

  if (message.includes(&amp;quot;arbiter.assembly.cue&amp;quot;)) {
    console.log(chalk.dim(&amp;#39;   â€¢ Run &amp;quot;arbiter init --template &amp;lt;type&amp;gt;&amp;quot; to create assembly file&amp;#39;));
    console.log(chalk.dim(&amp;quot;   â€¢ Check you&amp;#39;re in the right directory&amp;quot;));
    console.log(chalk.dim(&amp;#39;   â€¢ Use &amp;quot;arbiter examples profile&amp;quot; to see working examples&amp;#39;));
  } else if (message.includes(&amp;quot;.cue&amp;quot;)) {
    console.log(chalk.dim(&amp;quot;   â€¢ Check the file path is correct&amp;quot;));
    console.log(chalk.dim(&amp;quot;   â€¢ Ensure CUE files have proper syntax&amp;quot;));
    console.log(chalk.dim(&amp;#39;   â€¢ Use &amp;quot;arbiter check&amp;quot; to validate all CUE files&amp;#39;));
  } else {
    console.log(chalk.dim(&amp;quot;   â€¢ Check the file or directory path&amp;quot;));
    console.log(chalk.dim(&amp;quot;   â€¢ Ensure you have the right permissions&amp;quot;));
    console.log(chalk.dim(&amp;quot;   â€¢ Make sure you&amp;#39;re in the correct directory&amp;quot;));
  }
}

/**
 * Show help for permission errors
 */
function showPermissionHelp(): void {
  console.log();
  console.log(chalk.yellow.bold(&amp;quot;ğŸ’¡ Permission solutions:&amp;quot;));
  console.log(chalk.dim(&amp;quot;   â€¢ Check file and directory permissions&amp;quot;));
  console.log(chalk.dim(&amp;quot;   â€¢ Ensure you have write access to the target directory&amp;quot;));
  console.log(chalk.dim(&amp;quot;   â€¢ Try running with appropriate user permissions&amp;quot;));
  console.log(chalk.dim(&amp;quot;   â€¢ Use --output to specify a different directory&amp;quot;));
}

/**
 * Show help for connection errors
 */
function showConnectionHelp(): void {
  console.log();
  console.log(chalk.yellow.bold(&amp;quot;ğŸ’¡ Connection solutions:&amp;quot;));
  console.log(chalk.dim(&amp;quot;   â€¢ Start the Arbiter server: bun run dev&amp;quot;));
  console.log(chalk.dim(&amp;quot;   â€¢ Check server is running on correct port&amp;quot;));
  console.log(chalk.dim(&amp;quot;   â€¢ Verify API URL in configuration&amp;quot;));
  console.log(chalk.dim(&amp;quot;   â€¢ Test connection: arbiter health&amp;quot;));
}

/**
 * Show help for assembly file issues
 */
function showAssemblyHelp(): void {
  console.log();
  console.log(chalk.yellow.bold(&amp;quot;ğŸ’¡ Assembly configuration help:&amp;quot;));
  console.log(chalk.dim(&amp;quot;   â€¢ Create assembly: arbiter init --template &amp;lt;type&amp;gt;&amp;quot;));
  console.log(chalk.dim(&amp;quot;   â€¢ Understand config: arbiter explain&amp;quot;));
  console.log(chalk.dim(&amp;quot;   â€¢ See examples: arbiter examples profile&amp;quot;));
  console.log(chalk.dim(&amp;quot;   â€¢ Generate docs: arbiter docs schema&amp;quot;));
}

/**
 * Show help for validation errors
 */
function showValidationHelp(): void {
  console.log();
  console.log(chalk.yellow.bold(&amp;quot;ğŸ’¡ Validation help:&amp;quot;));
  console.log(chalk.dim(&amp;#39;   â€¢ Check CUE syntax with &amp;quot;cue fmt&amp;quot;&amp;#39;));
  console.log(chalk.dim(&amp;#39;   â€¢ Use &amp;quot;arbiter check --verbose&amp;quot; for details&amp;#39;));
  console.log(chalk.dim(&amp;#39;   â€¢ Compare with &amp;quot;arbiter examples profile&amp;quot;&amp;#39;));
  console.log(chalk.dim(&amp;#39;   â€¢ Get explanation: &amp;quot;arbiter explain&amp;quot;&amp;#39;));
}

/**
 * Show progress indicator for long operations
 */
export class ProgressIndicator {
  private interval?: NodeJS.Timeout;
  private frames &#x3D; [&amp;quot;â ‹&amp;quot;, &amp;quot;â ™&amp;quot;, &amp;quot;â ¹&amp;quot;, &amp;quot;â ¸&amp;quot;, &amp;quot;â ¼&amp;quot;, &amp;quot;â ´&amp;quot;, &amp;quot;â ¦&amp;quot;, &amp;quot;â §&amp;quot;, &amp;quot;â ‡&amp;quot;, &amp;quot;â &amp;quot;];
  private current &#x3D; 0;
  private message &#x3D; &amp;quot;&amp;quot;;

  constructor(message: string) {
    this.message &#x3D; message;
  }

  start(): void {
    process.stdout.write(&#x60;${chalk.blue(this.frames[0])} ${this.message}&#x60;);

    this.interval &#x3D; setInterval(() &#x3D;&amp;gt; {
      this.current &#x3D; (this.current + 1) % this.frames.length;
      process.stdout.write(&#x60;\r${chalk.blue(this.frames[this.current])} ${this.message}&#x60;);
    }, 80);
  }

  update(message: string): void {
    this.message &#x3D; message;
    if (this.interval) {
      process.stdout.write(&#x60;\r${chalk.blue(this.frames[this.current])} ${this.message}&#x60;);
    }
  }

  succeed(message?: string): void {
    this.stop();
    const finalMessage &#x3D; message || this.message;
    console.log(&#x60;${chalk.green(&amp;quot;âœ…&amp;quot;)} ${finalMessage}&#x60;);
  }

  fail(message?: string): void {
    this.stop();
    const finalMessage &#x3D; message || this.message;
    console.log(&#x60;${chalk.red(&amp;quot;âŒ&amp;quot;)} ${finalMessage}&#x60;);
  }

  stop(): void {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval &#x3D; undefined;
      process.stdout.write(&amp;quot;\r&amp;quot;);
    }
  }
}

/**
 * Format success messages with consistent styling
 */
export function showSuccess(message: string, details?: string[]): void {
  console.log();
  console.log(chalk.green.bold(&amp;quot;âœ… Success&amp;quot;));
  console.log(chalk.green(&#x60;   ${message}&#x60;));

  if (details &amp;amp;&amp;amp; details.length &amp;gt; 0) {
    console.log();
    for (const detail of details) {
      console.log(chalk.dim(&#x60;   â€¢ ${detail}&#x60;));
    }
  }

  console.log();
}

/**
 * Format warning messages
 */
export function showWarning(message: string, suggestions?: string[]): void {
  console.log();
  console.log(chalk.yellow.bold(&amp;quot;âš ï¸  Warning&amp;quot;));
  console.log(chalk.yellow(&#x60;   ${message}&#x60;));

  if (suggestions &amp;amp;&amp;amp; suggestions.length &amp;gt; 0) {
    console.log();
    console.log(chalk.yellow.bold(&amp;quot;ğŸ’¡ Suggestions:&amp;quot;));
    for (const suggestion of suggestions) {
      console.log(chalk.dim(&#x60;   â€¢ ${suggestion}&#x60;));
    }
  }

  console.log();
}

/**
 * Format info messages with consistent styling
 */
export function showInfo(message: string, items?: string[]): void {
  console.log();
  console.log(chalk.blue.bold(&amp;quot;â„¹ï¸  Information&amp;quot;));
  console.log(chalk.blue(&#x60;   ${message}&#x60;));

  if (items &amp;amp;&amp;amp; items.length &amp;gt; 0) {
    console.log();
    for (const item of items) {
      console.log(chalk.dim(&#x60;   â€¢ ${item}&#x60;));
    }
  }

  console.log();
}

/**
 * Create a beautiful banner for major operations
 */
export function showBanner(title: string, subtitle?: string): void {
  const width &#x3D; Math.max(title.length, subtitle?.length || 0) + 4;
  const border &#x3D; &amp;quot;â•&amp;quot;.repeat(width);

  console.log();
  console.log(chalk.cyan(&#x60;â•”${border}â•—&#x60;));
  console.log(
    chalk.cyan(&amp;quot;â•‘&amp;quot;) +
      chalk.bold.white(title.padStart((width + title.length) / 2).padEnd(width)) +
      chalk.cyan(&amp;quot;â•‘&amp;quot;),
  );

  if (subtitle) {
    console.log(
      chalk.cyan(&amp;quot;â•‘&amp;quot;) +
        chalk.gray(subtitle.padStart((width + subtitle.length) / 2).padEnd(width)) +
        chalk.cyan(&amp;quot;â•‘&amp;quot;),
    );
  }

  console.log(chalk.cyan(&#x60;â•š${border}â•&#x60;));
  console.log();
}

/**
 * Show helpful hints for discovery
 */
export function showHints(): void {
  const hints &#x3D; [
    &amp;#39;Use &amp;quot;arbiter explain&amp;quot; to understand your project configuration&amp;#39;,
    &amp;#39;Run &amp;quot;arbiter examples profile&amp;quot; to see working project templates&amp;#39;,
    &amp;#39;Try &amp;quot;arbiter watch&amp;quot; for continuous validation during development&amp;#39;,
    &amp;#39;Generate documentation with &amp;quot;arbiter docs schema --examples&amp;quot;&amp;#39;,
    &amp;#39;Check server health with &amp;quot;arbiter health&amp;quot; if having issues&amp;#39;,
    &amp;#39;Use &amp;quot;arbiter --help&amp;quot; to see all available commands&amp;#39;,
  ];

  const randomHint &#x3D; hints[Math.floor(Math.random() * hints.length)];

  console.log();
  console.log(chalk.magenta.bold(&amp;quot;ğŸ’¡ Hint:&amp;quot;));
  console.log(chalk.dim(&#x60;   ${randomHint}&#x60;));
  console.log();
}

/**
 * Command execution wrapper with consistent UX
 */
export async function executeWithUX&amp;lt;T&amp;gt;(
  operation: () &#x3D;&amp;gt; Promise&amp;lt;T&amp;gt;,
  {
    startMessage,
    successMessage,
    errorContext,
    command,
    showHints: hints &#x3D; true,
  }: {
    startMessage: string;
    successMessage?: string;
    errorContext?: string;
    command?: string;
    showHints?: boolean;
  },
): Promise&amp;lt;T&amp;gt; {
  const progress &#x3D; new ProgressIndicator(startMessage);
  progress.start();

  try {
    const result &#x3D; await operation();

    progress.succeed(successMessage || startMessage);

    if (command) {
      showNextSteps(command);
    }

    if (hints &amp;amp;&amp;amp; Math.random() &amp;lt; 0.3) {
      // 30% chance to show a hint
      showHints();
    }

    return result;
  } catch (error) {
    progress.fail(&#x60;Failed: ${startMessage}&#x60;);
    formatError(error instanceof Error ? error : new Error(String(error)), errorContext);
    throw error;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-48">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/docs.ts</div>
                <div class="file-content">
                    <pre>#!/usr/bin/env node

import fs from &amp;#39;node:fs/promises&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import type { CLIConfig } from &amp;#39;../types.js&amp;#39;;

/**
 * Options for docs command
 */
export interface DocsOptions {
  format?: &amp;#39;markdown&amp;#39; | &amp;#39;html&amp;#39; | &amp;#39;json&amp;#39;;
  output?: string;
  outputDir?: string;
  template?: string;
  interactive?: boolean;
  examples?: boolean;
}

/**
 * CUE Schema Documentation Structure
 */
interface SchemaDoc {
  name: string;
  description: string;
  fields: FieldDoc[];
  examples: string[];
  constraints: string[];
  imports: string[];
}

interface FieldDoc {
  name: string;
  type: string;
  description: string;
  required: boolean;
  default?: string;
  constraints: string[];
}

/**
 * Schema documentation generator from CUE definitions
 */
export async function docsCommand(
  subcommand: &amp;#39;schema&amp;#39; | &amp;#39;api&amp;#39; | &amp;#39;help&amp;#39;,
  options: DocsOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  try {
    switch (subcommand) {
      case &amp;#39;schema&amp;#39;:
        return await generateSchemaDocumentation(options, config);
      case &amp;#39;api&amp;#39;:
        return await generateApiDocumentation(options, config);
      case &amp;#39;help&amp;#39;:
        showDocsHelp();
        return 0;
      default:
        console.error(chalk.red(&#x60;Unknown docs subcommand: ${subcommand}&#x60;));
        showDocsHelp();
        return 1;
    }
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Documentation generation failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 2;
  }
}

/**
 * Generate schema documentation from arbiter.assembly.cue
 */
async function generateSchemaDocumentation(
  options: DocsOptions,
  _config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  console.log(chalk.blue(&amp;#39;ğŸ“š Generating schema documentation from CUE definitions...&amp;#39;));

  // Check for assembly file
  const assemblyPath &#x3D; path.resolve(&amp;#39;arbiter.assembly.cue&amp;#39;);

  try {
    await fs.access(assemblyPath);
    console.log(chalk.green(&amp;#39;âœ… Found arbiter.assembly.cue&amp;#39;));
  } catch {
    console.log(chalk.red(&amp;#39;âŒ No arbiter.assembly.cue found in current directory&amp;#39;));
    console.log(chalk.dim(&amp;#39;Run: arbiter init --template &amp;lt;type&amp;gt; to create one&amp;#39;));
    return 1;
  }

  // Read and parse the assembly file
  const assemblyContent &#x3D; await fs.readFile(assemblyPath, &amp;#39;utf-8&amp;#39;);

  // Parse CUE content to extract schema information
  const schemaInfo &#x3D; await parseCueSchema(assemblyContent);

  // Generate documentation based on format
  const format &#x3D; options.format || &amp;#39;markdown&amp;#39;;
  const outputDir &#x3D; options.outputDir || &amp;#39;.&amp;#39;;
  const filename &#x3D;
    options.output ||
    &#x60;schema-docs.${format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39; ? &amp;#39;json&amp;#39; : format &#x3D;&#x3D;&#x3D; &amp;#39;html&amp;#39; ? &amp;#39;html&amp;#39; : &amp;#39;md&amp;#39;}&#x60;;
  const outputPath &#x3D; path.isAbsolute(filename) ? filename : path.join(outputDir, filename);

  // Ensure output directory exists
  const outputDirPath &#x3D; path.dirname(outputPath);
  await fs.mkdir(outputDirPath, { recursive: true });

  console.log(chalk.blue(&#x60;ğŸ“ Generating ${format.toUpperCase()} documentation...&#x60;));
  console.log(chalk.dim(&#x60;Output: ${outputPath}&#x60;));

  let documentationContent: string;

  switch (format) {
    case &amp;#39;markdown&amp;#39;:
      documentationContent &#x3D; generateMarkdownDocs(schemaInfo);
      break;
    case &amp;#39;html&amp;#39;:
      documentationContent &#x3D; generateHtmlDocs(schemaInfo);
      break;
    case &amp;#39;json&amp;#39;:
      documentationContent &#x3D; JSON.stringify(schemaInfo, null, 2);
      break;
    default:
      throw new Error(&#x60;Unsupported format: ${format}&#x60;);
  }

  // Write documentation file
  await fs.writeFile(outputPath, documentationContent, &amp;#39;utf-8&amp;#39;);
  console.log(chalk.green(&#x60;âœ… Generated documentation: ${outputPath}&#x60;));

  // Generate examples if requested
  if (options.examples) {
    await generateExampleFiles(schemaInfo, outputDirPath);
  }

  // Show next steps
  console.log(chalk.blue(&amp;#39;\nğŸ¯ Next steps:&amp;#39;));
  console.log(chalk.dim(&#x60;  ğŸ“– View documentation: ${outputPath}&#x60;));
  console.log(chalk.dim(&amp;#39;  ğŸ”„ Regenerate automatically: arbiter watch --docs&amp;#39;));
  console.log(chalk.dim(&amp;#39;  ğŸŒ Serve docs: arbiter docs serve (coming soon)&amp;#39;));

  return 0;
}

/**
 * Generate API documentation from surface.json
 */
async function generateApiDocumentation(options: DocsOptions, _config: CLIConfig): Promise&amp;lt;number&amp;gt; {
  console.log(chalk.blue(&amp;#39;ğŸ”Œ Generating API documentation...&amp;#39;));

  const surfacePath &#x3D; path.resolve(&amp;#39;surface.json&amp;#39;);

  try {
    await fs.access(surfacePath);
  } catch {
    console.log(chalk.yellow(&amp;#39;âš ï¸  No surface.json found&amp;#39;));
    console.log(chalk.dim(&amp;#39;Run: arbiter surface &amp;lt;language&amp;gt; to generate API surface&amp;#39;));
    return 1;
  }

  const surfaceContent &#x3D; await fs.readFile(surfacePath, &amp;#39;utf-8&amp;#39;);
  const surfaceData &#x3D; JSON.parse(surfaceContent);

  const format &#x3D; options.format || &amp;#39;markdown&amp;#39;;
  const outputDir &#x3D; options.outputDir || &amp;#39;.&amp;#39;;
  const filename &#x3D; options.output || &#x60;api-docs.${format &#x3D;&#x3D;&#x3D; &amp;#39;html&amp;#39; ? &amp;#39;html&amp;#39; : &amp;#39;md&amp;#39;}&#x60;;
  const outputPath &#x3D; path.isAbsolute(filename) ? filename : path.join(outputDir, filename);

  // Ensure output directory exists
  const outputDirPath &#x3D; path.dirname(outputPath);
  await fs.mkdir(outputDirPath, { recursive: true });

  console.log(chalk.blue(&#x60;ğŸ“ Generating API ${format.toUpperCase()} documentation...&#x60;));
  console.log(chalk.dim(&#x60;Output: ${outputPath}&#x60;));

  const apiDocs &#x3D; generateApiDocs(surfaceData, format);

  await fs.writeFile(outputPath, apiDocs, &amp;#39;utf-8&amp;#39;);
  console.log(chalk.green(&#x60;âœ… Generated API documentation: ${outputPath}&#x60;));

  // Show next steps
  console.log(chalk.blue(&amp;#39;\nğŸ¯ Next steps:&amp;#39;));
  console.log(chalk.dim(&#x60;  ğŸ“– View API docs: ${outputPath}&#x60;));
  console.log(chalk.dim(&amp;#39;  ğŸ”„ Update surface: arbiter surface &amp;lt;language&amp;gt; --diff&amp;#39;));

  return 0;
}

/**
 * Parse CUE schema to extract documentation information
 */
async function parseCueSchema(content: string): Promise&amp;lt;SchemaDoc&amp;gt; {
  // This is a simplified parser - in production you&amp;#39;d use the CUE API
  // For now, we&amp;#39;ll extract basic structure from the assembly file

  const lines &#x3D; content.split(&amp;#39;\n&amp;#39;);
  const schemaDoc: SchemaDoc &#x3D; {
    name: &amp;#39;Arbiter Assembly&amp;#39;,
    description: &amp;#39;Arbiter project configuration schema&amp;#39;,
    fields: [],
    examples: [],
    constraints: [],
    imports: [],
  };

  const _currentField: FieldDoc | null &#x3D; null;
  let _inComment &#x3D; false;
  let commentBuffer: string[] &#x3D; [];

  for (const line of lines) {
    const trimmedLine &#x3D; line.trim();

    // Extract imports
    if (trimmedLine.startsWith(&amp;#39;import &amp;#39;)) {
      const importMatch &#x3D; trimmedLine.match(/import\s+&amp;quot;([^&amp;quot;]+)&amp;quot;/);
      if (importMatch) {
        schemaDoc.imports.push(importMatch[1]);
      }
    }

    // Extract comments
    if (trimmedLine.startsWith(&amp;#39;//&amp;#39;)) {
      commentBuffer.push(trimmedLine.replace(/^\/\/\s*/, &amp;#39;&amp;#39;));
      _inComment &#x3D; true;
      continue;
    }

    // Extract field definitions
    if (trimmedLine.includes(&amp;#39;:&amp;#39;) &amp;amp;&amp;amp; !trimmedLine.startsWith(&amp;#39;//&amp;#39;)) {
      const fieldMatch &#x3D; trimmedLine.match(/^([^:]+):\s*(.+)$/);
      if (fieldMatch) {
        const fieldName &#x3D; fieldMatch[1].trim();
        const fieldType &#x3D; fieldMatch[2].trim();

        // Skip internal fields
        if (fieldName.startsWith(&amp;#39;_&amp;#39;)) continue;

        const field: FieldDoc &#x3D; {
          name: fieldName,
          type: fieldType,
          description: commentBuffer.join(&amp;#39; &amp;#39;),
          required: !fieldType.includes(&amp;#39;?&amp;#39;) &amp;amp;&amp;amp; !trimmedLine.includes(&amp;#39;default:&amp;#39;),
          constraints: [],
        };

        // Extract default values
        if (trimmedLine.includes(&amp;#39;default:&amp;#39;)) {
          const defaultMatch &#x3D; trimmedLine.match(/default:\s*([^,}]+)/);
          if (defaultMatch) {
            field.default &#x3D; defaultMatch[1].trim();
          }
        }

        schemaDoc.fields.push(field);
      }

      // Reset comment buffer
      commentBuffer &#x3D; [];
      _inComment &#x3D; false;
    }
  }

  return schemaDoc;
}

/**
 * Generate Markdown documentation
 */
function generateMarkdownDocs(schemaInfo: SchemaDoc): string {
  let md &#x3D; &amp;#39;&amp;#39;;

  // Header
  md +&#x3D; &#x60;# ${schemaInfo.name}\n\n&#x60;;
  md +&#x3D; &#x60;${schemaInfo.description}\n\n&#x60;;

  // Auto-generated notice
  md +&#x3D; &amp;#39;&amp;gt; ğŸ¤– This documentation is auto-generated from CUE definitions.\n&amp;#39;;
  md +&#x3D; &#x60;&amp;gt; Last updated: ${new Date().toISOString()}\n\n&#x60;;

  // Table of Contents
  md +&#x3D; &amp;#39;## Table of Contents\n\n&amp;#39;;
  md +&#x3D; &amp;#39;- [Schema Overview](#schema-overview)\n&amp;#39;;
  md +&#x3D; &amp;#39;- [Fields](#fields)\n&amp;#39;;
  md +&#x3D; &amp;#39;- [Imports](#imports)\n&amp;#39;;
  md +&#x3D; &amp;#39;- [Examples](#examples)\n&amp;#39;;
  md +&#x3D; &amp;#39;- [Constraints](#constraints)\n\n&amp;#39;;

  // Schema Overview
  md +&#x3D; &amp;#39;## Schema Overview\n\n&amp;#39;;
  md +&#x3D; &amp;#39;This schema defines the structure for Arbiter project configurations.\n\n&amp;#39;;

  // Fields
  md +&#x3D; &amp;#39;## Fields\n\n&amp;#39;;
  md +&#x3D; &amp;#39;| Field | Type | Required | Default | Description |\n&amp;#39;;
  md +&#x3D; &amp;#39;|-------|------|----------|---------|-------------|\n&amp;#39;;

  for (const field of schemaInfo.fields) {
    const required &#x3D; field.required ? &amp;#39;âœ…&amp;#39; : &amp;#39;âŒ&amp;#39;;
    const defaultVal &#x3D; field.default ? &#x60;\&#x60;${field.default}\&#x60;&#x60; : &amp;#39;-&amp;#39;;
    md +&#x3D; &#x60;| \&#x60;${field.name}\&#x60; | \&#x60;${field.type}\&#x60; | ${required} | ${defaultVal} | ${field.description || &amp;#39;No description&amp;#39;} |\n&#x60;;
  }

  md +&#x3D; &amp;#39;\n&amp;#39;;

  // Imports
  if (schemaInfo.imports.length &amp;gt; 0) {
    md +&#x3D; &amp;#39;## Imports\n\n&amp;#39;;
    md +&#x3D; &amp;#39;This schema imports the following modules:\n\n&amp;#39;;

    for (const importPath of schemaInfo.imports) {
      md +&#x3D; &#x60;- \&#x60;${importPath}\&#x60;\n&#x60;;
    }

    md +&#x3D; &amp;#39;\n&amp;#39;;
  }

  // Examples
  md +&#x3D; &amp;#39;## Examples\n\n&amp;#39;;
  md +&#x3D; &amp;#39;### Basic Configuration\n\n&amp;#39;;
  md +&#x3D; &amp;#39;&#x60;&#x60;&#x60;cue\n&amp;#39;;
  md +&#x3D; &amp;#39;// Basic library configuration\n&amp;#39;;
  md +&#x3D; &#x60;import &amp;quot;github.com/arbiter-framework/schemas/artifact&amp;quot;\n&#x60;;
  md +&#x3D; &#x60;import &amp;quot;github.com/arbiter-framework/schemas/profiles&amp;quot;\n\n&#x60;;
  md +&#x3D; &amp;#39;Artifact: artifact.#Artifact &amp;amp; {\n&amp;#39;;
  md +&#x3D; &#x60;  kind: &amp;quot;library&amp;quot;\n&#x60;;
  md +&#x3D; &#x60;  language: &amp;quot;typescript&amp;quot;\n&#x60;;
  md +&#x3D; &amp;#39;  build: {\n&amp;#39;;
  md +&#x3D; &#x60;    tool: &amp;quot;bun&amp;quot;\n&#x60;;
  md +&#x3D; &#x60;    targets: [&amp;quot;./src&amp;quot;]\n&#x60;;
  md +&#x3D; &amp;#39;  }\n&amp;#39;;
  md +&#x3D; &amp;#39;}\n\n&amp;#39;;
  md +&#x3D; &amp;#39;Profile: profiles.#library &amp;amp; {\n&amp;#39;;
  md +&#x3D; &#x60;  semver: &amp;quot;strict&amp;quot;\n&#x60;;
  md +&#x3D; &amp;#39;  apiSurface: {\n&amp;#39;;
  md +&#x3D; &#x60;    source: &amp;quot;generated&amp;quot;\n&#x60;;
  md +&#x3D; &#x60;    file: &amp;quot;./dist/api-surface.json&amp;quot;\n&#x60;;
  md +&#x3D; &amp;#39;  }\n&amp;#39;;
  md +&#x3D; &amp;#39;}\n&amp;#39;;
  md +&#x3D; &amp;#39;&#x60;&#x60;&#x60;\n\n&amp;#39;;

  md +&#x3D; &amp;#39;### CLI Configuration\n\n&amp;#39;;
  md +&#x3D; &amp;#39;&#x60;&#x60;&#x60;cue\n&amp;#39;;
  md +&#x3D; &amp;#39;Artifact: artifact.#Artifact &amp;amp; {\n&amp;#39;;
  md +&#x3D; &#x60;  kind: &amp;quot;cli&amp;quot;\n&#x60;;
  md +&#x3D; &#x60;  language: &amp;quot;typescript&amp;quot;\n&#x60;;
  md +&#x3D; &amp;#39;}\n\n&amp;#39;;
  md +&#x3D; &amp;#39;Profile: profiles.#cli &amp;amp; {\n&amp;#39;;
  md +&#x3D; &amp;#39;  commands: [\n&amp;#39;;
  md +&#x3D; &amp;#39;    {\n&amp;#39;;
  md +&#x3D; &#x60;      name: &amp;quot;main&amp;quot;\n&#x60;;
  md +&#x3D; &#x60;      summary: &amp;quot;Main command&amp;quot;\n&#x60;;
  md +&#x3D; &amp;#39;      args: []\n&amp;#39;;
  md +&#x3D; &amp;#39;      flags: [\n&amp;#39;;
  md +&#x3D; &#x60;        {name: &amp;quot;help&amp;quot;, type: &amp;quot;bool&amp;quot;, default: false}\n&#x60;;
  md +&#x3D; &amp;#39;      ]\n&amp;#39;;
  md +&#x3D; &amp;#39;    }\n&amp;#39;;
  md +&#x3D; &amp;#39;  ]\n&amp;#39;;
  md +&#x3D; &amp;#39;}\n&amp;#39;;
  md +&#x3D; &amp;#39;&#x60;&#x60;&#x60;\n\n&amp;#39;;

  // Footer
  md +&#x3D; &amp;#39;---\n\n&amp;#39;;
  md +&#x3D;
    &amp;#39;**Generated by Arbiter CLI** - [Learn more](https://github.com/arbiter-framework/arbiter)\n&amp;#39;;

  return md;
}

/**
 * Generate HTML documentation
 */
function generateHtmlDocs(schemaInfo: SchemaDoc): string {
  let html &#x3D; &amp;#39;&amp;#39;;

  html +&#x3D; &amp;#39;&amp;lt;!DOCTYPE html&amp;gt;\n&amp;#39;;
  html +&#x3D; &#x60;&amp;lt;html lang&#x3D;&amp;quot;en&amp;quot;&amp;gt;\n&#x60;;
  html +&#x3D; &amp;#39;&amp;lt;head&amp;gt;\n&amp;#39;;
  html +&#x3D; &#x60;  &amp;lt;meta charset&#x3D;&amp;quot;UTF-8&amp;quot;&amp;gt;\n&#x60;;
  html +&#x3D; &#x60;  &amp;lt;meta name&#x3D;&amp;quot;viewport&amp;quot; content&#x3D;&amp;quot;width&#x3D;device-width, initial-scale&#x3D;1.0&amp;quot;&amp;gt;\n&#x60;;
  html +&#x3D; &#x60;  &amp;lt;title&amp;gt;${schemaInfo.name} - Schema Documentation&amp;lt;/title&amp;gt;\n&#x60;;
  html +&#x3D; &amp;#39;  &amp;lt;style&amp;gt;\n&amp;#39;;
  html +&#x3D; generateCssStyles();
  html +&#x3D; &amp;#39;  &amp;lt;/style&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;&amp;lt;/head&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;&amp;lt;body&amp;gt;\n&amp;#39;;

  // Header
  html +&#x3D; &amp;#39;  &amp;lt;header&amp;gt;\n&amp;#39;;
  html +&#x3D; &#x60;    &amp;lt;h1&amp;gt;${schemaInfo.name}&amp;lt;/h1&amp;gt;\n&#x60;;
  html +&#x3D; &#x60;    &amp;lt;p class&#x3D;&amp;quot;description&amp;quot;&amp;gt;${schemaInfo.description}&amp;lt;/p&amp;gt;\n&#x60;;
  html +&#x3D; &#x60;    &amp;lt;div class&#x3D;&amp;quot;meta&amp;quot;&amp;gt;Auto-generated on ${new Date().toLocaleString()}&amp;lt;/div&amp;gt;\n&#x60;;
  html +&#x3D; &amp;#39;  &amp;lt;/header&amp;gt;\n&amp;#39;;

  // Navigation
  html +&#x3D; &amp;#39;  &amp;lt;nav&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;    &amp;lt;ul&amp;gt;\n&amp;#39;;
  html +&#x3D; &#x60;      &amp;lt;li&amp;gt;&amp;lt;a href&#x3D;&amp;quot;#overview&amp;quot;&amp;gt;Overview&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;\n&#x60;;
  html +&#x3D; &#x60;      &amp;lt;li&amp;gt;&amp;lt;a href&#x3D;&amp;quot;#fields&amp;quot;&amp;gt;Fields&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;\n&#x60;;
  html +&#x3D; &#x60;      &amp;lt;li&amp;gt;&amp;lt;a href&#x3D;&amp;quot;#examples&amp;quot;&amp;gt;Examples&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;\n&#x60;;
  html +&#x3D; &amp;#39;    &amp;lt;/ul&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;  &amp;lt;/nav&amp;gt;\n&amp;#39;;

  // Main content
  html +&#x3D; &amp;#39;  &amp;lt;main&amp;gt;\n&amp;#39;;

  // Overview
  html +&#x3D; &#x60;    &amp;lt;section id&#x3D;&amp;quot;overview&amp;quot;&amp;gt;\n&#x60;;
  html +&#x3D; &amp;#39;      &amp;lt;h2&amp;gt;Schema Overview&amp;lt;/h2&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;      &amp;lt;p&amp;gt;This schema defines the structure for Arbiter project configurations.&amp;lt;/p&amp;gt;\n&amp;#39;;

  if (schemaInfo.imports.length &amp;gt; 0) {
    html +&#x3D; &amp;#39;      &amp;lt;h3&amp;gt;Imports&amp;lt;/h3&amp;gt;\n&amp;#39;;
    html +&#x3D; &amp;#39;      &amp;lt;ul&amp;gt;\n&amp;#39;;
    for (const importPath of schemaInfo.imports) {
      html +&#x3D; &#x60;        &amp;lt;li&amp;gt;&amp;lt;code&amp;gt;${importPath}&amp;lt;/code&amp;gt;&amp;lt;/li&amp;gt;\n&#x60;;
    }
    html +&#x3D; &amp;#39;      &amp;lt;/ul&amp;gt;\n&amp;#39;;
  }

  html +&#x3D; &amp;#39;    &amp;lt;/section&amp;gt;\n&amp;#39;;

  // Fields
  html +&#x3D; &#x60;    &amp;lt;section id&#x3D;&amp;quot;fields&amp;quot;&amp;gt;\n&#x60;;
  html +&#x3D; &amp;#39;      &amp;lt;h2&amp;gt;Fields&amp;lt;/h2&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;      &amp;lt;table&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;        &amp;lt;thead&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;          &amp;lt;tr&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;            &amp;lt;th&amp;gt;Field&amp;lt;/th&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;            &amp;lt;th&amp;gt;Type&amp;lt;/th&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;            &amp;lt;th&amp;gt;Required&amp;lt;/th&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;            &amp;lt;th&amp;gt;Default&amp;lt;/th&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;            &amp;lt;th&amp;gt;Description&amp;lt;/th&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;          &amp;lt;/tr&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;        &amp;lt;/thead&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;        &amp;lt;tbody&amp;gt;\n&amp;#39;;

  for (const field of schemaInfo.fields) {
    const required &#x3D; field.required
      ? &amp;#39;&amp;lt;span class&#x3D;&amp;quot;required&amp;quot;&amp;gt;Yes&amp;lt;/span&amp;gt;&amp;#39;
      : &amp;#39;&amp;lt;span class&#x3D;&amp;quot;optional&amp;quot;&amp;gt;No&amp;lt;/span&amp;gt;&amp;#39;;
    const defaultVal &#x3D; field.default ? &#x60;&amp;lt;code&amp;gt;${field.default}&amp;lt;/code&amp;gt;&#x60; : &amp;#39;-&amp;#39;;
    html +&#x3D; &amp;#39;          &amp;lt;tr&amp;gt;\n&amp;#39;;
    html +&#x3D; &#x60;            &amp;lt;td&amp;gt;&amp;lt;code&amp;gt;${field.name}&amp;lt;/code&amp;gt;&amp;lt;/td&amp;gt;\n&#x60;;
    html +&#x3D; &#x60;            &amp;lt;td&amp;gt;&amp;lt;code&amp;gt;${field.type}&amp;lt;/code&amp;gt;&amp;lt;/td&amp;gt;\n&#x60;;
    html +&#x3D; &#x60;            &amp;lt;td&amp;gt;${required}&amp;lt;/td&amp;gt;\n&#x60;;
    html +&#x3D; &#x60;            &amp;lt;td&amp;gt;${defaultVal}&amp;lt;/td&amp;gt;\n&#x60;;
    html +&#x3D; &#x60;            &amp;lt;td&amp;gt;${field.description || &amp;#39;No description&amp;#39;}&amp;lt;/td&amp;gt;\n&#x60;;
    html +&#x3D; &amp;#39;          &amp;lt;/tr&amp;gt;\n&amp;#39;;
  }

  html +&#x3D; &amp;#39;        &amp;lt;/tbody&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;      &amp;lt;/table&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;    &amp;lt;/section&amp;gt;\n&amp;#39;;

  // Examples
  html +&#x3D; &#x60;    &amp;lt;section id&#x3D;&amp;quot;examples&amp;quot;&amp;gt;\n&#x60;;
  html +&#x3D; &amp;#39;      &amp;lt;h2&amp;gt;Examples&amp;lt;/h2&amp;gt;\n&amp;#39;;
  html +&#x3D; &#x60;      &amp;lt;div class&#x3D;&amp;quot;example&amp;quot;&amp;gt;\n&#x60;;
  html +&#x3D; &amp;#39;        &amp;lt;h3&amp;gt;Basic Library Configuration&amp;lt;/h3&amp;gt;\n&amp;#39;;
  html +&#x3D; &#x60;        &amp;lt;pre&amp;gt;&amp;lt;code class&#x3D;&amp;quot;language-cue&amp;quot;&amp;gt;&#x60;;
  html +&#x3D; &#x60;// Basic library configuration
import &amp;quot;github.com/arbiter-framework/schemas/artifact&amp;quot;
import &amp;quot;github.com/arbiter-framework/schemas/profiles&amp;quot;

Artifact: artifact.#Artifact &amp;amp; {
  kind: &amp;quot;library&amp;quot;
  language: &amp;quot;typescript&amp;quot;
  build: {
    tool: &amp;quot;bun&amp;quot;
    targets: [&amp;quot;./src&amp;quot;]
  }
}

Profile: profiles.#library &amp;amp; {
  semver: &amp;quot;strict&amp;quot;
  apiSurface: {
    source: &amp;quot;generated&amp;quot;
    file: &amp;quot;./dist/api-surface.json&amp;quot;
  }
}&#x60;;
  html +&#x3D; &amp;#39;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;      &amp;lt;/div&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;    &amp;lt;/section&amp;gt;\n&amp;#39;;

  html +&#x3D; &amp;#39;  &amp;lt;/main&amp;gt;\n&amp;#39;;

  // Footer
  html +&#x3D; &amp;#39;  &amp;lt;footer&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;    &amp;lt;p&amp;gt;Generated by &amp;lt;strong&amp;gt;Arbiter CLI&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;  &amp;lt;/footer&amp;gt;\n&amp;#39;;

  html +&#x3D; &amp;#39;&amp;lt;/body&amp;gt;\n&amp;#39;;
  html +&#x3D; &amp;#39;&amp;lt;/html&amp;gt;\n&amp;#39;;

  return html;
}

/**
 * Generate CSS styles for HTML documentation
 */
function generateCssStyles(): string {
  return &#x60;
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, &amp;#39;Segoe UI&amp;#39;, Roboto, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
      background: #fafafa;
    }
    
    header {
      border-bottom: 3px solid #007acc;
      margin-bottom: 2rem;
      padding-bottom: 1rem;
    }
    
    header h1 {
      color: #007acc;
      margin: 0;
    }
    
    .description {
      font-size: 1.1rem;
      color: #666;
      margin: 0.5rem 0;
    }
    
    .meta {
      font-size: 0.9rem;
      color: #888;
    }
    
    nav {
      background: white;
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      gap: 2rem;
    }
    
    nav a {
      color: #007acc;
      text-decoration: none;
      font-weight: 500;
    }
    
    nav a:hover {
      text-decoration: underline;
    }
    
    main {
      background: white;
      border-radius: 8px;
      padding: 2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    section {
      margin-bottom: 3rem;
    }
    
    h2 {
      color: #007acc;
      border-bottom: 1px solid #eee;
      padding-bottom: 0.5rem;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }
    
    th, td {
      border: 1px solid #ddd;
      padding: 12px;
      text-align: left;
    }
    
    th {
      background: #f8f9fa;
      font-weight: 600;
    }
    
    tr:nth-child(even) {
      background: #f8f9fa;
    }
    
    code {
      background: #f1f3f4;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: &amp;#39;Monaco&amp;#39;, &amp;#39;Menlo&amp;#39;, monospace;
      font-size: 0.9em;
    }
    
    pre {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 1.5rem;
      border-radius: 6px;
      overflow-x: auto;
    }
    
    pre code {
      background: none;
      padding: 0;
      color: inherit;
    }
    
    .required {
      color: #28a745;
      font-weight: bold;
    }
    
    .optional {
      color: #6c757d;
    }
    
    .example {
      border: 1px solid #e1e4e8;
      border-radius: 6px;
      overflow: hidden;
      margin: 1rem 0;
    }
    
    .example h3 {
      background: #f6f8fa;
      margin: 0;
      padding: 1rem;
      border-bottom: 1px solid #e1e4e8;
    }
    
    footer {
      text-align: center;
      padding: 2rem;
      color: #666;
      border-top: 1px solid #eee;
      margin-top: 3rem;
    }
  &#x60;;
}

/**
 * Generate API documentation from surface data
 */
function generateApiDocs(surfaceData: any, format: string): string {
  if (format &#x3D;&#x3D;&#x3D; &amp;#39;html&amp;#39;) {
    return generateApiDocsHtml(surfaceData);
  }
  return generateApiDocsMarkdown(surfaceData);
}

/**
 * Generate API documentation in Markdown format
 */
function generateApiDocsMarkdown(surfaceData: any): string {
  let md &#x3D; &amp;#39;&amp;#39;;

  md +&#x3D; &amp;#39;# API Documentation\n\n&amp;#39;;
  md +&#x3D; &amp;#39;&amp;gt; ğŸ¤– Auto-generated from source code analysis\n&amp;#39;;
  md +&#x3D; &#x60;&amp;gt; Last updated: ${new Date().toISOString()}\n\n&#x60;;

  if (surfaceData.functions &amp;amp;&amp;amp; surfaceData.functions.length &amp;gt; 0) {
    md +&#x3D; &amp;#39;## Functions\n\n&amp;#39;;

    for (const func of surfaceData.functions) {
      md +&#x3D; &#x60;### \&#x60;${func.name}\&#x60;\n\n&#x60;;

      if (func.description) {
        md +&#x3D; &#x60;${func.description}\n\n&#x60;;
      }

      // Parameters
      if (func.parameters &amp;amp;&amp;amp; func.parameters.length &amp;gt; 0) {
        md +&#x3D; &amp;#39;**Parameters:**\n\n&amp;#39;;
        for (const param of func.parameters) {
          md +&#x3D; &#x60;- \&#x60;${param.name}\&#x60; (${param.type}): ${param.description || &amp;#39;No description&amp;#39;}\n&#x60;;
        }
        md +&#x3D; &amp;#39;\n&amp;#39;;
      }

      // Returns
      if (func.returns) {
        md +&#x3D; &#x60;**Returns:** \&#x60;${func.returns.type}\&#x60;\n\n&#x60;;
        if (func.returns.description) {
          md +&#x3D; &#x60;${func.returns.description}\n\n&#x60;;
        }
      }

      // Example
      if (func.example) {
        md +&#x3D; &amp;#39;**Example:**\n\n&amp;#39;;
        md +&#x3D; &#x60;\&#x60;\&#x60;\&#x60;typescript\n${func.example}\&#x60;\&#x60;\&#x60;\n\n&#x60;;
      }

      md +&#x3D; &amp;#39;---\n\n&amp;#39;;
    }
  }

  return md;
}

/**
 * Generate API documentation in HTML format
 */
function generateApiDocsHtml(surfaceData: any): string {
  let html &#x3D; &#x60;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang&#x3D;&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset&#x3D;&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;meta name&#x3D;&amp;quot;viewport&amp;quot; content&#x3D;&amp;quot;width&#x3D;device-width, initial-scale&#x3D;1.0&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;API Documentation&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;${generateCssStyles()}&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;header&amp;gt;
    &amp;lt;h1&amp;gt;API Documentation&amp;lt;/h1&amp;gt;
    &amp;lt;div class&#x3D;&amp;quot;meta&amp;quot;&amp;gt;Auto-generated on ${new Date().toLocaleString()}&amp;lt;/div&amp;gt;
  &amp;lt;/header&amp;gt;
  
  &amp;lt;main&amp;gt;&#x60;;

  if (surfaceData.functions &amp;amp;&amp;amp; surfaceData.functions.length &amp;gt; 0) {
    html +&#x3D; &#x60;
    &amp;lt;section id&#x3D;&amp;quot;functions&amp;quot;&amp;gt;
      &amp;lt;h2&amp;gt;Functions&amp;lt;/h2&amp;gt;&#x60;;

    for (const func of surfaceData.functions) {
      html +&#x3D; &#x60;
      &amp;lt;div class&#x3D;&amp;quot;function&amp;quot;&amp;gt;
        &amp;lt;h3&amp;gt;&amp;lt;code&amp;gt;${func.name}&amp;lt;/code&amp;gt;&amp;lt;/h3&amp;gt;&#x60;;

      if (func.description) {
        html +&#x3D; &#x60;&amp;lt;p&amp;gt;${func.description}&amp;lt;/p&amp;gt;&#x60;;
      }

      if (func.parameters &amp;amp;&amp;amp; func.parameters.length &amp;gt; 0) {
        html +&#x3D; &#x60;
        &amp;lt;h4&amp;gt;Parameters&amp;lt;/h4&amp;gt;
        &amp;lt;ul&amp;gt;&#x60;;
        for (const param of func.parameters) {
          html +&#x3D; &#x60;&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;${param.name}&amp;lt;/code&amp;gt; (${param.type}): ${param.description || &amp;#39;No description&amp;#39;}&amp;lt;/li&amp;gt;&#x60;;
        }
        html +&#x3D; &amp;#39;&amp;lt;/ul&amp;gt;&amp;#39;;
      }

      if (func.returns) {
        html +&#x3D; &amp;#39;&amp;lt;h4&amp;gt;Returns&amp;lt;/h4&amp;gt;&amp;#39;;
        html +&#x3D; &#x60;&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;${func.returns.type}&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;&#x60;;
        if (func.returns.description) {
          html +&#x3D; &#x60;&amp;lt;p&amp;gt;${func.returns.description}&amp;lt;/p&amp;gt;&#x60;;
        }
      }

      html +&#x3D; &amp;#39;&amp;lt;/div&amp;gt;&amp;#39;;
    }

    html +&#x3D; &amp;#39;&amp;lt;/section&amp;gt;&amp;#39;;
  }

  html +&#x3D; &#x60;
  &amp;lt;/main&amp;gt;
  
  &amp;lt;footer&amp;gt;
    &amp;lt;p&amp;gt;Generated by &amp;lt;strong&amp;gt;Arbiter CLI&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;/footer&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&#x60;;

  return html;
}

/**
 * Generate example files alongside documentation
 */
async function generateExampleFiles(_schemaInfo: SchemaDoc, outputDir: string): Promise&amp;lt;void&amp;gt; {
  const examplesDir &#x3D; path.join(outputDir, &amp;#39;examples&amp;#39;);
  await fs.mkdir(examplesDir, { recursive: true });

  // Generate basic library example
  const libraryExample &#x3D; &#x60;// Example: Basic Library Configuration
import &amp;quot;github.com/arbiter-framework/schemas/artifact&amp;quot;
import &amp;quot;github.com/arbiter-framework/schemas/profiles&amp;quot;

Artifact: artifact.#Artifact &amp;amp; {
  kind: &amp;quot;library&amp;quot;
  language: &amp;quot;typescript&amp;quot;
  
  build: {
    tool: &amp;quot;bun&amp;quot;
    targets: [&amp;quot;./src&amp;quot;]
    matrix: {
      versions: [&amp;quot;18&amp;quot;, &amp;quot;20&amp;quot;, &amp;quot;latest&amp;quot;]
      os: [&amp;quot;linux&amp;quot;, &amp;quot;darwin&amp;quot;]
    }
  }
  
  packaging: {
    publish: true
    registry: &amp;quot;npm&amp;quot;
  }
}

Profile: profiles.#library &amp;amp; {
  semver: &amp;quot;strict&amp;quot;
  apiSurface: {
    source: &amp;quot;generated&amp;quot;
    file: &amp;quot;./dist/api-surface.json&amp;quot;
  }
  contracts: {
    forbidBreaking: true
    invariants: [
      // Your invariants here
    ]
  }
}
&#x60;;

  await fs.writeFile(path.join(examplesDir, &amp;#39;library.cue&amp;#39;), libraryExample);

  // Generate CLI example
  const cliExample &#x3D; &#x60;// Example: CLI Tool Configuration
import &amp;quot;github.com/arbiter-framework/schemas/artifact&amp;quot;
import &amp;quot;github.com/arbiter-framework/schemas/profiles&amp;quot;

Artifact: artifact.#Artifact &amp;amp; {
  kind: &amp;quot;cli&amp;quot;
  language: &amp;quot;typescript&amp;quot;
  
  build: {
    tool: &amp;quot;bun&amp;quot;
    targets: [&amp;quot;./src/cli.ts&amp;quot;]
  }
}

Profile: profiles.#cli &amp;amp; {
  commands: [
    {
      name: &amp;quot;main&amp;quot;
      summary: &amp;quot;Main command&amp;quot;
      args: [
        {name: &amp;quot;input&amp;quot;, type: &amp;quot;string&amp;quot;, description: &amp;quot;Input file&amp;quot;}
      ]
      flags: [
        {name: &amp;quot;help&amp;quot;, type: &amp;quot;bool&amp;quot;, default: false}
        {name: &amp;quot;verbose&amp;quot;, type: &amp;quot;bool&amp;quot;, default: false}
        {name: &amp;quot;output&amp;quot;, type: &amp;quot;string&amp;quot;, default: &amp;quot;stdout&amp;quot;}
      ]
      exits: [
        {code: 0, meaning: &amp;quot;success&amp;quot;}
        {code: 1, meaning: &amp;quot;error&amp;quot;}
      ]
    }
  ]
  
  tests: {
    golden: [
      {name: &amp;quot;help_output&amp;quot;, command: [&amp;quot;--help&amp;quot;]}
    ]
  }
}
&#x60;;

  await fs.writeFile(path.join(examplesDir, &amp;#39;cli.cue&amp;#39;), cliExample);

  console.log(chalk.green(&#x60;âœ… Generated example files in ${examplesDir}&#x60;));
}

/**
 * Show help for docs command
 */
function showDocsHelp(): void {
  console.log(&#x60;
${chalk.bold(&amp;#39;arbiter docs&amp;#39;)} - Documentation generation

${chalk.bold(&amp;#39;USAGE:&amp;#39;)}
  arbiter docs schema [options]     Generate schema documentation from CUE
  arbiter docs api [options]        Generate API documentation from surface
  arbiter docs help                 Show this help

${chalk.bold(&amp;#39;OPTIONS:&amp;#39;)}
  --format &amp;lt;type&amp;gt;      Output format: markdown, html, json (default: markdown)
  --output &amp;lt;file&amp;gt;      Output file path (auto-named if not specified)
  --examples          Generate example files alongside documentation
  --interactive       Interactive documentation setup

${chalk.bold(&amp;#39;EXAMPLES:&amp;#39;)}
  arbiter docs schema                           # Generate Markdown schema docs
  arbiter docs schema --format html            # Generate HTML documentation
  arbiter docs schema --examples --format json # Generate JSON schema + examples
  arbiter docs api --format html               # Generate API docs from surface.json
&#x60;);
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-49">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/init.ts</div>
                <div class="file-content">
                    <pre>import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import inquirer from &amp;#39;inquirer&amp;#39;;
import type { InitOptions, ProjectTemplate } from &amp;#39;../types.js&amp;#39;;
import { withProgress } from &amp;#39;../utils/progress.js&amp;#39;;

/**
 * Basic project templates for initialization (structure only - no CUE files)
 */
const TEMPLATES: Record&amp;lt;string, ProjectTemplate&amp;gt; &#x3D; {
  basic: {
    name: &amp;#39;Basic&amp;#39;,
    description: &amp;#39;A simple CUE project with basic structure&amp;#39;,
    files: {
      &amp;#39;cue.mod/module.cue&amp;#39;: &#x60;module: &amp;quot;example.com/myproject&amp;quot;
language: version: &amp;quot;v0.6.0&amp;quot;
&#x60;,
      &amp;#39;README.md&amp;#39;: &#x60;# {{PROJECT_NAME}}

This is a CUE project created with Arbiter CLI.

## Getting Started

âš ï¸  **IMPORTANT**: This project has been initialized with basic structure only.
To add functionality, use the Arbiter CLI commands to build your specification:

### 1. Add components to your specification:
\&#x60;\&#x60;\&#x60;bash
# Add API endpoints, data models, configurations, etc.
arbiter add &amp;lt;component-type&amp;gt; &amp;lt;name&amp;gt;
\&#x60;\&#x60;\&#x60;

### 2. Generate project files from your specification:
\&#x60;\&#x60;\&#x60;bash
arbiter generate
\&#x60;\&#x60;\&#x60;

### 3. Validate your configuration:
\&#x60;\&#x60;\&#x60;bash
arbiter check
\&#x60;\&#x60;\&#x60;

## Project Structure

- \&#x60;cue.mod/\&#x60; - CUE module configuration
- \&#x60;.arbiter/config.json\&#x60; - Arbiter CLI configuration
- Generated CUE files will appear after running \&#x60;arbiter generate\&#x60;

## Learn More

- [CUE Documentation](https://cuelang.org/docs/)
- [Arbiter CLI](https://github.com/arbiter/cli)
&#x60;,
      &amp;#39;.gitignore&amp;#39;: &#x60;# Build artifacts
*.out
dist/
build/

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Temporary files
*.tmp
*.temp
&#x60;,
    },
  },

  kubernetes: {
    name: &amp;#39;Kubernetes&amp;#39;,
    description: &amp;#39;CUE project for Kubernetes configurations&amp;#39;,
    files: {
      &amp;#39;cue.mod/module.cue&amp;#39;: &#x60;module: &amp;quot;example.com/k8s-config&amp;quot;
language: version: &amp;quot;v0.6.0&amp;quot;
&#x60;,
      &amp;#39;README.md&amp;#39;: &#x60;# {{PROJECT_NAME}} - Kubernetes Configuration

This project uses CUE to manage Kubernetes configurations with type safety and validation.

## Getting Started

âš ï¸  **IMPORTANT**: This project has been initialized with basic structure only.
To add Kubernetes resources, use the Arbiter CLI commands:

### 1. Add Kubernetes components:
\&#x60;\&#x60;\&#x60;bash
# Add deployments, services, configmaps, etc.
arbiter add deployment &amp;lt;name&amp;gt;
arbiter add service &amp;lt;name&amp;gt;
arbiter add configmap &amp;lt;name&amp;gt;
\&#x60;\&#x60;\&#x60;

### 2. Generate CUE files:
\&#x60;\&#x60;\&#x60;bash
arbiter generate
\&#x60;\&#x60;\&#x60;

### 3. Validate configurations:
\&#x60;\&#x60;\&#x60;bash
arbiter check
\&#x60;\&#x60;\&#x60;

### 4. Export to YAML:
\&#x60;\&#x60;\&#x60;bash
arbiter export --format k8s
\&#x60;\&#x60;\&#x60;

## Next Steps

1. Import Kubernetes schemas: \&#x60;cue get go k8s.io/api/...\&#x60;
2. Use \&#x60;arbiter add\&#x60; commands to build your specification
3. Generate and validate your configurations
&#x60;,
    },
  },

  api: {
    name: &amp;#39;API Schema&amp;#39;,
    description: &amp;#39;CUE project for API schema definition&amp;#39;,
    files: {
      &amp;#39;cue.mod/module.cue&amp;#39;: &#x60;module: &amp;quot;example.com/api-schema&amp;quot;
language: version: &amp;quot;v0.6.0&amp;quot;
&#x60;,
      &amp;#39;README.md&amp;#39;: &#x60;# {{PROJECT_NAME}} - API Schema

This project defines API schemas using CUE with type safety and OpenAPI generation.

## Getting Started

âš ï¸  **IMPORTANT**: This project has been initialized with basic structure only.
To define your API, use the Arbiter CLI commands:

### 1. Add API components:
\&#x60;\&#x60;\&#x60;bash
# Add data models, endpoints, types, etc.
arbiter add model &amp;lt;name&amp;gt;
arbiter add endpoint &amp;lt;path&amp;gt;
arbiter add type &amp;lt;name&amp;gt;
\&#x60;\&#x60;\&#x60;

### 2. Generate CUE files:
\&#x60;\&#x60;\&#x60;bash
arbiter generate
\&#x60;\&#x60;\&#x60;

### 3. Validate schemas:
\&#x60;\&#x60;\&#x60;bash
arbiter check
\&#x60;\&#x60;\&#x60;

### 4. Export OpenAPI spec:
\&#x60;\&#x60;\&#x60;bash
arbiter export --format openapi &amp;gt; openapi.yaml
\&#x60;\&#x60;\&#x60;

### 5. Generate TypeScript types:
\&#x60;\&#x60;\&#x60;bash
arbiter export --format types &amp;gt; types.ts
\&#x60;\&#x60;\&#x60;

## Features (after adding components)

- Type-safe API definitions
- Automatic validation
- OpenAPI generation
- TypeScript type generation
&#x60;,
    },
  },
};

/**
 * Initialize a new CUE project with templates
 */
export async function initCommand(
  displayName: string | undefined,
  options: InitOptions
): Promise&amp;lt;number&amp;gt; {
  try {
    // Get project details
    const projectDetails &#x3D; await getProjectDetails(displayName, options);
    const { name, directory, template } &#x3D; projectDetails;

    // Check if directory exists and handle accordingly
    const targetDir &#x3D; path.resolve(directory);
    const exists &#x3D; await fs.pathExists(targetDir);

    if (exists &amp;amp;&amp;amp; !options.force) {
      console.log(
        chalk.yellow(&#x60;Directory &amp;quot;${directory}&amp;quot; already exists. Use --force to overwrite.&#x60;)
      );
      return 1;
    }

    // Create project
    return await withProgress(
      { text: &#x60;Creating project &amp;quot;${name}&amp;quot;...&#x60;, color: &amp;#39;green&amp;#39; },
      async () &#x3D;&amp;gt; {
        await createProject(targetDir, name, template);

        console.log(chalk.green(&#x60;\nâœ“ Created project &amp;quot;${name}&amp;quot; in ${directory}&#x60;));

        console.log(chalk.yellow(&amp;#39;\nğŸ“‹ IMPORTANT: Basic project structure created&amp;#39;));
        console.log(chalk.red(&amp;#39;âš ï¸  NO CUE files have been generated yet - this is intentional!&amp;#39;));
        console.log(chalk.dim(&amp;#39;\nNext steps:&amp;#39;));
        console.log(chalk.dim(&#x60;  cd ${directory}&#x60;));
        console.log(chalk.green(&amp;#39;  1. Add components to build your specification:&amp;#39;));
        console.log(
          chalk.cyan(
            &amp;#39;     arbiter add &amp;lt;component-type&amp;gt; &amp;lt;name&amp;gt;  # Add models, endpoints, configs, etc.&amp;#39;
          )
        );
        console.log(chalk.green(&amp;#39;  2. Generate CUE files from your specification:&amp;#39;));
        console.log(chalk.cyan(&amp;#39;     arbiter generate  # Creates the actual CUE files&amp;#39;));
        console.log(chalk.green(&amp;#39;  3. Validate your generated CUE files:&amp;#39;));
        console.log(chalk.cyan(&amp;#39;     arbiter check  # Validate the generated CUE&amp;#39;));
        console.log(chalk.dim(&amp;quot;\nğŸ’¡ Use &amp;#39;arbiter --help&amp;#39; to see all available add commands&amp;quot;));

        return 0;
      }
    );
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Init command failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 2;
  }
}

/**
 * Get project details from user input
 */
async function getProjectDetails(
  displayName: string | undefined,
  options: InitOptions
): Promise&amp;lt;{ name: string; directory: string; template: ProjectTemplate }&amp;gt; {
  // Use defaults for all required values, no interactive prompts
  const name &#x3D; displayName || path.basename(process.cwd());
  const templateKey &#x3D; options.template || &amp;#39;basic&amp;#39;;
  const directory &#x3D; process.cwd();
  const template &#x3D; TEMPLATES[templateKey];
  if (!template) {
    throw new Error(&#x60;Unknown template: ${templateKey}&#x60;);
  }

  return { name, directory, template };
}

/**
 * Create project files from template
 */
async function createProject(
  targetDir: string,
  projectName: string,
  template: ProjectTemplate
): Promise&amp;lt;void&amp;gt; {
  // Ensure target directory exists
  await fs.ensureDir(targetDir);

  // Create files from template
  for (const [filePath, content] of Object.entries(template.files)) {
    const fullPath &#x3D; path.join(targetDir, filePath);
    const dir &#x3D; path.dirname(fullPath);

    // Ensure directory exists
    await fs.ensureDir(dir);

    // Replace template variables
    const processedContent &#x3D; content
      .replace(/{{PROJECT_NAME}}/g, projectName)
      .replace(/{{DESCRIPTION}}/g, template.description);

    await fs.writeFile(fullPath, processedContent, &amp;#39;utf-8&amp;#39;);
  }

  // Create .arbiter/config.json config file
  const configContent &#x3D; {
    apiUrl: &amp;#39;http://localhost:8080&amp;#39;,
    format: &amp;#39;table&amp;#39;,
    color: true,
  };

  const arbiterDir &#x3D; path.join(targetDir, &amp;#39;.arbiter&amp;#39;);
  await fs.ensureDir(arbiterDir);
  await fs.writeFile(
    path.join(arbiterDir, &amp;#39;config.json&amp;#39;),
    JSON.stringify(configContent, null, 2),
    &amp;#39;utf-8&amp;#39;
  );
}

/**
 * List available templates
 */
export function listTemplates(): void {
  console.log(chalk.cyan(&amp;#39;Available templates:&amp;#39;));
  console.log();

  Object.entries(TEMPLATES).forEach(([key, template]) &#x3D;&amp;gt; {
    console.log(&#x60;${chalk.green(key.padEnd(12))} ${template.description}&#x60;);
  });
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-50">
                <div class="file-header">ğŸ“„ apps/api/src/handlers/examples/slack-notification.ts</div>
                <div class="file-content">
                    <pre>/**
 * Example: Slack notification handler
 * Sends formatted notifications to Slack channels on webhook events
 */

import type { HandlerModule, WebhookHandler } from &amp;#39;../types.js&amp;#39;;

const handleSlackNotification: WebhookHandler &#x3D; async (payload, context) &#x3D;&amp;gt; {
  const { logger, services, config } &#x3D; context;
  const { parsed } &#x3D; payload;

  logger.info(&amp;#39;Processing Slack notification handler&amp;#39;, {
    event: parsed.eventType,
    repository: parsed.repository.fullName,
  });

  const slackWebhook &#x3D; config.secrets.SLACK_WEBHOOK;
  if (!slackWebhook) {
    return {
      success: false,
      message: &amp;#39;SLACK_WEBHOOK secret not configured&amp;#39;,
      errors: [
        {
          code: &amp;#39;MISSING_CONFIGURATION&amp;#39;,
          message: &amp;#39;Slack webhook URL is required in handler configuration&amp;#39;,
        },
      ],
    };
  }

  try {
    let message &#x3D; &amp;#39;&amp;#39;;
    let blocks: unknown[] &#x3D; [];

    // Format message based on event type
    switch (parsed.eventType) {
      case &amp;#39;push&amp;#39;:
        if (parsed.commits &amp;amp;&amp;amp; parsed.commits.length &amp;gt; 0) {
          message &#x3D; &#x60;ğŸ“ ${parsed.commits.length} new commit(s) pushed to ${parsed.repository.fullName}&#x60;;

          blocks &#x3D; [
            {
              type: &amp;#39;header&amp;#39;,
              text: {
                type: &amp;#39;plain_text&amp;#39;,
                text: &amp;#39;ğŸ“ New commits pushed&amp;#39;,
              },
            },
            {
              type: &amp;#39;section&amp;#39;,
              fields: [
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Repository:* &amp;lt;${parsed.repository.url}|${parsed.repository.fullName}&amp;gt;&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Commits:* ${parsed.commits.length}&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Author:* ${parsed.author.name}&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Branch:* ${payload.ref?.replace(&amp;#39;refs/heads/&amp;#39;, &amp;#39;&amp;#39;) || &amp;#39;unknown&amp;#39;}&#x60;,
                },
              ],
            },
            {
              type: &amp;#39;section&amp;#39;,
              text: {
                type: &amp;#39;mrkdwn&amp;#39;,
                text: &amp;#39;*Recent commits:*&amp;#39;,
              },
            },
          ];

          // Add up to 5 recent commits
          const recentCommits &#x3D; parsed.commits.slice(0, 5);
          for (const commit of recentCommits) {
            blocks.push({
              type: &amp;#39;section&amp;#39;,
              text: {
                type: &amp;#39;mrkdwn&amp;#39;,
                text: &#x60;â€¢ &amp;lt;${commit.url}|${commit.sha.substring(0, 7)}&amp;gt; ${commit.message}\n  _by ${commit.author}_&#x60;,
              },
            });
          }

          if (parsed.commits.length &amp;gt; 5) {
            blocks.push({
              type: &amp;#39;context&amp;#39;,
              elements: [
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;_and ${parsed.commits.length - 5} more commits..._&#x60;,
                },
              ],
            });
          }
        }
        break;

      case &amp;#39;pull_request&amp;#39;:
        if (parsed.pullRequest &amp;amp;&amp;amp; parsed.action) {
          const pr &#x3D; parsed.pullRequest;
          const emoji &#x3D;
            parsed.action &#x3D;&#x3D;&#x3D; &amp;#39;opened&amp;#39;
              ? &amp;#39;ğŸ”€&amp;#39;
              : parsed.action &#x3D;&#x3D;&#x3D; &amp;#39;closed&amp;#39; &amp;amp;&amp;amp; pr.merged
                ? &amp;#39;âœ…&amp;#39;
                : parsed.action &#x3D;&#x3D;&#x3D; &amp;#39;closed&amp;#39;
                  ? &amp;#39;âŒ&amp;#39;
                  : &amp;#39;ğŸ“&amp;#39;;

          message &#x3D; &#x60;${emoji} Pull request ${parsed.action}: ${pr.title}&#x60;;

          blocks &#x3D; [
            {
              type: &amp;#39;header&amp;#39;,
              text: {
                type: &amp;#39;plain_text&amp;#39;,
                text: &#x60;${emoji} Pull request ${parsed.action}&#x60;,
              },
            },
            {
              type: &amp;#39;section&amp;#39;,
              fields: [
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Repository:* &amp;lt;${parsed.repository.url}|${parsed.repository.fullName}&amp;gt;&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*PR:* &amp;lt;${pr.url}|#${pr.id}&amp;gt;&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Author:* ${parsed.author.name}&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Branches:* ${pr.headBranch} â†’ ${pr.baseBranch}&#x60;,
                },
              ],
            },
            {
              type: &amp;#39;section&amp;#39;,
              text: {
                type: &amp;#39;mrkdwn&amp;#39;,
                text: &#x60;*${pr.title}*\n${pr.body ? pr.body.substring(0, 300) + (pr.body.length &amp;gt; 300 ? &amp;#39;...&amp;#39; : &amp;#39;&amp;#39;) : &amp;#39;_No description provided_&amp;#39;}&#x60;,
              },
            },
          ];

          if (parsed.action &#x3D;&#x3D;&#x3D; &amp;#39;closed&amp;#39; &amp;amp;&amp;amp; pr.merged) {
            blocks.push({
              type: &amp;#39;context&amp;#39;,
              elements: [
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &amp;#39;âœ… This pull request was merged successfully&amp;#39;,
                },
              ],
            });
          }
        }
        break;

      case &amp;#39;issues&amp;#39;:
        if (parsed.issue &amp;amp;&amp;amp; parsed.action) {
          const issue &#x3D; parsed.issue;
          const emoji &#x3D;
            parsed.action &#x3D;&#x3D;&#x3D; &amp;#39;opened&amp;#39; ? &amp;#39;ğŸ›&amp;#39; : parsed.action &#x3D;&#x3D;&#x3D; &amp;#39;closed&amp;#39; ? &amp;#39;âœ…&amp;#39; : &amp;#39;ğŸ“&amp;#39;;

          message &#x3D; &#x60;${emoji} Issue ${parsed.action}: ${issue.title}&#x60;;

          blocks &#x3D; [
            {
              type: &amp;#39;header&amp;#39;,
              text: {
                type: &amp;#39;plain_text&amp;#39;,
                text: &#x60;${emoji} Issue ${parsed.action}&#x60;,
              },
            },
            {
              type: &amp;#39;section&amp;#39;,
              fields: [
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Repository:* &amp;lt;${parsed.repository.url}|${parsed.repository.fullName}&amp;gt;&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Issue:* &amp;lt;${issue.url}|#${issue.id}&amp;gt;&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Author:* ${parsed.author.name}&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Labels:* ${issue.labels.length &amp;gt; 0 ? issue.labels.join(&amp;#39;, &amp;#39;) : &amp;#39;None&amp;#39;}&#x60;,
                },
              ],
            },
            {
              type: &amp;#39;section&amp;#39;,
              text: {
                type: &amp;#39;mrkdwn&amp;#39;,
                text: &#x60;*${issue.title}*\n${issue.body ? issue.body.substring(0, 300) + (issue.body.length &amp;gt; 300 ? &amp;#39;...&amp;#39; : &amp;#39;&amp;#39;) : &amp;#39;_No description provided_&amp;#39;}&#x60;,
              },
            },
          ];
        }
        break;

      default:
        message &#x3D; &#x60;ğŸ”” ${parsed.eventType} event in ${parsed.repository.fullName}&#x60;;
        blocks &#x3D; [
          {
            type: &amp;#39;section&amp;#39;,
            text: {
              type: &amp;#39;mrkdwn&amp;#39;,
              text: &#x60;ğŸ”” Received *${parsed.eventType}* event from &amp;lt;${parsed.repository.url}|${parsed.repository.fullName}&amp;gt;&#x60;,
            },
          },
        ];
    }

    // Send Slack notification
    await services.notifications.sendSlack(slackWebhook, {
      text: message,
      blocks,
      username: &amp;#39;Arbiter Webhook&amp;#39;,
      iconEmoji: &amp;#39;:robot_face:&amp;#39;,
    });

    logger.info(&amp;#39;Slack notification sent successfully&amp;#39;, {
      event: parsed.eventType,
      repository: parsed.repository.fullName,
    });

    return {
      success: true,
      message: &amp;#39;Slack notification sent successfully&amp;#39;,
      actions: [&amp;#39;Sent Slack notification&amp;#39;],
      data: {
        slackMessage: message,
        blocksCount: blocks.length,
      },
    };
  } catch (error) {
    logger.error(&amp;#39;Slack notification failed&amp;#39;, error as Error);

    return {
      success: false,
      message: &amp;#39;Failed to send Slack notification&amp;#39;,
      errors: [
        {
          code: &amp;#39;NOTIFICATION_FAILED&amp;#39;,
          message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
          stack: error instanceof Error ? error.stack : undefined,
        },
      ],
    };
  }
};

const handlerModule: HandlerModule &#x3D; {
  handler: handleSlackNotification,
  config: {
    enabled: true,
    timeout: 15000,
    retries: 1,
    environment: {},
    secrets: {},
  },
  metadata: {
    name: &amp;#39;Slack Notification Handler&amp;#39;,
    description: &amp;#39;Sends formatted notifications to Slack channels for webhook events&amp;#39;,
    version: &amp;#39;1.0.0&amp;#39;,
    author: &amp;#39;Arbiter Team&amp;#39;,
    supportedEvents: [
      &amp;#39;push&amp;#39;,
      &amp;#39;pull_request&amp;#39;,
      &amp;#39;merge_request&amp;#39;,
      &amp;#39;issues&amp;#39;,
      &amp;#39;Push Hook&amp;#39;,
      &amp;#39;Merge Request Hook&amp;#39;,
    ],
    requiredPermissions: [&amp;#39;notifications:send&amp;#39;],
  },
};

export default handlerModule;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-51">
                <div class="file-header">ğŸ“„ apps/api/src/webhooks.ts</div>
                <div class="file-content">
                    <pre>/**
 * Webhook service for handling GitLab and GitHub webhooks
 */
import { createHash, createHmac, timingSafeEqual } from &amp;#39;node:crypto&amp;#39;;
import type { SpecWorkbenchDB } from &amp;#39;./db.ts&amp;#39;;
import type { EventService } from &amp;#39;./events.ts&amp;#39;;
import { CustomHandlerManager } from &amp;#39;./handlers/manager.js&amp;#39;;
import type {
  EventType,
  ServerConfig,
  WebhookConfig,
  WebhookEventType,
  WebhookPayload,
  WebhookRequest,
  WebhookResponse,
} from &amp;#39;./types.ts&amp;#39;;
import { generateId, getCurrentTimestamp, logger } from &amp;#39;./utils.ts&amp;#39;;

export class WebhookService {
  private handlerManager: CustomHandlerManager;

  constructor(
    private config: ServerConfig,
    private events: EventService,
    private db: SpecWorkbenchDB
  ) {
    this.handlerManager &#x3D; new CustomHandlerManager(this.config, this.events, this.db, logger);
  }

  /**
   * Process incoming webhook from GitLab or GitHub
   */
  async processWebhook(
    provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;,
    event: string,
    signature: string | undefined,
    payload: WebhookPayload,
    headers: Record&amp;lt;string, string&amp;gt;
  ): Promise&amp;lt;WebhookResponse&amp;gt; {
    try {
      logger.info(&amp;#39;Processing webhook&amp;#39;, {
        provider,
        event,
        repository: payload.repository?.full_name,
        ref: payload.ref,
      });

      // Verify webhook signature
      const verification &#x3D; await this.verifySignature(provider, signature, JSON.stringify(payload));
      if (!verification.valid) {
        logger.warn(&amp;#39;Webhook signature verification failed&amp;#39;, {
          provider,
          repository: payload.repository?.full_name,
        });
        return {
          success: false,
          message: &amp;#39;Invalid signature&amp;#39;,
        };
      }

      // Find matching project configuration
      const projectId &#x3D; await this.findProjectForRepository(payload.repository.full_name);
      if (!projectId) {
        logger.info(&amp;#39;No project found for repository&amp;#39;, {
          repository: payload.repository.full_name,
        });
        return {
          success: false,
          message: &amp;#39;No project configured for this repository&amp;#39;,
        };
      }

      // Process the webhook event
      const webhookRequest: WebhookRequest &#x3D; {
        provider,
        event,
        signature,
        payload,
        timestamp: getCurrentTimestamp(),
      };

      // Process with both built-in and custom handlers
      const builtInActions &#x3D; await this.handleWebhookEvent(projectId, webhookRequest);
      const customActions &#x3D; await this.handlerManager.processWebhookWithCustomHandlers(
        projectId,
        webhookRequest
      );

      const actions &#x3D; [...builtInActions, ...customActions];

      // Broadcast webhook received event
      await this.events.broadcastToProject(projectId, {
        project_id: projectId,
        event_type: &amp;#39;webhook_received&amp;#39;,
        data: {
          provider,
          event,
          repository: payload.repository.full_name,
          ref: payload.ref,
          actions_taken: actions,
        },
      });

      return {
        success: true,
        message: &amp;#39;Webhook processed successfully&amp;#39;,
        actions_taken: actions,
        project_id: projectId,
      };
    } catch (error) {
      logger.error(&amp;#39;Webhook processing error&amp;#39;, error instanceof Error ? error : undefined, {
        provider,
        event,
      });
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
      };
    }
  }

  /**
   * Verify webhook signature based on provider
   */
  private async verifySignature(
    provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;,
    signature: string | undefined,
    payload: string
  ): Promise&amp;lt;{ valid: boolean; reason?: string }&amp;gt; {
    if (!this.config.webhooks?.enabled) {
      return { valid: true }; // Allow if webhooks not configured
    }

    if (!signature) {
      return { valid: false, reason: &amp;#39;No signature provided&amp;#39; };
    }

    try {
      if (provider &#x3D;&#x3D;&#x3D; &amp;#39;github&amp;#39;) {
        return this.verifyGitHubSignature(signature, payload);
      }
      if (provider &#x3D;&#x3D;&#x3D; &amp;#39;gitlab&amp;#39;) {
        return this.verifyGitLabSignature(signature, payload);
      }

      return { valid: false, reason: &amp;#39;Unknown provider&amp;#39; };
    } catch (error) {
      logger.error(&amp;#39;Signature verification error&amp;#39;, error instanceof Error ? error : undefined);
      return { valid: false, reason: &amp;#39;Verification failed&amp;#39; };
    }
  }

  /**
   * Verify GitHub webhook signature (HMAC SHA-256)
   */
  private verifyGitHubSignature(
    signature: string,
    payload: string
  ): { valid: boolean; reason?: string } {
    const secret &#x3D; this.config.webhooks?.github_secret || this.config.webhooks?.secret;

    if (!secret) {
      return { valid: false, reason: &amp;#39;No GitHub secret configured&amp;#39; };
    }

    // GitHub signature format: sha256&#x3D;&amp;lt;hex&amp;gt;
    if (!signature.startsWith(&amp;#39;sha256&#x3D;&amp;#39;)) {
      return { valid: false, reason: &amp;#39;Invalid signature format&amp;#39; };
    }

    const expectedSignature &#x3D; createHmac(&amp;#39;sha256&amp;#39;, secret).update(payload, &amp;#39;utf8&amp;#39;).digest(&amp;#39;hex&amp;#39;);

    const providedSignature &#x3D; signature.replace(&amp;#39;sha256&#x3D;&amp;#39;, &amp;#39;&amp;#39;);

    const valid &#x3D; timingSafeEqual(
      Buffer.from(expectedSignature, &amp;#39;hex&amp;#39;),
      Buffer.from(providedSignature, &amp;#39;hex&amp;#39;)
    );

    return { valid };
  }

  /**
   * Verify GitLab webhook signature (HMAC SHA-256)
   */
  private verifyGitLabSignature(
    signature: string,
    payload: string
  ): { valid: boolean; reason?: string } {
    const secret &#x3D; this.config.webhooks?.gitlab_secret || this.config.webhooks?.secret;

    if (!secret) {
      return { valid: false, reason: &amp;#39;No GitLab secret configured&amp;#39; };
    }

    const expectedSignature &#x3D; createHmac(&amp;#39;sha256&amp;#39;, secret).update(payload, &amp;#39;utf8&amp;#39;).digest(&amp;#39;base64&amp;#39;);

    const valid &#x3D; timingSafeEqual(Buffer.from(expectedSignature), Buffer.from(signature));

    return { valid };
  }

  /**
   * Find project ID for a given repository
   */
  private async findProjectForRepository(repositoryFullName: string): Promise&amp;lt;string | null&amp;gt; {
    try {
      // For now, we&amp;#39;ll use a simple naming convention
      // In a real implementation, this would query the database for webhook configs
      const projects &#x3D; await this.db.listProjects();

      // Look for project with matching name or check if repository is in allowed list
      const allowedRepos &#x3D; this.config.webhooks?.allowed_repos || [];

      if (allowedRepos.length &amp;gt; 0 &amp;amp;&amp;amp; !allowedRepos.includes(repositoryFullName)) {
        return null;
      }

      // Simple heuristic: find project by repository name
      const repoName &#x3D; repositoryFullName.split(&amp;#39;/&amp;#39;).pop()?.toLowerCase() || &amp;#39;&amp;#39;;
      const matchingProject &#x3D; projects.find(
        p &#x3D;&amp;gt; p.name.toLowerCase().includes(repoName) || repoName.includes(p.name.toLowerCase())
      );

      return matchingProject?.id || projects[0]?.id || null;
    } catch (error) {
      logger.error(
        &amp;#39;Error finding project for repository&amp;#39;,
        error instanceof Error ? error : undefined
      );
      return null;
    }
  }

  /**
   * Handle specific webhook events
   */
  private async handleWebhookEvent(projectId: string, request: WebhookRequest): Promise&amp;lt;string[]&amp;gt; {
    const actions: string[] &#x3D; [];

    try {
      if (request.provider &#x3D;&#x3D;&#x3D; &amp;#39;github&amp;#39;) {
        actions.push(...(await this.handleGitHubEvent(projectId, request)));
      } else if (request.provider &#x3D;&#x3D;&#x3D; &amp;#39;gitlab&amp;#39;) {
        actions.push(...(await this.handleGitLabEvent(projectId, request)));
      }
    } catch (error) {
      logger.error(&amp;#39;Error handling webhook event&amp;#39;, error instanceof Error ? error : undefined);
      actions.push(&amp;#39;Error processing event&amp;#39;);
    }

    return actions;
  }

  /**
   * Handle GitHub webhook events
   */
  private async handleGitHubEvent(projectId: string, request: WebhookRequest): Promise&amp;lt;string[]&amp;gt; {
    const actions: string[] &#x3D; [];
    const { event, payload } &#x3D; request;

    switch (event) {
      case &amp;#39;push&amp;#39;:
        if (payload.ref &amp;amp;&amp;amp; payload.commits) {
          actions.push(&#x60;Received ${payload.commits.length} commits on ${payload.ref}&#x60;);

          if (this.config.webhooks?.sync_on_push) {
            // TODO: Implement sync logic
            actions.push(&amp;#39;Triggered spec sync&amp;#39;);
          }

          // Broadcast git push event
          await this.events.broadcastToProject(projectId, {
            project_id: projectId,
            event_type: &amp;#39;git_push_processed&amp;#39;,
            data: {
              provider: &amp;#39;github&amp;#39;,
              ref: payload.ref,
              commits: payload.commits.length,
              repository: payload.repository.full_name,
            },
          });
        }
        break;

      case &amp;#39;pull_request&amp;#39;:
        if (payload.pull_request &amp;amp;&amp;amp; payload.action) {
          actions.push(&#x60;Pull request ${payload.action}: #${payload.pull_request.id}&#x60;);

          if (payload.action &#x3D;&#x3D;&#x3D; &amp;#39;closed&amp;#39; &amp;amp;&amp;amp; this.config.webhooks?.validate_on_merge) {
            // TODO: Implement validation logic
            actions.push(&amp;#39;Triggered spec validation&amp;#39;);
          }

          await this.events.broadcastToProject(projectId, {
            project_id: projectId,
            event_type: &amp;#39;git_merge_processed&amp;#39;,
            data: {
              provider: &amp;#39;github&amp;#39;,
              action: payload.action,
              pr_id: payload.pull_request.id,
              base_branch: payload.pull_request.base.ref,
              head_branch: payload.pull_request.head.ref,
            },
          });
        }
        break;

      default:
        actions.push(&#x60;Unhandled GitHub event: ${event}&#x60;);
    }

    return actions;
  }

  /**
   * Handle GitLab webhook events
   */
  private async handleGitLabEvent(projectId: string, request: WebhookRequest): Promise&amp;lt;string[]&amp;gt; {
    const actions: string[] &#x3D; [];
    const { event, payload } &#x3D; request;

    switch (event) {
      case &amp;#39;Push Hook&amp;#39;:
        if (payload.ref &amp;amp;&amp;amp; payload.commits) {
          actions.push(&#x60;Received ${payload.commits.length} commits on ${payload.ref}&#x60;);

          if (this.config.webhooks?.sync_on_push) {
            // TODO: Implement sync logic
            actions.push(&amp;#39;Triggered spec sync&amp;#39;);
          }

          await this.events.broadcastToProject(projectId, {
            project_id: projectId,
            event_type: &amp;#39;git_push_processed&amp;#39;,
            data: {
              provider: &amp;#39;gitlab&amp;#39;,
              ref: payload.ref,
              commits: payload.commits.length,
              repository: payload.repository.full_name,
            },
          });
        }
        break;

      case &amp;#39;Merge Request Hook&amp;#39;:
        if (payload.merge_request &amp;amp;&amp;amp; payload.action) {
          actions.push(&#x60;Merge request ${payload.action}: !${payload.merge_request.id}&#x60;);

          if (payload.action &#x3D;&#x3D;&#x3D; &amp;#39;merge&amp;#39; &amp;amp;&amp;amp; this.config.webhooks?.validate_on_merge) {
            // TODO: Implement validation logic
            actions.push(&amp;#39;Triggered spec validation&amp;#39;);
          }

          await this.events.broadcastToProject(projectId, {
            project_id: projectId,
            event_type: &amp;#39;git_merge_processed&amp;#39;,
            data: {
              provider: &amp;#39;gitlab&amp;#39;,
              action: payload.action,
              mr_id: payload.merge_request.id,
              target_branch: payload.merge_request.target_branch,
              source_branch: payload.merge_request.source_branch,
            },
          });
        }
        break;

      default:
        actions.push(&#x60;Unhandled GitLab event: ${event}&#x60;);
    }

    return actions;
  }

  /**
   * Get webhook configuration for a project
   */
  async getWebhookConfig(projectId: string): Promise&amp;lt;WebhookConfig | null&amp;gt; {
    // TODO: Implement database storage for webhook configs
    // For now, return a basic config based on server settings
    if (!this.config.webhooks?.enabled) {
      return null;
    }

    return {
      id: generateId(),
      project_id: projectId,
      provider: &amp;#39;github&amp;#39;, // Default
      repository_url: &amp;#39;&amp;#39;,
      enabled: true,
      events: [&amp;#39;push&amp;#39;, &amp;#39;pull_request&amp;#39;],
      created_at: getCurrentTimestamp(),
      updated_at: getCurrentTimestamp(),
    };
  }

  /**
   * Create or update webhook configuration
   */
  async updateWebhookConfig(
    config: Partial&amp;lt;WebhookConfig&amp;gt; &amp;amp; { project_id: string }
  ): Promise&amp;lt;WebhookConfig&amp;gt; {
    // TODO: Implement database storage
    const webhookConfig: WebhookConfig &#x3D; {
      id: config.id || generateId(),
      project_id: config.project_id,
      provider: config.provider || &amp;#39;github&amp;#39;,
      repository_url: config.repository_url || &amp;#39;&amp;#39;,
      secret_hash: config.secret_hash,
      enabled: config.enabled ?? true,
      events: config.events || [&amp;#39;push&amp;#39;],
      created_at: config.created_at || getCurrentTimestamp(),
      updated_at: getCurrentTimestamp(),
    };

    logger.info(&amp;#39;Updated webhook config&amp;#39;, {
      projectId: config.project_id,
      provider: webhookConfig.provider,
    });

    return webhookConfig;
  }

  /**
   * Delete webhook configuration
   */
  async deleteWebhookConfig(projectId: string): Promise&amp;lt;boolean&amp;gt; {
    // TODO: Implement database deletion
    logger.info(&amp;#39;Deleted webhook config&amp;#39;, { projectId });
    return true;
  }

  /**
   * Get custom handler manager for API endpoints
   */
  getHandlerManager(): CustomHandlerManager {
    return this.handlerManager;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-52">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/progress.ts</div>
                <div class="file-content">
                    <pre>import chalk from &amp;#39;chalk&amp;#39;;
import ora, { type Ora } from &amp;#39;ora&amp;#39;;
import type { ProgressBarOptions, ProgressOptions, StepProgressOptions } from &amp;#39;../types.js&amp;#39;;

/**
 * Enhanced progress indicator utility class with step-by-step tracking
 */
export class Progress {
  private spinner: Ora;
  private startTime: number;
  private steps: Array&amp;lt;{
    name: string;
    status: &amp;#39;pending&amp;#39; | &amp;#39;running&amp;#39; | &amp;#39;completed&amp;#39; | &amp;#39;failed&amp;#39;;
    startTime?: number;
    endTime?: number;
  }&amp;gt;;
  private currentStep &#x3D; -1;
  private totalSteps &#x3D; 0;

  constructor(options: ProgressOptions) {
    this.spinner &#x3D; ora({
      text: options.text,
      color: options.color || &amp;#39;blue&amp;#39;,
      spinner: options.spinner || &amp;#39;dots&amp;#39;,
    });
    this.startTime &#x3D; Date.now();
    this.steps &#x3D; [];
  }

  /**
   * Initialize steps for step-by-step progress tracking
   */
  addSteps(stepNames: string[]): void {
    this.steps &#x3D; stepNames.map(name &#x3D;&amp;gt; ({ name, status: &amp;#39;pending&amp;#39; }));
    this.totalSteps &#x3D; this.steps.length;
  }

  /**
   * Start the progress indicator
   */
  start(): void {
    this.spinner.start();
  }

  /**
   * Start the next step in the sequence
   */
  nextStep(stepName?: string): void {
    // Complete previous step if any
    if (this.currentStep &amp;gt;&#x3D; 0 &amp;amp;&amp;amp; this.currentStep &amp;lt; this.steps.length) {
      this.steps[this.currentStep].status &#x3D; &amp;#39;completed&amp;#39;;
      this.steps[this.currentStep].endTime &#x3D; Date.now();
    }

    // Move to next step
    this.currentStep++;
    if (this.currentStep &amp;lt; this.steps.length) {
      this.steps[this.currentStep].status &#x3D; &amp;#39;running&amp;#39;;
      this.steps[this.currentStep].startTime &#x3D; Date.now();

      const currentStepName &#x3D; stepName || this.steps[this.currentStep].name;
      const progress &#x3D; &#x60;(${this.currentStep + 1}/${this.totalSteps})&#x60;;
      this.update(&#x60;${currentStepName} ${chalk.dim(progress)}&#x60;);
    }
  }

  /**
   * Mark current step as failed
   */
  failCurrentStep(error?: string): void {
    if (this.currentStep &amp;gt;&#x3D; 0 &amp;amp;&amp;amp; this.currentStep &amp;lt; this.steps.length) {
      this.steps[this.currentStep].status &#x3D; &amp;#39;failed&amp;#39;;
      this.steps[this.currentStep].endTime &#x3D; Date.now();

      const stepName &#x3D; this.steps[this.currentStep].name;
      const errorMsg &#x3D; error ? &#x60;: ${error}&#x60; : &amp;#39;&amp;#39;;
      this.fail(&#x60;${stepName} failed${errorMsg}&#x60;);
    }
  }

  /**
   * Update the progress text
   */
  update(text: string): void {
    this.spinner.text &#x3D; text;
  }

  /**
   * Update with estimated time remaining
   */
  updateWithEstimate(text: string): void {
    const _elapsed &#x3D; this.getElapsed();
    const estimate &#x3D; this.getEstimatedTimeRemaining();
    const estimateText &#x3D;
      estimate &amp;gt; 0 ? chalk.dim(&#x60; ~${Math.round(estimate / 1000)}s remaining&#x60;) : &amp;#39;&amp;#39;;
    this.spinner.text &#x3D; &#x60;${text}${estimateText}&#x60;;
  }

  /**
   * Mark as successful and stop
   */
  succeed(text?: string): void {
    // Complete current step if any
    if (this.currentStep &amp;gt;&#x3D; 0 &amp;amp;&amp;amp; this.currentStep &amp;lt; this.steps.length) {
      this.steps[this.currentStep].status &#x3D; &amp;#39;completed&amp;#39;;
      this.steps[this.currentStep].endTime &#x3D; Date.now();
    }

    const elapsed &#x3D; Date.now() - this.startTime;
    const message &#x3D; text || this.spinner.text;
    const stepsSummary &#x3D; this.totalSteps &amp;gt; 0 ? this.getStepsSummary() : &amp;#39;&amp;#39;;
    this.spinner.succeed(&#x60;${message} ${chalk.dim(&#x60;(${elapsed}ms)&#x60;)}${stepsSummary}&#x60;);
  }

  /**
   * Mark as failed and stop
   */
  fail(text?: string): void {
    const elapsed &#x3D; Date.now() - this.startTime;
    const message &#x3D; text || this.spinner.text;
    const stepsSummary &#x3D; this.totalSteps &amp;gt; 0 ? this.getStepsSummary() : &amp;#39;&amp;#39;;
    this.spinner.fail(&#x60;${message} ${chalk.dim(&#x60;(${elapsed}ms)&#x60;)}${stepsSummary}&#x60;);
  }

  /**
   * Mark as warning and stop
   */
  warn(text?: string): void {
    const elapsed &#x3D; Date.now() - this.startTime;
    const message &#x3D; text || this.spinner.text;
    const stepsSummary &#x3D; this.totalSteps &amp;gt; 0 ? this.getStepsSummary() : &amp;#39;&amp;#39;;
    this.spinner.warn(&#x60;${message} ${chalk.dim(&#x60;(${elapsed}ms)&#x60;)}${stepsSummary}&#x60;);
  }

  /**
   * Stop without status
   */
  stop(): void {
    this.spinner.stop();
  }

  /**
   * Get elapsed time
   */
  getElapsed(): number {
    return Date.now() - this.startTime;
  }

  /**
   * Get estimated time remaining based on completed steps
   */
  getEstimatedTimeRemaining(): number {
    if (this.totalSteps &#x3D;&#x3D;&#x3D; 0 || this.currentStep &amp;lt; 0) return 0;

    const completedSteps &#x3D; this.steps.filter(step &#x3D;&amp;gt; step.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39;);
    if (completedSteps.length &#x3D;&#x3D;&#x3D; 0) return 0;

    const avgTimePerStep &#x3D;
      completedSteps.reduce((total, step) &#x3D;&amp;gt; {
        return total + ((step.endTime || Date.now()) - (step.startTime || this.startTime));
      }, 0) / completedSteps.length;

    const remainingSteps &#x3D; this.totalSteps - this.currentStep - 1;
    return remainingSteps * avgTimePerStep;
  }

  /**
   * Get a summary of completed steps
   */
  getStepsSummary(): string {
    if (this.totalSteps &#x3D;&#x3D;&#x3D; 0) return &amp;#39;&amp;#39;;

    const completed &#x3D; this.steps.filter(s &#x3D;&amp;gt; s.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39;).length;
    const failed &#x3D; this.steps.filter(s &#x3D;&amp;gt; s.status &#x3D;&#x3D;&#x3D; &amp;#39;failed&amp;#39;).length;

    if (failed &amp;gt; 0) {
      return chalk.dim(&#x60; [${completed}/${this.totalSteps} completed, ${failed} failed]&#x60;);
    }
    return chalk.dim(&#x60; [${completed}/${this.totalSteps} completed]&#x60;);
  }

  /**
   * Get detailed steps report for debugging
   */
  getStepsReport(): string {
    if (this.totalSteps &#x3D;&#x3D;&#x3D; 0) return &amp;#39;&amp;#39;;

    return &#x60;\n${this.steps
      .map((step, _index) &#x3D;&amp;gt; {
        const icon &#x3D;
          step.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39;
            ? &amp;#39;âœ“&amp;#39;
            : step.status &#x3D;&#x3D;&#x3D; &amp;#39;failed&amp;#39;
              ? &amp;#39;âœ—&amp;#39;
              : step.status &#x3D;&#x3D;&#x3D; &amp;#39;running&amp;#39;
                ? &amp;#39;âš¬&amp;#39;
                : &amp;#39;â—‹&amp;#39;;
        const color &#x3D;
          step.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39;
            ? chalk.green
            : step.status &#x3D;&#x3D;&#x3D; &amp;#39;failed&amp;#39;
              ? chalk.red
              : step.status &#x3D;&#x3D;&#x3D; &amp;#39;running&amp;#39;
                ? chalk.yellow
                : chalk.dim;

        const duration &#x3D;
          step.startTime &amp;amp;&amp;amp; step.endTime
            ? &#x60; (${step.endTime - step.startTime}ms)&#x60;
            : step.startTime &amp;amp;&amp;amp; !step.endTime
              ? &#x60; (${Date.now() - step.startTime}ms ongoing)&#x60;
              : &amp;#39;&amp;#39;;

        return &#x60;  ${color(icon)} ${step.name}${chalk.dim(duration)}&#x60;;
      })
      .join(&amp;#39;\n&amp;#39;)}&#x60;;
  }
}

/**
 * Progress bar for operations with known progress (0-100%)
 */
export class ProgressBar {
  private current &#x3D; 0;
  private total &#x3D; 100;
  private startTime: number;
  private lastUpdate: number;
  private title: string;

  constructor(options: ProgressBarOptions) {
    this.title &#x3D; options.title;
    this.total &#x3D; options.total || 100;
    this.startTime &#x3D; Date.now();
    this.lastUpdate &#x3D; this.startTime;
  }

  /**
   * Update progress value
   */
  update(current: number, message?: string): void {
    this.current &#x3D; Math.min(current, this.total);
    const now &#x3D; Date.now();

    // Only update display every 100ms to avoid flickering
    if (now - this.lastUpdate &amp;gt; 100 || this.current &#x3D;&#x3D;&#x3D; this.total) {
      this.render(message);
      this.lastUpdate &#x3D; now;
    }
  }

  /**
   * Increment progress by amount
   */
  increment(amount &#x3D; 1, message?: string): void {
    this.update(this.current + amount, message);
  }

  /**
   * Mark as complete
   */
  complete(message?: string): void {
    this.update(this.total, message);
    console.log(); // New line after progress bar
  }

  /**
   * Render the progress bar
   */
  private render(message?: string): void {
    if (!process.stdout.isTTY) {
      // Simple text progress for non-TTY environments
      const percent &#x3D; Math.round((this.current / this.total) * 100);
      console.log(&#x60;${this.title}: ${percent}% ${message || &amp;#39;&amp;#39;}&#x60;);
      return;
    }

    const percent &#x3D; (this.current / this.total) * 100;
    const width &#x3D; Math.min(40, process.stdout.columns - 30); // Leave space for text
    const filled &#x3D; Math.round((width * percent) / 100);
    const empty &#x3D; width - filled;

    const bar &#x3D; &amp;#39;â–ˆ&amp;#39;.repeat(filled) + &amp;#39;â–‘&amp;#39;.repeat(empty);
    const percentText &#x3D; &#x60;${Math.round(percent).toString().padStart(3)}%&#x60;;
    const progressText &#x3D; message ? &#x60; ${message}&#x60; : &amp;#39;&amp;#39;;
    const elapsed &#x3D; Math.round((Date.now() - this.startTime) / 1000);
    const timeText &#x3D; &#x60; (${elapsed}s)&#x60;;

    // Clear line and render progress
    process.stdout.write(
      &#x60;\r${this.title}: [${chalk.cyan(bar)}] ${percentText}${progressText}${chalk.dim(timeText)}&#x60;
    );
  }
}

/**
 * Create and manage multiple progress indicators
 */
export class MultiProgress {
  private progresses: Map&amp;lt;string, Progress&amp;gt; &#x3D; new Map();

  /**
   * Add a new progress indicator
   */
  add(id: string, options: ProgressOptions): Progress {
    const progress &#x3D; new Progress(options);
    this.progresses.set(id, progress);
    return progress;
  }

  /**
   * Get a progress indicator by ID
   */
  get(id: string): Progress | undefined {
    return this.progresses.get(id);
  }

  /**
   * Update all progress indicators
   */
  updateAll(text: string): void {
    this.progresses.forEach(progress &#x3D;&amp;gt; {
      progress.update(text);
    });
  }

  /**
   * Stop all progress indicators
   */
  stopAll(): void {
    this.progresses.forEach(progress &#x3D;&amp;gt; {
      progress.stop();
    });
    this.progresses.clear();
  }

  /**
   * Mark all as successful
   */
  succeedAll(text?: string): void {
    this.progresses.forEach(progress &#x3D;&amp;gt; {
      progress.succeed(text);
    });
    this.progresses.clear();
  }

  /**
   * Mark all as failed
   */
  failAll(text?: string): void {
    this.progresses.forEach(progress &#x3D;&amp;gt; {
      progress.fail(text);
    });
    this.progresses.clear();
  }
}

/**
 * Simple progress logger for non-interactive environments
 */
export class SimpleProgress {
  private startTime: number;
  private lastUpdate: number;
  private updateInterval: number;

  constructor(updateInterval &#x3D; 1000) {
    this.startTime &#x3D; Date.now();
    this.lastUpdate &#x3D; this.startTime;
    this.updateInterval &#x3D; updateInterval;
  }

  /**
   * Log progress message with timestamp
   */
  log(message: string): void {
    const now &#x3D; Date.now();
    const elapsed &#x3D; now - this.startTime;
    const since &#x3D; now - this.lastUpdate;

    if (since &amp;gt;&#x3D; this.updateInterval) {
      console.log(&#x60;[${new Date().toISOString()}] ${message} (+${elapsed}ms)&#x60;);
      this.lastUpdate &#x3D; now;
    }
  }

  /**
   * Log success message
   */
  success(message: string): void {
    const elapsed &#x3D; Date.now() - this.startTime;
    console.log(chalk.green(&#x60;âœ“ ${message} (${elapsed}ms)&#x60;));
  }

  /**
   * Log error message
   */
  error(message: string): void {
    const elapsed &#x3D; Date.now() - this.startTime;
    console.log(chalk.red(&#x60;âœ— ${message} (${elapsed}ms)&#x60;));
  }

  /**
   * Log warning message
   */
  warn(message: string): void {
    const elapsed &#x3D; Date.now() - this.startTime;
    console.log(chalk.yellow(&#x60;! ${message} (${elapsed}ms)&#x60;));
  }
}

/**
 * Create appropriate progress indicator based on environment and type
 */
export function createProgress(options: ProgressOptions): Progress | SimpleProgress {
  // Use simple progress in CI or non-TTY environments
  if (!process.stdout.isTTY || process.env.CI) {
    return new SimpleProgress();
  }

  return new Progress(options);
}

/**
 * Create step-based progress indicator
 */
export function createStepProgress(options: StepProgressOptions): Progress | SimpleProgress {
  const progress &#x3D; createProgress({ text: options.title });

  if (progress instanceof Progress) {
    progress.addSteps(options.steps);
  }

  return progress;
}

/**
 * Create progress bar for known-length operations
 */
export function createProgressBar(options: ProgressBarOptions): ProgressBar {
  return new ProgressBar(options);
}

/**
 * Measure and report performance of an operation
 */
export async function withProgress&amp;lt;T&amp;gt;(
  options: ProgressOptions,
  operation: () &#x3D;&amp;gt; Promise&amp;lt;T&amp;gt;
): Promise&amp;lt;T&amp;gt; {
  const progress &#x3D; createProgress(options);

  if (progress instanceof Progress) {
    progress.start();
  } else {
    progress.log(options.text);
  }

  try {
    const result &#x3D; await operation();

    if (progress instanceof Progress) {
      progress.succeed();
    } else {
      progress.success(options.text);
    }

    return result;
  } catch (error) {
    const message &#x3D; error instanceof Error ? error.message : String(error);

    if (progress instanceof Progress) {
      progress.fail(message);
    } else {
      progress.error(message);
    }

    throw error;
  }
}

/**
 * Execute multi-step operation with progress tracking
 */
export async function withStepProgress&amp;lt;T&amp;gt;(
  options: StepProgressOptions,
  operation: (progress: Progress | SimpleProgress) &#x3D;&amp;gt; Promise&amp;lt;T&amp;gt;
): Promise&amp;lt;T&amp;gt; {
  const progress &#x3D; createStepProgress(options);

  if (progress instanceof Progress) {
    progress.start();
  } else {
    progress.log(options.title);
  }

  try {
    const result &#x3D; await operation(progress);

    if (progress instanceof Progress) {
      progress.succeed(&#x60;${options.title} completed&#x60;);
    } else {
      progress.success(options.title);
    }

    return result;
  } catch (error) {
    const message &#x3D; error instanceof Error ? error.message : String(error);

    if (progress instanceof Progress) {
      progress.fail(message);
    } else {
      progress.error(message);
    }

    throw error;
  }
}

/**
 * Execute operation with progress bar (for known-length operations)
 */
export async function withProgressBar&amp;lt;T&amp;gt;(
  options: ProgressBarOptions,
  operation: (progressBar: ProgressBar) &#x3D;&amp;gt; Promise&amp;lt;T&amp;gt;
): Promise&amp;lt;T&amp;gt; {
  const progressBar &#x3D; createProgressBar(options);

  try {
    const result &#x3D; await operation(progressBar);
    progressBar.complete(options.completeMessage || &#x60;${options.title} completed&#x60;);
    return result;
  } catch (error) {
    progressBar.complete(chalk.red(&#x60;${options.title} failed&#x60;));
    throw error;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-53">
                <div class="file-header">ğŸ“„ packages/cli/src/cue/index.ts</div>
                <div class="file-content">
                    <pre>/**
 * CUE Manipulation Abstraction Layer
 *
 * This module provides a proper AST-based approach to CUE file manipulation,
 * replacing fragile string concatenation with validated CUE tool integration.
 *
 * Key Features:
 * - Parse CUE files using the CUE tool
 * - Manipulate CUE structures through JSON intermediate representation
 * - Format and validate using official CUE tooling
 * - Type-safe operations with proper error handling
 */

import * as os from &amp;#39;node:os&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import { CueRunner } from &amp;#39;@arbiter/cue-runner&amp;#39;;

/**
 * Platform-specific service types for popular cloud providers
 */
export type PlatformServiceType &#x3D;
  // Generic types
  | &amp;#39;bespoke&amp;#39;
  | &amp;#39;prebuilt&amp;#39;
  // Cloudflare platform
  | &amp;#39;cloudflare_worker&amp;#39;
  | &amp;#39;cloudflare_d1&amp;#39;
  | &amp;#39;cloudflare_kv&amp;#39;
  | &amp;#39;cloudflare_r2&amp;#39;
  | &amp;#39;cloudflare_durable_object&amp;#39;
  // Vercel platform
  | &amp;#39;vercel_function&amp;#39;
  | &amp;#39;vercel_edge_function&amp;#39;
  | &amp;#39;vercel_kv&amp;#39;
  | &amp;#39;vercel_postgres&amp;#39;
  | &amp;#39;vercel_blob&amp;#39;
  // Supabase platform
  | &amp;#39;supabase_database&amp;#39;
  | &amp;#39;supabase_auth&amp;#39;
  | &amp;#39;supabase_storage&amp;#39;
  | &amp;#39;supabase_functions&amp;#39;
  | &amp;#39;supabase_realtime&amp;#39;;

/**
 * Configuration for a service in the CUE specification
 */
export interface ServiceConfig {
  serviceType: PlatformServiceType;
  language: string;
  type: &amp;#39;deployment&amp;#39; | &amp;#39;statefulset&amp;#39; | &amp;#39;serverless&amp;#39; | &amp;#39;managed&amp;#39;;
  sourceDirectory?: string;
  image?: string;
  // Platform-specific configurations
  platform?: &amp;#39;cloudflare&amp;#39; | &amp;#39;vercel&amp;#39; | &amp;#39;supabase&amp;#39; | &amp;#39;kubernetes&amp;#39;;
  runtime?: string; // e.g., &amp;quot;durable_object&amp;quot;, &amp;quot;edge&amp;quot;, &amp;quot;nodejs18&amp;quot;
  region?: string;
  // Standard configurations
  ports?: Array&amp;lt;{
    name: string;
    port: number;
    targetPort: number;
  }&amp;gt;;
  volumes?: Array&amp;lt;{
    name: string;
    path: string;
    size?: string;
    type?: string;
  }&amp;gt;;
  env?: Record&amp;lt;string, string&amp;gt;;
  healthCheck?: {
    path: string;
    port: number;
  };
  template?: string;
}

/**
 * Configuration for an API endpoint
 */
export interface EndpointConfig {
  method: string;
  request?: {
    $ref: string;
  };
  response?: {
    $ref: string;
  };
}

/**
 * Configuration for a database service
 */
export interface DatabaseConfig extends ServiceConfig {
  attachTo?: string;
}

/**
 * Configuration for a UI route
 */
export interface RouteConfig {
  id: string;
  path: string;
  capabilities: string[];
  components?: string[];
}

/**
 * Configuration for a user flow
 */
export interface FlowConfig {
  id: string;
  steps: Array&amp;lt;any&amp;gt;;
}

/**
 * Result of CUE validation
 */
export interface ValidationResult {
  valid: boolean;
  errors: string[];
}

/**
 * Main CUE manipulator class providing AST-based operations
 */
export class CUEManipulator {
  private tempDir: string;

  constructor() {
    this.tempDir &#x3D; fs.mkdtempSync(path.join(os.tmpdir(), &amp;#39;cue-manipulator-&amp;#39;));
  }

  /**
   * Parse CUE content into a JavaScript object using the CUE tool
   */
  async parse(content: string): Promise&amp;lt;any&amp;gt; {
    const tempFile &#x3D; path.join(this.tempDir, &amp;#39;input.cue&amp;#39;);
    await fs.writeFile(tempFile, content);

    try {
      const runner &#x3D; this.createRunner();
      const exportResult &#x3D; await runner.exportJson([tempFile]);

      if (exportResult.success &amp;amp;&amp;amp; exportResult.value) {
        return exportResult.value;
      }

      const firstDiagnostic &#x3D; exportResult.diagnostics[0];
      const reason &#x3D; firstDiagnostic?.message || exportResult.error || &amp;#39;Unknown CUE export error&amp;#39;;
      throw new Error(reason);
    } catch (error) {
      throw new Error(&#x60;Failed to parse CUE content: ${error}&#x60;);
    }
  }

  /**
   * Add a service to the CUE structure
   */
  async addService(content: string, serviceName: string, config: ServiceConfig): Promise&amp;lt;string&amp;gt; {
    try {
      // Parse existing content
      const ast &#x3D; await this.parse(content);

      // Ensure services section exists
      if (!ast.services) {
        ast.services &#x3D; {};
      }

      // Add the service
      ast.services[serviceName] &#x3D; config;

      // Convert back to CUE and format
      return await this.serialize(ast, content);
    } catch (error) {
      // Fallback to direct manipulation if parsing fails (for incomplete CUE)
      return this.directServiceAdd(content, serviceName, config);
    }
  }

  /**
   * Add an endpoint to the CUE structure
   */
  async addEndpoint(content: string, endpoint: string, config: EndpointConfig): Promise&amp;lt;string&amp;gt; {
    try {
      const ast &#x3D; await this.parse(content);

      // Ensure paths section exists
      if (!ast.paths) {
        ast.paths &#x3D; {};
      }

      // Add the endpoint
      ast.paths[endpoint] &#x3D; {
        [config.method.toLowerCase()]: {
          ...(config.request &amp;amp;&amp;amp; { request: config.request }),
          ...(config.response &amp;amp;&amp;amp; { response: config.response }),
        },
      };

      return await this.serialize(ast, content);
    } catch (error) {
      return this.directEndpointAdd(content, endpoint, config);
    }
  }

  /**
   * Add a database to the CUE structure
   */
  async addDatabase(content: string, dbName: string, config: DatabaseConfig): Promise&amp;lt;string&amp;gt; {
    try {
      const ast &#x3D; await this.parse(content);

      // Ensure services section exists
      if (!ast.services) {
        ast.services &#x3D; {};
      }

      // Add the database service
      ast.services[dbName] &#x3D; config;

      // If attaching to another service, add connection environment variables
      if (config.attachTo &amp;amp;&amp;amp; ast.services[config.attachTo]) {
        if (!ast.services[config.attachTo].env) {
          ast.services[config.attachTo].env &#x3D; {};
        }

        // Generate connection string based on service type
        if (config.image) {
          // Container-based database
          const connectionString &#x3D; this.generateDbConnectionString(
            config.image,
            dbName,
            config.ports?.[0]?.port || 5432
          );
          ast.services[config.attachTo].env.DATABASE_URL &#x3D; connectionString;
        } else if (config.serviceType &amp;amp;&amp;amp; config.serviceType !&#x3D;&#x3D; &amp;#39;prebuilt&amp;#39;) {
          // Platform-managed database - generate appropriate env vars
          const envVars &#x3D; this.generatePlatformDbEnvVars(config.serviceType, dbName);
          Object.assign(ast.services[config.attachTo].env, envVars);
        }
      }

      return await this.serialize(ast, content);
    } catch (error) {
      return this.directDatabaseAdd(content, dbName, config);
    }
  }

  /**
   * Add a route to the UI routes array
   */
  async addRoute(content: string, route: RouteConfig): Promise&amp;lt;string&amp;gt; {
    try {
      const ast &#x3D; await this.parse(content);

      // Ensure ui.routes exists
      if (!ast.ui) {
        ast.ui &#x3D; {};
      }
      if (!ast.ui.routes) {
        ast.ui.routes &#x3D; [];
      }

      // Add the route
      ast.ui.routes.push(route);

      return await this.serialize(ast, content);
    } catch (error) {
      return this.directRouteAdd(content, route);
    }
  }

  /**
   * Add a flow to the flows array
   */
  async addFlow(content: string, flow: FlowConfig): Promise&amp;lt;string&amp;gt; {
    try {
      const ast &#x3D; await this.parse(content);

      // Ensure flows exists
      if (!ast.flows) {
        ast.flows &#x3D; [];
      }

      // Add the flow
      ast.flows.push(flow);

      return await this.serialize(ast, content);
    } catch (error) {
      return this.directFlowAdd(content, flow);
    }
  }

  /**
   * Add a key-value pair to a specific section
   */
  async addToSection(content: string, section: string, key: string, value: any): Promise&amp;lt;string&amp;gt; {
    try {
      const ast &#x3D; await this.parse(content);

      // Navigate to the section (support nested sections like &amp;quot;components.schemas&amp;quot;)
      const sections &#x3D; section.split(&amp;#39;.&amp;#39;);
      let current &#x3D; ast;

      for (const sec of sections) {
        if (!current[sec]) {
          current[sec] &#x3D; {};
        }
        current &#x3D; current[sec];
      }

      // Add the key-value pair
      current[key] &#x3D; value;

      return await this.serialize(ast, content);
    } catch (error) {
      return this.directSectionAdd(content, section, key, value);
    }
  }

  /**
   * Serialize a JavaScript object back to formatted CUE
   */
  async serialize(ast: any, originalContent?: string): Promise&amp;lt;string&amp;gt; {
    try {
      // Extract package declaration from original content if available
      let packageDeclaration &#x3D; &amp;#39;package main&amp;#39;;
      if (originalContent) {
        const packageMatch &#x3D; originalContent.match(/package\s+(\w+)/);
        if (packageMatch) {
          packageDeclaration &#x3D; &#x60;package ${packageMatch[1]}&#x60;;
        }
      }

      // Use manual CUE formatting for better control
      const cueBody &#x3D; this.formatCueObject(ast);
      const cueWithPackage &#x3D; &#x60;${packageDeclaration}\n\n${cueBody}&#x60;;

      return await this.format(cueWithPackage);
    } catch (error) {
      throw new Error(&#x60;Failed to serialize CUE content: ${error}&#x60;);
    }
  }

  /**
   * Format CUE content using the CUE tool
   */
  async format(content: string): Promise&amp;lt;string&amp;gt; {
    const tempFile &#x3D; path.join(this.tempDir, &amp;#39;format.cue&amp;#39;);
    await fs.writeFile(tempFile, content);

    try {
      const runner &#x3D; this.createRunner();
      const result &#x3D; await runner.fmt([tempFile]);
      if (!result.success) {
        throw new Error(result.stderr || &amp;#39;cue fmt failed&amp;#39;);
      }

      return await fs.readFile(tempFile, &amp;#39;utf-8&amp;#39;);
    } catch (error) {
      throw new Error(&#x60;Failed to format CUE content: ${error}&#x60;);
    }
  }

  /**
   * Validate CUE content using the CUE tool
   */
  async validate(content: string): Promise&amp;lt;ValidationResult&amp;gt; {
    const tempFile &#x3D; path.join(this.tempDir, &amp;#39;validate.cue&amp;#39;);
    await fs.writeFile(tempFile, content);

    try {
      const runner &#x3D; this.createRunner();
      const result &#x3D; await runner.vet([tempFile]);

      if (result.success) {
        return { valid: true, errors: [] };
      }

      const errors &#x3D; result.diagnostics.length
        ? result.diagnostics.map(diag &#x3D;&amp;gt; diag.message)
        : [result.raw.stderr || &amp;#39;cue vet failed&amp;#39;];

      return { valid: false, errors };
    } catch (error) {
      const message &#x3D; error instanceof Error ? error.message : String(error);
      return { valid: false, errors: [message] };
    }
  }

  private createRunner(): CueRunner {
    return new CueRunner({ cwd: this.tempDir });
  }

  /**
   * Direct service addition fallback for when parsing fails
   */
  private directServiceAdd(content: string, serviceName: string, config: ServiceConfig): string {
    const serviceBlock &#x3D; this.formatCueObject(config);

    const servicesRegex &#x3D; /(services:\s*{)([^}]*)(})/s;
    const match &#x3D; content.match(servicesRegex);

    if (match) {
      const existing &#x3D; match[2];
      const newEntry &#x3D; &#x60;\n\t${serviceName}: ${serviceBlock}&#x60;;
      const updated &#x3D; existing.trim() ? &#x60;${existing}${newEntry}&#x60; : newEntry;
      return content.replace(servicesRegex, &#x60;$1${updated}\n$3&#x60;);
    }
    return &#x60;${content}\n\nservices: {\n\t${serviceName}: ${serviceBlock}\n}&#x60;;
  }

  /**
   * Direct endpoint addition fallback
   */
  private directEndpointAdd(content: string, endpoint: string, config: EndpointConfig): string {
    const pathBlock &#x3D; this.formatCueObject({
      [config.method.toLowerCase()]: {
        ...(config.request &amp;amp;&amp;amp; { request: config.request }),
        ...(config.response &amp;amp;&amp;amp; { response: config.response }),
      },
    });

    const pathsRegex &#x3D; /(paths:\s*{)([^}]*)(})/s;
    const match &#x3D; content.match(pathsRegex);

    if (match) {
      const existing &#x3D; match[2];
      const newEntry &#x3D; &#x60;\n\t&amp;quot;${endpoint}&amp;quot;: ${pathBlock}&#x60;;
      const updated &#x3D; existing.trim() ? &#x60;${existing}${newEntry}&#x60; : newEntry;
      return content.replace(pathsRegex, &#x60;$1${updated}\n$3&#x60;);
    }
    return &#x60;${content}\n\npaths: {\n\t&amp;quot;${endpoint}&amp;quot;: ${pathBlock}\n}&#x60;;
  }

  /**
   * Direct database addition fallback
   */
  private directDatabaseAdd(content: string, dbName: string, config: DatabaseConfig): string {
    let result &#x3D; this.directServiceAdd(content, dbName, config);

    // Add connection string to attached service if specified
    if (config.attachTo) {
      if (config.image) {
        // Container-based database
        const connectionString &#x3D; this.generateDbConnectionString(
          config.image,
          dbName,
          config.ports?.[0]?.port || 5432
        );
        result &#x3D; this.addEnvironmentVariable(
          result,
          config.attachTo,
          &amp;#39;DATABASE_URL&amp;#39;,
          connectionString
        );
      } else if (config.serviceType &amp;amp;&amp;amp; config.serviceType !&#x3D;&#x3D; &amp;#39;prebuilt&amp;#39;) {
        // Platform-managed database - add multiple env vars
        const envVars &#x3D; this.generatePlatformDbEnvVars(config.serviceType, dbName);
        for (const [key, value] of Object.entries(envVars)) {
          result &#x3D; this.addEnvironmentVariable(result, config.attachTo, key, value);
        }
      }
    }

    return result;
  }

  /**
   * Direct route addition fallback
   */
  private directRouteAdd(content: string, route: RouteConfig): string {
    const routeBlock &#x3D; this.formatCueObject(route);

    const routesRegex &#x3D; /(ui:\s*routes:\s*\[)([^\]]*)]]/s;
    const match &#x3D; content.match(routesRegex);

    if (match) {
      const existing &#x3D; match[2];
      const separator &#x3D; existing.trim() ? &amp;#39;,\n\t&amp;#39; : &amp;#39;\n\t&amp;#39;;
      return content.replace(routesRegex, &#x60;$1${existing}${separator}${routeBlock}\n]&#x60;);
    }
    return content.replace(/ui:\s*routes:\s*\[\]/, &#x60;ui: routes: [\n\t${routeBlock}\n]&#x60;);
  }

  /**
   * Direct flow addition fallback
   */
  private directFlowAdd(content: string, flow: FlowConfig): string {
    const flowBlock &#x3D; this.formatCueObject(flow);

    const flowsRegex &#x3D; /(flows:\s*\[)([^\]]*)]]/s;
    const match &#x3D; content.match(flowsRegex);

    if (match) {
      const existing &#x3D; match[2];
      const separator &#x3D; existing.trim() ? &amp;#39;,\n\t&amp;#39; : &amp;#39;\n\t&amp;#39;;
      return content.replace(flowsRegex, &#x60;$1${existing}${separator}${flowBlock}\n]&#x60;);
    }
    return content.replace(/flows:\s*\[\]/, &#x60;flows: [\n\t${flowBlock}\n]&#x60;);
  }

  /**
   * Direct section addition fallback
   */
  private directSectionAdd(content: string, section: string, key: string, value: any): string {
    const valueStr &#x3D; this.formatCueObject(value);

    const sectionRegex &#x3D; new RegExp(&#x60;(${section.replace(&amp;#39;.&amp;#39;, &amp;#39;:\\s+&amp;#39;)}:\\s*{)([^}]*)(})&#x60;, &amp;#39;s&amp;#39;);
    const match &#x3D; content.match(sectionRegex);

    if (match) {
      const existing &#x3D; match[2];
      const newEntry &#x3D; &#x60;\n\t${key}: ${valueStr}&#x60;;
      const updated &#x3D; existing.trim() ? &#x60;${existing}${newEntry}&#x60; : newEntry;
      return content.replace(sectionRegex, &#x60;$1${updated}\n$3&#x60;);
    }
    return &#x60;${content}\n\n${section}: {\n\t${key}: ${valueStr}\n}&#x60;;
  }

  /**
   * Add environment variable to a service
   */
  private addEnvironmentVariable(
    content: string,
    serviceName: string,
    key: string,
    value: string
  ): string {
    const envRegex &#x3D; new RegExp(&#x60;(${serviceName}:\\s*{[^}]*env:\\s*{)([^}]*)(})&#x60;, &amp;#39;s&amp;#39;);
    const match &#x3D; content.match(envRegex);

    if (match) {
      const existing &#x3D; match[2];
      const newEntry &#x3D; &#x60;\n\t\t${key}: &amp;quot;${value}&amp;quot;&#x60;;
      const updated &#x3D; existing.trim() ? &#x60;${existing}${newEntry}&#x60; : newEntry;
      return content.replace(envRegex, &#x60;$1${updated}\n\t$3&#x60;);
    }
    // Add env section to service
    const serviceRegex &#x3D; new RegExp(&#x60;(${serviceName}:\\s*{[^}]*)(})&#x60;, &amp;#39;s&amp;#39;);
    return content.replace(serviceRegex, &#x60;$1\tenv: {\n\t\t${key}: &amp;quot;${value}&amp;quot;\n\t}\n$2&#x60;);
  }

  /**
   * Format a JavaScript object as CUE syntax
   */
  private formatCueObject(obj: any, indent &#x3D; &amp;#39;&amp;#39;): string {
    if (typeof obj &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39;) {
      return &#x60;&amp;quot;${obj.replace(/&amp;quot;/g, &amp;#39;\\&amp;quot;&amp;#39;)}&amp;quot;&#x60;;
    }
    if (typeof obj &#x3D;&#x3D;&#x3D; &amp;#39;number&amp;#39; || typeof obj &#x3D;&#x3D;&#x3D; &amp;#39;boolean&amp;#39;) {
      return String(obj);
    }

    if (Array.isArray(obj)) {
      if (obj.length &#x3D;&#x3D;&#x3D; 0) {
        return &amp;#39;[]&amp;#39;;
      }
      const items &#x3D; obj.map(item &#x3D;&amp;gt; &#x60;${indent}\t${this.formatCueObject(item, &#x60;${indent}\t&#x60;)}&#x60;);
      return &#x60;[\n${items.join(&amp;#39;,\n&amp;#39;)}\n${indent}]&#x60;;
    }

    if (typeof obj &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp; obj !&#x3D;&#x3D; null) {
      const entries &#x3D; Object.entries(obj);
      if (entries.length &#x3D;&#x3D;&#x3D; 0) {
        return &amp;#39;{}&amp;#39;;
      }
      const formattedEntries &#x3D; entries.map(([k, v]) &#x3D;&amp;gt; {
        const key &#x3D; /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(k) ? k : &#x60;&amp;quot;${k}&amp;quot;&#x60;;
        return &#x60;${indent}\t${key}: ${this.formatCueObject(v, &#x60;${indent}\t&#x60;)}&#x60;;
      });
      return &#x60;{\n${formattedEntries.join(&amp;#39;\n&amp;#39;)}\n${indent}}&#x60;;
    }

    return String(obj);
  }

  /**
   * Generate database connection string
   */
  private generateDbConnectionString(image: string, dbName: string, port: number): string {
    if (!image) {
      throw new Error(&amp;#39;generateDbConnectionString called with undefined image&amp;#39;);
    }
    if (image.includes(&amp;#39;postgres&amp;#39;)) {
      return &#x60;postgresql://user:password@${dbName}:${port}/${dbName}&#x60;;
    }
    if (image.includes(&amp;#39;mysql&amp;#39;)) {
      return &#x60;mysql://user:password@${dbName}:${port}/${dbName}&#x60;;
    }
    return &#x60;db://${dbName}:${port}/${dbName}&#x60;;
  }

  /**
   * Generate platform-specific database environment variables
   */
  private generatePlatformDbEnvVars(serviceType: string, dbName: string): Record&amp;lt;string, string&amp;gt; {
    switch (serviceType) {
      case &amp;#39;cloudflare_d1&amp;#39;:
        return {
          D1_DATABASE_ID: &#x60;${dbName}_id&#x60;,
          D1_DATABASE_NAME: dbName,
          DATABASE_URL: &#x60;d1://${dbName}&#x60;,
        };
      case &amp;#39;cloudflare_kv&amp;#39;:
        return {
          KV_NAMESPACE_ID: &#x60;${dbName}_namespace_id&#x60;,
          KV_BINDING_NAME: dbName.toUpperCase(),
        };
      case &amp;#39;vercel_postgres&amp;#39;:
        return {
          POSTGRES_URL: &#x60;postgres://${dbName}&#x60;,
          POSTGRES_PRISMA_URL: &#x60;postgres://${dbName}?pgbouncer&#x3D;true&#x60;,
          POSTGRES_URL_NON_POOLING: &#x60;postgres://${dbName}&#x60;,
        };
      case &amp;#39;vercel_kv&amp;#39;:
        return {
          KV_REST_API_URL: &#x60;https://${dbName}.kv.vercel-storage.com&#x60;,
          KV_REST_API_TOKEN: &#x60;${dbName}_token&#x60;,
          KV_URL: &#x60;redis://${dbName}&#x60;,
        };
      case &amp;#39;supabase_database&amp;#39;:
        return {
          SUPABASE_URL: &#x60;https://${dbName}.supabase.co&#x60;,
          SUPABASE_ANON_KEY: &#x60;${dbName}_anon_key&#x60;,
          SUPABASE_SERVICE_ROLE_KEY: &#x60;${dbName}_service_role_key&#x60;,
          DATABASE_URL: &#x60;postgresql://${dbName}&#x60;,
        };
      default:
        return {
          DATABASE_URL: &#x60;${serviceType}://${dbName}&#x60;,
        };
    }
  }

  /**
   * Cleanup temporary files
   */
  async cleanup(): Promise&amp;lt;void&amp;gt; {
    await fs.remove(this.tempDir);
  }
}

/**
 * Create a new CUE manipulator instance
 */
export function createCUEManipulator(): CUEManipulator {
  return new CUEManipulator();
}

/**
 * Helper function to validate CUE content
 */
export async function validateCUE(content: string): Promise&amp;lt;ValidationResult&amp;gt; {
  const manipulator &#x3D; createCUEManipulator();
  try {
    return await manipulator.validate(content);
  } finally {
    await manipulator.cleanup();
  }
}

/**
 * Helper function to format CUE content
 */
export async function formatCUE(content: string): Promise&amp;lt;string&amp;gt; {
  const manipulator &#x3D; createCUEManipulator();
  try {
    return await manipulator.format(content);
  } finally {
    await manipulator.cleanup();
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-54">
                <div class="file-header">ğŸ“„ examples/external-agent.ts</div>
                <div class="file-content">
                    <pre>#!/usr/bin/env bun
/**
 * Example external agent that subscribes to spec events via NATS
 * This demonstrates how AI agents can react to specification changes
 */
import { type NatsConnection, connect } from &amp;#39;nats&amp;#39;;

interface NatsSpecEvent {
  topic: string;
  projectId: string;
  event: {
    project_id: string;
    event_type: string;
    data: Record&amp;lt;string, unknown&amp;gt;;
  };
  metadata: {
    timestamp: string;
    specHash?: string;
    sequence: number;
  };
}

class SpecAnalysisAgent {
  private connection: NatsConnection | null &#x3D; null;
  private name: string;

  constructor(name &#x3D; &amp;#39;SpecAnalysisAgent&amp;#39;) {
    this.name &#x3D; name;
  }

  /**
   * Connect to NATS and start listening for spec events
   */
  async start(natsUrl &#x3D; &amp;#39;nats://localhost:4222&amp;#39;): Promise&amp;lt;void&amp;gt; {
    try {
      console.log(&#x60;ğŸ¤– ${this.name} connecting to NATS at ${natsUrl}...&#x60;);

      this.connection &#x3D; await connect({
        servers: [natsUrl],
        reconnectTimeWait: 2000,
        maxReconnectAttempts: 10,
      });

      console.log(&#x60;âœ… ${this.name} connected to NATS server&#x60;);

      // Subscribe to all spec events for all projects
      // In production, you might want to filter by specific projects
      const subscription &#x3D; this.connection.subscribe(&amp;#39;spec.*.*.updated&amp;#39;);

      console.log(&#x60;ğŸ” ${this.name} listening for spec events...&#x60;);

      // Process incoming events
      for await (const message of subscription) {
        try {
          const event: NatsSpecEvent &#x3D; JSON.parse(message.data.toString());
          await this.processSpecEvent(event);
        } catch (error) {
          console.error(&amp;#39;âŒ Error processing message:&amp;#39;, error);
        }
      }
    } catch (error) {
      console.error(&#x60;âŒ ${this.name} failed to connect to NATS:&#x60;, error);
      process.exit(1);
    }
  }

  /**
   * Process a spec event and provide AI analysis
   */
  private async processSpecEvent(event: NatsSpecEvent): Promise&amp;lt;void&amp;gt; {
    const { topic, projectId, event: specEvent, metadata } &#x3D; event;

    console.log(&#x60;\nğŸ“¨ ${this.name} received event:&#x60;);
    console.log(&#x60;   Topic: ${topic}&#x60;);
    console.log(&#x60;   Project: ${projectId}&#x60;);
    console.log(&#x60;   Type: ${specEvent.event_type}&#x60;);
    console.log(&#x60;   Sequence: ${metadata.sequence}&#x60;);
    console.log(&#x60;   Timestamp: ${metadata.timestamp}&#x60;);

    // Example analysis based on event type
    switch (specEvent.event_type) {
      case &amp;#39;fragment_updated&amp;#39;:
        await this.analyzeFragmentUpdate(projectId, specEvent);
        break;

      case &amp;#39;validation_failed&amp;#39;:
        await this.analyzeValidationFailure(projectId, specEvent);
        break;

      case &amp;#39;validation_completed&amp;#39;:
        await this.analyzeValidationSuccess(projectId, specEvent);
        break;

      case &amp;#39;version_frozen&amp;#39;:
        await this.analyzeVersionFreeze(projectId, specEvent);
        break;

      default:
        console.log(&#x60;   ğŸ“‹ No specific analysis for event type: ${specEvent.event_type}&#x60;);
    }
  }

  /**
   * Analyze fragment updates for potential issues or improvements
   */
  private async analyzeFragmentUpdate(projectId: string, event: any): Promise&amp;lt;void&amp;gt; {
    console.log(&#x60;ğŸ” Analyzing fragment update in project ${projectId}...&#x60;);

    // Simulate AI analysis delay
    await new Promise(resolve &#x3D;&amp;gt; setTimeout(resolve, 100));

    // Example analysis outputs
    const fragmentPath &#x3D; event.data.path || &amp;#39;unknown&amp;#39;;
    const insights &#x3D; [
      &amp;#39;Fragment structure appears consistent with domain patterns&amp;#39;,
      &amp;#39;Consider adding validation constraints for better error messages&amp;#39;,
      &amp;#39;This change might benefit from additional test coverage&amp;#39;,
    ];

    console.log(&#x60;   ğŸ“Š Analysis for ${fragmentPath}:&#x60;);
    insights.forEach(insight &#x3D;&amp;gt; console.log(&#x60;      â€¢ ${insight}&#x60;));

    // In a real agent, you might:
    // - Send analysis back via NATS to another topic
    // - Store insights in a database
    // - Generate automated recommendations
    // - Trigger other automated workflows
  }

  /**
   * Analyze validation failures and suggest fixes
   */
  private async analyzeValidationFailure(projectId: string, event: any): Promise&amp;lt;void&amp;gt; {
    console.log(&#x60;âŒ Analyzing validation failure in project ${projectId}...&#x60;);

    await new Promise(resolve &#x3D;&amp;gt; setTimeout(resolve, 150));

    const errors &#x3D; event.data.errors || [];
    const suggestions &#x3D; [
      &amp;#39;Check for circular dependencies in fragment imports&amp;#39;,
      &amp;#39;Ensure all required fields are properly defined&amp;#39;,
      &amp;#39;Validate CUE syntax and type constraints&amp;#39;,
    ];

    console.log(&#x60;   ğŸ”§ Failure analysis (${errors.length} errors):&#x60;);
    suggestions.forEach(suggestion &#x3D;&amp;gt; console.log(&#x60;      â€¢ ${suggestion}&#x60;));

    // Real agent might publish back remediation suggestions
    if (this.connection) {
      const remediation &#x3D; {
        projectId,
        agentName: this.name,
        type: &amp;#39;validation_remediation&amp;#39;,
        suggestions,
        timestamp: new Date().toISOString(),
        originalEventSequence: event.data.sequence,
      };

      this.connection.publish(&#x60;agent.${projectId}.remediation&#x60;, JSON.stringify(remediation));
      console.log(&#x60;   ğŸ“¤ Published remediation suggestions to agent.${projectId}.remediation&#x60;);
    }
  }

  /**
   * Analyze successful validations for quality insights
   */
  private async analyzeValidationSuccess(projectId: string, event: any): Promise&amp;lt;void&amp;gt; {
    console.log(&#x60;âœ… Analyzing validation success in project ${projectId}...&#x60;);

    await new Promise(resolve &#x3D;&amp;gt; setTimeout(resolve, 80));

    const specHash &#x3D; event.data.spec_hash;
    console.log(&#x60;   ğŸ¯ Validation passed for spec ${specHash}&#x60;);
    console.log(&amp;#39;      â€¢ Spec structure is valid and consistent&amp;#39;);
    console.log(&amp;#39;      â€¢ All constraints are properly satisfied&amp;#39;);
    console.log(&amp;#39;      â€¢ Ready for potential version freeze&amp;#39;);
  }

  /**
   * Analyze version freezes for historical tracking
   */
  private async analyzeVersionFreeze(projectId: string, event: any): Promise&amp;lt;void&amp;gt; {
    console.log(&#x60;ğŸ”’ Analyzing version freeze in project ${projectId}...&#x60;);

    const versionId &#x3D; event.data.version_id;
    const specHash &#x3D; event.data.spec_hash;

    console.log(&#x60;   ğŸ“š Version ${versionId} frozen with spec ${specHash}&#x60;);
    console.log(&amp;#39;      â€¢ Milestone reached - spec locked for stability&amp;#39;);
    console.log(&amp;#39;      â€¢ Consider generating documentation snapshot&amp;#39;);
    console.log(&amp;#39;      â€¢ Good time for comprehensive testing&amp;#39;);
  }

  /**
   * Cleanup and disconnect
   */
  async stop(): Promise&amp;lt;void&amp;gt; {
    if (this.connection) {
      await this.connection.close();
      console.log(&#x60;ğŸ‘‹ ${this.name} disconnected from NATS&#x60;);
    }
  }
}

// Main execution
if (import.meta.main) {
  const agentName &#x3D; process.argv[2] || &amp;#39;SpecAnalysisAgent&amp;#39;;
  const natsUrl &#x3D; process.env.NATS_URL || &amp;#39;nats://localhost:4222&amp;#39;;

  const agent &#x3D; new SpecAnalysisAgent(agentName);

  // Handle graceful shutdown
  process.on(&amp;#39;SIGINT&amp;#39;, async () &#x3D;&amp;gt; {
    console.log(&amp;#39;\nğŸ›‘ Shutting down agent...&amp;#39;);
    await agent.stop();
    process.exit(0);
  });

  process.on(&amp;#39;SIGTERM&amp;#39;, async () &#x3D;&amp;gt; {
    console.log(&amp;#39;\nğŸ›‘ Shutting down agent...&amp;#39;);
    await agent.stop();
    process.exit(0);
  });

  // Start the agent
  agent.start(natsUrl).catch(error &#x3D;&amp;gt; {
    console.error(&amp;#39;Failed to start agent:&amp;#39;, error);
    process.exit(1);
  });
}

export { SpecAnalysisAgent };
</pre>
                </div>
            </div>
            <div class="file-section" id="file-55">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/templates.ts</div>
                <div class="file-content">
                    <pre>/**
 * Templates command - Template management for Arbiter
 *
 * This command provides template management functionality:
 * - List available templates
 * - Show template details
 * - Add/update template aliases
 * - Remove template aliases
 */

import chalk from &amp;#39;chalk&amp;#39;;
import { type TemplateAlias, templateManager } from &amp;#39;../templates/index.js&amp;#39;;
import type { CLIConfig } from &amp;#39;../types.js&amp;#39;;

export interface TemplatesOptions {
  verbose?: boolean;
  format?: &amp;#39;table&amp;#39; | &amp;#39;json&amp;#39;;
  engine?: string;
}

/**
 * Main templates command dispatcher
 */
export async function templatesCommand(
  action: string,
  name?: string,
  options: TemplatesOptions &amp;amp; Record&amp;lt;string, any&amp;gt; &#x3D; {},
  _config?: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  try {
    // Load template configuration
    await templateManager.loadConfig();

    switch (action) {
      case &amp;#39;list&amp;#39;:
        return await listTemplates(options);
      case &amp;#39;show&amp;#39;:
        if (!name) {
          console.error(chalk.red(&amp;#39;âŒ Template name is required for show command&amp;#39;));
          return 1;
        }
        return await showTemplate(name, options);
      case &amp;#39;add&amp;#39;:
        if (!name) {
          console.error(chalk.red(&amp;#39;âŒ Template name is required for add command&amp;#39;));
          return 1;
        }
        return await addTemplate(name, options);
      case &amp;#39;remove&amp;#39;:
        if (!name) {
          console.error(chalk.red(&amp;#39;âŒ Template name is required for remove command&amp;#39;));
          return 1;
        }
        return await removeTemplate(name, options);
      case &amp;#39;update&amp;#39;:
        return await updateTemplates(options);
      default:
        console.error(chalk.red(&#x60;âŒ Unknown templates action: ${action}&#x60;));
        console.log(chalk.dim(&amp;#39;Available actions: list, show, add, remove, update&amp;#39;));
        return 1;
    }
  } catch (error) {
    console.error(chalk.red(&amp;#39;âŒ Templates command failed:&amp;#39;));
    console.error(chalk.red(error instanceof Error ? error.message : String(error)));
    return 1;
  }
}

/**
 * List all available template aliases
 */
async function listTemplates(options: TemplatesOptions): Promise&amp;lt;number&amp;gt; {
  try {
    const aliases &#x3D; templateManager.getAliases();
    const entries &#x3D; Object.entries(aliases);

    if (entries.length &#x3D;&#x3D;&#x3D; 0) {
      console.log(chalk.yellow(&amp;#39;ğŸ“‹ No template aliases configured&amp;#39;));
      console.log(
        chalk.dim(&amp;quot;Use &amp;#39;arbiter templates add &amp;lt;name&amp;gt; --source &amp;lt;source&amp;gt;&amp;#39; to add templates&amp;quot;)
      );
      return 0;
    }

    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      console.log(JSON.stringify(aliases, null, 2));
      return 0;
    }

    console.log(chalk.cyan(&amp;#39;ğŸ“‹ Available Template Aliases:&amp;#39;));
    console.log();

    // Group by engine
    const engineGroups &#x3D; new Map&amp;lt;string, Array&amp;lt;[string, TemplateAlias]&amp;gt;&amp;gt;();
    for (const [name, alias] of entries) {
      if (!engineGroups.has(alias.engine)) {
        engineGroups.set(alias.engine, []);
      }
      engineGroups.get(alias.engine)?.push([name, alias]);
    }

    for (const [engine, templates] of engineGroups.entries()) {
      console.log(chalk.bold(chalk.blue(&#x60;${engine.toUpperCase()} Templates:&#x60;)));

      for (const [name, alias] of templates) {
        console.log(&#x60;  ${chalk.green(name)}&#x60;);
        console.log(&#x60;    ${chalk.dim(alias.description)}&#x60;);
        console.log(&#x60;    ${chalk.dim(&#x60;Source: ${alias.source}&#x60;)}&#x60;);

        if (alias.prerequisites &amp;amp;&amp;amp; alias.prerequisites.length &amp;gt; 0) {
          console.log(&#x60;    ${chalk.dim(&#x60;Prerequisites: ${alias.prerequisites.join(&amp;#39;, &amp;#39;)}&#x60;)}&#x60;);
        }

        console.log();
      }
    }

    console.log(chalk.dim(&amp;quot;Use &amp;#39;arbiter templates show &amp;lt;name&amp;gt;&amp;#39; to view template details&amp;quot;));
    console.log(chalk.dim(&amp;quot;Use &amp;#39;arbiter add service &amp;lt;name&amp;gt; --template &amp;lt;alias&amp;gt;&amp;#39; to use a template&amp;quot;));

    return 0;
  } catch (error) {
    console.error(chalk.red(&amp;#39;Failed to list templates:&amp;#39;));
    console.error(chalk.red(error instanceof Error ? error.message : String(error)));
    return 1;
  }
}

/**
 * Show details for a specific template alias
 */
async function showTemplate(name: string, options: TemplatesOptions): Promise&amp;lt;number&amp;gt; {
  try {
    const alias &#x3D; templateManager.getAlias(name);

    if (!alias) {
      return handleTemplateNotFound(name);
    }

    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      return displayTemplateAsJson(name, alias);
    }

    return displayTemplateDetails(name, alias);
  } catch (error) {
    return handleTemplateDisplayError(error);
  }
}

/**
 * Handle template not found scenario
 */
function handleTemplateNotFound(name: string): number {
  console.error(chalk.red(&#x60;âŒ Template alias &amp;#39;${name}&amp;#39; not found&#x60;));

  const availableTemplates &#x3D; Object.keys(templateManager.getAliases());
  if (availableTemplates.length &amp;gt; 0) {
    console.log(chalk.dim(&amp;#39;Available templates:&amp;#39;));
    availableTemplates.forEach(t &#x3D;&amp;gt; console.log(chalk.dim(&#x60;  â€¢ ${t}&#x60;)));
  }

  return 1;
}

/**
 * Display template in JSON format
 */
function displayTemplateAsJson(name: string, alias: any): number {
  console.log(JSON.stringify({ [name]: alias }, null, 2));
  return 0;
}

/**
 * Display template details in formatted output
 */
function displayTemplateDetails(name: string, alias: any): number {
  displayTemplateHeader(name);
  displayTemplateBasicInfo(alias);
  displayTemplatePrerequisites(alias);
  displayTemplateVariables(alias);
  displayTemplateUsage(name);

  return 0;
}

/**
 * Display template header
 */
function displayTemplateHeader(name: string): void {
  console.log(chalk.cyan(&#x60;ğŸ“‹ Template: ${chalk.bold(name)}&#x60;));
  console.log();
}

/**
 * Display basic template information
 */
function displayTemplateBasicInfo(alias: any): void {
  console.log(chalk.bold(&amp;#39;Description:&amp;#39;));
  console.log(&#x60;  ${alias.description}&#x60;);
  console.log();

  console.log(chalk.bold(&amp;#39;Engine:&amp;#39;));
  console.log(&#x60;  ${alias.engine}&#x60;);
  console.log();

  console.log(chalk.bold(&amp;#39;Source:&amp;#39;));
  console.log(&#x60;  ${alias.source}&#x60;);
  console.log();
}

/**
 * Display template prerequisites if available
 */
function displayTemplatePrerequisites(alias: any): void {
  if (alias.prerequisites &amp;amp;&amp;amp; alias.prerequisites.length &amp;gt; 0) {
    console.log(chalk.bold(&amp;#39;Prerequisites:&amp;#39;));
    alias.prerequisites.forEach((prereq: string) &#x3D;&amp;gt; {
      console.log(&#x60;  â€¢ ${prereq}&#x60;);
    });
    console.log();
  }
}

/**
 * Display template variables if available
 */
function displayTemplateVariables(alias: any): void {
  if (alias.variables &amp;amp;&amp;amp; Object.keys(alias.variables).length &amp;gt; 0) {
    console.log(chalk.bold(&amp;#39;Default Variables:&amp;#39;));
    Object.entries(alias.variables).forEach(([key, value]) &#x3D;&amp;gt; {
      console.log(&#x60;  ${chalk.green(key)}: ${JSON.stringify(value)}&#x60;);
    });
    console.log();
  }
}

/**
 * Display template usage examples
 */
function displayTemplateUsage(name: string): void {
  console.log(chalk.bold(&amp;#39;Usage:&amp;#39;));
  console.log(&#x60;  arbiter add service myapi --template ${name}&#x60;);
  console.log(&#x60;  arbiter add frontend web --template ${name}&#x60;);
}

/**
 * Handle template display errors
 */
function handleTemplateDisplayError(error: unknown): number {
  console.error(chalk.red(&amp;#39;Failed to show template:&amp;#39;));
  console.error(chalk.red(error instanceof Error ? error.message : String(error)));
  return 1;
}

/**
 * Add a new template alias
 */
async function addTemplate(name: string, options: Record&amp;lt;string, any&amp;gt;): Promise&amp;lt;number&amp;gt; {
  try {
    const { source, description, engine &#x3D; &amp;#39;cookiecutter&amp;#39;, prerequisites } &#x3D; options;

    if (!source) {
      console.error(chalk.red(&amp;#39;âŒ Template source is required&amp;#39;));
      console.log(chalk.dim(&amp;#39;Use --source to specify the template source (URL, path, or repo)&amp;#39;));
      return 1;
    }

    if (!description) {
      console.error(chalk.red(&amp;#39;âŒ Template description is required&amp;#39;));
      console.log(chalk.dim(&amp;#39;Use --description to provide a template description&amp;#39;));
      return 1;
    }

    // Check if engine is supported
    const supportedEngines &#x3D; templateManager.getEngines();
    if (!supportedEngines.includes(engine)) {
      console.error(chalk.red(&#x60;âŒ Unsupported engine: ${engine}&#x60;));
      console.log(chalk.dim(&#x60;Supported engines: ${supportedEngines.join(&amp;#39;, &amp;#39;)}&#x60;));
      return 1;
    }

    const alias: TemplateAlias &#x3D; {
      engine,
      source,
      description,
      ...(prerequisites &amp;amp;&amp;amp; {
        prerequisites: prerequisites.split(&amp;#39;,&amp;#39;).map((p: string) &#x3D;&amp;gt; p.trim()),
      }),
    };

    await templateManager.addAlias(name, alias);

    console.log(chalk.green(&#x60;âœ… Template alias &amp;#39;${name}&amp;#39; added successfully&#x60;));
    console.log(chalk.dim(&#x60;Engine: ${engine}&#x60;));
    console.log(chalk.dim(&#x60;Source: ${source}&#x60;));
    console.log(chalk.dim(&#x60;Description: ${description}&#x60;));

    if (prerequisites) {
      console.log(chalk.dim(&#x60;Prerequisites: ${prerequisites}&#x60;));
    }

    console.log();
    console.log(chalk.bold(&amp;#39;Usage:&amp;#39;));
    console.log(&#x60;  arbiter add service myapi --template ${name}&#x60;);

    return 0;
  } catch (error) {
    console.error(chalk.red(&amp;#39;Failed to add template:&amp;#39;));
    console.error(chalk.red(error instanceof Error ? error.message : String(error)));
    return 1;
  }
}

/**
 * Remove a template alias
 */
async function removeTemplate(name: string, options: TemplatesOptions): Promise&amp;lt;number&amp;gt; {
  try {
    const alias &#x3D; templateManager.getAlias(name);

    if (!alias) {
      console.error(chalk.red(&#x60;âŒ Template alias &amp;#39;${name}&amp;#39; not found&#x60;));
      return 1;
    }

    await templateManager.removeAlias(name);

    console.log(chalk.green(&#x60;âœ… Template alias &amp;#39;${name}&amp;#39; removed successfully&#x60;));
    console.log(chalk.dim(&#x60;Was: ${alias.description} (${alias.engine})&#x60;));

    return 0;
  } catch (error) {
    console.error(chalk.red(&amp;#39;Failed to remove template:&amp;#39;));
    console.error(chalk.red(error instanceof Error ? error.message : String(error)));
    return 1;
  }
}

/**
 * Update template configuration (reload/refresh)
 */
async function updateTemplates(options: TemplatesOptions): Promise&amp;lt;number&amp;gt; {
  try {
    console.log(chalk.blue(&amp;#39;ğŸ”„ Updating template configuration...&amp;#39;));

    // Reload configuration
    await templateManager.loadConfig();

    const aliases &#x3D; templateManager.getAliases();
    const count &#x3D; Object.keys(aliases).length;

    console.log(chalk.green(&amp;#39;âœ… Template configuration updated&amp;#39;));
    console.log(chalk.dim(&#x60;Found ${count} template aliases&#x60;));

    if (options.verbose) {
      console.log();
      console.log(chalk.bold(&amp;#39;Available templates:&amp;#39;));
      Object.keys(aliases).forEach(name &#x3D;&amp;gt; {
        console.log(&#x60;  â€¢ ${name}&#x60;);
      });
    }

    return 0;
  } catch (error) {
    console.error(chalk.red(&amp;#39;Failed to update templates:&amp;#39;));
    console.error(chalk.red(error instanceof Error ? error.message : String(error)));
    return 1;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-56">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/github-template.ts</div>
                <div class="file-content">
                    <pre>/**
 * GitHub Template management command
 *
 * Handles GitHub template scaffolding, generation, and management
 */

import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import type { CLIConfig } from &amp;#39;../types.js&amp;#39;;
import { FileBasedTemplateManager } from &amp;#39;../utils/file-based-template-manager.js&amp;#39;;

export interface GitHubTemplateOptions {
  /** List available templates */
  list?: boolean;
  /** Initialize templates from scratch */
  init?: boolean;
  /** Generate specific template type */
  generate?: string;
  /** Scaffold template files */
  scaffold?: boolean;
  /** Validate template configuration */
  validate?: boolean;
  /** Output directory for templates */
  outputDir?: string;
  /** Template discovery paths */
  discoveryPaths?: string[];
  /** Verbose output */
  verbose?: boolean;
  /** Force overwrite existing files */
  force?: boolean;
}

/**
 * Main GitHub template command handler
 */
export async function githubTemplateCommand(
  options: GitHubTemplateOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  try {
    if (options.list) {
      return await listTemplates(options, config);
    }

    if (options.init || options.scaffold) {
      return await scaffoldTemplates(options, config);
    }

    if (options.validate) {
      return await validateTemplates(options, config);
    }

    if (options.generate) {
      return await generateTemplate(options.generate, options, config);
    }

    // Show help by default
    console.log(chalk.blue(&amp;#39;Arbiter GitHub Template Management\n&amp;#39;));
    console.log(&amp;#39;Available commands:&amp;#39;);
    console.log(&amp;#39;  --list          List available GitHub templates&amp;#39;);
    console.log(&amp;#39;  --init          Initialize default template files&amp;#39;);
    console.log(&amp;#39;  --scaffold      Scaffold template directory structure&amp;#39;);
    console.log(&amp;#39;  --validate      Validate template configuration&amp;#39;);
    console.log(&amp;#39;  --generate TYPE Generate a specific template&amp;#39;);
    console.log(&amp;#39;\nTemplate types: epic, task, bug-report, feature-request&amp;#39;);
    console.log(&amp;#39;\nOptions:&amp;#39;);
    console.log(&amp;#39;  --output-dir DIR    Output directory for templates&amp;#39;);
    console.log(&amp;#39;  --force             Force overwrite existing files&amp;#39;);
    console.log(&amp;#39;  --verbose           Verbose output&amp;#39;);

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;GitHub template command failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * List available templates
 */
async function listTemplates(options: GitHubTemplateOptions, config: CLIConfig): Promise&amp;lt;number&amp;gt; {
  try {
    console.log(chalk.blue(&amp;#39;ğŸ“‹ Available GitHub Templates\n&amp;#39;));

    // Load template manager
    const templatesConfig &#x3D; config.github?.templates || {};
    const templateManager &#x3D; new FileBasedTemplateManager(templatesConfig, config.projectDir);

    // Discover templates in discovery paths
    const discovered &#x3D; await templateManager.discoverTemplates();

    if (discovered.length &#x3D;&#x3D;&#x3D; 0) {
      console.log(chalk.yellow(&amp;#39;No templates found. Use --init to create default templates.&amp;#39;));
      return 0;
    }

    // Group by directory
    const byDirectory: Record&amp;lt;string, typeof discovered&amp;gt; &#x3D; {};
    discovered.forEach(template &#x3D;&amp;gt; {
      const dir &#x3D; path.dirname(template.templatePath);
      if (!byDirectory[dir]) {
        byDirectory[dir] &#x3D; [];
      }
      byDirectory[dir].push(template);
    });

    // Display templates by directory
    for (const [directory, templates] of Object.entries(byDirectory)) {
      console.log(chalk.cyan(&#x60;ğŸ“ ${path.relative(config.projectDir, directory)}/&#x60;));

      templates.forEach(template &#x3D;&amp;gt; {
        const filename &#x3D; path.basename(template.templatePath);
        const metadata &#x3D; template.metadata;

        console.log(&#x60;  â€¢ ${chalk.green(filename)}&#x60;);
        if (metadata?.name) {
          console.log(&#x60;    ${chalk.dim(&amp;#39;Name:&amp;#39;)} ${metadata.name}&#x60;);
        }
        if (metadata?.description) {
          console.log(&#x60;    ${chalk.dim(&amp;#39;Description:&amp;#39;)} ${metadata.description}&#x60;);
        }
        if (metadata?.inherits) {
          console.log(&#x60;    ${chalk.dim(&amp;#39;Inherits:&amp;#39;)} ${metadata.inherits}&#x60;);
        }
        console.log();
      });
    }

    // Show configured templates
    const configuredTemplates &#x3D; Object.entries(templatesConfig)
      .filter(([key]) &#x3D;&amp;gt; [&amp;#39;base&amp;#39;, &amp;#39;epic&amp;#39;, &amp;#39;task&amp;#39;, &amp;#39;bugReport&amp;#39;, &amp;#39;featureRequest&amp;#39;].includes(key))
      .filter(([, value]) &#x3D;&amp;gt; value);

    if (configuredTemplates.length &amp;gt; 0) {
      console.log(chalk.blue(&amp;#39;ğŸ”§ Configured Templates\n&amp;#39;));
      configuredTemplates.forEach(([type, templateRef]) &#x3D;&amp;gt; {
        console.log(&#x60;  â€¢ ${chalk.green(type)}&#x60;);
        if (&amp;#39;file&amp;#39; in templateRef) {
          console.log(&#x60;    ${chalk.dim(&amp;#39;File:&amp;#39;)} ${templateRef.file}&#x60;);
          if (templateRef.inherits) {
            console.log(&#x60;    ${chalk.dim(&amp;#39;Inherits:&amp;#39;)} ${templateRef.inherits}&#x60;);
          }
        } else if (&amp;#39;templateFile&amp;#39; in templateRef &amp;amp;&amp;amp; templateRef.templateFile) {
          console.log(&#x60;    ${chalk.dim(&amp;#39;File:&amp;#39;)} ${templateRef.templateFile}&#x60;);
        }
        console.log();
      });
    }

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Failed to list templates:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Scaffold template files and directory structure
 */
async function scaffoldTemplates(
  options: GitHubTemplateOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  try {
    const outputDir &#x3D;
      options.outputDir || path.join(config.projectDir, &amp;#39;.arbiter&amp;#39;, &amp;#39;templates&amp;#39;, &amp;#39;github&amp;#39;);

    console.log(chalk.blue(&amp;#39;ğŸ—ï¸ Scaffolding GitHub templates...&amp;#39;));
    console.log(chalk.dim(&#x60;Output directory: ${outputDir}\n&#x60;));

    // Ensure output directory exists
    await fs.ensureDir(outputDir);

    // Copy templates from the existing created directory
    const existingTemplatesDir &#x3D; path.join(config.projectDir, &amp;#39;.arbiter&amp;#39;, &amp;#39;templates&amp;#39;, &amp;#39;github&amp;#39;);

    const templates &#x3D; [
      { name: &amp;#39;base.hbs&amp;#39;, description: &amp;#39;Base template for all GitHub issues&amp;#39; },
      { name: &amp;#39;epic.hbs&amp;#39;, description: &amp;#39;Epic template with task overview&amp;#39; },
      { name: &amp;#39;task.hbs&amp;#39;, description: &amp;#39;Task template with implementation details&amp;#39; },
      { name: &amp;#39;bug-report.hbs&amp;#39;, description: &amp;#39;Bug report template with reproduction steps&amp;#39; },
      { name: &amp;#39;feature-request.hbs&amp;#39;, description: &amp;#39;Feature request template with use cases&amp;#39; },
    ];

    // Create template files
    for (const template of templates) {
      const sourcePath &#x3D; path.join(existingTemplatesDir, template.name);
      const targetPath &#x3D; path.join(outputDir, template.name);

      if ((await fs.pathExists(targetPath)) &amp;amp;&amp;amp; !options.force) {
        console.log(chalk.yellow(&#x60;âš ï¸  Skipping ${template.name} (already exists)&#x60;));
        continue;
      }

      if (await fs.pathExists(sourcePath)) {
        await fs.copy(sourcePath, targetPath);
        console.log(chalk.green(&#x60;âœ… Created ${template.name}&#x60;));
      } else {
        console.log(chalk.red(&#x60;âŒ Source template ${template.name} not found&#x60;));
      }

      if (options.verbose) {
        console.log(chalk.dim(&#x60;   ${template.description}&#x60;));
      }
    }

    // Update or create config.json to reference templates
    await updateConfigForTemplates(config, outputDir);

    console.log(chalk.green(&amp;#39;\nğŸ‰ Template scaffolding complete!&amp;#39;));
    console.log(chalk.dim(&amp;#39;Edit the template files to customize your GitHub issue templates.&amp;#39;));
    console.log(chalk.dim(&amp;quot;Use &amp;#39;arbiter github-template --validate&amp;#39; to check your templates.&amp;quot;));

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Failed to scaffold templates:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Validate template configuration and files
 */
async function validateTemplates(
  options: GitHubTemplateOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  try {
    console.log(chalk.blue(&amp;#39;ğŸ” Validating template configuration...\n&amp;#39;));

    const templatesConfig &#x3D; config.github?.templates || {};
    const templateManager &#x3D; new FileBasedTemplateManager(templatesConfig, config.projectDir);

    // Validate configuration
    const errors &#x3D; await templateManager.validateTemplateConfig();

    if (errors.length &#x3D;&#x3D;&#x3D; 0) {
      console.log(chalk.green(&amp;#39;âœ… All template configurations are valid&amp;#39;));
    } else {
      console.log(chalk.red(&#x60;âŒ Found ${errors.length} validation error(s):\n&#x60;));
      errors.forEach(error &#x3D;&amp;gt; {
        console.log(chalk.red(&#x60;â€¢ ${error.field}: ${error.message}&#x60;));
      });
    }

    // Try to load each template to check for syntax errors
    const templateTypes &#x3D; [&amp;#39;epic&amp;#39;, &amp;#39;task&amp;#39;, &amp;#39;bugReport&amp;#39;, &amp;#39;featureRequest&amp;#39;] as const;
    let syntaxErrors &#x3D; 0;

    for (const templateType of templateTypes) {
      const templateRef &#x3D; templatesConfig[templateType];
      if (!templateRef) continue;

      try {
        // Test template loading with sample data
        const sampleData &#x3D; getSampleDataForTemplate(templateType);

        if (templateType &#x3D;&#x3D;&#x3D; &amp;#39;task&amp;#39;) {
          await templateManager.generateTaskTemplate(sampleData.task, sampleData.epic);
        } else if (templateType &#x3D;&#x3D;&#x3D; &amp;#39;epic&amp;#39;) {
          await templateManager.generateEpicTemplate(sampleData);
        } else if (templateType &#x3D;&#x3D;&#x3D; &amp;#39;bugReport&amp;#39;) {
          await templateManager.generateBugReportTemplate(sampleData);
        } else if (templateType &#x3D;&#x3D;&#x3D; &amp;#39;featureRequest&amp;#39;) {
          await templateManager.generateFeatureRequestTemplate(sampleData);
        }

        console.log(chalk.green(&#x60;âœ… ${templateType} template syntax is valid&#x60;));
      } catch (error) {
        syntaxErrors++;
        console.log(chalk.red(&#x60;âŒ ${templateType} template has syntax errors:&#x60;));
        console.log(chalk.red(&#x60;   ${error instanceof Error ? error.message : String(error)}&#x60;));
      }
    }

    const totalErrors &#x3D; errors.length + syntaxErrors;

    if (totalErrors &#x3D;&#x3D;&#x3D; 0) {
      console.log(chalk.green(&amp;#39;\nğŸ‰ All templates are valid and ready to use!&amp;#39;));
      return 0;
    }
    console.log(chalk.red(&#x60;\nğŸ’¥ Found ${totalErrors} error(s) in templates.&#x60;));
    return 1;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Failed to validate templates:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Generate a specific template for testing
 */
async function generateTemplate(
  templateType: string,
  options: GitHubTemplateOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  try {
    console.log(chalk.blue(&#x60;ğŸ¯ Generating ${templateType} template...\n&#x60;));

    const templatesConfig &#x3D; config.github?.templates || {};
    const templateManager &#x3D; new FileBasedTemplateManager(templatesConfig, config.projectDir);

    // Get sample data for the template type
    const sampleData &#x3D; getSampleDataForTemplate(templateType);
    let result;

    switch (templateType.toLowerCase()) {
      case &amp;#39;epic&amp;#39;:
        result &#x3D; await templateManager.generateEpicTemplate(sampleData);
        break;
      case &amp;#39;task&amp;#39;:
        result &#x3D; await templateManager.generateTaskTemplate(sampleData.task, sampleData.epic);
        break;
      case &amp;#39;bug-report&amp;#39;:
      case &amp;#39;bug&amp;#39;:
        result &#x3D; await templateManager.generateBugReportTemplate(sampleData);
        break;
      case &amp;#39;feature-request&amp;#39;:
      case &amp;#39;feature&amp;#39;:
        result &#x3D; await templateManager.generateFeatureRequestTemplate(sampleData);
        break;
      default:
        console.error(chalk.red(&#x60;Unknown template type: ${templateType}&#x60;));
        console.log(&amp;#39;Available types: epic, task, bug-report, feature-request&amp;#39;);
        return 1;
    }

    console.log(chalk.green(&amp;#39;Generated Template Output:\n&amp;#39;));
    console.log(chalk.cyan(&#x60;Title: ${result.title}\n&#x60;));
    console.log(chalk.dim(&amp;#39;Body:&amp;#39;));
    console.log(result.body);

    if (result.labels.length &amp;gt; 0) {
      console.log(chalk.dim(&#x60;\nLabels: ${result.labels.join(&amp;#39;, &amp;#39;)}&#x60;));
    }

    if (result.assignees &amp;amp;&amp;amp; result.assignees.length &amp;gt; 0) {
      console.log(chalk.dim(&#x60;Assignees: ${result.assignees.join(&amp;#39;, &amp;#39;)}&#x60;));
    }

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&#x60;Failed to generate ${templateType} template:&#x60;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Update config.json to reference template files
 */
async function updateConfigForTemplates(config: CLIConfig, templatesDir: string): Promise&amp;lt;void&amp;gt; {
  const configPath &#x3D; path.join(config.projectDir, &amp;#39;.arbiter&amp;#39;, &amp;#39;config.json&amp;#39;);

  // Read existing config
  let existingConfig: any &#x3D; {};
  if (await fs.pathExists(configPath)) {
    existingConfig &#x3D; await fs.readJson(configPath);
  }

  // Ensure github.templates structure exists
  if (!existingConfig.github) {
    existingConfig.github &#x3D; {};
  }
  if (!existingConfig.github.templates) {
    existingConfig.github.templates &#x3D; {};
  }

  // Get relative path from project root
  const relativeTemplatesDir &#x3D; path.relative(config.projectDir, templatesDir);

  // Update templates configuration
  existingConfig.github.templates &#x3D; {
    ...existingConfig.github.templates,
    discoveryPaths: [relativeTemplatesDir, &amp;#39;~/.arbiter/templates/github&amp;#39;],
    defaultExtension: &amp;#39;hbs&amp;#39;,
    base: {
      file: &amp;#39;base.hbs&amp;#39;,
      metadata: {
        name: &amp;#39;Arbiter Base Template&amp;#39;,
        description: &amp;#39;Base template for all Arbiter-managed GitHub issues&amp;#39;,
      },
    },
    epic: {
      file: &amp;#39;epic.hbs&amp;#39;,
      inherits: &amp;#39;base.hbs&amp;#39;,
      metadata: {
        name: &amp;#39;Epic&amp;#39;,
        description: &amp;#39;Template for epic issues&amp;#39;,
        labels: [&amp;#39;epic&amp;#39;, &amp;#39;priority:{{priority}}&amp;#39;, &amp;#39;status:{{status}}&amp;#39;],
      },
    },
    task: {
      file: &amp;#39;task.hbs&amp;#39;,
      inherits: &amp;#39;base.hbs&amp;#39;,
      metadata: {
        name: &amp;#39;Task&amp;#39;,
        description: &amp;#39;Template for task issues&amp;#39;,
        labels: [&amp;#39;type:{{type}}&amp;#39;, &amp;#39;priority:{{priority}}&amp;#39;, &amp;#39;status:{{status}}&amp;#39;, &amp;#39;epic:{{epicId}}&amp;#39;],
      },
    },
    bugReport: {
      file: &amp;#39;bug-report.hbs&amp;#39;,
      metadata: {
        name: &amp;#39;Bug Report&amp;#39;,
        description: &amp;#39;Template for bug report issues&amp;#39;,
        labels: [&amp;#39;type:bug&amp;#39;, &amp;#39;priority:{{priority}}&amp;#39;],
      },
    },
    featureRequest: {
      file: &amp;#39;feature-request.hbs&amp;#39;,
      metadata: {
        name: &amp;#39;Feature Request&amp;#39;,
        description: &amp;#39;Template for feature request issues&amp;#39;,
        labels: [&amp;#39;type:feature&amp;#39;, &amp;#39;priority:{{priority}}&amp;#39;],
      },
    },
  };

  // Write updated config
  await fs.writeJson(configPath, existingConfig, { spaces: 2 });
  console.log(chalk.dim(&amp;#39;ğŸ“ Updated .arbiter/config.json with template references&amp;#39;));
}

/**
 * Get sample data for template testing
 */
function getSampleDataForTemplate(templateType: string): any {
  const baseData &#x3D; {
    id: &amp;#39;sample-001&amp;#39;,
    name: &amp;#39;Sample Item&amp;#39;,
    description: &amp;#39;This is a sample description for testing the template.&amp;#39;,
    priority: &amp;#39;high&amp;#39;,
    status: &amp;#39;in_progress&amp;#39;,
    assignee: &amp;#39;sample-user&amp;#39;,
    estimatedHours: 8,
    acceptanceCriteria: [
      &amp;#39;First acceptance criterion&amp;#39;,
      &amp;#39;Second acceptance criterion&amp;#39;,
      &amp;#39;Third acceptance criterion&amp;#39;,
    ],
    dependencies: [&amp;#39;Complete prerequisite task A&amp;#39;, &amp;#39;Review with stakeholders&amp;#39;],
  };

  switch (templateType.toLowerCase()) {
    case &amp;#39;epic&amp;#39;:
      return {
        ...baseData,
        name: &amp;#39;Sample Epic&amp;#39;,
        successCriteria:
          &amp;#39;Epic is complete when all tasks are done and users can successfully use the new feature&amp;#39;,
        inScope: [&amp;#39;Feature A development&amp;#39;, &amp;#39;Integration testing&amp;#39;, &amp;#39;User documentation&amp;#39;],
        outOfScope: [&amp;#39;Advanced analytics&amp;#39;, &amp;#39;Mobile app updates&amp;#39;],
        tasks: [
          {
            id: &amp;#39;task-001&amp;#39;,
            name: &amp;#39;Implement core functionality&amp;#39;,
            type: &amp;#39;feature&amp;#39;,
            priority: &amp;#39;high&amp;#39;,
            status: &amp;#39;todo&amp;#39;,
            estimatedHours: 5,
          },
          {
            id: &amp;#39;task-002&amp;#39;,
            name: &amp;#39;Add error handling&amp;#39;,
            type: &amp;#39;feature&amp;#39;,
            priority: &amp;#39;medium&amp;#39;,
            status: &amp;#39;todo&amp;#39;,
            estimatedHours: 3,
          },
        ],
        stakeholders: [
          { role: &amp;#39;Product Owner&amp;#39;, username: &amp;#39;product-owner&amp;#39; },
          { role: &amp;#39;Tech Lead&amp;#39;, username: &amp;#39;tech-lead&amp;#39; },
        ],
      };

    case &amp;#39;task&amp;#39;:
      return {
        task: {
          ...baseData,
          name: &amp;#39;Sample Task&amp;#39;,
          type: &amp;#39;feature&amp;#39;,
          context: &amp;#39;This task is needed to implement the new user authentication flow.&amp;#39;,
          implementationNotes:
            &amp;#39;Use the existing authentication library and extend it for SSO support.&amp;#39;,
          testScenarios: [
            &amp;#39;User logs in with SSO&amp;#39;,
            &amp;#39;User logs in with existing credentials&amp;#39;,
            &amp;#39;Invalid credentials are handled correctly&amp;#39;,
          ],
          technicalNotes: &amp;#39;Requires updating the user model and adding new API endpoints.&amp;#39;,
          subtasks: [
            { name: &amp;#39;Update user model&amp;#39;, description: &amp;#39;Add SSO fields to user schema&amp;#39; },
            { name: &amp;#39;Create SSO endpoints&amp;#39;, description: &amp;#39;Implement /auth/sso endpoints&amp;#39; },
          ],
        },
        epic: {
          id: &amp;#39;epic-001&amp;#39;,
          name: &amp;#39;User Authentication Epic&amp;#39;,
        },
      };

    case &amp;#39;bug-report&amp;#39;:
    case &amp;#39;bug&amp;#39;:
      return {
        ...baseData,
        summary: &amp;#39;Login button not responding on Safari&amp;#39;,
        stepsToReproduce: [
          &amp;#39;Open the application in Safari browser&amp;#39;,
          &amp;#39;Navigate to the login page&amp;#39;,
          &amp;quot;Click the &amp;#39;Log In&amp;#39; button&amp;quot;,
          &amp;#39;Observe that nothing happens&amp;#39;,
        ],
        expectedBehavior: &amp;#39;Login modal should appear when clicking the Log In button&amp;#39;,
        actualBehavior: &amp;#39;Clicking the button has no effect and no modal appears&amp;#39;,
        environment: {
          os: &amp;#39;macOS 12.6&amp;#39;,
          browser: &amp;#39;Safari 16.1&amp;#39;,
          version: &amp;#39;v2.1.0&amp;#39;,
          additional: &amp;#39;Issue only occurs on Safari, works fine on Chrome and Firefox&amp;#39;,
        },
        impact: {
          affectedUsers: &amp;#39;~15% of users using Safari browser&amp;#39;,
          frequency: &amp;#39;Every time user tries to log in via Safari&amp;#39;,
          businessImpact: &amp;#39;Users cannot access the application, leading to potential churn&amp;#39;,
        },
        workaround: &amp;#39;Users can use Chrome or Firefox browser as an alternative&amp;#39;,
        severity: &amp;#39;high&amp;#39;,
        reportedBy: &amp;#39;qa-tester&amp;#39;,
      };

    case &amp;#39;feature-request&amp;#39;:
    case &amp;#39;feature&amp;#39;:
      return {
        ...baseData,
        summary: &amp;#39;Add dark mode support&amp;#39;,
        problemStatement:
          &amp;#39;Many users work in low-light environments and find the current light theme straining on their eyes, especially during extended usage sessions.&amp;#39;,
        proposedSolution:
          &amp;#39;Implement a dark mode theme that users can toggle between light and dark modes. The preference should be saved and persist across sessions.&amp;#39;,
        useCases: [
          {
            userType: &amp;#39;developer&amp;#39;,
            goal: &amp;#39;work in low-light environments&amp;#39;,
            benefit: &amp;#39;I can reduce eye strain during long coding sessions&amp;#39;,
          },
          {
            userType: &amp;#39;designer&amp;#39;,
            goal: &amp;#39;review designs in different contexts&amp;#39;,
            benefit: &amp;#39;I can see how designs look in both light and dark themes&amp;#39;,
          },
          {
            userType: &amp;#39;power user&amp;#39;,
            goal: &amp;#39;customize my interface&amp;#39;,
            benefit: &amp;#39;I can personalize my workspace according to my preferences&amp;#39;,
          },
        ],
        alternativesConsidered:
          &amp;#39;We considered automatic dark mode based on system settings, but decided to give users explicit control over the theme choice.&amp;#39;,
        impact: {
          potentialUsers: &amp;#39;Survey indicates 60% of users would use dark mode&amp;#39;,
          businessValue: &amp;#39;Improved user satisfaction and reduced eye strain complaints&amp;#39;,
          technicalComplexity: &amp;#39;Medium - requires CSS theme system and preference storage&amp;#39;,
          dependencies: &amp;#39;None - can be implemented independently&amp;#39;,
        },
        technicalRequirements: [
          &amp;#39;CSS custom properties for theme switching&amp;#39;,
          &amp;#39;User preference storage in localStorage/database&amp;#39;,
          &amp;#39;Toggle component in user settings&amp;#39;,
          &amp;#39;Dark mode versions of all UI components&amp;#39;,
        ],
        targetVersion: &amp;#39;v2.2.0&amp;#39;,
        effortEstimate: &amp;#39;2-3 sprints&amp;#39;,
        requestedBy: &amp;#39;user-research-team&amp;#39;,
      };

    default:
      return baseData;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-57">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/performance.ts</div>
                <div class="file-content">
                    <pre>import { performance } from &amp;#39;node:perf_hooks&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;

/**
 * Performance measurement utility for CLI operations
 */
export class PerformanceTracker {
  private measurements &#x3D; new Map&amp;lt;string, number&amp;gt;();
  private marks &#x3D; new Map&amp;lt;string, number&amp;gt;();

  /**
   * Start measuring an operation
   */
  mark(name: string): void {
    this.marks.set(name, performance.now());
  }

  /**
   * End measuring an operation and store the duration
   */
  measure(name: string, startMark?: string): number {
    const endTime &#x3D; performance.now();
    const startTime &#x3D; startMark ? this.marks.get(startMark) || 0 : this.marks.get(name) || 0;
    const duration &#x3D; endTime - startTime;

    this.measurements.set(name, duration);
    return duration;
  }

  /**
   * Get measurement duration
   */
  getDuration(name: string): number | undefined {
    return this.measurements.get(name);
  }

  /**
   * Get all measurements
   */
  getAllMeasurements(): Record&amp;lt;string, number&amp;gt; {
    return Object.fromEntries(this.measurements);
  }

  /**
   * Manually record a measurement duration
   */
  record(name: string, duration: number): void {
    this.measurements.set(name, duration);
  }

  /**
   * Clear all measurements
   */
  clear(): void {
    this.measurements.clear();
    this.marks.clear();
  }

  /**
   * Print performance report
   */
  printReport(title &#x3D; &amp;#39;Performance Report&amp;#39;): void {
    console.log(chalk.cyan(&#x60;\n${title}:&#x60;));

    const sorted &#x3D; Array.from(this.measurements.entries()).sort(([, a], [, b]) &#x3D;&amp;gt; b - a);

    for (const [name, duration] of sorted) {
      const color &#x3D; duration &amp;lt; 100 ? &amp;#39;green&amp;#39; : duration &amp;lt; 500 ? &amp;#39;yellow&amp;#39; : &amp;#39;red&amp;#39;;
      console.log(&#x60;  ${chalk[color](formatDuration(duration).padStart(8))} ${name}&#x60;);
    }

    const total &#x3D; Array.from(this.measurements.values()).reduce((a, b) &#x3D;&amp;gt; a + b, 0);
    console.log(&#x60;  ${chalk.bold(formatDuration(total).padStart(8))} Total&#x60;);
  }
}

/**
 * Format duration with appropriate units
 */
export function formatDuration(ms: number): string {
  if (ms &amp;lt; 1) {
    return &#x60;${(ms * 1000).toFixed(0)}Î¼s&#x60;;
  }
  if (ms &amp;lt; 1000) {
    return &#x60;${ms.toFixed(1)}ms&#x60;;
  }
  return &#x60;${(ms / 1000).toFixed(2)}s&#x60;;
}

/**
 * Measure async function execution time
 */
export async function measureAsync&amp;lt;T&amp;gt;(
  name: string,
  fn: () &#x3D;&amp;gt; Promise&amp;lt;T&amp;gt;,
  tracker?: PerformanceTracker
): Promise&amp;lt;{ result: T; duration: number }&amp;gt; {
  const start &#x3D; performance.now();
  try {
    const result &#x3D; await fn();
    const duration &#x3D; performance.now() - start;

    if (tracker) {
      tracker.record(name, duration);
    }

    return { result, duration };
  } catch (error) {
    const duration &#x3D; performance.now() - start;

    if (tracker) {
      tracker.record(&#x60;${name} (failed)&#x60;, duration);
    }

    throw error;
  }
}

/**
 * Measure sync function execution time
 */
export function measureSync&amp;lt;T&amp;gt;(
  name: string,
  fn: () &#x3D;&amp;gt; T,
  tracker?: PerformanceTracker
): { result: T; duration: number } {
  const start &#x3D; performance.now();
  try {
    const result &#x3D; fn();
    const duration &#x3D; performance.now() - start;

    if (tracker) {
      tracker.record(name, duration);
    }

    return { result, duration };
  } catch (error) {
    const duration &#x3D; performance.now() - start;

    if (tracker) {
      tracker.record(&#x60;${name} (failed)&#x60;, duration);
    }

    throw error;
  }
}

/**
 * Performance optimization configurations
 */
export const PERFORMANCE_TARGETS &#x3D; {
  /** Target for check command on 10KB documents (P95) */
  CHECK_10KB_P95: 1000, // 1 second

  /** Target for API response time */
  API_RESPONSE: 200, // 200ms

  /** Target for file I/O operations */
  FILE_IO: 50, // 50ms

  /** Target for validation per file */
  VALIDATION_PER_FILE: 100, // 100ms

  /** Maximum concurrent validations */
  MAX_CONCURRENCY: 5,
};

/**
 * Check if performance targets are met
 */
export function checkPerformanceTargets(
  measurements: Record&amp;lt;string, number&amp;gt;,
  targets: Record&amp;lt;string, number&amp;gt; &#x3D; PERFORMANCE_TARGETS
): {
  passed: boolean;
  violations: Array&amp;lt;{ name: string; actual: number; target: number }&amp;gt;;
} {
  const violations: Array&amp;lt;{ name: string; actual: number; target: number }&amp;gt; &#x3D; [];

  for (const [name, target] of Object.entries(targets)) {
    const actual &#x3D; measurements[name];
    if (actual !&#x3D;&#x3D; undefined &amp;amp;&amp;amp; actual &amp;gt; target) {
      violations.push({ name, actual, target });
    }
  }

  return {
    passed: violations.length &#x3D;&#x3D;&#x3D; 0,
    violations,
  };
}

/**
 * Global performance tracker instance
 */
export const globalTracker &#x3D; new PerformanceTracker();

/**
 * Decorator for measuring method performance
 */
export function measured(name?: string) {
  return (target: any, propertyName: string, descriptor: PropertyDescriptor) &#x3D;&amp;gt; {
    const method &#x3D; descriptor.value;
    const measurementName &#x3D; name || &#x60;${target.constructor.name}.${propertyName}&#x60;;

    descriptor.value &#x3D; async function (...args: any[]) {
      const { result, duration } &#x3D; await measureAsync(
        measurementName,
        () &#x3D;&amp;gt; method.apply(this, args),
        globalTracker
      );
      return result;
    };
  };
}

/**
 * Performance benchmark for CLI commands
 */
export class CLIBenchmark {
  private results: Array&amp;lt;{
    command: string;
    args: string[];
    duration: number;
    exitCode: number;
  }&amp;gt; &#x3D; [];

  /**
   * Add benchmark result
   */
  addResult(command: string, args: string[], duration: number, exitCode: number): void {
    this.results.push({ command, args, duration, exitCode });
  }

  /**
   * Get statistics for a command
   */
  getStats(command: string): {
    count: number;
    avgDuration: number;
    minDuration: number;
    maxDuration: number;
    p95Duration: number;
    successRate: number;
  } | null {
    const commandResults &#x3D; this.results.filter(r &#x3D;&amp;gt; r.command &#x3D;&#x3D;&#x3D; command);

    if (commandResults.length &#x3D;&#x3D;&#x3D; 0) {
      return null;
    }

    const durations &#x3D; commandResults.map(r &#x3D;&amp;gt; r.duration).sort((a, b) &#x3D;&amp;gt; a - b);
    const successCount &#x3D; commandResults.filter(r &#x3D;&amp;gt; r.exitCode &#x3D;&#x3D;&#x3D; 0).length;

    return {
      count: commandResults.length,
      avgDuration: durations.reduce((a, b) &#x3D;&amp;gt; a + b) / durations.length,
      minDuration: durations[0],
      maxDuration: durations[durations.length - 1],
      p95Duration: durations[Math.floor(durations.length * 0.95)],
      successRate: successCount / commandResults.length,
    };
  }

  /**
   * Print benchmark report
   */
  printReport(): void {
    const commands &#x3D; [...new Set(this.results.map(r &#x3D;&amp;gt; r.command))];

    console.log(chalk.cyan(&amp;#39;\nCLI Performance Benchmark:&amp;#39;));
    console.log(&amp;#39;&amp;#39;.padEnd(60, &amp;#39;-&amp;#39;));

    for (const command of commands) {
      const stats &#x3D; this.getStats(command);
      if (!stats) continue;

      console.log(&#x60;${chalk.bold(command)}:&#x60;);
      console.log(&#x60;  Count:       ${stats.count}&#x60;);
      console.log(&#x60;  Success:     ${(stats.successRate * 100).toFixed(1)}%&#x60;);
      console.log(&#x60;  Avg:         ${formatDuration(stats.avgDuration)}&#x60;);
      console.log(&#x60;  Min:         ${formatDuration(stats.minDuration)}&#x60;);
      console.log(&#x60;  Max:         ${formatDuration(stats.maxDuration)}&#x60;);
      console.log(&#x60;  P95:         ${formatDuration(stats.p95Duration)}&#x60;);

      // Check against targets
      const target &#x3D; PERFORMANCE_TARGETS.CHECK_10KB_P95;
      if (command &#x3D;&#x3D;&#x3D; &amp;#39;check&amp;#39; &amp;amp;&amp;amp; stats.p95Duration &amp;gt; target) {
        console.log(&#x60;  ${chalk.red(&amp;#39;âš  P95 exceeds target&amp;#39;)} (${formatDuration(target)})&#x60;);
      } else if (command &#x3D;&#x3D;&#x3D; &amp;#39;check&amp;#39;) {
        console.log(&#x60;  ${chalk.green(&amp;#39;âœ“ P95 meets target&amp;#39;)} (${formatDuration(target)})&#x60;);
      }

      console.log();
    }
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-58">
                <div class="file-header">ğŸ“„ apps/api/src/types.ts</div>
                <div class="file-content">
                    <pre>/**
 * Core domain types for Spec Workbench backend
 */

// Database entity types
export interface Project {
  id: string;
  name: string;
  created_at: string;
  updated_at: string;
}

export interface Fragment {
  id: string;
  project_id: string;
  path: string;
  content: string;
  created_at: string;
  updated_at: string;
  head_revision_id?: string;
}

export interface FragmentRevision {
  id: string;
  fragment_id: string;
  revision_number: number;
  content: string;
  content_hash: string;
  author?: string;
  message?: string;
  created_at: string;
}

export interface Version {
  id: string;
  project_id: string;
  spec_hash: string;
  resolved_json: string;
  created_at: string;
}

export interface Event {
  id: string;
  project_id: string;
  event_type: EventType;
  data: Record&amp;lt;string, unknown&amp;gt;;
  created_at: string;
}

// Event types for real-time collaboration
export type EventType &#x3D;
  | &amp;#39;fragment_created&amp;#39;
  | &amp;#39;fragment_updated&amp;#39;
  | &amp;#39;fragment_deleted&amp;#39;
  | &amp;#39;fragment_revision_created&amp;#39;
  | &amp;#39;validation_started&amp;#39;
  | &amp;#39;validation_completed&amp;#39;
  | &amp;#39;validation_failed&amp;#39;
  | &amp;#39;version_frozen&amp;#39;
  | &amp;#39;webhook_received&amp;#39;
  | &amp;#39;git_push_processed&amp;#39;
  | &amp;#39;git_merge_processed&amp;#39;;

// API request/response types
export interface CreateFragmentRequest {
  path: string;
  content: string;
}

export interface CreateFragmentResponse {
  id: string;
  path: string;
  created_at: string;
}

export interface ResolvedSpecResponse {
  spec_hash: string;
  resolved: Record&amp;lt;string, unknown&amp;gt;;
  last_updated: string;
}

export interface ValidationRequest {
  force?: boolean;
}

export interface ValidationResponse {
  success: boolean;
  spec_hash: string;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

export interface ValidationError {
  type: &amp;#39;schema&amp;#39; | &amp;#39;assertion&amp;#39; | &amp;#39;custom&amp;#39;;
  message: string;
  location?: string;
  details?: Record&amp;lt;string, unknown&amp;gt;;
}

export interface ValidationWarning {
  type: &amp;#39;orphan_token&amp;#39; | &amp;#39;coverage&amp;#39; | &amp;#39;duplicate&amp;#39;;
  message: string;
  location?: string;
}

// Gap analysis types
export interface GapSet {
  missing_capabilities: string[];
  orphaned_tokens: TokenReference[];
  coverage_gaps: CoverageGap[];
  duplicates: Duplicate[];
}

export interface TokenReference {
  token: string;
  defined_in: string[];
  referenced_in: string[];
}

export interface CoverageGap {
  capability: string;
  expected_coverage: number;
  actual_coverage: number;
  missing_scenarios: string[];
}

export interface Duplicate {
  type: &amp;#39;capability&amp;#39; | &amp;#39;requirement&amp;#39; | &amp;#39;test_case&amp;#39;;
  name: string;
  locations: string[];
}

// IR (Intermediate Representation) types for diagrams
export type IRKind &#x3D;
  | &amp;#39;flow&amp;#39;
  | &amp;#39;fsm&amp;#39;
  | &amp;#39;view&amp;#39;
  | &amp;#39;site&amp;#39;
  | &amp;#39;capabilities&amp;#39;
  | &amp;#39;flows&amp;#39;
  | &amp;#39;dependencies&amp;#39;
  | &amp;#39;coverage&amp;#39;;

export interface IRResponse {
  kind: IRKind;
  data: Record&amp;lt;string, unknown&amp;gt;;
  generated_at: string;
}

// Version freezing
export interface FreezeRequest {
  version_name: string;
  description?: string;
}

export interface FreezeResponse {
  version_id: string;
  spec_hash: string;
  frozen_at: string;
}

// Authentication
export interface AuthContext {
  token: string;
  user_id?: string;
  project_access: string[];
  oauth_token?: any; // OAuth JWT token for scope checking
}

// External tool execution results
export interface ExternalToolResult {
  success: boolean;
  stdout: string;
  stderr: string;
  exit_code: number;
  duration_ms: number;
}

// Rate limiting
export interface RateLimitBucket {
  tokens: number;
  last_refill: number;
  max_tokens: number;
  refill_rate: number;
}

// WebSocket message types
export interface WebSocketMessage {
  type: &amp;#39;event&amp;#39; | &amp;#39;error&amp;#39; | &amp;#39;ping&amp;#39; | &amp;#39;pong&amp;#39;;
  project_id?: string;
  data: Record&amp;lt;string, unknown&amp;gt;;
}

// NATS integration types
export interface NatsSpecEvent {
  topic: string;
  projectId: string;
  event: Omit&amp;lt;Event, &amp;#39;id&amp;#39; | &amp;#39;created_at&amp;#39;&amp;gt;;
  metadata: {
    timestamp: string;
    specHash?: string;
    sequence: number;
  };
}

export interface NatsConfig {
  url?: string;
  enabled: boolean;
  reconnectTimeWait: number;
  maxReconnectAttempts: number;
  topicPrefix: string;
}

// Error response structure (RFC 7807 Problem Details)
export interface ProblemDetails {
  type: string;
  title: string;
  status: number;
  detail?: string;
  instance?: string;
  [key: string]: unknown;
}

// Webhook types
export interface WebhookPayload {
  repository: {
    full_name: string;
    clone_url: string;
    default_branch?: string;
  };
  commits?: Array&amp;lt;{
    id: string;
    message: string;
    author: {
      name: string;
      email: string;
    };
    modified?: string[];
    added?: string[];
    removed?: string[];
  }&amp;gt;;
  ref?: string;
  before?: string;
  after?: string;
  action?: string;
  merge_request?: {
    id: number;
    state: string;
    target_branch: string;
    source_branch: string;
  };
  pull_request?: {
    id: number;
    state: string;
    base: { ref: string };
    head: { ref: string };
  };
}

export interface WebhookConfig {
  id: string;
  project_id: string;
  provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;;
  repository_url: string;
  secret_hash?: string;
  enabled: boolean;
  events: WebhookEventType[];
  created_at: string;
  updated_at: string;
}

export type WebhookEventType &#x3D; &amp;#39;push&amp;#39; | &amp;#39;merge_request&amp;#39; | &amp;#39;pull_request&amp;#39; | &amp;#39;tag&amp;#39;;

export interface WebhookRequest {
  provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;;
  event: string;
  signature?: string;
  payload: WebhookPayload;
  timestamp: string;
}

export interface WebhookResponse {
  success: boolean;
  message: string;
  actions_taken?: string[];
  project_id?: string;
}

// Configuration
export interface ServerConfig {
  port: number;
  host: string;
  database_path: string;
  spec_workdir: string;
  cue_binary_path: string;
  jq_binary_path: string;
  auth_required: boolean;
  rate_limit: {
    max_tokens: number;
    refill_rate: number; // tokens per second
    window_ms: number;
  };
  external_tool_timeout_ms: number;
  websocket: {
    max_connections: number;
    ping_interval_ms: number;
  };
  nats?: NatsConfig;
  webhooks?: {
    enabled: boolean;
    secret?: string;
    github_secret?: string;
    gitlab_secret?: string;
    allowed_repos?: string[];
    sync_on_push: boolean;
    validate_on_merge: boolean;
  };
  handlers?: {
    enableAutoReload: boolean;
    maxConcurrentExecutions: number;
    defaultTimeout: number;
    defaultRetries: number;
    sandboxEnabled: boolean;
    allowedModules: string[];
    enableMetrics: boolean;
    notifications?: {
      email?: {
        mode?: &amp;#39;disabled&amp;#39; | &amp;#39;log&amp;#39; | &amp;#39;smtp&amp;#39;;
        from?: string;
        smtp?: {
          host?: string;
          port?: number;
          secure?: boolean;
          user?: string;
          pass?: string;
        };
      };
    };
  };
  oauth?: {
    enabled: boolean;
    mcpBaseUrl: string;
    authServerUrl: string;
    authServerPort: number;
    enableAuthServer: boolean;
    requiredScopes?: string[];
  };
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-59">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/github-templates.ts</div>
                <div class="file-content">
                    <pre>import fs from &amp;#39;node:fs/promises&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import { getDefaultConfigPath, loadConfig, saveConfig } from &amp;#39;../config.js&amp;#39;;
import type { CLIConfig, TemplateManagementOptions } from &amp;#39;../types.js&amp;#39;;
import { FileBasedTemplateManager } from &amp;#39;../utils/file-based-template-manager.js&amp;#39;;
import {
  ConfigurableTemplateManager,
  DEFAULT_TEMPLATES_CONFIG,
} from &amp;#39;../utils/github-template-config.js&amp;#39;;

/**
 * GitHub Template management command - list, add, remove, and validate GitHub templates
 */
export async function githubTemplatesCommand(
  options: TemplateManagementOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  try {
    // Load current configuration
    const currentConfig &#x3D; await loadConfig();
    const templateManager &#x3D; new ConfigurableTemplateManager(currentConfig.github?.templates);
    const fileBasedTemplateManager &#x3D; new FileBasedTemplateManager(
      currentConfig.github?.templates || {},
      config.projectDir
    );

    // List templates
    if (options.list) {
      return await listTemplates(templateManager, options.format || &amp;#39;table&amp;#39;);
    }

    // Show specific template
    if (options.show &amp;amp;&amp;amp; options.name) {
      return await showTemplate(templateManager, options.name, options.format || &amp;#39;table&amp;#39;);
    }

    // Validate template configuration
    if (options.validate) {
      return await validateTemplates(templateManager);
    }

    // Initialize/scaffold templates
    if (options.init || options.scaffold) {
      return await scaffoldTemplates(options, config, fileBasedTemplateManager);
    }

    // Generate template example
    if (options.generate) {
      return await generateTemplateExample(options.generate, fileBasedTemplateManager);
    }

    // Add template (interactive or from config)
    if (options.add) {
      console.log(chalk.yellow(&amp;#39;âš ï¸  Adding custom templates via CLI is not yet implemented.&amp;#39;));
      console.log(chalk.cyan(&amp;#39;ğŸ’¡ To add custom templates, edit your .arbiter/config.json file:&amp;#39;));
      console.log(chalk.dim(&#x60;    ${getDefaultConfigPath()}&#x60;));
      console.log(chalk.dim(&amp;#39;   Add templates under github.templates section&amp;#39;));
      console.log(chalk.cyan(&amp;#39;ğŸ’¡ Or use --init to scaffold file-based templates:&amp;#39;));
      console.log(chalk.dim(&amp;#39;   arbiter github-templates --init&amp;#39;));
      return 0;
    }

    // Remove template
    if (options.remove &amp;amp;&amp;amp; options.name) {
      return await removeTemplate(options.name, currentConfig);
    }

    // Default: show available commands
    console.log(chalk.blue(&amp;#39;ğŸ“ GitHub Template Management&amp;#39;));
    console.log(&amp;#39;&amp;#39;);
    console.log(&amp;#39;Available commands:&amp;#39;);
    console.log(&#x60;${chalk.cyan(&amp;#39;  --list                 &amp;#39;)}List all available templates&#x60;);
    console.log(&#x60;${chalk.cyan(&amp;#39;  --show &amp;lt;name&amp;gt;          &amp;#39;)}Show details of a specific template&#x60;);
    console.log(&#x60;${chalk.cyan(&amp;#39;  --validate             &amp;#39;)}Validate template configuration&#x60;);
    console.log(&#x60;${chalk.cyan(&amp;#39;  --add                  &amp;#39;)}Add a new template (interactive)&#x60;);
    console.log(
      &#x60;${chalk.cyan(&amp;#39;  --init                 &amp;#39;)}Initialize/scaffold file-based templates&#x60;
    );
    console.log(&#x60;${chalk.cyan(&amp;#39;  --scaffold             &amp;#39;)}Scaffold template directory structure&#x60;);
    console.log(&#x60;${chalk.cyan(&amp;#39;  --generate &amp;lt;type&amp;gt;      &amp;#39;)}Generate template example&#x60;);
    console.log(&#x60;${chalk.cyan(&amp;#39;  --remove &amp;lt;name&amp;gt;        &amp;#39;)}Remove a template&#x60;);
    console.log(&amp;#39;&amp;#39;);
    console.log(&amp;#39;Format options:&amp;#39;);
    console.log(chalk.dim(&amp;#39;  --format table|json|yaml  Output format&amp;#39;));
    console.log(&amp;#39;&amp;#39;);
    console.log(&amp;#39;Examples:&amp;#39;);
    console.log(chalk.dim(&amp;#39;  arbiter github-templates --list&amp;#39;));
    console.log(chalk.dim(&amp;#39;  arbiter github-templates --show epic&amp;#39;));
    console.log(chalk.dim(&amp;#39;  arbiter github-templates --validate&amp;#39;));
    console.log(chalk.dim(&amp;#39;  arbiter github-templates --list --format json&amp;#39;));

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;âŒ GitHub Template management failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * List available templates
 */
async function listTemplates(
  templateManager: ConfigurableTemplateManager,
  format: &amp;#39;table&amp;#39; | &amp;#39;json&amp;#39; | &amp;#39;yaml&amp;#39;
): Promise&amp;lt;number&amp;gt; {
  const templates &#x3D; templateManager.getAvailableTemplates() as Array&amp;lt;any&amp;gt;;

  if (format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
    console.log(JSON.stringify(templates, null, 2));
    return 0;
  }

  if (format &#x3D;&#x3D;&#x3D; &amp;#39;yaml&amp;#39;) {
    const YAML &#x3D; await import(&amp;#39;yaml&amp;#39;);
    console.log(YAML.stringify(templates));
    return 0;
  }

  // Table format
  console.log(chalk.blue(&amp;#39;ğŸ“ Available GitHub Templates&amp;#39;));
  console.log(&amp;#39;&amp;#39;);

  if (templates.length &#x3D;&#x3D;&#x3D; 0) {
    console.log(chalk.yellow(&amp;#39;No templates configured&amp;#39;));
    console.log(chalk.dim(&amp;#39;Add templates to your .arbiter/config.json under github.templates&amp;#39;));
    return 0;
  }

  const maxNameWidth &#x3D; Math.max(...templates.map(t &#x3D;&amp;gt; t.name.length), 10);
  const maxTypeWidth &#x3D; Math.max(...templates.map(t &#x3D;&amp;gt; t.type.length), 8);

  // Header
  const nameHeader &#x3D; &amp;#39;NAME&amp;#39;.padEnd(maxNameWidth);
  const typeHeader &#x3D; &amp;#39;TYPE&amp;#39;.padEnd(maxTypeWidth);
  console.log(chalk.bold(&#x60;${nameHeader} ${typeHeader} DESCRIPTION&#x60;));
  console.log(&amp;#39;â”€&amp;#39;.repeat(maxNameWidth + maxTypeWidth + 20));

  // Templates
  templates.forEach(template &#x3D;&amp;gt; {
    const name &#x3D; template.name.padEnd(maxNameWidth);
    const type &#x3D; template.type.padEnd(maxTypeWidth);
    const description &#x3D; template.description || &amp;#39;No description&amp;#39;;
    console.log(&#x60;${chalk.cyan(name)} ${chalk.yellow(type)} ${chalk.dim(description)}&#x60;);
  });

  console.log(&amp;#39;&amp;#39;);
  console.log(chalk.dim(&#x60;Found ${templates.length} template(s)&#x60;));
  return 0;
}

/**
 * Show specific template details
 */
async function showTemplate(
  templateManager: ConfigurableTemplateManager,
  templateName: string,
  format: &amp;#39;table&amp;#39; | &amp;#39;json&amp;#39; | &amp;#39;yaml&amp;#39;
): Promise&amp;lt;number&amp;gt; {
  const templates &#x3D; templateManager.getAvailableTemplates();
  const template &#x3D; templates.find(t &#x3D;&amp;gt; t.name &#x3D;&#x3D;&#x3D; templateName || t.type &#x3D;&#x3D;&#x3D; templateName);

  if (!template) {
    console.error(chalk.red(&#x60;âŒ Template &amp;quot;${templateName}&amp;quot; not found&#x60;));
    console.log(chalk.dim(&amp;#39;Available templates:&amp;#39;));
    templates.forEach(t &#x3D;&amp;gt; {
      console.log(chalk.dim(&#x60;  â€¢ ${t.name} (${t.type})&#x60;));
    });
    return 1;
  }

  if (format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
    console.log(JSON.stringify(template, null, 2));
    return 0;
  }

  if (format &#x3D;&#x3D;&#x3D; &amp;#39;yaml&amp;#39;) {
    const YAML &#x3D; await import(&amp;#39;yaml&amp;#39;);
    console.log(YAML.stringify(template));
    return 0;
  }

  // Table format - show detailed template information
  console.log(chalk.blue(&#x60;ğŸ“ Template: ${template.name}&#x60;));
  console.log(&amp;#39;&amp;#39;);
  console.log(&#x60;${chalk.bold(&amp;#39;Name:&amp;#39;)}        ${template.name}&#x60;);
  console.log(&#x60;${chalk.bold(&amp;#39;Type:&amp;#39;)}        ${template.type}&#x60;);
  console.log(&#x60;${chalk.bold(&amp;#39;Description:&amp;#39;)} ${template.description || &amp;#39;No description&amp;#39;}&#x60;);
  console.log(&amp;#39;&amp;#39;);

  // Show template files that would be generated
  try {
    const allFiles &#x3D; templateManager.generateRepositoryTemplates();
    const templateFile &#x3D; Object.entries(allFiles).find(
      ([path]) &#x3D;&amp;gt; path.includes(template.type) || path.includes(template.name.toLowerCase())
    );

    if (templateFile) {
      console.log(chalk.bold(&amp;#39;Template File:&amp;#39;));
      console.log(chalk.dim(templateFile[0]));
      console.log(&amp;#39;&amp;#39;);

      // Show first few lines of template
      const lines &#x3D; templateFile[1].split(&amp;#39;\n&amp;#39;).slice(0, 10);
      lines.forEach(line &#x3D;&amp;gt; {
        console.log(chalk.dim(&#x60;  ${line}&#x60;));
      });

      if (templateFile[1].split(&amp;#39;\n&amp;#39;).length &amp;gt; 10) {
        console.log(chalk.dim(&amp;#39;  ... (truncated)&amp;#39;));
      }
    }
  } catch (error) {
    console.log(chalk.yellow(&amp;#39;âš ï¸  Could not generate template preview&amp;#39;));
  }

  return 0;
}

/**
 * Validate template configuration
 */
async function validateTemplates(templateManager: ConfigurableTemplateManager): Promise&amp;lt;number&amp;gt; {
  console.log(chalk.blue(&amp;#39;ğŸ” Validating template configuration...&amp;#39;));

  const errors &#x3D; templateManager.validateTemplateConfig();

  if (errors.length &#x3D;&#x3D;&#x3D; 0) {
    console.log(chalk.green(&amp;#39;âœ… Template configuration is valid&amp;#39;));
    return 0;
  }

  console.log(chalk.red(&amp;#39;âŒ Template configuration has errors:&amp;#39;));
  console.log(&amp;#39;&amp;#39;);

  errors.forEach(error &#x3D;&amp;gt; {
    console.log(&#x60;  ${chalk.red(&amp;#39;â€¢&amp;#39;)} ${chalk.bold(error.field)}: ${error.message}&#x60;);
  });

  console.log(&amp;#39;&amp;#39;);
  console.log(chalk.yellow(&amp;#39;ğŸ’¡ Fix these errors in your .arbiter/config.json file&amp;#39;));

  return 1;
}

/**
 * Remove a template from configuration
 */
async function removeTemplate(templateName: string, currentConfig: CLIConfig): Promise&amp;lt;number&amp;gt; {
  const configPath &#x3D; getDefaultConfigPath();

  // Check if template exists
  const availableTypes &#x3D; [&amp;#39;epic&amp;#39;, &amp;#39;task&amp;#39;, &amp;#39;bugReport&amp;#39;, &amp;#39;featureRequest&amp;#39;] as const;
  const templateType &#x3D; availableTypes.find(type &#x3D;&amp;gt; {
    const entry &#x3D; currentConfig.github?.templates?.[type];
    if (!entry) {
      return type &#x3D;&#x3D;&#x3D; templateName;
    }

    if (typeof entry &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39;) {
      return entry &#x3D;&#x3D;&#x3D; templateName || type &#x3D;&#x3D;&#x3D; templateName;
    }

    if (&amp;#39;name&amp;#39; in entry &amp;amp;&amp;amp; entry.name) {
      return entry.name &#x3D;&#x3D;&#x3D; templateName;
    }

    return type &#x3D;&#x3D;&#x3D; templateName;
  });

  if (!templateType) {
    console.error(chalk.red(&#x60;âŒ Template &amp;quot;${templateName}&amp;quot; not found&#x60;));
    return 1;
  }

  try {
    // Create updated config without the template
    const templates &#x3D; currentConfig.github?.templates
      ? { ...currentConfig.github.templates }
      : undefined;

    if (templates) {
      delete (templates as Record&amp;lt;string, unknown&amp;gt;)[templateType];
    }

    const updatedConfig: Partial&amp;lt;CLIConfig&amp;gt; &#x3D; currentConfig.github
      ? {
          ...currentConfig,
          github: {
            ...currentConfig.github,
            templates: templates &amp;amp;&amp;amp; Object.keys(templates).length &amp;gt; 0 ? templates : undefined,
          },
        }
      : { ...currentConfig };

    await saveConfig(updatedConfig, configPath);

    console.log(chalk.green(&#x60;âœ… Removed template &amp;quot;${templateName}&amp;quot;&#x60;));
    console.log(chalk.dim(&#x60;Updated configuration: ${configPath}&#x60;));

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;âŒ Failed to remove template:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Generate templates for a project
 */
export async function generateProjectTemplates(
  outputDir &#x3D; &amp;#39;.github&amp;#39;,
  config?: CLIConfig
): Promise&amp;lt;void&amp;gt; {
  const templateManager &#x3D; new ConfigurableTemplateManager(config?.github?.templates);
  const templateFiles &#x3D; templateManager.generateRepositoryTemplates();

  console.log(chalk.blue(&amp;#39;ğŸ“ Generating GitHub templates...&amp;#39;));

  let generated &#x3D; 0;
  for (const [filePath, content] of Object.entries(templateFiles)) {
    const fullPath &#x3D; path.join(outputDir, filePath.replace(&amp;#39;.github/&amp;#39;, &amp;#39;&amp;#39;));

    // Ensure directory exists
    await fs.mkdir(path.dirname(fullPath), { recursive: true });

    // Write template file
    await fs.writeFile(fullPath, content);
    console.log(chalk.green(&#x60;âœ… Generated ${filePath}&#x60;));
    generated++;
  }

  console.log(&amp;#39;&amp;#39;);
  console.log(chalk.green(&#x60;ğŸ‰ Generated ${generated} template file(s)&#x60;));
  console.log(chalk.cyan(&amp;#39;Next steps:&amp;#39;));
  console.log(chalk.dim(&amp;#39;  1. Review and customize the generated templates&amp;#39;));
  console.log(chalk.dim(&amp;#39;  2. Commit the templates to your repository&amp;#39;));
  console.log(chalk.dim(&amp;#39;  3. Configure your .arbiter/config.json for custom templates&amp;#39;));
}

/**
 * Scaffold file-based templates
 */
async function scaffoldTemplates(
  options: TemplateManagementOptions,
  config: CLIConfig,
  fileBasedTemplateManager: FileBasedTemplateManager
): Promise&amp;lt;number&amp;gt; {
  try {
    const outputDir &#x3D;
      options.outputDir || path.join(config.projectDir, &amp;#39;.arbiter&amp;#39;, &amp;#39;templates&amp;#39;, &amp;#39;github&amp;#39;);

    console.log(chalk.blue(&amp;#39;ğŸ—ï¸ Scaffolding file-based GitHub templates...&amp;#39;));
    console.log(chalk.dim(&#x60;Output directory: ${outputDir}\n&#x60;));

    // Ensure output directory exists
    await fs.mkdir(outputDir, { recursive: true });

    // Get existing templates from the created directory
    const existingTemplatesDir &#x3D; path.join(config.projectDir, &amp;#39;.arbiter&amp;#39;, &amp;#39;templates&amp;#39;, &amp;#39;github&amp;#39;);

    const templates &#x3D; [
      { name: &amp;#39;base.hbs&amp;#39;, description: &amp;#39;Base template for all GitHub issues&amp;#39; },
      { name: &amp;#39;epic.hbs&amp;#39;, description: &amp;#39;Epic template with task overview&amp;#39; },
      { name: &amp;#39;task.hbs&amp;#39;, description: &amp;#39;Task template with implementation details&amp;#39; },
      { name: &amp;#39;bug-report.hbs&amp;#39;, description: &amp;#39;Bug report template with reproduction steps&amp;#39; },
      { name: &amp;#39;feature-request.hbs&amp;#39;, description: &amp;#39;Feature request template with use cases&amp;#39; },
    ];

    let created &#x3D; 0;

    // Create template files
    for (const template of templates) {
      const sourcePath &#x3D; path.join(existingTemplatesDir, template.name);
      const targetPath &#x3D; path.join(outputDir, template.name);

      if (
        (await fs
          .access(targetPath)
          .then(() &#x3D;&amp;gt; true)
          .catch(() &#x3D;&amp;gt; false)) &amp;amp;&amp;amp;
        !options.force
      ) {
        console.log(chalk.yellow(&#x60;âš ï¸  Skipping ${template.name} (already exists)&#x60;));
        continue;
      }

      try {
        if (
          await fs
            .access(sourcePath)
            .then(() &#x3D;&amp;gt; true)
            .catch(() &#x3D;&amp;gt; false)
        ) {
          const content &#x3D; await fs.readFile(sourcePath, &amp;#39;utf-8&amp;#39;);
          await fs.writeFile(targetPath, content);
          console.log(chalk.green(&#x60;âœ… Created ${template.name}&#x60;));
          created++;
        } else {
          console.log(
            chalk.red(&#x60;âŒ Source template ${template.name} not found in ${existingTemplatesDir}&#x60;)
          );
        }
      } catch (error) {
        console.log(
          chalk.red(
            &#x60;âŒ Failed to create ${template.name}: ${error instanceof Error ? error.message : String(error)}&#x60;
          )
        );
      }

      if (options.verbose) {
        console.log(chalk.dim(&#x60;   ${template.description}&#x60;));
      }
    }

    if (created &amp;gt; 0) {
      // Update config.json to reference templates
      await updateConfigForTemplates(config, outputDir);

      console.log(chalk.green(&#x60;\nğŸ‰ Scaffolded ${created} template file(s)!&#x60;));
      console.log(chalk.dim(&amp;#39;Edit the template files to customize your GitHub issue templates.&amp;#39;));
      console.log(chalk.dim(&amp;quot;Use &amp;#39;arbiter github-templates --validate&amp;#39; to check your templates.&amp;quot;));
    } else {
      console.log(chalk.yellow(&amp;#39;\nâš ï¸  No templates were created.&amp;#39;));
      console.log(chalk.dim(&amp;#39;Use --force to overwrite existing files.&amp;#39;));
    }

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Failed to scaffold templates:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Generate template example for testing
 */
async function generateTemplateExample(
  templateType: string,
  fileBasedTemplateManager: FileBasedTemplateManager
): Promise&amp;lt;number&amp;gt; {
  try {
    console.log(chalk.blue(&#x60;ğŸ¯ Generating ${templateType} template example...\n&#x60;));

    // Get sample data for the template type
    const sampleData &#x3D; getSampleDataForTemplate(templateType);
    let result;

    switch (templateType.toLowerCase()) {
      case &amp;#39;epic&amp;#39;:
        result &#x3D; await fileBasedTemplateManager.generateEpicTemplate(sampleData);
        break;
      case &amp;#39;task&amp;#39;:
        result &#x3D; await fileBasedTemplateManager.generateTaskTemplate(
          sampleData.task,
          sampleData.epic
        );
        break;
      case &amp;#39;bug-report&amp;#39;:
      case &amp;#39;bug&amp;#39;:
        result &#x3D; await fileBasedTemplateManager.generateBugReportTemplate(sampleData);
        break;
      case &amp;#39;feature-request&amp;#39;:
      case &amp;#39;feature&amp;#39;:
        result &#x3D; await fileBasedTemplateManager.generateFeatureRequestTemplate(sampleData);
        break;
      default:
        console.error(chalk.red(&#x60;Unknown template type: ${templateType}&#x60;));
        console.log(&amp;#39;Available types: epic, task, bug-report, feature-request&amp;#39;);
        return 1;
    }

    console.log(chalk.green(&amp;#39;Generated Template Output:\n&amp;#39;));
    console.log(chalk.cyan(&#x60;Title: ${result.title}\n&#x60;));
    console.log(chalk.dim(&amp;#39;Body:&amp;#39;));
    console.log(result.body);

    if (result.labels.length &amp;gt; 0) {
      console.log(chalk.dim(&#x60;\nLabels: ${result.labels.join(&amp;#39;, &amp;#39;)}&#x60;));
    }

    if (result.assignees &amp;amp;&amp;amp; result.assignees.length &amp;gt; 0) {
      console.log(chalk.dim(&#x60;Assignees: ${result.assignees.join(&amp;#39;, &amp;#39;)}&#x60;));
    }

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&#x60;Failed to generate ${templateType} template:&#x60;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Update config.json to reference template files
 */
async function updateConfigForTemplates(config: CLIConfig, templatesDir: string): Promise&amp;lt;void&amp;gt; {
  const configPath &#x3D; getDefaultConfigPath();

  // Read existing config
  let existingConfig: any &#x3D; {};
  try {
    const configContent &#x3D; await fs.readFile(configPath, &amp;#39;utf-8&amp;#39;);
    existingConfig &#x3D; JSON.parse(configContent);
  } catch (error) {
    // Config doesn&amp;#39;t exist or is invalid, start fresh
    existingConfig &#x3D; {};
  }

  // Ensure github.templates structure exists
  if (!existingConfig.github) {
    existingConfig.github &#x3D; {};
  }
  if (!existingConfig.github.templates) {
    existingConfig.github.templates &#x3D; {};
  }

  // Get relative path from project root
  const relativeTemplatesDir &#x3D; path.relative(config.projectDir, templatesDir);

  // Update templates configuration
  existingConfig.github.templates &#x3D; {
    ...existingConfig.github.templates,
    discoveryPaths: [relativeTemplatesDir, &amp;#39;~/.arbiter/templates/github&amp;#39;],
    defaultExtension: &amp;#39;hbs&amp;#39;,
    base: {
      file: &amp;#39;base.hbs&amp;#39;,
      metadata: {
        name: &amp;#39;Arbiter Base Template&amp;#39;,
        description: &amp;#39;Base template for all Arbiter-managed GitHub issues&amp;#39;,
      },
    },
    epic: {
      file: &amp;#39;epic.hbs&amp;#39;,
      inherits: &amp;#39;base.hbs&amp;#39;,
      metadata: {
        name: &amp;#39;Epic&amp;#39;,
        description: &amp;#39;Template for epic issues&amp;#39;,
        labels: [&amp;#39;epic&amp;#39;, &amp;#39;priority:{{priority}}&amp;#39;, &amp;#39;status:{{status}}&amp;#39;],
      },
    },
    task: {
      file: &amp;#39;task.hbs&amp;#39;,
      inherits: &amp;#39;base.hbs&amp;#39;,
      metadata: {
        name: &amp;#39;Task&amp;#39;,
        description: &amp;#39;Template for task issues&amp;#39;,
        labels: [&amp;#39;type:{{type}}&amp;#39;, &amp;#39;priority:{{priority}}&amp;#39;, &amp;#39;status:{{status}}&amp;#39;, &amp;#39;epic:{{epicId}}&amp;#39;],
      },
    },
    bugReport: {
      file: &amp;#39;bug-report.hbs&amp;#39;,
      metadata: {
        name: &amp;#39;Bug Report&amp;#39;,
        description: &amp;#39;Template for bug report issues&amp;#39;,
        labels: [&amp;#39;type:bug&amp;#39;, &amp;#39;priority:{{priority}}&amp;#39;],
      },
    },
    featureRequest: {
      file: &amp;#39;feature-request.hbs&amp;#39;,
      metadata: {
        name: &amp;#39;Feature Request&amp;#39;,
        description: &amp;#39;Template for feature request issues&amp;#39;,
        labels: [&amp;#39;type:feature&amp;#39;, &amp;#39;priority:{{priority}}&amp;#39;],
      },
    },
  };

  // Write updated config
  await fs.writeFile(configPath, JSON.stringify(existingConfig, null, 2));
  console.log(chalk.dim(&amp;#39;ğŸ“ Updated .arbiter/config.json with template references&amp;#39;));
}

/**
 * Get sample data for template testing
 */
function getSampleDataForTemplate(templateType: string): any {
  const baseData &#x3D; {
    id: &amp;#39;sample-001&amp;#39;,
    name: &amp;#39;Sample Item&amp;#39;,
    description: &amp;#39;This is a sample description for testing the template.&amp;#39;,
    priority: &amp;#39;high&amp;#39;,
    status: &amp;#39;in_progress&amp;#39;,
    assignee: &amp;#39;sample-user&amp;#39;,
    estimatedHours: 8,
    acceptanceCriteria: [
      &amp;#39;First acceptance criterion&amp;#39;,
      &amp;#39;Second acceptance criterion&amp;#39;,
      &amp;#39;Third acceptance criterion&amp;#39;,
    ],
    dependencies: [&amp;#39;Complete prerequisite task A&amp;#39;, &amp;#39;Review with stakeholders&amp;#39;],
  };

  switch (templateType.toLowerCase()) {
    case &amp;#39;epic&amp;#39;:
      return {
        ...baseData,
        name: &amp;#39;Sample Epic&amp;#39;,
        successCriteria:
          &amp;#39;Epic is complete when all tasks are done and users can successfully use the new feature&amp;#39;,
        inScope: [&amp;#39;Feature A development&amp;#39;, &amp;#39;Integration testing&amp;#39;, &amp;#39;User documentation&amp;#39;],
        outOfScope: [&amp;#39;Advanced analytics&amp;#39;, &amp;#39;Mobile app updates&amp;#39;],
        tasks: [
          {
            id: &amp;#39;task-001&amp;#39;,
            name: &amp;#39;Implement core functionality&amp;#39;,
            type: &amp;#39;feature&amp;#39;,
            priority: &amp;#39;high&amp;#39;,
            status: &amp;#39;todo&amp;#39;,
            estimatedHours: 5,
          },
          {
            id: &amp;#39;task-002&amp;#39;,
            name: &amp;#39;Add error handling&amp;#39;,
            type: &amp;#39;feature&amp;#39;,
            priority: &amp;#39;medium&amp;#39;,
            status: &amp;#39;todo&amp;#39;,
            estimatedHours: 3,
          },
        ],
        stakeholders: [
          { role: &amp;#39;Product Owner&amp;#39;, username: &amp;#39;product-owner&amp;#39; },
          { role: &amp;#39;Tech Lead&amp;#39;, username: &amp;#39;tech-lead&amp;#39; },
        ],
      };

    case &amp;#39;task&amp;#39;:
      return {
        task: {
          ...baseData,
          name: &amp;#39;Sample Task&amp;#39;,
          type: &amp;#39;feature&amp;#39;,
          context: &amp;#39;This task is needed to implement the new user authentication flow.&amp;#39;,
          implementationNotes:
            &amp;#39;Use the existing authentication library and extend it for SSO support.&amp;#39;,
          testScenarios: [
            &amp;#39;User logs in with SSO&amp;#39;,
            &amp;#39;User logs in with existing credentials&amp;#39;,
            &amp;#39;Invalid credentials are handled correctly&amp;#39;,
          ],
          technicalNotes: &amp;#39;Requires updating the user model and adding new API endpoints.&amp;#39;,
          subtasks: [
            { name: &amp;#39;Update user model&amp;#39;, description: &amp;#39;Add SSO fields to user schema&amp;#39; },
            { name: &amp;#39;Create SSO endpoints&amp;#39;, description: &amp;#39;Implement /auth/sso endpoints&amp;#39; },
          ],
        },
        epic: {
          id: &amp;#39;epic-001&amp;#39;,
          name: &amp;#39;User Authentication Epic&amp;#39;,
        },
      };

    default:
      return baseData;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-60">
                <div class="file-header">ğŸ“„ packages/cli/src/types.ts</div>
                <div class="file-content">
                    <pre>/**
 * CLI configuration schema and types
 */

import type { SpinnerName } from &amp;#39;cli-spinners&amp;#39;;
import type { Spinner } from &amp;#39;ora&amp;#39;;

// Re-export issue types from shared package
export type {
  IssueSpec,
  ChecklistItem,
  IssueValidationConfig,
  IssueValidationResult,
} from &amp;#39;@arbiter/shared&amp;#39;;
export {
  DEFAULT_ISSUE_VALIDATION,
  validateIssue,
  createIssue,
  createChecklistItem,
} from &amp;#39;@arbiter/shared&amp;#39;;
export interface GitHubRepo {
  /** GitHub repository owner/organization (auto-detected from Git remote if not specified) */
  owner?: string;
  /** GitHub repository name (auto-detected from Git remote if not specified) */
  repo?: string;
  /** Base URL for GitHub API (defaults to github.com) */
  baseUrl?: string;
  /** Environment variable name for GitHub token (defaults to GITHUB_TOKEN) */
  tokenEnv?: string;
}

export interface GitHubSyncConfig {
  /** GitHub repository configuration */
  repository?: GitHubRepo;
  /** Mapping configuration for syncing */
  mapping?: {
    /** Epic to GitHub issue label mappings */
    epicLabels?: Record&amp;lt;string, string[]&amp;gt;;
    /** Task to GitHub issue label mappings */
    taskLabels?: Record&amp;lt;string, string[]&amp;gt;;
    /** Default labels to apply to all synced issues */
    defaultLabels?: string[];
    /** Prefix for epic issues */
    epicPrefix?: string;
    /** Prefix for task issues */
    taskPrefix?: string;
  };
  /** Sync behavior configuration */
  behavior?: {
    /** Create GitHub milestones for epics */
    createMilestones?: boolean;
    /** Close GitHub issues when tasks/epics are completed */
    autoClose?: boolean;
    /** Update GitHub issue descriptions with acceptance criteria */
    syncAcceptanceCriteria?: boolean;
    /** Sync assignees between systems */
    syncAssignees?: boolean;
  };
  /** GitHub templates configuration */
  templates?: GitHubTemplatesConfig;
}

export interface CLIConfig {
  /** API endpoint URL */
  apiUrl: string;
  /** Default timeout in milliseconds */
  timeout: number;
  /** Default output format */
  format: &amp;#39;table&amp;#39; | &amp;#39;json&amp;#39; | &amp;#39;yaml&amp;#39;;
  /** Enable colored output */
  color: boolean;
  /** Default project directory */
  projectDir: string;
  /** GitHub sync configuration */
  github?: GitHubSyncConfig;
}

/**
 * Command result interface for consistent error handling
 */
export interface CommandResult&amp;lt;T &#x3D; any&amp;gt; {
  success: boolean;
  data?: T;
  error?: string;
  exitCode: number;
}

/**
 * Validation result for pretty table output
 */
export interface ValidationResult {
  file: string;
  status: &amp;#39;valid&amp;#39; | &amp;#39;invalid&amp;#39; | &amp;#39;error&amp;#39;;
  errors: Array&amp;lt;{
    line: number;
    column: number;
    message: string;
    severity: &amp;#39;error&amp;#39; | &amp;#39;warning&amp;#39;;
    category: string;
  }&amp;gt;;
  warnings: Array&amp;lt;{
    line: number;
    column: number;
    message: string;
    category: string;
  }&amp;gt;;
  processingTime: number;
}

/**
 * Export format options
 */
export type ExportFormat &#x3D;
  | &amp;#39;openapi&amp;#39;
  | &amp;#39;types&amp;#39;
  | &amp;#39;k8s&amp;#39;
  | &amp;#39;terraform&amp;#39;
  | &amp;#39;json-schema&amp;#39;
  | &amp;#39;json&amp;#39;
  | &amp;#39;yaml&amp;#39;;

/**
 * Progress indicator options
 */
export interface ProgressOptions {
  text: string;
  color?: &amp;#39;blue&amp;#39; | &amp;#39;green&amp;#39; | &amp;#39;yellow&amp;#39; | &amp;#39;red&amp;#39; | &amp;#39;cyan&amp;#39; | &amp;#39;magenta&amp;#39;;
  spinner?: Spinner | SpinnerName;
}

/**
 * Step-based progress options for multi-step operations
 */
export interface StepProgressOptions {
  title: string;
  steps: string[];
  color?: &amp;#39;blue&amp;#39; | &amp;#39;green&amp;#39; | &amp;#39;yellow&amp;#39; | &amp;#39;red&amp;#39; | &amp;#39;cyan&amp;#39; | &amp;#39;magenta&amp;#39;;
  spinner?: Spinner | SpinnerName;
}

/**
 * Progress bar options for operations with known progress
 */
export interface ProgressBarOptions {
  title: string;
  total?: number;
  completeMessage?: string;
}

/**
 * Project template types
 */
export interface ProjectTemplate {
  name: string;
  description: string;
  files: Record&amp;lt;string, string&amp;gt;;
  dependencies?: string[];
}

/**
 * Init command options
 */
export interface InitOptions {
  template?: string;
  name?: string;
  force?: boolean;
}

/**
 * Check command options
 */
export interface CheckOptions {
  recursive?: boolean;
  watch?: boolean;
  format?: &amp;#39;table&amp;#39; | &amp;#39;json&amp;#39;;
  verbose?: boolean;
  failFast?: boolean;
}

/**
 * Validate command options
 */
export interface ValidateOptions {
  schema?: string;
  config?: string;
  format?: &amp;#39;table&amp;#39; | &amp;#39;json&amp;#39;;
  strict?: boolean;
  verbose?: boolean;
}

/**
 * Export command options
 */
export interface ExportOptions {
  format: ExportFormat[];
  output?: string;
  schema?: string;
  config?: string;
  minify?: boolean;
  strict?: boolean;
  verbose?: boolean;
}

/**
 * Template command options
 */
export interface TemplateOptions {
  output?: string;
  format?: &amp;#39;cue&amp;#39; | &amp;#39;json&amp;#39;;
  list?: boolean;
  interactive?: boolean;
}

/**
 * Create command options
 */
export interface CreateOptions {
  interactive?: boolean;
  template?: string;
  output?: string;
  name?: string;
}

/**
 * Import command options
 */
export interface ImportOptions {
  global?: boolean;
  list?: boolean;
  remove?: boolean;
  validate?: boolean;
  allow?: string[];
}

/**
 * Diff command options
 */
export interface DiffOptions {
  migration?: boolean;
  format?: &amp;#39;text&amp;#39; | &amp;#39;json&amp;#39;;
  context?: number;
  summary?: boolean;
}

/**
 * Execute command options for Epic v2 deterministic execution
 */
export interface ExecuteOptions {
  epic: string;
  dryRun?: boolean;
  workspace?: string;
  timeout?: number;
  junit?: string;
  verbose?: boolean;
}

/**
 * Test command options for unified test harness
 */
export interface TestOptions {
  epic?: string;
  types?: string[];
  junit?: string;
  timeout?: number;
  verbose?: boolean;
  parallel?: boolean;
  updateGolden?: boolean;
}

/**
 * Watch command options for file monitoring
 */
export interface WatchOptions {
  path?: string;
  agentMode?: boolean;
  debounce?: number;
  patterns?: string[];
  validate?: boolean;
  plan?: boolean;
}

/**
 * Surface command options for API extraction
 */
export interface SurfaceOptions {
  language: &amp;#39;typescript&amp;#39; | &amp;#39;python&amp;#39; | &amp;#39;rust&amp;#39; | &amp;#39;go&amp;#39; | &amp;#39;bash&amp;#39;;
  output?: string;
  diff?: boolean;
  includePrivate?: boolean;
  verbose?: boolean;
}

/**
 * Tests command options for scaffolding and coverage
 */
export interface TestsOptions {
  language?: &amp;#39;python&amp;#39; | &amp;#39;typescript&amp;#39; | &amp;#39;rust&amp;#39; | &amp;#39;go&amp;#39; | &amp;#39;bash&amp;#39;;
  framework?: string;
  property?: boolean;
  output?: string;
  outputDir?: string;
  threshold?: number;
  junit?: string;
  force?: boolean;
  verbose?: boolean;
}

/**
 * Version plan command options
 */
export interface VersionPlanOptions {
  /** Current surface file path */
  current?: string;
  /** Previous surface file path for comparison */
  previous?: string;
  /** Output file for version plan */
  output?: string;
  /** Enable strict mode for library compliance */
  strict?: boolean;
  /** Include all changes in analysis */
  verbose?: boolean;
}

/**
 * Version release command options
 */
export interface VersionReleaseOptions {
  /** Version plan file to execute */
  plan?: string;
  /** Specific version to set (overrides plan) */
  version?: string;
  /** Changelog output file */
  changelog?: string;
  /** Enable dry-run mode (default) */
  dryRun?: boolean;
  /** Apply changes (disables dry-run) */
  apply?: boolean;
  /** Verbose output */
  verbose?: boolean;
}

/**
 * IDE recommendation command options
 */
export interface IDEOptions {
  /** Editor type to generate config for */
  editor?: &amp;#39;vscode&amp;#39; | &amp;#39;idea&amp;#39; | &amp;#39;vim&amp;#39; | &amp;#39;all&amp;#39;;
  /** Force overwrite existing configuration */
  force?: boolean;
  /** Only detect project languages, don&amp;#39;t generate config */
  detect?: boolean;
  /** Output directory for IDE configs */
  output?: string;
  /** Output directory for IDE configs (alias for output) */
  outputDir?: string;
}

/**
 * Sync command options for manifest synchronization
 */
export interface SyncOptions {
  /** Language manifests to sync */
  language?: &amp;#39;python&amp;#39; | &amp;#39;typescript&amp;#39; | &amp;#39;rust&amp;#39; | &amp;#39;bash&amp;#39; | &amp;#39;all&amp;#39;;
  /** Sync all detected languages */
  all?: boolean;
  /** Dry run - show what would be changed */
  dryRun?: boolean;
  /** Create backup before modifying files */
  backup?: boolean;
  /** Force overwrite conflicting sections */
  force?: boolean;
}

/**
 * Integrate command options for CI/CD generation
 */
export interface IntegrateOptions {
  /** CI provider to generate workflows for */
  provider?: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39; | &amp;#39;azure&amp;#39; | &amp;#39;all&amp;#39;;
  /** Workflow type to generate */
  type?: &amp;#39;pr&amp;#39; | &amp;#39;main&amp;#39; | &amp;#39;release&amp;#39; | &amp;#39;all&amp;#39;;
  /** Output directory for CI files */
  output?: string;
  /** Force overwrite existing workflows */
  force?: boolean;
  /** Use build matrix from assembly file */
  matrix?: boolean;
  /** Generate GitHub issue templates and configuration */
  templates?: boolean;
}

/**
 * Docs command options for documentation generation
 */
export interface DocsOptions {
  /** Output format */
  format?: &amp;#39;markdown&amp;#39; | &amp;#39;html&amp;#39; | &amp;#39;json&amp;#39;;
  /** Output file path */
  output?: string;
  /** Template to use */
  template?: string;
  /** Interactive mode */
  interactive?: boolean;
  /** Generate examples */
  examples?: boolean;
}

/**
 * Examples command options for project generation
 */
export interface ExamplesOptions {
  /** Example type */
  type?: &amp;#39;profile&amp;#39; | &amp;#39;language&amp;#39;;
  /** Specific profile to generate */
  profile?: string;
  /** Specific language to generate */
  language?: string;
  /** Output directory */
  output?: string;
  /** Generate minimal examples */
  minimal?: boolean;
  /** Generate complete examples */
  complete?: boolean;
}

/**
 * GitHub Templates Configuration
 */
export type GitHubTemplateSetSource &#x3D;
  | GitHubTemplateSet
  | GitHubFileTemplateRef
  | {
      name?: string;
      description?: string;
      sections?: {
        description?: string;
        details?: Array&amp;lt;Partial&amp;lt;GitHubTemplateField&amp;gt;&amp;gt;;
        acceptanceCriteria?: string;
        dependencies?: string;
        additional?: Record&amp;lt;string, string&amp;gt;;
      };
      labels?: string[];
      validation?: GitHubTemplateValidation;
    };

export interface GitHubTemplatesConfig {
  /** Base templates that can be inherited from */
  base?: GitHubTemplateSetSource;
  /** Epic template configuration */
  epic?: GitHubTemplateConfig | GitHubFileTemplateRef;
  /** Task template configuration */
  task?: GitHubTemplateConfig | GitHubFileTemplateRef;
  /** Bug report template configuration */
  bugReport?: GitHubTemplateConfig | GitHubFileTemplateRef;
  /** Feature request template configuration */
  featureRequest?: GitHubTemplateConfig | GitHubFileTemplateRef;
  /** GitHub repository configuration files */
  repositoryConfig?: GitHubRepoConfig;
  /** Template discovery paths - directories to search for template files */
  discoveryPaths?: string[];
  /** Default template file extension */
  defaultExtension?: string;
}

/** Reference to a file-based template */
export interface GitHubFileTemplateRef {
  /** Path to template file (relative or absolute) */
  file: string;
  /** Optional metadata for the file template */
  metadata?: {
    name?: string;
    description?: string;
    labels?: string[];
    assignees?: string[];
  };
  /** Template to inherit from (file path or template name) */
  inherits?: string;
  /** Template generation options */
  options?: GitHubTemplateOptions;
}

export interface GitHubTemplateSet {
  /** Template name/identifier */
  name: string;
  /** Template description */
  description?: string;
  /** Template content sections */
  sections: GitHubTemplateSections;
  /** Default labels to apply */
  labels?: string[];
  /** Template validation rules */
  validation?: GitHubTemplateValidation;
}

export interface GitHubTemplateConfig {
  /** Inherit from base template (template name or file path) */
  inherits?: string;
  /** Template name/identifier */
  name?: string;
  /** Template title format */
  title?: string;
  /** Template description */
  description?: string;
  /** Custom template sections */
  sections?: Partial&amp;lt;GitHubTemplateSections&amp;gt;;
  /** Labels to apply */
  labels?: string[];
  /** Default assignees */
  assignees?: string[];
  /** Template validation rules */
  validation?: GitHubTemplateValidation;
  /** Template generation options */
  options?: GitHubTemplateOptions;
  /** Path to template file (if using file-based template) */
  templateFile?: string;
}

export interface GitHubTemplateSections {
  /** Description section content */
  description: string;
  /** Details table fields */
  details?: GitHubTemplateField[];
  /** Acceptance criteria section */
  acceptanceCriteria?: string;
  /** Dependencies section */
  dependencies?: string;
  /** Additional sections */
  additional?: Record&amp;lt;string, string&amp;gt;;
}

export interface GitHubTemplateField {
  /** Field name */
  name: string;
  /** Field label for display */
  label: string;
  /** Whether field is required */
  required?: boolean;
  /** Field type */
  type?: &amp;#39;text&amp;#39; | &amp;#39;number&amp;#39; | &amp;#39;date&amp;#39; | &amp;#39;select&amp;#39; | &amp;#39;boolean&amp;#39;;
  /** Default value */
  default?: string;
  /** Validation pattern */
  pattern?: string;
  /** Help text */
  help?: string;
}

export interface GitHubTemplateValidation {
  /** Field validation rules */
  fields?: GitHubFieldValidation[];
  /** Custom validation functions */
  custom?: string[];
}

export interface GitHubFieldValidation {
  /** Field name to validate */
  field: string;
  /** Whether field is required */
  required?: boolean;
  /** Minimum length */
  minLength?: number;
  /** Maximum length */
  maxLength?: number;
  /** Regex pattern */
  pattern?: string;
  /** Allowed values */
  enum?: string[];
  /** Custom validation function name */
  validator?: string;
  /** Error message */
  errorMessage?: string;
}

export interface GitHubRepoConfig {
  /** Issue template chooser configuration */
  issueConfig?: {
    /** Allow blank issues */
    blankIssuesEnabled?: boolean;
    /** Contact links */
    contactLinks?: Array&amp;lt;{
      name: string;
      url: string;
      about: string;
    }&amp;gt;;
  };
  /** Labels configuration */
  labels?: GitHubLabel[];
  /** Pull request template */
  pullRequestTemplate?: string;
}

export interface GitHubLabel {
  /** Label name */
  name: string;
  /** Label color (hex without #) */
  color: string;
  /** Label description */
  description?: string;
}

export interface GitHubTemplateOptions {
  /** Include metadata in templates */
  includeMetadata?: boolean;
  /** Include Arbiter IDs for tracking */
  includeArbiterIds?: boolean;
  /** Include acceptance criteria */
  includeAcceptanceCriteria?: boolean;
  /** Include dependencies */
  includeDependencies?: boolean;
  /** Include time estimations */
  includeEstimations?: boolean;
  /** Custom field values */
  customFields?: Record&amp;lt;string, string&amp;gt;;
}

/**
 * Template management command options
 */
export interface TemplateManagementOptions {
  /** Template type */
  type?: &amp;#39;epic&amp;#39; | &amp;#39;task&amp;#39; | &amp;#39;bug&amp;#39; | &amp;#39;feature&amp;#39;;
  /** Template name */
  name?: string;
  /** List available templates */
  list?: boolean;
  /** Add new template */
  add?: boolean;
  /** Remove template */
  remove?: boolean;
  /** Validate template configuration */
  validate?: boolean;
  /** Show template details */
  show?: boolean;
  /** Output format */
  format?: &amp;#39;table&amp;#39; | &amp;#39;json&amp;#39; | &amp;#39;yaml&amp;#39;;
  /** Initialize/scaffold template files */
  init?: boolean;
  /** Scaffold template files */
  scaffold?: boolean;
  /** Generate template example */
  generate?: string;
  /** Output directory for templates */
  outputDir?: string;
  /** Force overwrite existing files */
  force?: boolean;
  /** Verbose output */
  verbose?: boolean;
}

/**
 * Explain command options for assembly explanation
 */
export interface ExplainOptions {
  /** Output format */
  format?: &amp;#39;text&amp;#39; | &amp;#39;json&amp;#39;;
  /** Output file path */
  output?: string;
  /** Verbose explanation */
  verbose?: boolean;
  /** Show helpful hints */
  hints?: boolean;
}

/**
 * Generate command options for code generation
 */
export interface GenerateOptions {
  /** Output directory */
  output?: string;
  /** Output directory (alternative) */
  outputDir?: string;
  /** Include CI/CD files */
  includeCi?: boolean;
  /** Force overwrite existing files */
  force?: boolean;
  /** Dry run - show what would be generated */
  dryRun?: boolean;
  /** Verbose output */
  verbose?: boolean;
  /** Output format */
  format?: &amp;#39;auto&amp;#39; | &amp;#39;json&amp;#39; | &amp;#39;yaml&amp;#39; | &amp;#39;typescript&amp;#39; | &amp;#39;python&amp;#39; | &amp;#39;rust&amp;#39; | &amp;#39;go&amp;#39; | &amp;#39;shell&amp;#39;;
  /** Sync with GitHub */
  syncGithub?: boolean;
  /** Use configuration file */
  useConfig?: boolean;
  /** Use Git remote for repository detection */
  useGitRemote?: boolean;
}

/**
 * Preview command options for deterministic planning
 */
export interface PreviewOptions {
  /** Output format */
  format?: &amp;#39;json&amp;#39; | &amp;#39;yaml&amp;#39; | &amp;#39;text&amp;#39;;
  /** Output file path */
  output?: string;
  /** Output directory for plan file */
  outputDir?: string;
  /** Verbose output */
  verbose?: boolean;
  /** Include file content in preview */
  includeContent?: boolean;
}

/**
 * Rename command options for file naming migration
 */
export interface RenameOptions {
  /** Show what would be renamed without doing it */
  dryRun?: boolean;
  /** Apply the renaming changes */
  apply?: boolean;
  /** Force overwrite existing files */
  force?: boolean;
  /** Show verbose output */
  verbose?: boolean;
  /** Specific file types to rename */
  types?: string[];
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-61">
                <div class="file-header">ğŸ“„ apps/web/frontend/.storybook/preview.ts</div>
                <div class="file-content">
                    <pre>import type { Preview } from &amp;quot;@storybook/react&amp;quot;;
import &amp;quot;../src/index.css&amp;quot;;

// Import design tokens for consistent theming
import { colors } from &amp;quot;../src/design-system/tokens&amp;quot;;

// Import decorators
import { DesignSystemDecorator } from &amp;quot;./decorators&amp;quot;;

const preview: Preview &#x3D; {
  parameters: {
    // Enhanced action detection
    actions: {
      argTypesRegex: &amp;quot;^on[A-Z].*&amp;quot;,
      handles: [&amp;quot;mouseover&amp;quot;, &amp;quot;click .btn&amp;quot;],
    },

    // Improved controls configuration
    controls: {
      expanded: true,
      sort: &amp;quot;requiredFirst&amp;quot;,
      matchers: {
        color: /(background|color)$/i,
        date: /Date$/i,
      },
    },

    // Enhanced documentation
    docs: {
      toc: {
        contentsSelector: &amp;quot;.sbdocs-content&amp;quot;,
        headingSelector: &amp;quot;h1, h2, h3&amp;quot;,
        ignoreSelector: &amp;quot;#primary&amp;quot;,
        title: &amp;quot;Table of Contents&amp;quot;,
        disable: false,
        unsafeTocbotOptions: {
          orderedList: false,
        },
      },
      source: {
        state: &amp;quot;open&amp;quot;,
        excludeDecorators: true,
      },
    },

    // Comprehensive background options using design tokens
    backgrounds: {
      default: &amp;quot;light&amp;quot;,
      grid: {
        cellSize: 20,
        opacity: 0.1,
        cellAmount: 5,
      },
      values: [
        { name: &amp;quot;Pure White&amp;quot;, value: &amp;quot;#ffffff&amp;quot; },
        { name: &amp;quot;Graphite 25&amp;quot;, value: colors.graphite[25] },
        { name: &amp;quot;Graphite 50&amp;quot;, value: colors.graphite[50] },
        { name: &amp;quot;Graphite 100&amp;quot;, value: colors.graphite[100] },
        { name: &amp;quot;Graphite 200&amp;quot;, value: colors.graphite[200] },
        { name: &amp;quot;Graphite 800&amp;quot;, value: colors.graphite[800] },
        { name: &amp;quot;Graphite 900&amp;quot;, value: colors.graphite[900] },
        { name: &amp;quot;Blue Tint&amp;quot;, value: colors.semantic.info[50] },
        { name: &amp;quot;Purple Tint&amp;quot;, value: &amp;quot;#f3f4f6&amp;quot; },
        { name: &amp;quot;Dark Mode&amp;quot;, value: colors.graphite[900] },
      ],
    },

    // Responsive viewport configurations
    viewport: {
      viewports: {
        // Mobile devices
        mobile1: {
          name: &amp;quot;Small Mobile&amp;quot;,
          styles: { width: &amp;quot;320px&amp;quot;, height: &amp;quot;568px&amp;quot; },
          type: &amp;quot;mobile&amp;quot;,
        },
        mobile2: {
          name: &amp;quot;Mobile&amp;quot;,
          styles: { width: &amp;quot;375px&amp;quot;, height: &amp;quot;667px&amp;quot; },
          type: &amp;quot;mobile&amp;quot;,
        },
        mobile3: {
          name: &amp;quot;Large Mobile&amp;quot;,
          styles: { width: &amp;quot;414px&amp;quot;, height: &amp;quot;896px&amp;quot; },
          type: &amp;quot;mobile&amp;quot;,
        },

        // Tablets
        tablet: {
          name: &amp;quot;Tablet&amp;quot;,
          styles: { width: &amp;quot;768px&amp;quot;, height: &amp;quot;1024px&amp;quot; },
          type: &amp;quot;tablet&amp;quot;,
        },
        tabletLandscape: {
          name: &amp;quot;Tablet Landscape&amp;quot;,
          styles: { width: &amp;quot;1024px&amp;quot;, height: &amp;quot;768px&amp;quot; },
          type: &amp;quot;tablet&amp;quot;,
        },

        // Desktop
        laptop: {
          name: &amp;quot;Laptop&amp;quot;,
          styles: { width: &amp;quot;1366px&amp;quot;, height: &amp;quot;768px&amp;quot; },
          type: &amp;quot;desktop&amp;quot;,
        },
        desktop: {
          name: &amp;quot;Desktop&amp;quot;,
          styles: { width: &amp;quot;1920px&amp;quot;, height: &amp;quot;1080px&amp;quot; },
          type: &amp;quot;desktop&amp;quot;,
        },
        desktopLarge: {
          name: &amp;quot;Large Desktop&amp;quot;,
          styles: { width: &amp;quot;2560px&amp;quot;, height: &amp;quot;1440px&amp;quot; },
          type: &amp;quot;desktop&amp;quot;,
        },

        // Developer-specific viewports
        specWorkbench: {
          name: &amp;quot;Spec Workbench&amp;quot;,
          styles: { width: &amp;quot;1440px&amp;quot;, height: &amp;quot;900px&amp;quot; },
          type: &amp;quot;desktop&amp;quot;,
        },
      },
      defaultViewport: &amp;quot;specWorkbench&amp;quot;,
    },

    // Enhanced accessibility testing configuration
    a11y: {
      config: {
        rules: [
          // WCAG 2.1 AA compliance rules
          { id: &amp;quot;color-contrast&amp;quot;, enabled: true },
          { id: &amp;quot;keyboard-navigation&amp;quot;, enabled: true },
          { id: &amp;quot;focus-management&amp;quot;, enabled: true },
          { id: &amp;quot;aria-labels&amp;quot;, enabled: true },
          { id: &amp;quot;heading-order&amp;quot;, enabled: true },
          { id: &amp;quot;landmark-roles&amp;quot;, enabled: true },
          { id: &amp;quot;list-structure&amp;quot;, enabled: true },
          { id: &amp;quot;image-alt&amp;quot;, enabled: true },
          { id: &amp;quot;form-labels&amp;quot;, enabled: true },
          { id: &amp;quot;link-purpose&amp;quot;, enabled: true },

          // Disable problematic rules for design system components
          { id: &amp;quot;color-contrast-enhanced&amp;quot;, enabled: false }, // AAA level - optional for design system
          { id: &amp;quot;focus-order-semantics&amp;quot;, enabled: false }, // May conflict with custom focus management
        ],
      },
      options: {
        checks: { &amp;quot;color-contrast&amp;quot;: { options: { noScroll: true } } },
        restoreScroll: true,
      },
      // Run accessibility tests automatically
      manual: false,
    },

    // Layout configuration
    layout: &amp;quot;centered&amp;quot;,

    // Custom toolbars for design system testing
    toolbars: {
      designSystem: {
        title: &amp;quot;Design System&amp;quot;,
        description: &amp;quot;Design system utilities&amp;quot;,
        defaultValue: &amp;quot;default&amp;quot;,
        toolbar: {
          icon: &amp;quot;paintbrush&amp;quot;,
          items: [
            { value: &amp;quot;default&amp;quot;, title: &amp;quot;Default Theme&amp;quot; },
            { value: &amp;quot;compact&amp;quot;, title: &amp;quot;Compact Spacing&amp;quot; },
            { value: &amp;quot;comfortable&amp;quot;, title: &amp;quot;Comfortable Spacing&amp;quot; },
            { value: &amp;quot;high-contrast&amp;quot;, title: &amp;quot;High Contrast&amp;quot; },
          ],
        },
      },
      colorScheme: {
        title: &amp;quot;Color Scheme&amp;quot;,
        description: &amp;quot;Color scheme preference&amp;quot;,
        defaultValue: &amp;quot;light&amp;quot;,
        toolbar: {
          icon: &amp;quot;mirror&amp;quot;,
          items: [
            { value: &amp;quot;light&amp;quot;, title: &amp;quot;Light Mode&amp;quot; },
            { value: &amp;quot;dark&amp;quot;, title: &amp;quot;Dark Mode&amp;quot; },
            { value: &amp;quot;auto&amp;quot;, title: &amp;quot;System Preference&amp;quot; },
          ],
        },
      },
    },

    // Story sorting and organization
    options: {
      storySort: {
        order: [
          &amp;quot;Design System&amp;quot;,
          [&amp;quot;Overview&amp;quot;, &amp;quot;Tokens&amp;quot;, &amp;quot;Colors&amp;quot;, &amp;quot;Typography&amp;quot;, &amp;quot;Spacing&amp;quot;],
          &amp;quot;Components&amp;quot;,
          [&amp;quot;Form&amp;quot;, &amp;quot;Display&amp;quot;, &amp;quot;Feedback&amp;quot;, &amp;quot;Navigation&amp;quot;, &amp;quot;Layout&amp;quot;],
          &amp;quot;Layout&amp;quot;,
          &amp;quot;Editor&amp;quot;,
          &amp;quot;*&amp;quot;,
        ],
      },
    },

    // Performance monitoring
    test: {
      // Configure interaction tests
      interactions: { debugger: true },
      // Performance budgets for stories
      performance: {
        allowedMetrics: [&amp;quot;fcp&amp;quot;, &amp;quot;lcp&amp;quot;, &amp;quot;cls&amp;quot;],
        budgets: {
          fcp: 1000,
          lcp: 2000,
          cls: 0.1,
        },
      },
    },
  },

  // Global decorators
  decorators: [DesignSystemDecorator],

  // Global types for custom toolbars
  globalTypes: {
    designSystem: {
      name: &amp;quot;Design System&amp;quot;,
      description: &amp;quot;Design system theme variant&amp;quot;,
      defaultValue: &amp;quot;default&amp;quot;,
      toolbar: {
        icon: &amp;quot;paintbrush&amp;quot;,
        items: [&amp;quot;default&amp;quot;, &amp;quot;compact&amp;quot;, &amp;quot;comfortable&amp;quot;, &amp;quot;high-contrast&amp;quot;],
      },
    },
    colorScheme: {
      name: &amp;quot;Color Scheme&amp;quot;,
      description: &amp;quot;Color scheme preference&amp;quot;,
      defaultValue: &amp;quot;light&amp;quot;,
      toolbar: {
        icon: &amp;quot;mirror&amp;quot;,
        items: [&amp;quot;light&amp;quot;, &amp;quot;dark&amp;quot;, &amp;quot;auto&amp;quot;],
      },
    },
  },
};

export default preview;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-62">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/epic.ts</div>
                <div class="file-content">
                    <pre>/**
 * Epic command - Epic and task management with ordered execution
 *
 * Manages epics and their ordered tasks using sharded CUE storage
 */

import chalk from &amp;#39;chalk&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import type { CLIConfig } from &amp;#39;../types.js&amp;#39;;
import { formatJson } from &amp;#39;../utils/formatting.js&amp;#39;;
import { withProgress } from &amp;#39;../utils/progress.js&amp;#39;;
import { type Epic, ShardedCUEStorage, type Task } from &amp;#39;../utils/sharded-storage.js&amp;#39;;

// Simple table formatting function
function formatTable(headers: string[], rows: string[][]): string {
  const table &#x3D; [headers, ...rows];
  const colWidths &#x3D; headers.map((_, colIndex) &#x3D;&amp;gt;
    Math.max(...table.map(row &#x3D;&amp;gt; (row[colIndex] || &amp;#39;&amp;#39;).length))
  );

  const formatRow &#x3D; (row: string[], isHeader &#x3D; false) &#x3D;&amp;gt; {
    const formattedCells &#x3D; row.map((cell, idx) &#x3D;&amp;gt; (cell || &amp;#39;&amp;#39;).padEnd(colWidths[idx])).join(&amp;#39; | &amp;#39;);
    return isHeader ? chalk.cyan(formattedCells) : formattedCells;
  };

  const lines &#x3D; [
    formatRow(headers, true),
    colWidths.map(w &#x3D;&amp;gt; &amp;#39;-&amp;#39;.repeat(w)).join(&amp;#39;-|-&amp;#39;),
    ...rows.map(row &#x3D;&amp;gt; formatRow(row)),
  ];

  return lines.join(&amp;#39;\n&amp;#39;);
}

export interface EpicOptions {
  verbose?: boolean;
  format?: &amp;#39;table&amp;#39; | &amp;#39;json&amp;#39;;
  status?: string;
  assignee?: string;
  priority?: string;
  shard?: string;
}

export interface EpicCreateOptions extends EpicOptions {
  name: string;
  description?: string;
  priority?: &amp;#39;critical&amp;#39; | &amp;#39;high&amp;#39; | &amp;#39;medium&amp;#39; | &amp;#39;low&amp;#39;;
  owner?: string;
  assignee?: string;
  startDate?: string;
  dueDate?: string;
  labels?: string;
  tags?: string;
  allowParallelTasks?: boolean;
  autoProgress?: boolean;
  requireAllTasks?: boolean;
}

export interface TaskOptions {
  verbose?: boolean;
  format?: &amp;#39;table&amp;#39; | &amp;#39;json&amp;#39;;
  status?: string;
  type?: string;
  assignee?: string;
  priority?: string;
}

export interface TaskCreateOptions extends TaskOptions {
  epic: string;
  name?: string;
  description?: string;
  type?: &amp;#39;feature&amp;#39; | &amp;#39;bug&amp;#39; | &amp;#39;refactor&amp;#39; | &amp;#39;test&amp;#39; | &amp;#39;docs&amp;#39; | &amp;#39;devops&amp;#39; | &amp;#39;research&amp;#39;;
  priority?: &amp;#39;critical&amp;#39; | &amp;#39;high&amp;#39; | &amp;#39;medium&amp;#39; | &amp;#39;low&amp;#39;;
  assignee?: string;
  reviewer?: string;
  dependsOn?: string;
  acceptanceCriteria?: string;
  canRunInParallel?: boolean;
  requiresReview?: boolean;
  requiresTesting?: boolean;
  blocksOtherTasks?: boolean;
  // Batch creation support
  json?: string;
  file?: string;
}

/**
 * Main epic command dispatcher
 */
export async function epicCommand(
  action: string,
  epicId: string | undefined,
  options: EpicOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  const storage &#x3D; new ShardedCUEStorage();

  try {
    await storage.initialize();

    switch (action) {
      case &amp;#39;list&amp;#39;:
        return await listEpics(storage, options, config);
      case &amp;#39;show&amp;#39;:
        if (!epicId) {
          console.error(chalk.red(&amp;#39;Epic ID is required for show command&amp;#39;));
          return 1;
        }
        return await showEpic(storage, epicId, options, config);
      case &amp;#39;create&amp;#39;:
        return await createEpic(storage, options as EpicCreateOptions, config);
      case &amp;#39;update&amp;#39;:
        if (!epicId) {
          console.error(chalk.red(&amp;#39;Epic ID is required for update command&amp;#39;));
          return 1;
        }
        return await updateEpic(storage, epicId, options, config);
      case &amp;#39;delete&amp;#39;:
        if (!epicId) {
          console.error(chalk.red(&amp;#39;Epic ID is required for delete command&amp;#39;));
          return 1;
        }
        return await deleteEpic(storage, epicId, options, config);
      case &amp;#39;stats&amp;#39;:
        return await showStats(storage, options, config);
      default:
        console.error(chalk.red(&#x60;Unknown action: ${action}&#x60;));
        console.log(chalk.dim(&amp;#39;Available actions: list, show, create, update, delete, stats&amp;#39;));
        return 1;
    }
  } catch (error) {
    console.error(chalk.red(&amp;#39;Epic command failed:&amp;#39;));
    console.error(chalk.red(error instanceof Error ? error.message : String(error)));
    return 1;
  } finally {
    await storage.close();
  }
}

/**
 * Task command dispatcher
 */
export async function taskCommand(
  action: string,
  taskId: string | undefined,
  options: TaskOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  const storage &#x3D; new ShardedCUEStorage();

  try {
    await storage.initialize();

    switch (action) {
      case &amp;#39;list&amp;#39;:
        return await listTasks(storage, options, config);
      case &amp;#39;show&amp;#39;:
        if (!taskId) {
          console.error(chalk.red(&amp;#39;Task ID is required for show command&amp;#39;));
          return 1;
        }
        return await showTask(storage, taskId, options, config);
      case &amp;#39;create&amp;#39;:
        return await createTask(storage, options as TaskCreateOptions, config);
      case &amp;#39;batch&amp;#39;:
        return await batchCreateTasks(storage, options as TaskCreateOptions, config);
      case &amp;#39;update&amp;#39;:
        if (!taskId) {
          console.error(chalk.red(&amp;#39;Task ID is required for update command&amp;#39;));
          return 1;
        }
        return await updateTask(storage, taskId, options, config);
      case &amp;#39;complete&amp;#39;:
        if (!taskId) {
          console.error(chalk.red(&amp;#39;Task ID is required for complete command&amp;#39;));
          return 1;
        }
        return await completeTask(storage, taskId, options, config);
      case &amp;#39;deps&amp;#39;:
      case &amp;#39;dependencies&amp;#39;:
        return await showDependencies(storage, options, config);
      case &amp;#39;ready&amp;#39;:
        return await showReadyTasks(storage, options, config);
      case &amp;#39;blocked&amp;#39;:
        return await showBlockedTasks(storage, options, config);
      default:
        console.error(chalk.red(&#x60;Unknown action: ${action}&#x60;));
        console.log(
          chalk.dim(
            &amp;#39;Available actions: list, show, create, batch, update, complete, deps, ready, blocked&amp;#39;
          )
        );
        return 1;
    }
  } catch (error) {
    console.error(chalk.red(&amp;#39;Task command failed:&amp;#39;));
    console.error(chalk.red(error instanceof Error ? error.message : String(error)));
    return 1;
  } finally {
    await storage.close();
  }
}

/**
 * List all epics
 */
async function listEpics(
  storage: ShardedCUEStorage,
  options: EpicOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  return await withProgress({ text: &amp;#39;Loading epics...&amp;#39; }, async () &#x3D;&amp;gt; {
    const epics &#x3D; await storage.listEpics(options.status);

    if (epics.length &#x3D;&#x3D;&#x3D; 0) {
      console.log(chalk.yellow(&amp;#39;No epics found&amp;#39;));
      if (options.status) {
        console.log(chalk.dim(&#x60;Filtered by status: ${options.status}&#x60;));
      }
      return 0;
    }

    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      console.log(formatJson(epics));
      return 0;
    }

    // Table format
    const headers &#x3D; [&amp;#39;ID&amp;#39;, &amp;#39;Name&amp;#39;, &amp;#39;Status&amp;#39;, &amp;#39;Priority&amp;#39;, &amp;#39;Tasks&amp;#39;, &amp;#39;Progress&amp;#39;, &amp;#39;Assignee&amp;#39;];
    const rows &#x3D; epics.map(epic &#x3D;&amp;gt; {
      const completedTasks &#x3D; epic.tasks?.filter(t &#x3D;&amp;gt; t.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39;).length || 0;
      const totalTasks &#x3D; epic.tasks?.length || 0;
      const progress &#x3D; totalTasks &amp;gt; 0 ? &#x60;${completedTasks}/${totalTasks}&#x60; : &amp;#39;0/0&amp;#39;;

      return [
        epic.id,
        epic.name,
        epic.status,
        epic.priority,
        totalTasks.toString(),
        progress,
        epic.assignee || &amp;#39;-&amp;#39;,
      ];
    });

    console.log(formatTable(headers, rows));

    if (options.verbose) {
      console.log(chalk.dim(&#x60;\nShowing ${epics.length} epic(s)&#x60;));
    }

    return 0;
  });
}

/**
 * Show detailed epic information
 */
async function showEpic(
  storage: ShardedCUEStorage,
  epicId: string,
  options: EpicOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  return await withProgress({ text: &#x60;Loading epic ${epicId}...&#x60; }, async () &#x3D;&amp;gt; {
    const epic &#x3D; await storage.getEpic(epicId);

    if (!epic) {
      console.error(chalk.red(&#x60;Epic &amp;#39;${epicId}&amp;#39; not found&#x60;));
      return 1;
    }

    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      console.log(formatJson(epic));
      return 0;
    }

    // Detailed display
    console.log(chalk.cyan(&#x60;Epic: ${epic.name}&#x60;));
    console.log(chalk.dim(&#x60;ID: ${epic.id}&#x60;));

    if (epic.description) {
      console.log(chalk.dim(&#x60;Description: ${epic.description}&#x60;));
    }

    console.log(&#x60;Status: ${getStatusColor(epic.status)}&#x60;);
    console.log(&#x60;Priority: ${getPriorityColor(epic.priority)}&#x60;);

    if (epic.assignee) {
      console.log(&#x60;Assignee: ${epic.assignee}&#x60;);
    }

    if (epic.startDate || epic.dueDate) {
      console.log(chalk.dim(&amp;#39;Dates:&amp;#39;));
      if (epic.startDate) console.log(chalk.dim(&#x60;  Start: ${epic.startDate}&#x60;));
      if (epic.dueDate) console.log(chalk.dim(&#x60;  Due: ${epic.dueDate}&#x60;));
      if (epic.completedDate) console.log(chalk.dim(&#x60;  Completed: ${epic.completedDate}&#x60;));
    }

    if (epic.dependencies &amp;amp;&amp;amp; epic.dependencies.length &amp;gt; 0) {
      console.log(chalk.dim(&#x60;Dependencies: ${epic.dependencies.join(&amp;#39;, &amp;#39;)}&#x60;));
    }

    // Show dependency-ordered tasks
    if (epic.tasks &amp;amp;&amp;amp; epic.tasks.length &amp;gt; 0) {
      console.log(chalk.cyan(&amp;#39;\nTasks (dependency order):&amp;#39;));

      const headers &#x3D; [&amp;#39;ID&amp;#39;, &amp;#39;Name&amp;#39;, &amp;#39;Type&amp;#39;, &amp;#39;Status&amp;#39;, &amp;#39;Dependencies&amp;#39;, &amp;#39;Assignee&amp;#39;];
      const rows &#x3D; epic.tasks.map(task &#x3D;&amp;gt; [
        task.id,
        task.name,
        task.type,
        task.status,
        task.dependsOn?.join(&amp;#39;, &amp;#39;) || &amp;#39;-&amp;#39;,
        task.assignee || &amp;#39;-&amp;#39;,
      ]);

      console.log(formatTable(headers, rows));

      // Show ready/blocked task summary
      if (options.verbose) {
        const storage &#x3D; new ShardedCUEStorage();
        const readyTasks &#x3D; storage.getReadyTasks(epic.tasks);
        const blockedTasks &#x3D; storage.getBlockedTasks(epic.tasks);

        console.log(chalk.dim(&amp;#39;\nTask Status:&amp;#39;));
        console.log(chalk.dim(&#x60;  Ready to start: ${readyTasks.length}&#x60;));
        console.log(chalk.dim(&#x60;  Blocked by dependencies: ${blockedTasks.length}&#x60;));
        console.log(chalk.dim(&#x60;  Total tasks: ${epic.tasks.length}&#x60;));
      }
    }

    if (options.verbose &amp;amp;&amp;amp; epic.arbiter) {
      console.log(chalk.dim(&#x60;\nShard: ${epic.arbiter.shard || &amp;#39;unknown&amp;#39;}&#x60;));
      console.log(chalk.dim(&#x60;Package: ${epic.arbiter.cuePackage || &amp;#39;unknown&amp;#39;}&#x60;));
    }

    return 0;
  });
}

/**
 * Create a new epic
 */
async function createEpic(
  storage: ShardedCUEStorage,
  options: EpicCreateOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  if (!options.name) {
    console.error(chalk.red(&amp;#39;Epic name is required&amp;#39;));
    return 1;
  }

  return await withProgress({ text: &#x60;Creating epic ${options.name}...&#x60; }, async () &#x3D;&amp;gt; {
    const epicId &#x3D; generateSlug(options.name);

    // Check if epic already exists
    const existing &#x3D; await storage.getEpic(epicId);
    if (existing) {
      console.error(chalk.red(&#x60;Epic &amp;#39;${epicId}&amp;#39; already exists&#x60;));
      return 1;
    }

    const epic: Epic &#x3D; {
      id: epicId,
      name: options.name,
      description: options.description,
      priority: options.priority || &amp;#39;medium&amp;#39;,
      status: &amp;#39;planning&amp;#39;,
      owner: options.owner,
      assignee: options.assignee,
      startDate: options.startDate,
      dueDate: options.dueDate,
      tasks: [], // Start with no tasks
      labels: options.labels ? options.labels.split(&amp;#39;,&amp;#39;).map(s &#x3D;&amp;gt; s.trim()) : undefined,
      tags: options.tags ? options.tags.split(&amp;#39;,&amp;#39;).map(s &#x3D;&amp;gt; s.trim()) : undefined,
      config: {
        allowParallelTasks: options.allowParallelTasks,
        autoProgress: options.autoProgress,
        requireAllTasks: options.requireAllTasks,
      },
    };

    const shardId &#x3D; await storage.addEpic(epic);

    console.log(chalk.green(&#x60;âœ… Created epic &amp;#39;${epic.name}&amp;#39; (${epicId}) in shard ${shardId}&#x60;));

    if (options.verbose) {
      console.log(chalk.dim(&#x60;Next: Add tasks with &amp;#39;arbiter task create --epic ${epicId}&amp;#39;&#x60;));
    }

    return 0;
  });
}

/**
 * Update an existing epic
 */
async function updateEpic(
  storage: ShardedCUEStorage,
  epicId: string,
  options: EpicOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  return await withProgress({ text: &#x60;Updating epic ${epicId}...&#x60; }, async () &#x3D;&amp;gt; {
    const epic &#x3D; await storage.getEpic(epicId);

    if (!epic) {
      console.error(chalk.red(&#x60;Epic &amp;#39;${epicId}&amp;#39; not found&#x60;));
      return 1;
    }

    // Update fields based on options
    let updated &#x3D; false;

    if (
      options.status &amp;amp;&amp;amp;
      [&amp;#39;planning&amp;#39;, &amp;#39;in_progress&amp;#39;, &amp;#39;completed&amp;#39;, &amp;#39;cancelled&amp;#39;].includes(options.status)
    ) {
      epic.status &#x3D; options.status as Epic[&amp;#39;status&amp;#39;];
      updated &#x3D; true;
    }

    if (options.priority &amp;amp;&amp;amp; [&amp;#39;critical&amp;#39;, &amp;#39;high&amp;#39;, &amp;#39;medium&amp;#39;, &amp;#39;low&amp;#39;].includes(options.priority)) {
      epic.priority &#x3D; options.priority as Epic[&amp;#39;priority&amp;#39;];
      updated &#x3D; true;
    }

    if (options.assignee !&#x3D;&#x3D; undefined) {
      epic.assignee &#x3D; options.assignee || undefined;
      updated &#x3D; true;
    }

    if (!updated) {
      console.log(chalk.yellow(&amp;#39;No updates specified&amp;#39;));
      return 0;
    }

    await storage.updateEpic(epic);

    console.log(chalk.green(&#x60;âœ… Updated epic &amp;#39;${epic.name}&amp;#39;&#x60;));
    return 0;
  });
}

/**
 * Delete an epic
 */
async function deleteEpic(
  storage: ShardedCUEStorage,
  epicId: string,
  options: EpicOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  // For now, we&amp;#39;ll just mark as cancelled rather than actually deleting
  return await updateEpic(storage, epicId, { ...options, status: &amp;#39;cancelled&amp;#39; }, config);
}

/**
 * Show storage statistics
 */
async function showStats(
  storage: ShardedCUEStorage,
  options: EpicOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  return await withProgress({ text: &amp;#39;Calculating statistics...&amp;#39; }, async () &#x3D;&amp;gt; {
    const stats &#x3D; await storage.getStats();

    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      console.log(formatJson(stats));
      return 0;
    }

    console.log(chalk.cyan(&amp;#39;Sharded Storage Statistics:&amp;#39;));
    console.log(&#x60;Total Shards: ${stats.totalShards}&#x60;);
    console.log(&#x60;Total Epics: ${stats.totalEpics}&#x60;);
    console.log(&#x60;Total Tasks: ${stats.totalTasks}&#x60;);
    console.log(&#x60;Average Epics per Shard: ${stats.avgEpicsPerShard.toFixed(1)}&#x60;);
    console.log(&#x60;Shard Utilization: ${stats.shardUtilization.toFixed(1)}%&#x60;);

    return 0;
  });
}

/**
 * List tasks (across epics or filtered)
 */
async function listTasks(
  storage: ShardedCUEStorage,
  options: TaskOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  return await withProgress({ text: &amp;#39;Loading tasks...&amp;#39; }, async () &#x3D;&amp;gt; {
    const tasks &#x3D; await storage.getOrderedTasks();

    // Apply filters
    let filteredTasks &#x3D; tasks;

    if (options.status) {
      filteredTasks &#x3D; filteredTasks.filter(t &#x3D;&amp;gt; t.status &#x3D;&#x3D;&#x3D; options.status);
    }

    if (options.type) {
      filteredTasks &#x3D; filteredTasks.filter(t &#x3D;&amp;gt; t.type &#x3D;&#x3D;&#x3D; options.type);
    }

    if (options.assignee) {
      filteredTasks &#x3D; filteredTasks.filter(t &#x3D;&amp;gt; t.assignee &#x3D;&#x3D;&#x3D; options.assignee);
    }

    if (options.priority) {
      filteredTasks &#x3D; filteredTasks.filter(t &#x3D;&amp;gt; t.priority &#x3D;&#x3D;&#x3D; options.priority);
    }

    if (filteredTasks.length &#x3D;&#x3D;&#x3D; 0) {
      console.log(chalk.yellow(&amp;#39;No tasks found&amp;#39;));
      return 0;
    }

    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      console.log(formatJson(filteredTasks));
      return 0;
    }

    // Table format
    const headers &#x3D; [&amp;#39;ID&amp;#39;, &amp;#39;Name&amp;#39;, &amp;#39;Type&amp;#39;, &amp;#39;Status&amp;#39;, &amp;#39;Priority&amp;#39;, &amp;#39;Dependencies&amp;#39;, &amp;#39;Assignee&amp;#39;];
    const rows &#x3D; filteredTasks.map(task &#x3D;&amp;gt; [
      task.id,
      task.name,
      task.type,
      task.status,
      task.priority,
      task.dependsOn?.join(&amp;#39;, &amp;#39;) || &amp;#39;-&amp;#39;,
      task.assignee || &amp;#39;-&amp;#39;,
    ]);

    console.log(formatTable(headers, rows));

    if (options.verbose) {
      console.log(chalk.dim(&#x60;\nShowing ${filteredTasks.length} task(s)&#x60;));
    }

    return 0;
  });
}

/**
 * Show task details
 */
async function showTask(
  storage: ShardedCUEStorage,
  taskId: string,
  options: TaskOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  // Find task across all epics
  const epics &#x3D; await storage.listEpics();
  let targetEpic: Epic | null &#x3D; null;
  let targetTask: Task | null &#x3D; null;

  for (const epic of epics) {
    const task &#x3D; epic.tasks?.find(t &#x3D;&amp;gt; t.id &#x3D;&#x3D;&#x3D; taskId);
    if (task) {
      targetEpic &#x3D; epic;
      targetTask &#x3D; task;
      break;
    }
  }

  if (!targetTask || !targetEpic) {
    console.error(chalk.red(&#x60;Task &amp;#39;${taskId}&amp;#39; not found&#x60;));
    return 1;
  }

  if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
    console.log(formatJson({ epic: targetEpic.id, task: targetTask }));
    return 0;
  }

  console.log(chalk.cyan(&#x60;Task: ${targetTask.name}&#x60;));
  console.log(chalk.dim(&#x60;ID: ${targetTask.id}&#x60;));
  console.log(chalk.dim(&#x60;Epic: ${targetEpic.name} (${targetEpic.id})&#x60;));

  if (targetTask.description) {
    console.log(chalk.dim(&#x60;Description: ${targetTask.description}&#x60;));
  }

  console.log(&#x60;Status: ${getStatusColor(targetTask.status)}&#x60;);
  console.log(&#x60;Type: ${targetTask.type}&#x60;);
  console.log(&#x60;Priority: ${getPriorityColor(targetTask.priority)}&#x60;);

  if (targetTask.assignee) {
    console.log(&#x60;Assignee: ${targetTask.assignee}&#x60;);
  }

  if (targetTask.dependsOn &amp;amp;&amp;amp; targetTask.dependsOn.length &amp;gt; 0) {
    console.log(chalk.dim(&#x60;Depends on: ${targetTask.dependsOn.join(&amp;#39;, &amp;#39;)}&#x60;));
  }

  if (targetTask.acceptanceCriteria &amp;amp;&amp;amp; targetTask.acceptanceCriteria.length &amp;gt; 0) {
    console.log(chalk.cyan(&amp;#39;Acceptance Criteria:&amp;#39;));
    targetTask.acceptanceCriteria.forEach((criteria, index) &#x3D;&amp;gt; {
      console.log(chalk.dim(&#x60;  ${index + 1}. ${criteria}&#x60;));
    });
  }

  return 0;
}

/**
 * Create a new task in an epic
 */
async function createTask(
  storage: ShardedCUEStorage,
  options: TaskCreateOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  if (!options.epic) {
    console.error(chalk.red(&amp;#39;Epic ID is required (use --epic &amp;lt;epic-id&amp;gt;)&amp;#39;));
    return 1;
  }

  if (!options.name) {
    console.error(chalk.red(&amp;#39;Task name is required&amp;#39;));
    return 1;
  }

  try {
    await createSingleTask(storage, options.epic, options, config);
    return 0;
  } catch (error) {
    console.error(chalk.red(error instanceof Error ? error.message : String(error)));
    return 1;
  }
}

/**
 * Batch create tasks from JSON input
 */
async function batchCreateTasks(
  storage: ShardedCUEStorage,
  options: TaskCreateOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  if (!options.epic) {
    console.error(chalk.red(&amp;#39;Epic ID is required (use --epic &amp;lt;epic-id&amp;gt;)&amp;#39;));
    return 1;
  }

  let tasksData: any[];

  try {
    // Get JSON data from file or command line
    if (options.file) {
      const fileContent &#x3D; await fs.readFile(options.file, &amp;#39;utf-8&amp;#39;);
      tasksData &#x3D; JSON.parse(fileContent);
    } else if (options.json) {
      tasksData &#x3D; JSON.parse(options.json);
    } else {
      console.error(chalk.red(&amp;#39;Either --json or --file is required for batch creation&amp;#39;));
      console.log(chalk.dim(&amp;#39;Examples:&amp;#39;));
      console.log(
        chalk.dim(
          &amp;#39;  arbiter task batch --epic my-epic --json \&amp;#39;[{&amp;quot;name&amp;quot;:&amp;quot;Task 1&amp;quot;,&amp;quot;order&amp;quot;:0},{&amp;quot;name&amp;quot;:&amp;quot;Task 2&amp;quot;,&amp;quot;order&amp;quot;:1}]\&amp;#39;&amp;#39;
        )
      );
      console.log(chalk.dim(&amp;#39;  arbiter task batch --epic my-epic --file tasks.json&amp;#39;));
      return 1;
    }

    if (!Array.isArray(tasksData)) {
      console.error(chalk.red(&amp;#39;JSON input must be an array of task objects&amp;#39;));
      return 1;
    }

    if (tasksData.length &#x3D;&#x3D;&#x3D; 0) {
      console.error(chalk.red(&amp;#39;No tasks provided in JSON input&amp;#39;));
      return 1;
    }

    // Validate epic exists
    const epic &#x3D; await storage.getEpic(options.epic);
    if (!epic) {
      console.error(chalk.red(&#x60;Epic &amp;#39;${options.epic}&amp;#39; not found&#x60;));
      return 1;
    }

    console.log(chalk.blue(&#x60;Creating ${tasksData.length} tasks in epic &amp;#39;${options.epic}&amp;#39;...&#x60;));

    let successCount &#x3D; 0;
    let errorCount &#x3D; 0;
    const errors: string[] &#x3D; [];

    // Process each task
    for (let i &#x3D; 0; i &amp;lt; tasksData.length; i++) {
      const taskData &#x3D; tasksData[i];

      try {
        // Validate required fields
        if (!taskData.name) {
          errors.push(&#x60;Task ${i + 1}: Missing required field &amp;#39;name&amp;#39;&#x60;);
          errorCount++;
          continue;
        }

        // Create task options from JSON data
        const taskOptions: TaskCreateOptions &#x3D; {
          ...options,
          name: taskData.name,
          description: taskData.description,
          type: taskData.type || &amp;#39;feature&amp;#39;,
          priority: taskData.priority || &amp;#39;medium&amp;#39;,
          assignee: taskData.assignee,
          reviewer: taskData.reviewer,
          dependsOn: Array.isArray(taskData.dependsOn)
            ? taskData.dependsOn.join(&amp;#39;,&amp;#39;)
            : taskData.dependsOn,
          acceptanceCriteria: Array.isArray(taskData.acceptanceCriteria)
            ? taskData.acceptanceCriteria.join(&amp;#39;,&amp;#39;)
            : taskData.acceptanceCriteria,
          canRunInParallel: taskData.canRunInParallel,
          requiresReview: taskData.requiresReview,
          requiresTesting: taskData.requiresTesting,
          blocksOtherTasks: taskData.blocksOtherTasks,
        };

        await createSingleTask(storage, options.epic, taskOptions, config, false); // Don&amp;#39;t show individual success messages
        successCount++;

        if (options.verbose) {
          console.log(chalk.dim(&#x60;  âœ“ Created task: ${taskData.name}&#x60;));
        }
      } catch (error) {
        const errorMsg &#x3D; &#x60;Task ${i + 1} (${taskData.name || &amp;#39;unnamed&amp;#39;}): ${error instanceof Error ? error.message : String(error)}&#x60;;
        errors.push(errorMsg);
        errorCount++;

        if (options.verbose) {
          console.log(chalk.red(&#x60;  âœ— Failed to create task: ${taskData.name}&#x60;));
        }
      }
    }

    // Summary
    if (successCount &amp;gt; 0) {
      console.log(chalk.green(&#x60;âœ… Successfully created ${successCount} task(s)&#x60;));
    }

    if (errorCount &amp;gt; 0) {
      console.log(chalk.red(&#x60;âŒ Failed to create ${errorCount} task(s):&#x60;));
      errors.forEach(error &#x3D;&amp;gt; console.log(chalk.red(&#x60;  â€¢ ${error}&#x60;)));
      return errorCount &#x3D;&#x3D;&#x3D; tasksData.length ? 1 : 0; // Return error only if all failed
    }

    return 0;
  } catch (error) {
    if (error instanceof SyntaxError) {
      console.error(chalk.red(&amp;#39;Invalid JSON format in input&amp;#39;));
      console.log(chalk.dim(&amp;#39;Example format:&amp;#39;));
      console.log(
        chalk.dim(&#x60;[
  {
    &amp;quot;name&amp;quot;: &amp;quot;Implement user authentication&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;Add login/logout functionality&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;feature&amp;quot;,
    &amp;quot;priority&amp;quot;: &amp;quot;high&amp;quot;,
    &amp;quot;order&amp;quot;: 0,
    &amp;quot;assignee&amp;quot;: &amp;quot;dev1&amp;quot;,
    &amp;quot;acceptanceCriteria&amp;quot;: [&amp;quot;User can log in&amp;quot;, &amp;quot;User can log out&amp;quot;, &amp;quot;Session persists&amp;quot;]
  },
  {
    &amp;quot;name&amp;quot;: &amp;quot;Write unit tests&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;Add comprehensive unit tests for auth&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;test&amp;quot;, 
    &amp;quot;priority&amp;quot;: &amp;quot;medium&amp;quot;,
    &amp;quot;order&amp;quot;: 1,
    &amp;quot;dependsOn&amp;quot;: [&amp;quot;implement-user-authentication&amp;quot;]
  }
]&#x60;)
      );
    } else {
      console.error(
        chalk.red(
          &#x60;Batch task creation failed: ${error instanceof Error ? error.message : String(error)}&#x60;
        )
      );
    }
    return 1;
  }
}

/**
 * Create a single task (shared logic)
 */
async function createSingleTask(
  storage: ShardedCUEStorage,
  epicId: string,
  options: TaskCreateOptions,
  config: CLIConfig,
  showSuccessMessage &#x3D; true
): Promise&amp;lt;void&amp;gt; {
  const epic &#x3D; await storage.getEpic(epicId);
  if (!epic) {
    throw new Error(&#x60;Epic &amp;#39;${epicId}&amp;#39; not found&#x60;);
  }

  if (!options.name) {
    throw new Error(&amp;#39;Task name is required&amp;#39;);
  }

  const taskId &#x3D; generateSlug(options.name);

  // Check if task already exists in this epic
  if (epic.tasks?.some(t &#x3D;&amp;gt; t.id &#x3D;&#x3D;&#x3D; taskId)) {
    throw new Error(&#x60;Task &amp;#39;${taskId}&amp;#39; already exists in epic &amp;#39;${epicId}&amp;#39;&#x60;);
  }

  const task: Task &#x3D; {
    id: taskId,
    name: options.name,
    description: options.description,
    type: options.type || &amp;#39;feature&amp;#39;,
    priority: options.priority || &amp;#39;medium&amp;#39;,
    status: &amp;#39;todo&amp;#39;,
    assignee: options.assignee,
    reviewer: options.reviewer,
    dependsOn: options.dependsOn ? options.dependsOn.split(&amp;#39;,&amp;#39;).map(s &#x3D;&amp;gt; s.trim()) : undefined,
    acceptanceCriteria: options.acceptanceCriteria
      ? options.acceptanceCriteria.split(&amp;#39;,&amp;#39;).map(s &#x3D;&amp;gt; s.trim())
      : undefined,
    config: {
      canRunInParallel: options.canRunInParallel,
      requiresReview: options.requiresReview,
      requiresTesting: options.requiresTesting,
      blocksOtherTasks: options.blocksOtherTasks,
    },
  };

  // Add task to epic
  if (!epic.tasks) {
    epic.tasks &#x3D; [];
  }
  epic.tasks.push(task);

  await storage.updateEpic(epic);

  if (showSuccessMessage) {
    console.log(chalk.green(&#x60;âœ… Created task &amp;#39;${task.name}&amp;#39; (${taskId}) in epic &amp;#39;${epicId}&amp;#39;&#x60;));
    if (task.dependsOn &amp;amp;&amp;amp; task.dependsOn.length &amp;gt; 0) {
      console.log(chalk.dim(&#x60;Dependencies: ${task.dependsOn.join(&amp;#39;, &amp;#39;)}&#x60;));
    }
  }
}

/**
 * Update a task
 */
async function updateTask(
  storage: ShardedCUEStorage,
  taskId: string,
  options: TaskOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  // Find task across all epics
  const epics &#x3D; await storage.listEpics();
  let targetEpic: Epic | null &#x3D; null;
  let targetTask: Task | null &#x3D; null;

  for (const epic of epics) {
    const task &#x3D; epic.tasks?.find(t &#x3D;&amp;gt; t.id &#x3D;&#x3D;&#x3D; taskId);
    if (task) {
      targetEpic &#x3D; epic;
      targetTask &#x3D; task;
      break;
    }
  }

  if (!targetTask || !targetEpic) {
    console.error(chalk.red(&#x60;Task &amp;#39;${taskId}&amp;#39; not found&#x60;));
    return 1;
  }

  // Update fields
  let updated &#x3D; false;

  if (
    options.status &amp;amp;&amp;amp;
    [&amp;#39;todo&amp;#39;, &amp;#39;in_progress&amp;#39;, &amp;#39;review&amp;#39;, &amp;#39;testing&amp;#39;, &amp;#39;completed&amp;#39;, &amp;#39;cancelled&amp;#39;].includes(options.status)
  ) {
    targetTask.status &#x3D; options.status as Task[&amp;#39;status&amp;#39;];
    updated &#x3D; true;
  }

  if (options.priority &amp;amp;&amp;amp; [&amp;#39;critical&amp;#39;, &amp;#39;high&amp;#39;, &amp;#39;medium&amp;#39;, &amp;#39;low&amp;#39;].includes(options.priority)) {
    targetTask.priority &#x3D; options.priority as Task[&amp;#39;priority&amp;#39;];
    updated &#x3D; true;
  }

  if (
    options.type &amp;amp;&amp;amp;
    [&amp;#39;feature&amp;#39;, &amp;#39;bug&amp;#39;, &amp;#39;refactor&amp;#39;, &amp;#39;test&amp;#39;, &amp;#39;docs&amp;#39;, &amp;#39;devops&amp;#39;, &amp;#39;research&amp;#39;].includes(options.type)
  ) {
    targetTask.type &#x3D; options.type as Task[&amp;#39;type&amp;#39;];
    updated &#x3D; true;
  }

  if (options.assignee !&#x3D;&#x3D; undefined) {
    targetTask.assignee &#x3D; options.assignee || undefined;
    updated &#x3D; true;
  }

  if (!updated) {
    console.log(chalk.yellow(&amp;#39;No updates specified&amp;#39;));
    return 0;
  }

  await storage.updateEpic(targetEpic);

  console.log(chalk.green(&#x60;âœ… Updated task &amp;#39;${targetTask.name}&amp;#39;&#x60;));
  return 0;
}

/**
 * Move a task to a different order position
 */
async function moveTask(
  storage: ShardedCUEStorage,
  taskId: string,
  options: TaskOptions &amp;amp; { newOrder?: number },
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  if (options.newOrder &#x3D;&#x3D;&#x3D; undefined) {
    console.error(chalk.red(&amp;#39;New order position is required (use --new-order &amp;lt;number&amp;gt;)&amp;#39;));
    return 1;
  }

  // Find task and update order
  const epics &#x3D; await storage.listEpics();
  let targetEpic: Epic | null &#x3D; null;
  let targetTask: Task | null &#x3D; null;

  for (const epic of epics) {
    const task &#x3D; epic.tasks?.find(t &#x3D;&amp;gt; t.id &#x3D;&#x3D;&#x3D; taskId);
    if (task) {
      targetEpic &#x3D; epic;
      targetTask &#x3D; task;
      break;
    }
  }

  if (!targetTask || !targetEpic) {
    console.error(chalk.red(&#x60;Task &amp;#39;${taskId}&amp;#39; not found&#x60;));
    return 1;
  }

  const oldOrder &#x3D; targetTask.order;
  targetTask.order &#x3D; options.newOrder;

  await storage.updateEpic(targetEpic);

  console.log(
    chalk.green(&#x60;âœ… Moved task &amp;#39;${targetTask.name}&amp;#39; from order ${oldOrder} to ${options.newOrder}&#x60;)
  );
  return 0;
}

/**
 * Mark a task as completed
 */
async function completeTask(
  storage: ShardedCUEStorage,
  taskId: string,
  options: TaskOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  return await updateTask(storage, taskId, { ...options, status: &amp;#39;completed&amp;#39; }, config);
}

/**
 * Show dependency graph and relationships
 */
async function showDependencies(
  storage: ShardedCUEStorage,
  options: TaskOptions &amp;amp; { epic?: string },
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  return await withProgress({ text: &amp;#39;Analyzing dependencies...&amp;#39; }, async () &#x3D;&amp;gt; {
    let tasks: Task[] &#x3D; [];

    if (options.epic) {
      // Show dependencies for specific epic
      const epic &#x3D; await storage.getEpic(options.epic);
      if (!epic) {
        console.error(chalk.red(&#x60;Epic &amp;#39;${options.epic}&amp;#39; not found&#x60;));
        return 1;
      }
      tasks &#x3D; epic.tasks || [];
      console.log(chalk.cyan(&#x60;Dependencies for epic: ${epic.name}&#x60;));
    } else {
      // Show dependencies across all epics
      tasks &#x3D; await storage.getOrderedTasks();
      console.log(chalk.cyan(&amp;#39;Dependencies across all epics:&amp;#39;));
    }

    if (tasks.length &#x3D;&#x3D;&#x3D; 0) {
      console.log(chalk.yellow(&amp;#39;No tasks found&amp;#39;));
      return 0;
    }

    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      const graph &#x3D; storage.getDependencyGraph(tasks);
      console.log(formatJson(graph));
      return 0;
    }

    // Show dependency relationships
    const hasDependencies &#x3D; tasks.filter(t &#x3D;&amp;gt; t.dependsOn &amp;amp;&amp;amp; t.dependsOn.length &amp;gt; 0);

    if (hasDependencies.length &#x3D;&#x3D;&#x3D; 0) {
      console.log(chalk.yellow(&amp;#39;No task dependencies found&amp;#39;));
      return 0;
    }

    console.log(chalk.cyan(&amp;#39;\nDependency Relationships:&amp;#39;));

    for (const task of hasDependencies) {
      console.log(chalk.white(&#x60;${task.name} (${task.id})&#x60;));
      console.log(
        chalk.dim(&#x60;  Type: ${task.type} | Status: ${task.status} | Priority: ${task.priority}&#x60;)
      );

      if (task.dependsOn) {
        console.log(chalk.dim(&amp;#39;  Depends on:&amp;#39;));
        for (const depId of task.dependsOn) {
          const depTask &#x3D; tasks.find(t &#x3D;&amp;gt; t.id &#x3D;&#x3D;&#x3D; depId);
          if (depTask) {
            const statusColor &#x3D;
              depTask.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39;
                ? chalk.green
                : depTask.status &#x3D;&#x3D;&#x3D; &amp;#39;in_progress&amp;#39;
                  ? chalk.yellow
                  : chalk.gray;
            console.log(chalk.dim(&#x60;    â†’ ${depTask.name} (${statusColor(depTask.status)})&#x60;));
          } else {
            console.log(chalk.dim(&#x60;    â†’ ${depId} ${chalk.red(&amp;#39;(not found)&amp;#39;)}&#x60;));
          }
        }
      }
      console.log();
    }

    return 0;
  });
}

/**
 * Show tasks that are ready to start (no blocking dependencies)
 */
async function showReadyTasks(
  storage: ShardedCUEStorage,
  options: TaskOptions &amp;amp; { epic?: string },
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  return await withProgress({ text: &amp;#39;Finding ready tasks...&amp;#39; }, async () &#x3D;&amp;gt; {
    let allTasks: Task[] &#x3D; [];

    if (options.epic) {
      const epic &#x3D; await storage.getEpic(options.epic);
      if (!epic) {
        console.error(chalk.red(&#x60;Epic &amp;#39;${options.epic}&amp;#39; not found&#x60;));
        return 1;
      }
      allTasks &#x3D; epic.tasks || [];
    } else {
      allTasks &#x3D; await storage.getOrderedTasks();
    }

    const readyTasks &#x3D; storage.getReadyTasks(allTasks);

    if (readyTasks.length &#x3D;&#x3D;&#x3D; 0) {
      console.log(chalk.yellow(&amp;#39;No tasks are ready to start&amp;#39;));
      return 0;
    }

    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      console.log(formatJson(readyTasks));
      return 0;
    }

    console.log(chalk.green(&#x60;${readyTasks.length} task(s) ready to start:&#x60;));

    const headers &#x3D; [&amp;#39;ID&amp;#39;, &amp;#39;Name&amp;#39;, &amp;#39;Type&amp;#39;, &amp;#39;Priority&amp;#39;, &amp;#39;Assignee&amp;#39;];
    const rows &#x3D; readyTasks.map(task &#x3D;&amp;gt; [
      task.id,
      task.name,
      task.type,
      task.priority,
      task.assignee || &amp;#39;-&amp;#39;,
    ]);

    console.log(formatTable(headers, rows));

    return 0;
  });
}

/**
 * Show tasks that are blocked by dependencies
 */
async function showBlockedTasks(
  storage: ShardedCUEStorage,
  options: TaskOptions &amp;amp; { epic?: string },
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  return await withProgress({ text: &amp;#39;Finding blocked tasks...&amp;#39; }, async () &#x3D;&amp;gt; {
    let allTasks: Task[] &#x3D; [];

    if (options.epic) {
      const epic &#x3D; await storage.getEpic(options.epic);
      if (!epic) {
        console.error(chalk.red(&#x60;Epic &amp;#39;${options.epic}&amp;#39; not found&#x60;));
        return 1;
      }
      allTasks &#x3D; epic.tasks || [];
    } else {
      allTasks &#x3D; await storage.getOrderedTasks();
    }

    const blockedTasks &#x3D; storage.getBlockedTasks(allTasks);

    if (blockedTasks.length &#x3D;&#x3D;&#x3D; 0) {
      console.log(chalk.green(&amp;#39;No tasks are currently blocked&amp;#39;));
      return 0;
    }

    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      console.log(formatJson(blockedTasks));
      return 0;
    }

    console.log(chalk.red(&#x60;${blockedTasks.length} task(s) blocked by dependencies:&#x60;));

    for (const task of blockedTasks) {
      console.log(chalk.white(&#x60;${task.name} (${task.id})&#x60;));
      console.log(chalk.dim(&#x60;  Type: ${task.type} | Priority: ${task.priority}&#x60;));

      if (task.dependsOn) {
        console.log(chalk.dim(&amp;#39;  Waiting for:&amp;#39;));
        for (const depId of task.dependsOn) {
          const depTask &#x3D; allTasks.find(t &#x3D;&amp;gt; t.id &#x3D;&#x3D;&#x3D; depId);
          if (depTask &amp;amp;&amp;amp; depTask.status !&#x3D;&#x3D; &amp;#39;completed&amp;#39;) {
            console.log(chalk.dim(&#x60;    â†’ ${depTask.name} (${depTask.status})&#x60;));
          }
        }
      }
      console.log();
    }

    return 0;
  });
}

// Helper functions
function generateSlug(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, &amp;#39;&amp;#39;)
    .replace(/\s+/g, &amp;#39;-&amp;#39;)
    .replace(/-+/g, &amp;#39;-&amp;#39;)
    .trim();
}

function getStatusColor(status: string): string {
  switch (status) {
    case &amp;#39;completed&amp;#39;:
      return chalk.green(status);
    case &amp;#39;in_progress&amp;#39;:
      return chalk.yellow(status);
    case &amp;#39;cancelled&amp;#39;:
      return chalk.red(status);
    default:
      return chalk.dim(status);
  }
}

function getPriorityColor(priority: string): string {
  switch (priority) {
    case &amp;#39;critical&amp;#39;:
      return chalk.red(priority);
    case &amp;#39;high&amp;#39;:
      return chalk.yellow(priority);
    case &amp;#39;medium&amp;#39;:
      return chalk.blue(priority);
    case &amp;#39;low&amp;#39;:
      return chalk.dim(priority);
    default:
      return priority;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-63">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/utils/diagramLayout.ts</div>
                <div class="file-content">
                    <pre>/**
 * Diagram Layout Algorithms
 * Automatic positioning of components for different diagram types
 */

import {
  type DiagramComponent,
  type DiagramConnection,
  type DiagramLayer,
  DiagramLayout,
  type LayoutAlgorithm,
} from &amp;#39;../types/architecture&amp;#39;;

export class LayeredLayoutAlgorithm implements LayoutAlgorithm {
  name &#x3D; &amp;#39;layered&amp;#39;;

  calculate(
    components: DiagramComponent[],
    connections: DiagramConnection[]
  ): { components: DiagramComponent[]; viewport: { width: number; height: number } } {
    // Define layer ordering
    const layerOrder: DiagramLayer[] &#x3D; [
      &amp;#39;presentation&amp;#39;,
      &amp;#39;application&amp;#39;,
      &amp;#39;service&amp;#39;,
      &amp;#39;data&amp;#39;,
      &amp;#39;external&amp;#39;,
    ];

    // Group components by layer
    const layerGroups &#x3D; this.groupByLayer(components, layerOrder);

    // Calculate positions
    const positioned &#x3D; this.positionComponentsByLayer(layerGroups, layerOrder);

    // Calculate viewport size
    const viewport &#x3D; this.calculateViewport(positioned);

    return { components: positioned, viewport };
  }

  private groupByLayer(
    components: DiagramComponent[],
    layerOrder: DiagramLayer[]
  ): Map&amp;lt;DiagramLayer, DiagramComponent[]&amp;gt; {
    const groups &#x3D; new Map&amp;lt;DiagramLayer, DiagramComponent[]&amp;gt;();

    // Initialize groups
    layerOrder.forEach(layer &#x3D;&amp;gt; groups.set(layer, []));

    // Group components
    components.forEach(component &#x3D;&amp;gt; {
      const layer &#x3D; component.layer || &amp;#39;service&amp;#39;;
      if (!groups.has(layer)) {
        groups.set(layer, []);
      }
      groups.get(layer)?.push(component);
    });

    return groups;
  }

  private positionComponentsByLayer(
    layerGroups: Map&amp;lt;DiagramLayer, DiagramComponent[]&amp;gt;,
    layerOrder: DiagramLayer[]
  ): DiagramComponent[] {
    const positioned: DiagramComponent[] &#x3D; [];
    const layerHeight &#x3D; 200;
    const componentSpacing &#x3D; 20;
    let currentY &#x3D; 60; // Start below header

    layerOrder.forEach(layer &#x3D;&amp;gt; {
      const components &#x3D; layerGroups.get(layer) || [];
      if (components.length &#x3D;&#x3D;&#x3D; 0) return;

      // Calculate total width needed for this layer
      const totalWidth &#x3D; components.reduce((sum, comp) &#x3D;&amp;gt; sum + comp.size.width, 0);
      const totalSpacing &#x3D; (components.length - 1) * componentSpacing;
      const layerWidth &#x3D; totalWidth + totalSpacing;

      // Center the layer horizontally
      let currentX &#x3D; Math.max(50, (800 - layerWidth) / 2);

      components.forEach(component &#x3D;&amp;gt; {
        positioned.push({
          ...component,
          position: { x: currentX, y: currentY },
        });
        currentX +&#x3D; component.size.width + componentSpacing;
      });

      currentY +&#x3D; layerHeight;
    });

    return positioned;
  }

  private calculateViewport(components: DiagramComponent[]): { width: number; height: number } {
    if (components.length &#x3D;&#x3D;&#x3D; 0) {
      return { width: 800, height: 600 };
    }

    const padding &#x3D; 50;
    const maxX &#x3D; Math.max(...components.map(c &#x3D;&amp;gt; c.position.x + c.size.width));
    const maxY &#x3D; Math.max(...components.map(c &#x3D;&amp;gt; c.position.y + c.size.height));

    return {
      width: Math.max(800, maxX + padding),
      height: Math.max(600, maxY + padding),
    };
  }
}

export class ForceDirectedLayoutAlgorithm implements LayoutAlgorithm {
  name &#x3D; &amp;#39;force_directed&amp;#39;;

  calculate(
    components: DiagramComponent[],
    connections: DiagramConnection[]
  ): { components: DiagramComponent[]; viewport: { width: number; height: number } } {
    // Simple force-directed layout using basic physics simulation
    const positioned &#x3D; [...components];
    const iterations &#x3D; 50;
    const repulsionForce &#x3D; 5000;
    const attractionForce &#x3D; 0.1;
    const damping &#x3D; 0.9;

    // Initialize random positions if not set
    positioned.forEach(component &#x3D;&amp;gt; {
      if (component.position.x &#x3D;&#x3D;&#x3D; 0 &amp;amp;&amp;amp; component.position.y &#x3D;&#x3D;&#x3D; 0) {
        component.position &#x3D; {
          x: Math.random() * 600 + 100,
          y: Math.random() * 400 + 100,
        };
      }
    });

    // Track velocities
    const velocities &#x3D; new Map&amp;lt;string, { x: number; y: number }&amp;gt;();
    positioned.forEach(comp &#x3D;&amp;gt; {
      velocities.set(comp.id, { x: 0, y: 0 });
    });

    // Simulation iterations
    for (let iter &#x3D; 0; iter &amp;lt; iterations; iter++) {
      // Reset forces
      positioned.forEach(comp &#x3D;&amp;gt; {
        const vel &#x3D; velocities.get(comp.id)!;
        vel.x *&#x3D; damping;
        vel.y *&#x3D; damping;
      });

      // Repulsion forces (all components push each other away)
      for (let i &#x3D; 0; i &amp;lt; positioned.length; i++) {
        for (let j &#x3D; i + 1; j &amp;lt; positioned.length; j++) {
          const comp1 &#x3D; positioned[i];
          const comp2 &#x3D; positioned[j];
          const vel1 &#x3D; velocities.get(comp1.id)!;
          const vel2 &#x3D; velocities.get(comp2.id)!;

          const dx &#x3D; comp2.position.x - comp1.position.x;
          const dy &#x3D; comp2.position.y - comp1.position.y;
          const distance &#x3D; Math.sqrt(dx * dx + dy * dy) || 1;

          const force &#x3D; repulsionForce / (distance * distance);
          const fx &#x3D; (dx / distance) * force;
          const fy &#x3D; (dy / distance) * force;

          vel1.x -&#x3D; fx;
          vel1.y -&#x3D; fy;
          vel2.x +&#x3D; fx;
          vel2.y +&#x3D; fy;
        }
      }

      // Attraction forces (connected components pull each other)
      connections.forEach(connection &#x3D;&amp;gt; {
        const comp1 &#x3D; positioned.find(c &#x3D;&amp;gt; c.id &#x3D;&#x3D;&#x3D; connection.from.componentId);
        const comp2 &#x3D; positioned.find(c &#x3D;&amp;gt; c.id &#x3D;&#x3D;&#x3D; connection.to.componentId);

        if (comp1 &amp;amp;&amp;amp; comp2) {
          const vel1 &#x3D; velocities.get(comp1.id)!;
          const vel2 &#x3D; velocities.get(comp2.id)!;

          const dx &#x3D; comp2.position.x - comp1.position.x;
          const dy &#x3D; comp2.position.y - comp1.position.y;
          const distance &#x3D; Math.sqrt(dx * dx + dy * dy) || 1;

          const force &#x3D; distance * attractionForce;
          const fx &#x3D; (dx / distance) * force;
          const fy &#x3D; (dy / distance) * force;

          vel1.x +&#x3D; fx;
          vel1.y +&#x3D; fy;
          vel2.x -&#x3D; fx;
          vel2.y -&#x3D; fy;
        }
      });

      // Apply velocities
      positioned.forEach(comp &#x3D;&amp;gt; {
        const vel &#x3D; velocities.get(comp.id)!;
        comp.position.x +&#x3D; vel.x;
        comp.position.y +&#x3D; vel.y;

        // Keep components within bounds
        comp.position.x &#x3D; Math.max(50, Math.min(750, comp.position.x));
        comp.position.y &#x3D; Math.max(50, Math.min(550, comp.position.y));
      });
    }

    const viewport &#x3D; this.calculateViewport(positioned);
    return { components: positioned, viewport };
  }

  private calculateViewport(components: DiagramComponent[]): { width: number; height: number } {
    if (components.length &#x3D;&#x3D;&#x3D; 0) {
      return { width: 800, height: 600 };
    }

    const padding &#x3D; 100;
    const maxX &#x3D; Math.max(...components.map(c &#x3D;&amp;gt; c.position.x + c.size.width));
    const maxY &#x3D; Math.max(...components.map(c &#x3D;&amp;gt; c.position.y + c.size.height));

    return {
      width: Math.max(800, maxX + padding),
      height: Math.max(600, maxY + padding),
    };
  }
}

export class FlowLayoutAlgorithm implements LayoutAlgorithm {
  name &#x3D; &amp;#39;flow&amp;#39;;

  calculate(
    components: DiagramComponent[],
    connections: DiagramConnection[]
  ): { components: DiagramComponent[]; viewport: { width: number; height: number } } {
    // Organize components based on flow connections
    const positioned &#x3D; [...components];

    // Find starting components (no incoming flow connections)
    const hasIncoming &#x3D; new Set&amp;lt;string&amp;gt;();
    connections
      .filter(conn &#x3D;&amp;gt; [&amp;#39;user_navigation&amp;#39;, &amp;#39;user_interaction&amp;#39;].includes(conn.type))
      .forEach(conn &#x3D;&amp;gt; hasIncoming.add(conn.to.componentId));

    const startComponents &#x3D; positioned.filter(comp &#x3D;&amp;gt; !hasIncoming.has(comp.id));
    const remainingComponents &#x3D; positioned.filter(comp &#x3D;&amp;gt; hasIncoming.has(comp.id));

    // Layout in flow order
    let currentX &#x3D; 50;
    const currentY &#x3D; 100;
    const stepWidth &#x3D; 200;
    const stepHeight &#x3D; 150;

    // Position start components
    startComponents.forEach((comp, index) &#x3D;&amp;gt; {
      comp.position &#x3D; { x: currentX, y: currentY + index * stepHeight };
    });

    // Position remaining components based on flow order
    const positioned_ids &#x3D; new Set(startComponents.map(c &#x3D;&amp;gt; c.id));
    let currentStep &#x3D; 1;

    while (positioned_ids.size &amp;lt; positioned.length &amp;amp;&amp;amp; currentStep &amp;lt; 10) {
      currentX +&#x3D; stepWidth;
      let yOffset &#x3D; 0;

      // Find components that can be positioned in this step
      const canPosition &#x3D; remainingComponents.filter(comp &#x3D;&amp;gt; {
        if (positioned_ids.has(comp.id)) return false;

        // Check if all predecessors are positioned
        const predecessors &#x3D; connections
          .filter(conn &#x3D;&amp;gt; conn.to.componentId &#x3D;&#x3D;&#x3D; comp.id)
          .map(conn &#x3D;&amp;gt; conn.from.componentId);

        return predecessors.length &#x3D;&#x3D;&#x3D; 0 || predecessors.every(id &#x3D;&amp;gt; positioned_ids.has(id));
      });

      canPosition.forEach(comp &#x3D;&amp;gt; {
        comp.position &#x3D; { x: currentX, y: currentY + yOffset };
        positioned_ids.add(comp.id);
        yOffset +&#x3D; stepHeight;
      });

      currentStep++;
    }

    // Position any remaining components
    remainingComponents
      .filter(comp &#x3D;&amp;gt; !positioned_ids.has(comp.id))
      .forEach((comp, index) &#x3D;&amp;gt; {
        comp.position &#x3D; {
          x: currentX + stepWidth,
          y: currentY + index * stepHeight,
        };
      });

    const viewport &#x3D; this.calculateViewport(positioned);
    return { components: positioned, viewport };
  }

  private calculateViewport(components: DiagramComponent[]): { width: number; height: number } {
    if (components.length &#x3D;&#x3D;&#x3D; 0) {
      return { width: 800, height: 600 };
    }

    const padding &#x3D; 100;
    const maxX &#x3D; Math.max(...components.map(c &#x3D;&amp;gt; c.position.x + c.size.width));
    const maxY &#x3D; Math.max(...components.map(c &#x3D;&amp;gt; c.position.y + c.size.height));

    return {
      width: Math.max(1000, maxX + padding),
      height: Math.max(600, maxY + padding),
    };
  }
}

export class DiagramLayoutEngine {
  private algorithms: Map&amp;lt;string, LayoutAlgorithm&amp;gt; &#x3D; new Map();

  constructor() {
    this.algorithms.set(&amp;#39;layered&amp;#39;, new LayeredLayoutAlgorithm());
    this.algorithms.set(&amp;#39;force_directed&amp;#39;, new ForceDirectedLayoutAlgorithm());
    this.algorithms.set(&amp;#39;flow&amp;#39;, new FlowLayoutAlgorithm());
  }

  /**
   * Apply layout algorithm to components
   */
  applyLayout(
    components: DiagramComponent[],
    connections: DiagramConnection[],
    layoutType &#x3D; &amp;#39;layered&amp;#39;
  ): { components: DiagramComponent[]; viewport: { width: number; height: number } } {
    const algorithm &#x3D; this.algorithms.get(layoutType);

    if (!algorithm) {
      console.warn(&#x60;Unknown layout algorithm: ${layoutType}, falling back to layered&#x60;);
      return this.algorithms.get(&amp;#39;layered&amp;#39;)?.calculate(components, connections);
    }

    return algorithm.calculate(components, connections);
  }

  /**
   * Suggest best layout based on diagram characteristics
   */
  suggestLayout(components: DiagramComponent[], connections: DiagramConnection[]): string {
    // Check for flow-based connections
    const hasFlowConnections &#x3D; connections.some(conn &#x3D;&amp;gt;
      [&amp;#39;user_navigation&amp;#39;, &amp;#39;user_interaction&amp;#39;].includes(conn.type)
    );

    if (hasFlowConnections) {
      return &amp;#39;flow&amp;#39;;
    }

    // Check for clear layer separation
    const layers &#x3D; new Set(components.map(c &#x3D;&amp;gt; c.layer));
    if (layers.size &amp;gt;&#x3D; 3) {
      return &amp;#39;layered&amp;#39;;
    }

    // Default to force-directed for complex interconnections
    return &amp;#39;force_directed&amp;#39;;
  }

  /**
   * Get available layout algorithms
   */
  getAvailableLayouts(): string[] {
    return Array.from(this.algorithms.keys());
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-64">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/execute.ts</div>
                <div class="file-content">
                    <pre>import fs from &amp;#39;node:fs/promises&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import { diffLines } from &amp;#39;diff&amp;#39;;
import yaml from &amp;#39;js-yaml&amp;#39;;
import { withStepProgress } from &amp;#39;../utils/progress.js&amp;#39;;
import {
  type ExecutionReport,
  type PlanOutput,
  createOutputManager,
  shouldUseAgentMode,
} from &amp;#39;../utils/standardized-output.js&amp;#39;;

// Strategy interfaces for execution patterns
interface ExecutionStrategy {
  execute(plan: ExecutionPlan, options: ExecuteOptions): Promise&amp;lt;void&amp;gt;;
}

// Command interfaces for operation steps
interface Command {
  execute(): Promise&amp;lt;void&amp;gt;;
}

// Builder interface for plan construction
interface PlanBuilder {
  build(): Promise&amp;lt;ExecutionPlan&amp;gt;;
}

/**
 * Epic v2 execution engine with deterministic file-plan generation
 * Implements the agent-first, idempotent codegen approach from TODO.md
 */

export interface Epic {
  id: string;
  title: string;
  owners: string[];
  targets: Array&amp;lt;{
    root: string;
    include: string[];
    exclude: string[];
  }&amp;gt;;
  generate: Array&amp;lt;{
    path: string;
    mode: &amp;#39;create&amp;#39; | &amp;#39;patch&amp;#39;;
    template: string;
    data: Record&amp;lt;string, any&amp;gt;;
    guards: string[];
  }&amp;gt;;
  contracts: {
    types: string[];
    invariants: string[];
  };
  tests: {
    static: Array&amp;lt;{ selector: string }&amp;gt;;
    property: Array&amp;lt;{ name: string; cue: string }&amp;gt;;
    golden: Array&amp;lt;{ input: string; want: string }&amp;gt;;
    cli: Array&amp;lt;{ cmd: string; expectExit: number; expectRE?: string }&amp;gt;;
  };
  rollout: {
    steps: string[];
    gates: Array&amp;lt;{ name: string; cue: string }&amp;gt;;
  };
  heuristics: {
    preferSmallPRs: boolean;
    maxFilesPerPR: number;
  };
  metadata?: {
    created?: string;
    updated?: string;
    version?: string;
    tags?: string[];
    priority?: &amp;#39;low&amp;#39; | &amp;#39;medium&amp;#39; | &amp;#39;high&amp;#39; | &amp;#39;critical&amp;#39;;
    complexity?: number;
  };
}

export interface FileOperation {
  path: string;
  mode: &amp;#39;create&amp;#39; | &amp;#39;patch&amp;#39;;
  content: string;
  guards: string[];
  originalExists: boolean;
  originalContent?: string;
}

export interface ExecutionPlan {
  epicId: string;
  operations: FileOperation[];
  sortedOrder: string[];
  conflicts: string[];
  guardViolations: string[];
}

export interface ExecutionSummary {
  epicId: string;
  timestamp: string;
  filesChanged: number;
  testsRun: number;
  testsPassed: number;
  contractsChecked: number;
  contractsPassed: number;
  rolloutGatesChecked: number;
  rolloutGatesPassed: number;
  overallSuccess: boolean;
  duration: number;
  results: Array&amp;lt;{
    name: string;
    passed: boolean;
    duration?: number;
    error?: string;
    details?: any;
  }&amp;gt;;
}

export interface ExecuteOptions {
  dryRun?: boolean;
  epic: string;
  workspace?: string;
  timeout?: number;
  junit?: string;
  verbose?: boolean;
  agentMode?: boolean;
  ndjsonOutput?: string;
}

/**
 * Epic loader class - Single responsibility: Loading and parsing epic files
 */
class EpicLoader {
  private epicPath: string;

  constructor(epicPath: string) {
    this.epicPath &#x3D; epicPath;
  }

  async load(): Promise&amp;lt;Epic&amp;gt; {
    try {
      const content &#x3D; await fs.readFile(this.epicPath, &amp;#39;utf-8&amp;#39;);

      // For now, assume the epic is in JSON format or can be parsed as such
      // In a real implementation, we&amp;#39;d use CUE&amp;#39;s parser
      // This is a simplified version for the prototype
      if (content.includes(&amp;#39;package epics&amp;#39;) || content.includes(&amp;#39;: epics.#Epic&amp;#39;)) {
        // CUE format - would need proper CUE parsing here
        throw new Error(&amp;#39;CUE parsing not yet implemented - please provide JSON format for now&amp;#39;);
      }

      // Try to parse as JSON/YAML
      let epic: Epic;
      try {
        epic &#x3D; JSON.parse(content);
      } catch {
        epic &#x3D; yaml.load(content) as Epic;
      }

      // Validate required fields
      this.validateEpic(epic);
      return epic;
    } catch (error) {
      throw new Error(
        &#x60;Failed to load epic from ${this.epicPath}: ${error instanceof Error ? error.message : String(error)}&#x60;
      );
    }
  }

  private validateEpic(epic: Epic): void {
    if (!epic.id || !epic.title || !epic.owners || !epic.generate) {
      throw new Error(&amp;#39;Invalid epic: missing required fields (id, title, owners, generate)&amp;#39;);
    }
  }
}

/**
 * Plan generator class - Single responsibility: Creating execution plans
 */
class PlanGenerator implements PlanBuilder {
  private epic: Epic;
  private workspace: string;

  constructor(epic: Epic, workspace: string) {
    this.epic &#x3D; epic;
    this.workspace &#x3D; workspace;
  }

  async build(): Promise&amp;lt;ExecutionPlan&amp;gt; {
    const operations: FileOperation[] &#x3D; [];
    const conflicts: string[] &#x3D; [];
    const guardViolations: string[] &#x3D; [];

    for (const gen of this.epic.generate) {
      const operation &#x3D; await this.createFileOperation(gen);
      operations.push(operation);

      // Check guards
      const violations &#x3D; await this.checkGuards(operation.path, gen.guards);
      guardViolations.push(...violations);

      // Check for conflicts
      if (gen.mode &#x3D;&#x3D;&#x3D; &amp;#39;create&amp;#39; &amp;amp;&amp;amp; operation.originalExists) {
        conflicts.push(&#x60;Conflict: ${gen.path} already exists but mode is &amp;#39;create&amp;#39;&#x60;);
      }
    }

    const sortedOrder &#x3D; this.calculateSortOrder(operations);

    return {
      epicId: this.epic.id,
      operations: operations.sort(
        (a, b) &#x3D;&amp;gt; sortedOrder.indexOf(a.path) - sortedOrder.indexOf(b.path)
      ),
      sortedOrder,
      conflicts,
      guardViolations,
    };
  }

  private async createFileOperation(gen: Epic[&amp;#39;generate&amp;#39;][0]): Promise&amp;lt;FileOperation&amp;gt; {
    const fullPath &#x3D; path.isAbsolute(gen.path) ? gen.path : path.join(this.workspace, gen.path);

    // Check if file exists
    let originalExists &#x3D; false;
    let originalContent: string | undefined;
    try {
      originalContent &#x3D; await fs.readFile(fullPath, &amp;#39;utf-8&amp;#39;);
      originalExists &#x3D; true;
    } catch {
      originalExists &#x3D; false;
    }

    // Load and render template
    const content &#x3D; await this.loadTemplate(gen.template, gen.data);

    return {
      path: fullPath,
      mode: gen.mode,
      content,
      guards: gen.guards,
      originalExists,
      originalContent,
    };
  }

  private calculateSortOrder(operations: FileOperation[]): string[] {
    return operations
      .map(op &#x3D;&amp;gt; op.path)
      .sort((a, b) &#x3D;&amp;gt; {
        const depthA &#x3D; a.split(path.sep).length;
        const depthB &#x3D; b.split(path.sep).length;

        if (depthA !&#x3D;&#x3D; depthB) {
          return depthA - depthB; // Parents before children
        }

        return a.localeCompare(b); // Lexicographic order
      });
  }

  private async checkGuards(filePath: string, guards: string[]): Promise&amp;lt;string[]&amp;gt; {
    const violations: string[] &#x3D; [];

    try {
      const content &#x3D; await fs.readFile(filePath, &amp;#39;utf-8&amp;#39;);

      for (const guard of guards) {
        if (content.includes(guard)) {
          violations.push(&#x60;Guard violation: &amp;quot;${guard}&amp;quot; already exists in ${filePath}&#x60;);
        }
      }
    } catch (_error) {
      // File doesn&amp;#39;t exist - no guard violations
    }

    return violations;
  }

  private async loadTemplate(templatePath: string, data: Record&amp;lt;string, any&amp;gt;): Promise&amp;lt;string&amp;gt; {
    try {
      let content &#x3D; await fs.readFile(templatePath, &amp;#39;utf-8&amp;#39;);

      // Simple template variable substitution - {{.variable}}
      for (const [key, value] of Object.entries(data)) {
        const regex &#x3D; new RegExp(&#x60;\\{\\{\\.${key}\\}\\}&#x60;, &amp;#39;g&amp;#39;);
        content &#x3D; content.replace(regex, String(value));
      }

      // Handle conditional blocks - {{if .variable}}...{{end}}
      content &#x3D; content.replace(
        /\{\{if\s+\.(\w+)\}\}(.*?)\{\{end\}\}/gs,
        (_match, varName, block) &#x3D;&amp;gt; {
          return data[varName] ? block : &amp;#39;&amp;#39;;
        }
      );

      return content;
    } catch (error) {
      // If template file doesn&amp;#39;t exist, treat template as inline content
      if ((error as any).code &#x3D;&#x3D;&#x3D; &amp;#39;ENOENT&amp;#39;) {
        let content &#x3D; templatePath;

        // Apply same substitutions to inline template
        for (const [key, value] of Object.entries(data)) {
          const regex &#x3D; new RegExp(&#x60;\\{\\{\\.${key}\\}\\}&#x60;, &amp;#39;g&amp;#39;);
          content &#x3D; content.replace(regex, String(value));
        }

        return content;
      }
      throw error;
    }
  }
}

/**
 * Plan executor classes - Strategy pattern for execution modes
 */
class RealExecutionStrategy implements ExecutionStrategy {
  async execute(plan: ExecutionPlan, _options: ExecuteOptions): Promise&amp;lt;void&amp;gt; {
    for (const operation of plan.operations) {
      await this.executeOperation(operation);
    }
  }

  private async executeOperation(operation: FileOperation): Promise&amp;lt;void&amp;gt; {
    // Ensure directory exists
    const dir &#x3D; path.dirname(operation.path);
    await fs.mkdir(dir, { recursive: true });

    let finalContent &#x3D; operation.content;

    if (operation.mode &#x3D;&#x3D;&#x3D; &amp;#39;patch&amp;#39; &amp;amp;&amp;amp; operation.originalExists &amp;amp;&amp;amp; operation.originalContent) {
      finalContent &#x3D; this.applyPatch(operation.originalContent, operation.content);
    }

    await fs.writeFile(operation.path, finalContent, &amp;#39;utf-8&amp;#39;);
  }

  private applyPatch(originalContent: string, patchContent: string): string {
    // Look for ARBITER:BEGIN/END markers in patch
    const markerRegex &#x3D; /\/\/\s*ARBITER:BEGIN\s+(\w+)(.*?)\/\/\s*ARBITER:END\s+\1/g;

    let result &#x3D; originalContent;
    let match;

    while ((match &#x3D; markerRegex.exec(patchContent)) !&#x3D;&#x3D; null) {
      const [fullMatch, markerId, _blockContent] &#x3D; match;

      // Check if this block already exists in original
      const existingBlockRegex &#x3D; new RegExp(
        &#x60;//\\s*ARBITER:BEGIN\\s+${markerId}.*?//\\s*ARBITER:END\\s+${markerId}&#x60;,
        &amp;#39;g&amp;#39;
      );

      if (existingBlockRegex.test(result)) {
        // Replace existing block
        result &#x3D; result.replace(existingBlockRegex, fullMatch.trim());
      } else {
        // Append new block
        result &#x3D; &#x60;${result}\n\n${fullMatch.trim()}&#x60;;
      }
    }

    return result;
  }
}

class DryRunExecutionStrategy implements ExecutionStrategy {
  async execute(_plan: ExecutionPlan, _options: ExecuteOptions): Promise&amp;lt;void&amp;gt; {
    // No-op for dry run - just validates the plan
  }
}

/**
 * Plan executor class - Single responsibility: Executing plans
 */
class PlanExecutor {
  private strategy: ExecutionStrategy;

  constructor(strategy: ExecutionStrategy) {
    this.strategy &#x3D; strategy;
  }

  async execute(plan: ExecutionPlan, options: ExecuteOptions): Promise&amp;lt;void&amp;gt; {
    await this.strategy.execute(plan, options);
  }
}

/**
 * Report generator class - Single responsibility: Creating execution reports
 */
class ReportGenerator {
  private workspace: string;

  constructor(workspace: string) {
    this.workspace &#x3D; workspace;
  }

  generateDiff(operation: FileOperation): string {
    if (!operation.originalExists) {
      // New file
      const lines &#x3D; operation.content.split(&amp;#39;\n&amp;#39;);
      return lines.map(line &#x3D;&amp;gt; chalk.green(&#x60;+${line}&#x60;)).join(&amp;#39;\n&amp;#39;);
    }

    if (!operation.originalContent) {
      return chalk.red(&amp;#39;Error: Original content not available&amp;#39;);
    }

    let finalContent &#x3D; operation.content;
    if (operation.mode &#x3D;&#x3D;&#x3D; &amp;#39;patch&amp;#39;) {
      finalContent &#x3D; this.applyPatch(operation.originalContent, operation.content);
    }

    const diff &#x3D; diffLines(operation.originalContent, finalContent);
    return diff
      .map(part &#x3D;&amp;gt; {
        const lines &#x3D; part.value.split(&amp;#39;\n&amp;#39;).filter(line &#x3D;&amp;gt; line !&#x3D;&#x3D; &amp;#39;&amp;#39;);
        if (part.added) {
          return lines.map(line &#x3D;&amp;gt; chalk.green(&#x60;+${line}&#x60;)).join(&amp;#39;\n&amp;#39;);
        }
        if (part.removed) {
          return lines.map(line &#x3D;&amp;gt; chalk.red(&#x60;-${line}&#x60;)).join(&amp;#39;\n&amp;#39;);
        }
        return lines.map(line &#x3D;&amp;gt; &#x60; ${line}&#x60;).join(&amp;#39;\n&amp;#39;);
      })
      .join(&amp;#39;\n&amp;#39;);
  }

  createExecutionSummary(
    epic: Epic,
    plan: ExecutionPlan,
    results: ExecutionSummary[&amp;#39;results&amp;#39;],
    startTime: number
  ): ExecutionSummary {
    const duration &#x3D; Date.now() - startTime;
    return {
      epicId: epic.id,
      timestamp: new Date().toISOString(),
      filesChanged: plan.operations.length,
      testsRun: results.length,
      testsPassed: results.filter(r &#x3D;&amp;gt; r.passed).length,
      contractsChecked: epic.contracts.types.length + epic.contracts.invariants.length,
      contractsPassed: 0, // Would be implemented with actual CUE evaluation
      rolloutGatesChecked: epic.rollout.gates.length,
      rolloutGatesPassed: 0, // Would be implemented with actual CUE evaluation
      overallSuccess: results.every(r &#x3D;&amp;gt; r.passed),
      duration,
      results,
    };
  }

  createExecutionReport(plan: ExecutionPlan, duration: number): ExecutionReport {
    return {
      apiVersion: &amp;#39;arbiter.dev/v2&amp;#39;,
      timestamp: Date.now(),
      command: &amp;#39;execute&amp;#39;,
      kind: &amp;#39;ExecutionReport&amp;#39;,
      applied: plan.operations.map((op, index) &#x3D;&amp;gt; ({
        id: &#x60;op-${index + 1}&#x60;,
        action: op.mode,
        target: path.relative(this.workspace, op.path),
        status: &amp;#39;success&amp;#39; as const,
        duration: 100, // Would track actual duration
      })),
      report: {
        totalActions: plan.operations.length,
        successful: plan.operations.length,
        failed: 0,
        skipped: 0,
        duration,
      },
    };
  }

  createPlanOutput(plan: ExecutionPlan): {
    planOutput: PlanOutput[&amp;#39;plan&amp;#39;];
    guards: PlanOutput[&amp;#39;guards&amp;#39;];
    diff: any;
  } {
    const planOutput: PlanOutput[&amp;#39;plan&amp;#39;] &#x3D; plan.operations.map((op, index) &#x3D;&amp;gt; ({
      id: &#x60;op-${index + 1}&#x60;,
      type: &amp;#39;file&amp;#39; as const,
      action: op.mode &#x3D;&#x3D;&#x3D; &amp;#39;create&amp;#39; ? (&amp;#39;create&amp;#39; as const) : (&amp;#39;update&amp;#39; as const),
      target: path.relative(this.workspace, op.path),
      content: op.content,
      dependencies: [],
      estimatedTime: 100, // milliseconds estimate
    }));

    const guards: PlanOutput[&amp;#39;guards&amp;#39;] &#x3D; plan.guardViolations.map((violation, index) &#x3D;&amp;gt; ({
      id: &#x60;guard-${index + 1}&#x60;,
      type: &amp;#39;constraint&amp;#39; as const,
      description: violation,
      required: true,
    }));

    const diff &#x3D; {
      added: plan.operations.filter(op &#x3D;&amp;gt; !op.originalExists).length,
      modified: plan.operations.filter(op &#x3D;&amp;gt; op.originalExists).length,
      deleted: 0,
      summary: &#x60;${plan.operations.length} operations planned&#x60;,
    };

    return { planOutput, guards, diff };
  }

  private applyPatch(originalContent: string, patchContent: string): string {
    // Look for ARBITER:BEGIN/END markers in patch
    const markerRegex &#x3D; /\/\/\s*ARBITER:BEGIN\s+(\w+)(.*?)\/\/\s*ARBITER:END\s+\1/g;

    let result &#x3D; originalContent;
    let match;

    while ((match &#x3D; markerRegex.exec(patchContent)) !&#x3D;&#x3D; null) {
      const [fullMatch, markerId, _blockContent] &#x3D; match;

      // Check if this block already exists in original
      const existingBlockRegex &#x3D; new RegExp(
        &#x60;//\\s*ARBITER:BEGIN\\s+${markerId}.*?//\\s*ARBITER:END\\s+${markerId}&#x60;,
        &amp;#39;g&amp;#39;
      );

      if (existingBlockRegex.test(result)) {
        // Replace existing block
        result &#x3D; result.replace(existingBlockRegex, fullMatch.trim());
      } else {
        // Append new block
        result &#x3D; &#x60;${result}\n\n${fullMatch.trim()}&#x60;;
      }
    }

    return result;
  }
}

/**
 * Test runner class - Single responsibility: Running and managing tests
 */
class TestRunner {
  private timeout: number;

  constructor(timeout &#x3D; 30000) {
    this.timeout &#x3D; timeout;
  }

  async runCliTests(tests: Epic[&amp;#39;tests&amp;#39;][&amp;#39;cli&amp;#39;]): Promise&amp;lt;ExecutionSummary[&amp;#39;results&amp;#39;]&amp;gt; {
    const results: ExecutionSummary[&amp;#39;results&amp;#39;] &#x3D; [];

    for (const test of tests) {
      const result &#x3D; await this.runSingleCliTest(test);
      results.push({
        name: &#x60;CLI: ${test.cmd}&#x60;,
        passed: result.passed,
        duration: result.duration,
        error: result.error,
      });
    }

    return results;
  }

  private async runSingleCliTest(test: {
    cmd: string;
    expectExit: number;
    expectRE?: string;
  }): Promise&amp;lt;{ passed: boolean; error?: string; duration: number }&amp;gt; {
    const startTime &#x3D; Date.now();

    try {
      const { spawn } &#x3D; await import(&amp;#39;node:child_process&amp;#39;);
      const [command, ...args] &#x3D; test.cmd.split(&amp;#39; &amp;#39;);

      return new Promise(resolve &#x3D;&amp;gt; {
        const proc &#x3D; spawn(command, args, {
          stdio: [&amp;#39;pipe&amp;#39;, &amp;#39;pipe&amp;#39;, &amp;#39;pipe&amp;#39;],
          timeout: this.timeout,
        });

        let stdout &#x3D; &amp;#39;&amp;#39;;
        let stderr &#x3D; &amp;#39;&amp;#39;;

        proc.stdout?.on(&amp;#39;data&amp;#39;, data &#x3D;&amp;gt; {
          stdout +&#x3D; data.toString();
        });

        proc.stderr?.on(&amp;#39;data&amp;#39;, data &#x3D;&amp;gt; {
          stderr +&#x3D; data.toString();
        });

        proc.on(&amp;#39;close&amp;#39;, code &#x3D;&amp;gt; {
          const duration &#x3D; Date.now() - startTime;

          if (code !&#x3D;&#x3D; test.expectExit) {
            resolve({
              passed: false,
              error: &#x60;Expected exit code ${test.expectExit}, got ${code}. stderr: ${stderr}&#x60;,
              duration,
            });
            return;
          }

          if (test.expectRE &amp;amp;&amp;amp; !new RegExp(test.expectRE).test(stdout)) {
            resolve({
              passed: false,
              error: &#x60;Output didn&amp;#39;t match expected regex: ${test.expectRE}&#x60;,
              duration,
            });
            return;
          }

          resolve({ passed: true, duration });
        });

        proc.on(&amp;#39;error&amp;#39;, error &#x3D;&amp;gt; {
          resolve({
            passed: false,
            error: error.message,
            duration: Date.now() - startTime,
          });
        });
      });
    } catch (error) {
      return {
        passed: false,
        error: error instanceof Error ? error.message : String(error),
        duration: Date.now() - startTime,
      };
    }
  }
}

/**
 * Command classes - Command pattern for execution steps
 */
class LoadEpicCommand implements Command {
  private loader: EpicLoader;
  private epic: Epic | null &#x3D; null;

  constructor(epicPath: string) {
    this.loader &#x3D; new EpicLoader(epicPath);
  }

  async execute(): Promise&amp;lt;void&amp;gt; {
    this.epic &#x3D; await this.loader.load();
  }

  getEpic(): Epic {
    if (!this.epic) {
      throw new Error(&amp;#39;Epic not loaded - execute() must be called first&amp;#39;);
    }
    return this.epic;
  }
}

class GeneratePlanCommand implements Command {
  private generator: PlanGenerator;
  private plan: ExecutionPlan | null &#x3D; null;

  constructor(epic: Epic, workspace: string) {
    this.generator &#x3D; new PlanGenerator(epic, workspace);
  }

  async execute(): Promise&amp;lt;void&amp;gt; {
    this.plan &#x3D; await this.generator.build();
  }

  getPlan(): ExecutionPlan {
    if (!this.plan) {
      throw new Error(&amp;#39;Plan not generated - execute() must be called first&amp;#39;);
    }
    return this.plan;
  }
}

class ExecutePlanCommand implements Command {
  private executor: PlanExecutor;
  private plan: ExecutionPlan;
  private options: ExecuteOptions;

  constructor(plan: ExecutionPlan, options: ExecuteOptions) {
    const strategy &#x3D; options.dryRun ? new DryRunExecutionStrategy() : new RealExecutionStrategy();
    this.executor &#x3D; new PlanExecutor(strategy);
    this.plan &#x3D; plan;
    this.options &#x3D; options;
  }

  async execute(): Promise&amp;lt;void&amp;gt; {
    await this.executor.execute(this.plan, this.options);
  }
}

class RunTestsCommand implements Command {
  private testRunner: TestRunner;
  private epic: Epic;
  private results: ExecutionSummary[&amp;#39;results&amp;#39;] &#x3D; [];
  private options: ExecuteOptions;

  constructor(epic: Epic, options: ExecuteOptions) {
    this.testRunner &#x3D; new TestRunner(options.timeout || 30000);
    this.epic &#x3D; epic;
    this.options &#x3D; options;
  }

  async execute(): Promise&amp;lt;void&amp;gt; {
    if (this.epic.tests.cli?.length &amp;gt; 0) {
      this.results &#x3D; await this.testRunner.runCliTests(this.epic.tests.cli);
    }
  }

  getResults(): ExecutionSummary[&amp;#39;results&amp;#39;] {
    return this.results;
  }
}

/**
 * Execution context for passing state between execution phases
 */
interface ExecutionContext {
  startTime: number;
  workspace: string;
  agentMode: boolean;
  outputManager: any;
  reportGenerator: ReportGenerator;
  epic?: Epic;
  plan?: ExecutionPlan;
  testResults?: ExecutionSummary[&amp;#39;results&amp;#39;];
}

/**
 * Main orchestrator - Coordinates all execution steps using command pattern
 */
export async function executeCommand(options: ExecuteOptions): Promise&amp;lt;number&amp;gt; {
  const context &#x3D; initializeExecutionContext(options);

  return withStepProgress(
    {
      title: &#x60;Executing epic: ${path.basename(options.epic)}&#x60;,
      steps: getExecutionSteps(),
      color: &amp;#39;blue&amp;#39;,
    },
    async progress &#x3D;&amp;gt; {
      try {
        return await executeMainWorkflow(context, options, progress);
      } catch (error) {
        return handleExecutionError(error, context);
      }
    }
  );
}

/**
 * Initialize execution context with shared state
 */
function initializeExecutionContext(options: ExecuteOptions): ExecutionContext {
  const workspace &#x3D; options.workspace || process.cwd();
  const agentMode &#x3D; shouldUseAgentMode(options);
  const outputManager &#x3D; createOutputManager(&amp;#39;execute&amp;#39;, agentMode, options.ndjsonOutput);
  const reportGenerator &#x3D; new ReportGenerator(workspace);

  return {
    startTime: Date.now(),
    workspace,
    agentMode,
    outputManager,
    reportGenerator,
  };
}

/**
 * Get the standard execution steps
 */
function getExecutionSteps(): string[] {
  return [
    &amp;#39;Loading epic configuration&amp;#39;,
    &amp;#39;Analyzing targets and dependencies&amp;#39;,
    &amp;#39;Generating execution plan&amp;#39;,
    &amp;#39;Validating guards and constraints&amp;#39;,
    &amp;#39;Applying file changes&amp;#39;,
    &amp;#39;Running tests&amp;#39;,
    &amp;#39;Verifying contracts&amp;#39;,
    &amp;#39;Generating execution report&amp;#39;,
  ];
}

/**
 * Execute the main workflow
 */
async function executeMainWorkflow(
  context: ExecutionContext,
  options: ExecuteOptions,
  progress: any
): Promise&amp;lt;number&amp;gt; {
  await initializeExecution(context);

  context.epic &#x3D; await loadEpicConfiguration(context, options, progress);
  await analyzeTargetsAndDependencies(context, progress);

  context.plan &#x3D; await generateExecutionPlan(context, progress);
  const validationResult &#x3D; await validatePlanAndConstraints(context, options, progress);
  if (validationResult !&#x3D;&#x3D; null) return validationResult;

  if (options.dryRun) {
    return await handleDryRun(
      context.plan!,
      options,
      context.outputManager,
      context.reportGenerator,
      context.workspace,
      context.agentMode
    );
  }

  await executeFileChanges(context, options, progress);
  context.testResults &#x3D; await runTests(context, options, progress);
  await verifyContracts(context, progress);

  return await generateFinalReports(context, options, progress);
}

/**
 * Initialize execution phase
 */
async function initializeExecution(context: ExecutionContext): Promise&amp;lt;void&amp;gt; {
  context.outputManager.emitEvent({
    phase: &amp;#39;plan&amp;#39;,
    status: &amp;#39;start&amp;#39;,
    data: { actions: 0, guards: 0 },
  });

  if (!context.agentMode) {
    console.log(chalk.dim(&#x60;Workspace: ${context.workspace}&#x60;));
  }
}

/**
 * Load and validate epic configuration
 */
async function loadEpicConfiguration(
  context: ExecutionContext,
  options: ExecuteOptions,
  progress: any
): Promise&amp;lt;Epic&amp;gt; {
  progress.nextStep(&amp;#39;Loading epic configuration&amp;#39;);
  const loadEpicCommand &#x3D; new LoadEpicCommand(options.epic);
  await loadEpicCommand.execute();
  const epic &#x3D; loadEpicCommand.getEpic();

  if (!context.agentMode) {
    console.log(chalk.cyan(&#x60;ğŸ“‹ Epic: ${epic.title} (${epic.id})&#x60;));
    console.log(chalk.dim(&#x60;Owners: ${epic.owners.join(&amp;#39;, &amp;#39;)}&#x60;));
  }

  return epic;
}

/**
 * Analyze targets and dependencies
 */
async function analyzeTargetsAndDependencies(
  context: ExecutionContext,
  progress: any
): Promise&amp;lt;void&amp;gt; {
  progress.nextStep(&amp;#39;Analyzing targets and dependencies&amp;#39;);
  // Implementation would go here
}

/**
 * Generate execution plan
 */
async function generateExecutionPlan(
  context: ExecutionContext,
  progress: any
): Promise&amp;lt;ExecutionPlan&amp;gt; {
  progress.nextStep(&amp;#39;Generating execution plan&amp;#39;);
  const generatePlanCommand &#x3D; new GeneratePlanCommand(context.epic!, context.workspace);
  await generatePlanCommand.execute();
  return generatePlanCommand.getPlan();
}

/**
 * Validate plan and constraints
 */
async function validatePlanAndConstraints(
  context: ExecutionContext,
  options: ExecuteOptions,
  progress: any
): Promise&amp;lt;number | null&amp;gt; {
  progress.nextStep(&amp;#39;Validating guards and constraints&amp;#39;);

  const validationError &#x3D; validatePlan(context.plan!, context.agentMode, context.outputManager);
  if (validationError) {
    context.outputManager.close();
    return validationError;
  }

  const { planOutput, guards, diff } &#x3D; context.reportGenerator.createPlanOutput(context.plan!);
  await context.outputManager.writePlanFile(planOutput, guards, diff);

  context.outputManager.emitEvent({
    phase: &amp;#39;plan&amp;#39;,
    status: &amp;#39;complete&amp;#39;,
    data: { actions: context.plan?.operations.length, guards: guards.length },
  });

  if (!context.agentMode) {
    console.log(chalk.green(&#x60;âœ“ Plan generated: ${context.plan?.operations.length} operations&#x60;));
  }

  return null;
}

/**
 * Execute file changes
 */
async function executeFileChanges(
  context: ExecutionContext,
  options: ExecuteOptions,
  progress: any
): Promise&amp;lt;void&amp;gt; {
  progress.nextStep(&amp;#39;Applying file changes&amp;#39;);

  context.outputManager.emitEvent({
    phase: &amp;#39;execute&amp;#39;,
    status: &amp;#39;start&amp;#39;,
    data: { total: context.plan?.operations.length },
  });

  if (!context.agentMode) {
    console.log(chalk.blue(&amp;#39;\nğŸ”§ Applying changes...&amp;#39;));
  }

  const executePlanCommand &#x3D; new ExecutePlanCommand(context.plan!, options);
  await executePlanCommand.execute();

  if (!context.agentMode) {
    console.log(chalk.green(&#x60;âœ“ Applied ${context.plan?.operations.length} file operations&#x60;));
  }

  context.outputManager.emitEvent({
    phase: &amp;#39;execute&amp;#39;,
    status: &amp;#39;complete&amp;#39;,
    data: { progress: context.plan?.operations.length, total: context.plan?.operations.length },
  });
}

/**
 * Run tests and return results
 */
async function runTests(
  context: ExecutionContext,
  options: ExecuteOptions,
  progress: any
): Promise&amp;lt;ExecutionSummary[&amp;#39;results&amp;#39;]&amp;gt; {
  progress.nextStep(&amp;#39;Running tests&amp;#39;);

  const runTestsCommand &#x3D; new RunTestsCommand(context.epic!, options);

  if (context.epic?.tests.cli?.length &amp;gt; 0) {
    context.outputManager.emitEvent({
      phase: &amp;#39;test&amp;#39;,
      status: &amp;#39;start&amp;#39;,
      data: { tests: context.epic?.tests.cli.length },
    });

    if (!context.agentMode) {
      console.log(chalk.blue(&amp;#39;\nğŸ§ª Running CLI tests...&amp;#39;));
    }

    await runTestsCommand.execute();
    const results &#x3D; runTestsCommand.getResults();

    await logTestResults(results, context.agentMode);

    context.outputManager.emitEvent({
      phase: &amp;#39;test&amp;#39;,
      status: &amp;#39;complete&amp;#39;,
      data: {
        tests: results.length,
        passed: results.filter(r &#x3D;&amp;gt; r.passed).length,
        failed: results.filter(r &#x3D;&amp;gt; !r.passed).length,
      },
    });

    return results;
  }

  return runTestsCommand.getResults();
}

/**
 * Log test results to console
 */
async function logTestResults(
  results: ExecutionSummary[&amp;#39;results&amp;#39;],
  agentMode: boolean
): Promise&amp;lt;void&amp;gt; {
  if (!agentMode) {
    for (const result of results) {
      if (result.passed) {
        console.log(chalk.green(&#x60;  âœ“ ${result.name} (${result.duration}ms)&#x60;));
      } else {
        console.log(chalk.red(&#x60;  âœ— ${result.name} (${result.duration}ms)&#x60;));
        if (result.error) {
          console.log(chalk.red(&#x60;    ${result.error}&#x60;));
        }
      }
    }
  }
}

/**
 * Verify contracts
 */
async function verifyContracts(context: ExecutionContext, progress: any): Promise&amp;lt;void&amp;gt; {
  progress.nextStep(&amp;#39;Verifying contracts&amp;#39;);
  // Implementation would go here
}

/**
 * Generate final reports and return exit code
 */
async function generateFinalReports(
  context: ExecutionContext,
  options: ExecuteOptions,
  progress: any
): Promise&amp;lt;number&amp;gt; {
  progress.nextStep(&amp;#39;Generating execution report&amp;#39;);

  const duration &#x3D; Date.now() - context.startTime;
  const summary &#x3D; context.reportGenerator.createExecutionSummary(
    context.epic!,
    context.plan!,
    context.testResults!,
    context.startTime
  );
  const executionReport &#x3D; context.reportGenerator.createExecutionReport(context.plan!, duration);

  await addJUnitReportIfNeeded(executionReport, options, context);
  await writeReportFiles(context, options, executionReport);
  await outputFinalSummary(summary, context.agentMode);

  context.outputManager.close();
  return summary.overallSuccess ? 0 : 1;
}

/**
 * Add JUnit report if needed
 */
async function addJUnitReportIfNeeded(
  executionReport: ExecutionReport,
  options: ExecuteOptions,
  context: ExecutionContext
): Promise&amp;lt;void&amp;gt; {
  if (options.junit || context.testResults?.length &amp;gt; 0) {
    executionReport.junit &#x3D; {
      name: &#x60;Epic.${context.epic?.id}&#x60;,
      tests: context.testResults?.length,
      failures: context.testResults?.filter(r &#x3D;&amp;gt; !r.passed).length,
      errors: 0,
      time: (Date.now() - context.startTime) / 1000,
      testcases: context.testResults?.map(result &#x3D;&amp;gt; ({
        classname: &#x60;Epic.${context.epic?.id}&#x60;,
        name: result.name,
        time: (result.duration || 0) / 1000,
        ...(result.passed
          ? {}
          : {
              failure: {
                message: result.error || &amp;#39;Test failed&amp;#39;,
                type: &amp;#39;AssertionError&amp;#39;,
                content: result.error || &amp;#39;Test failed&amp;#39;,
              },
            }),
      })),
    };
  }
}

/**
 * Write report files
 */
async function writeReportFiles(
  context: ExecutionContext,
  options: ExecuteOptions,
  executionReport: ExecutionReport
): Promise&amp;lt;void&amp;gt; {
  await context.outputManager.writeReportFile(executionReport);

  if (options.junit) {
    await context.outputManager.writeJUnitFile(executionReport.junit!);
  }
}

/**
 * Output final summary to console
 */
async function outputFinalSummary(summary: ExecutionSummary, agentMode: boolean): Promise&amp;lt;void&amp;gt; {
  if (!agentMode) {
    console.log(chalk.blue(&amp;#39;\nğŸ“Š Execution Summary:&amp;#39;));
    console.log(&#x60;  Epic: ${summary.epicId}&#x60;);
    console.log(&#x60;  Files changed: ${summary.filesChanged}&#x60;);
    console.log(&#x60;  Tests: ${summary.testsPassed}/${summary.testsRun} passed&#x60;);
    console.log(&#x60;  Duration: ${summary.duration}ms&#x60;);
    console.log(
      &#x60;  Overall: ${summary.overallSuccess ? chalk.green(&amp;#39;SUCCESS&amp;#39;) : chalk.red(&amp;#39;FAILED&amp;#39;)}&#x60;
    );
  }
}

/**
 * Handle execution errors
 */
function handleExecutionError(error: unknown, context: ExecutionContext): number {
  const errorMessage &#x3D; error instanceof Error ? error.message : String(error);

  if (!context.agentMode) {
    console.error(chalk.red(&amp;#39;âŒ Execution failed:&amp;#39;), errorMessage);
  }

  context.outputManager.emitEvent({
    phase: &amp;#39;execute&amp;#39;,
    status: &amp;#39;complete&amp;#39;,
    data: { progress: 0, total: 0 },
  });

  context.outputManager.close();
  return 2;
}

/**
 * Helper function to validate execution plan
 */
function validatePlan(plan: ExecutionPlan, agentMode: boolean, outputManager: any): number | null {
  // Check for conflicts
  if (plan.conflicts.length &amp;gt; 0) {
    if (!agentMode) {
      console.log(chalk.red(&amp;#39;\nâŒ Conflicts detected:&amp;#39;));
      plan.conflicts.forEach(conflict &#x3D;&amp;gt; console.log(chalk.red(&#x60;  â€¢ ${conflict}&#x60;)));
    }
    outputManager.emitEvent({
      phase: &amp;#39;plan&amp;#39;,
      status: &amp;#39;error&amp;#39;,
      error: &#x60;Conflicts detected: ${plan.conflicts.join(&amp;#39;, &amp;#39;)}&#x60;,
    });
    return 1;
  }

  // Check for guard violations
  if (plan.guardViolations.length &amp;gt; 0) {
    if (!agentMode) {
      console.log(chalk.red(&amp;#39;\nâŒ Guard violations:&amp;#39;));
      plan.guardViolations.forEach(violation &#x3D;&amp;gt; console.log(chalk.red(&#x60;  â€¢ ${violation}&#x60;)));
    }
    outputManager.emitEvent({
      phase: &amp;#39;plan&amp;#39;,
      status: &amp;#39;error&amp;#39;,
      error: &#x60;Guard violations: ${plan.guardViolations.join(&amp;#39;, &amp;#39;)}&#x60;,
    });
    return 1;
  }

  return null;
}

/**
 * Helper function to handle dry run execution
 */
async function handleDryRun(
  plan: ExecutionPlan,
  options: ExecuteOptions,
  outputManager: any,
  reportGenerator: ReportGenerator,
  workspace: string,
  agentMode: boolean
): Promise&amp;lt;number&amp;gt; {
  if (!agentMode) {
    console.log(chalk.blue(&amp;#39;\nğŸ“ Dry run - showing planned changes:\n&amp;#39;));

    for (const operation of plan.operations) {
      const relativePath &#x3D; path.relative(workspace, operation.path);
      console.log(chalk.bold(&#x60;ğŸ“„ ${relativePath} (${operation.mode})&#x60;));

      if (options.verbose) {
        const diffText &#x3D; reportGenerator.generateDiff(operation);
        console.log(diffText);
        console.log(&amp;#39;&amp;#39;); // Empty line separator
      }
    }

    console.log(chalk.blue(&amp;#39;\nğŸ“Š Summary:&amp;#39;));
    console.log(&#x60;  Files to modify: ${plan.operations.length}&#x60;);
    console.log(&#x60;  New files: ${plan.operations.filter(op &#x3D;&amp;gt; !op.originalExists).length}&#x60;);
    console.log(&#x60;  Existing files: ${plan.operations.filter(op &#x3D;&amp;gt; op.originalExists).length}&#x60;);
  }

  // Generate diff.txt file
  const diffContent &#x3D; plan.operations.map(op &#x3D;&amp;gt; reportGenerator.generateDiff(op)).join(&amp;#39;\n\n&amp;#39;);
  await outputManager.writeDiffFile(diffContent);

  outputManager.close();
  return 0;
}

/**
 * Generate JUnit XML report
 */
function _generateJUnitXML(summary: ExecutionSummary): string {
  const testcases &#x3D; summary.results
    .map(
      result &#x3D;&amp;gt; &#x60;
    &amp;lt;testcase 
      classname&#x3D;&amp;quot;Epic.${summary.epicId}&amp;quot; 
      name&#x3D;&amp;quot;${result.name}&amp;quot; 
      time&#x3D;&amp;quot;${(result.duration || 0) / 1000}&amp;quot;&amp;gt;
      ${result.passed ? &amp;#39;&amp;#39; : &#x60;&amp;lt;failure message&#x3D;&amp;quot;${result.error || &amp;#39;Test failed&amp;#39;}&amp;quot;&amp;gt;${result.error || &amp;#39;Test failed&amp;#39;}&amp;lt;/failure&amp;gt;&#x60;}
    &amp;lt;/testcase&amp;gt;&#x60;
    )
    .join(&amp;#39;&amp;#39;);

  return &#x60;&amp;lt;?xml version&#x3D;&amp;quot;1.0&amp;quot; encoding&#x3D;&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;testsuite 
  name&#x3D;&amp;quot;Epic.${summary.epicId}&amp;quot; 
  tests&#x3D;&amp;quot;${summary.testsRun}&amp;quot; 
  failures&#x3D;&amp;quot;${summary.testsRun - summary.testsPassed}&amp;quot; 
  time&#x3D;&amp;quot;${summary.duration / 1000}&amp;quot;
  timestamp&#x3D;&amp;quot;${summary.timestamp}&amp;quot;&amp;gt;
  ${testcases}
&amp;lt;/testsuite&amp;gt;&#x60;;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-65">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/types/api.ts</div>
                <div class="file-content">
                    <pre>/**
 * Frontend types matching backend API contracts
 * Synchronized with backend/src/types.ts
 */

// Database entity types
export interface Project {
  id: string;
  name: string;
  created_at: string;
  updated_at: string;
}

export interface Fragment {
  id: string;
  project_id: string;
  path: string;
  content: string;
  created_at: string;
  updated_at: string;
}

export interface Version {
  id: string;
  project_id: string;
  spec_hash: string;
  resolved_json: string;
  created_at: string;
}

export interface Event {
  id: string;
  project_id: string;
  event_type: EventType;
  data: Record&amp;lt;string, unknown&amp;gt;;
  created_at: string;
}

// Event types for real-time collaboration
export type EventType &#x3D;
  | &amp;quot;fragment_created&amp;quot;
  | &amp;quot;fragment_updated&amp;quot;
  | &amp;quot;fragment_deleted&amp;quot;
  | &amp;quot;validation_started&amp;quot;
  | &amp;quot;validation_completed&amp;quot;
  | &amp;quot;validation_failed&amp;quot;
  | &amp;quot;version_frozen&amp;quot;;

// API request/response types
export interface CreateFragmentRequest {
  path: string;
  content: string;
}

export interface CreateFragmentResponse {
  id: string;
  path: string;
  created_at: string;
}

export interface ResolvedSpecResponse {
  spec_hash: string;
  resolved: Record&amp;lt;string, unknown&amp;gt;;
  last_updated: string;
}

export interface ValidationRequest {
  force?: boolean;
}

export interface ValidationResponse {
  success: boolean;
  spec_hash: string;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

export interface ValidationError {
  type: &amp;quot;schema&amp;quot; | &amp;quot;assertion&amp;quot; | &amp;quot;custom&amp;quot;;
  message: string;
  location?: string;
  details?: Record&amp;lt;string, unknown&amp;gt;;
}

export interface ValidationWarning {
  type: &amp;quot;orphan_token&amp;quot; | &amp;quot;coverage&amp;quot; | &amp;quot;duplicate&amp;quot;;
  message: string;
  location?: string;
}

// Gap analysis types
export interface GapSet {
  missing_capabilities: string[];
  orphaned_tokens: TokenReference[];
  coverage_gaps: CoverageGap[];
  duplicates: Duplicate[];
}

export interface TokenReference {
  token: string;
  defined_in: string[];
  referenced_in: string[];
}

export interface CoverageGap {
  capability: string;
  expected_coverage: number;
  actual_coverage: number;
  missing_scenarios: string[];
}

export interface Duplicate {
  type: &amp;quot;capability&amp;quot; | &amp;quot;requirement&amp;quot; | &amp;quot;test_case&amp;quot;;
  name: string;
  locations: string[];
}

// IR (Intermediate Representation) types for diagrams
export type IRKind &#x3D; &amp;quot;flow&amp;quot; | &amp;quot;fsm&amp;quot; | &amp;quot;view&amp;quot; | &amp;quot;site&amp;quot;;

export interface IRResponse {
  kind: IRKind;
  data: Record&amp;lt;string, unknown&amp;gt;;
  generated_at: string;
}

// Specialized IR types for different diagrams
export interface FlowIR {
  nodes: FlowNode[];
  edges: FlowEdge[];
  clusters?: FlowCluster[];
}

export interface FlowNode {
  id: string;
  label: string;
  type: &amp;quot;start&amp;quot; | &amp;quot;end&amp;quot; | &amp;quot;process&amp;quot; | &amp;quot;decision&amp;quot; | &amp;quot;data&amp;quot;;
  metadata?: Record&amp;lt;string, unknown&amp;gt;;
}

export interface FlowEdge {
  from: string;
  to: string;
  label?: string;
  type?: &amp;quot;normal&amp;quot; | &amp;quot;conditional&amp;quot; | &amp;quot;error&amp;quot;;
}

export interface FlowCluster {
  id: string;
  label: string;
  nodes: string[];
}

export interface SiteIR {
  routes: SiteRoute[];
  dependencies: SiteDependency[];
}

export interface SiteRoute {
  id: string;
  path: string;
  method: &amp;quot;GET&amp;quot; | &amp;quot;POST&amp;quot; | &amp;quot;PUT&amp;quot; | &amp;quot;DELETE&amp;quot; | &amp;quot;PATCH&amp;quot;;
  handler: string;
  dependencies: string[];
}

export interface SiteDependency {
  from: string;
  to: string;
  type: &amp;quot;data&amp;quot; | &amp;quot;service&amp;quot; | &amp;quot;auth&amp;quot;;
}

export interface FsmIR {
  states: FsmState[];
  transitions: FsmTransition[];
  initial: string;
  final: string[];
}

export interface FsmState {
  id: string;
  label: string;
  type: &amp;quot;normal&amp;quot; | &amp;quot;initial&amp;quot; | &amp;quot;final&amp;quot; | &amp;quot;compound&amp;quot;;
  metadata?: Record&amp;lt;string, unknown&amp;gt;;
}

export interface FsmTransition {
  from: string;
  to: string;
  event: string;
  guard?: string;
  action?: string;
}

export interface ViewIR {
  tokens: ViewToken[];
  connections: ViewConnection[];
  layout: ViewLayout;
}

export interface ViewToken {
  id: string;
  label: string;
  type: &amp;quot;capability&amp;quot; | &amp;quot;requirement&amp;quot; | &amp;quot;test&amp;quot; | &amp;quot;data&amp;quot;;
  position: { x: number; y: number };
  metadata?: Record&amp;lt;string, unknown&amp;gt;;
}

export interface ViewConnection {
  from: string;
  to: string;
  type: &amp;quot;implements&amp;quot; | &amp;quot;tests&amp;quot; | &amp;quot;depends_on&amp;quot; | &amp;quot;provides&amp;quot;;
}

export interface ViewLayout {
  width: number;
  height: number;
  padding: number;
}

// Version freezing
export interface FreezeRequest {
  version_name: string;
  description?: string;
}

export interface FreezeResponse {
  version_id: string;
  spec_hash: string;
  frozen_at: string;
}

// WebSocket message types
export interface WebSocketMessage {
  type: &amp;quot;event&amp;quot; | &amp;quot;error&amp;quot; | &amp;quot;ping&amp;quot; | &amp;quot;pong&amp;quot;;
  project_id?: string;
  data: Record&amp;lt;string, unknown&amp;gt;;
}

// WebSocket events for real-time collaboration
export interface WsEvent {
  type: &amp;quot;fragment_updated&amp;quot; | &amp;quot;resolved_updated&amp;quot; | &amp;quot;gaps_updated&amp;quot; | &amp;quot;ir_updated&amp;quot;;
  project_id: string;
  data: WsEventData;
  timestamp: string;
  user?: string;
}

export type WsEventData &#x3D;
  | WsFragmentUpdatedData
  | WsResolvedUpdatedData
  | WsGapsUpdatedData
  | WsIrUpdatedData;

export interface WsFragmentUpdatedData {
  fragment: Fragment;
  operation: &amp;quot;created&amp;quot; | &amp;quot;updated&amp;quot; | &amp;quot;deleted&amp;quot;;
}

export interface WsResolvedUpdatedData {
  spec_hash: string;
  resolved: Record&amp;lt;string, unknown&amp;gt;;
}

export interface WsGapsUpdatedData {
  gaps: GapSet;
  spec_hash: string;
}

export interface WsIrUpdatedData {
  kind: IRKind;
  data: Record&amp;lt;string, unknown&amp;gt;;
  spec_hash: string;
}

// Webhook Handler types
export interface WebhookHandler {
  id: string;
  name: string;
  provider: WebhookProvider;
  event_type: string;
  enabled: boolean;
  code: string;
  created_at: string;
  updated_at: string;
  last_execution?: string;
  execution_count: number;
  success_count: number;
  error_count: number;
}

export type WebhookProvider &#x3D; &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot; | &amp;quot;bitbucket&amp;quot; | &amp;quot;slack&amp;quot; | &amp;quot;discord&amp;quot; | &amp;quot;custom&amp;quot;;

export interface CreateHandlerRequest {
  name: string;
  provider: WebhookProvider;
  event_type: string;
  code: string;
  enabled?: boolean;
}

export interface UpdateHandlerRequest {
  name?: string;
  provider?: WebhookProvider;
  event_type?: string;
  code?: string;
  enabled?: boolean;
}

export interface HandlerExecution {
  id: string;
  handler_id: string;
  status: &amp;quot;success&amp;quot; | &amp;quot;error&amp;quot; | &amp;quot;timeout&amp;quot;;
  started_at: string;
  completed_at?: string;
  duration_ms?: number;
  payload: Record&amp;lt;string, unknown&amp;gt;;
  result?: Record&amp;lt;string, unknown&amp;gt;;
  error_message?: string;
  error_stack?: string;
}

export interface HandlerStats {
  handler_id: string;
  total_executions: number;
  successful_executions: number;
  failed_executions: number;
  avg_duration_ms: number;
  last_execution?: string;
  recent_executions: HandlerExecution[];
}

// Error response structure (RFC 7807 Problem Details)
export interface ProblemDetails {
  type: string;
  title: string;
  status: number;
  detail?: string;
  instance?: string;
  [key: string]: unknown;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-66">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/webhook.ts</div>
                <div class="file-content">
                    <pre>/**
 * Webhook management commands
 */
import chalk from &amp;#39;chalk&amp;#39;;
import { ApiClient } from &amp;#39;../api-client.js&amp;#39;;
import type { CLIConfig } from &amp;#39;../types.js&amp;#39;;
import { formatJson, formatTable } from &amp;#39;../utils/formatting.js&amp;#39;;
import { withProgress } from &amp;#39;../utils/progress.js&amp;#39;;

export interface WebhookOptions {
  projectId?: string;
  provider?: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;;
  repository?: string;
  events?: string;
  enabled?: boolean;
  secret?: string;
  format: &amp;#39;table&amp;#39; | &amp;#39;json&amp;#39; | &amp;#39;yaml&amp;#39;;
  dry?: boolean;
  force?: boolean;
}

export interface WebhookConfigOptions {
  show?: boolean;
  set?: boolean;
  unset?: boolean;
  list?: boolean;
}

/**
 * List webhook configurations
 */
export async function listWebhooksCommand(
  options: WebhookOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  const client &#x3D; new ApiClient(config);

  try {
    const webhooksData &#x3D; await withProgress({ text: &amp;#39;Fetching webhooks...&amp;#39; }, async () &#x3D;&amp;gt; {
      const response &#x3D; await client.request(&amp;#39;/api/webhooks&amp;#39;, {
        method: &amp;#39;GET&amp;#39;,
      });

      if (!response.ok) {
        throw new Error(&#x60;Failed to fetch webhooks: ${response.statusText}&#x60;);
      }

      return response.json();
    });

    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      console.log(formatJson(webhooksData));
      return 0;
    }

    // Display webhook status
    console.log(chalk.blue(&amp;#39;\nğŸ“¡ Webhook Configuration\n&amp;#39;));

    console.log(&#x60;Status: ${webhooksData.enabled ? chalk.green(&amp;#39;Enabled&amp;#39;) : chalk.red(&amp;#39;Disabled&amp;#39;)}&#x60;);
    console.log(&#x60;Providers: ${webhooksData.providers.join(&amp;#39;, &amp;#39;)}&#x60;);

    console.log(chalk.blue(&amp;#39;\nğŸ”— Endpoints:\n&amp;#39;));
    Object.entries(webhooksData.endpoints).forEach(([provider, endpoint]) &#x3D;&amp;gt; {
      console.log(&#x60;  ${provider}: ${config.apiUrl}${endpoint}&#x60;);
    });

    if (webhooksData.configuration) {
      console.log(chalk.blue(&amp;#39;\nâš™ï¸  Configuration:\n&amp;#39;));

      const configRows &#x3D; [
        [&amp;#39;Sync on Push&amp;#39;, webhooksData.configuration.sync_on_push ? &amp;#39;Yes&amp;#39; : &amp;#39;No&amp;#39;],
        [&amp;#39;Validate on Merge&amp;#39;, webhooksData.configuration.validate_on_merge ? &amp;#39;Yes&amp;#39; : &amp;#39;No&amp;#39;],
        [&amp;#39;Allowed Repos&amp;#39;, String(webhooksData.configuration.allowed_repos?.length || 0)],
        [&amp;#39;GitHub Secret&amp;#39;, webhooksData.configuration.github_secret ? &amp;#39;Set&amp;#39; : &amp;#39;Not set&amp;#39;],
        [&amp;#39;GitLab Secret&amp;#39;, webhooksData.configuration.gitlab_secret ? &amp;#39;Set&amp;#39; : &amp;#39;Not set&amp;#39;],
      ];

      console.log(formatTable([&amp;#39;Setting&amp;#39;, &amp;#39;Value&amp;#39;], configRows));
    }

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Error listing webhooks:&amp;#39;),
      error instanceof Error ? error.message : error
    );
    return 1;
  }
}

/**
 * Get webhook configuration for a specific project
 */
export async function getWebhookCommand(
  projectId: string,
  options: WebhookOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  if (!projectId) {
    console.error(chalk.red(&amp;#39;Error: Project ID is required&amp;#39;));
    return 1;
  }

  const client &#x3D; new ApiClient(config);

  try {
    const webhookConfig &#x3D; await withProgress(
      { text: &#x60;Getting webhook config for ${projectId}...&#x60; },
      async () &#x3D;&amp;gt; {
        const response &#x3D; await client.request(&#x60;/api/webhooks/${projectId}&#x60;, {
          method: &amp;#39;GET&amp;#39;,
        });

        if (!response.ok) {
          if (response.status &#x3D;&#x3D;&#x3D; 404) {
            throw new Error(&amp;#39;No webhook configuration found for this project&amp;#39;);
          }
          throw new Error(&#x60;Failed to get webhook config: ${response.statusText}&#x60;);
        }

        return response.json();
      }
    );

    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      console.log(formatJson(webhookConfig));
      return 0;
    }

    console.log(chalk.blue(&#x60;\nğŸ“¡ Webhook Configuration - ${projectId}\n&#x60;));

    const configRows &#x3D; [
      [&amp;#39;Provider&amp;#39;, webhookConfig.provider],
      [&amp;#39;Repository&amp;#39;, webhookConfig.repository_url || &amp;#39;Not set&amp;#39;],
      [&amp;#39;Enabled&amp;#39;, webhookConfig.enabled ? &amp;#39;Yes&amp;#39; : &amp;#39;No&amp;#39;],
      [&amp;#39;Events&amp;#39;, webhookConfig.events.join(&amp;#39;, &amp;#39;)],
      [&amp;#39;Created&amp;#39;, new Date(webhookConfig.created_at).toLocaleString()],
      [&amp;#39;Updated&amp;#39;, new Date(webhookConfig.updated_at).toLocaleString()],
    ];

    console.log(formatTable([&amp;#39;Property&amp;#39;, &amp;#39;Value&amp;#39;], configRows));

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Error getting webhook config:&amp;#39;),
      error instanceof Error ? error.message : error
    );
    return 1;
  }
}

/**
 * Create or update webhook configuration
 */
export async function setWebhookCommand(
  projectId: string,
  options: WebhookOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  if (!projectId) {
    console.error(chalk.red(&amp;#39;Error: Project ID is required&amp;#39;));
    return 1;
  }

  if (!options.provider) {
    console.error(chalk.red(&amp;#39;Error: Provider (--provider github|gitlab) is required&amp;#39;));
    return 1;
  }

  const client &#x3D; new ApiClient(config);

  try {
    const webhookConfig &#x3D; {
      project_id: projectId,
      provider: options.provider,
      repository_url: options.repository || &amp;#39;&amp;#39;,
      enabled: options.enabled ?? true,
      events: options.events ? options.events.split(&amp;#39;,&amp;#39;) : [&amp;#39;push&amp;#39;],
      secret_hash: options.secret ? Buffer.from(options.secret).toString(&amp;#39;base64&amp;#39;) : undefined,
    };

    if (options.dry) {
      console.log(chalk.yellow(&amp;#39;ğŸ” Dry run - would create/update webhook config:&amp;#39;));
      console.log(formatJson(webhookConfig));
      return 0;
    }

    const result &#x3D; await withProgress({ text: &amp;#39;Creating/updating webhook config...&amp;#39; }, async () &#x3D;&amp;gt; {
      const response &#x3D; await client.request(&amp;#39;/api/webhooks&amp;#39;, {
        method: &amp;#39;POST&amp;#39;,
        headers: {
          &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;,
        },
        body: JSON.stringify(webhookConfig),
      });

      if (!response.ok) {
        throw new Error(&#x60;Failed to create webhook config: ${response.statusText}&#x60;);
      }

      return response.json();
    });

    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      console.log(formatJson(result));
      return 0;
    }

    console.log(chalk.green(&amp;#39;âœ… Webhook configuration saved successfully&amp;#39;));
    console.log(chalk.blue(&#x60;\nğŸ“¡ Configuration for ${projectId}:\n&#x60;));

    const configRows &#x3D; [
      [&amp;#39;Provider&amp;#39;, result.provider],
      [&amp;#39;Repository&amp;#39;, result.repository_url || &amp;#39;Not set&amp;#39;],
      [&amp;#39;Enabled&amp;#39;, result.enabled ? &amp;#39;Yes&amp;#39; : &amp;#39;No&amp;#39;],
      [&amp;#39;Events&amp;#39;, result.events.join(&amp;#39;, &amp;#39;)],
    ];

    console.log(formatTable([&amp;#39;Property&amp;#39;, &amp;#39;Value&amp;#39;], configRows));

    console.log(chalk.blue(&amp;#39;\nğŸ”— Webhook URL:&amp;#39;));
    console.log(&#x60;${config.apiUrl}/webhooks/${result.provider}&#x60;);

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Error setting webhook config:&amp;#39;),
      error instanceof Error ? error.message : error
    );
    return 1;
  }
}

/**
 * Delete webhook configuration
 */
export async function deleteWebhookCommand(
  projectId: string,
  options: WebhookOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  if (!projectId) {
    console.error(chalk.red(&amp;#39;Error: Project ID is required&amp;#39;));
    return 1;
  }

  if (!options.force) {
    console.log(
      chalk.yellow(&amp;#39;Warning: This will delete the webhook configuration for this project.&amp;#39;)
    );
    console.log(chalk.yellow(&amp;#39;Use --force to confirm deletion.&amp;#39;));
    return 1;
  }

  const client &#x3D; new ApiClient(config);

  try {
    await withProgress({ text: &#x60;Deleting webhook config for ${projectId}...&#x60; }, async () &#x3D;&amp;gt; {
      const response &#x3D; await client.request(&#x60;/api/webhooks/${projectId}&#x60;, {
        method: &amp;#39;DELETE&amp;#39;,
      });

      if (!response.ok) {
        if (response.status &#x3D;&#x3D;&#x3D; 404) {
          throw new Error(&amp;#39;No webhook configuration found for this project&amp;#39;);
        }
        throw new Error(&#x60;Failed to delete webhook config: ${response.statusText}&#x60;);
      }

      return response.json();
    });

    console.log(chalk.green(&amp;#39;âœ… Webhook configuration deleted successfully&amp;#39;));
    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Error deleting webhook config:&amp;#39;),
      error instanceof Error ? error.message : error
    );
    return 1;
  }
}

/**
 * Test webhook endpoint
 */
export async function testWebhookCommand(
  provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;,
  options: WebhookOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  if (!provider || ![&amp;#39;github&amp;#39;, &amp;#39;gitlab&amp;#39;].includes(provider)) {
    console.error(chalk.red(&amp;quot;Error: Provider must be &amp;#39;github&amp;#39; or &amp;#39;gitlab&amp;#39;&amp;quot;));
    return 1;
  }

  // Create a test payload based on provider
  const testPayload &#x3D;
    provider &#x3D;&#x3D;&#x3D; &amp;#39;github&amp;#39;
      ? {
          repository: {
            full_name: &amp;#39;test/repo&amp;#39;,
            clone_url: &amp;#39;https://github.com/test/repo.git&amp;#39;,
          },
          commits: [
            {
              id: &amp;#39;abc123&amp;#39;,
              message: &amp;#39;Test commit&amp;#39;,
              author: {
                name: &amp;#39;Test User&amp;#39;,
                email: &amp;#39;test@example.com&amp;#39;,
              },
            },
          ],
          ref: &amp;#39;refs/heads/main&amp;#39;,
        }
      : {
          repository: {
            full_name: &amp;#39;test/repo&amp;#39;,
            clone_url: &amp;#39;https://gitlab.com/test/repo.git&amp;#39;,
          },
          commits: [
            {
              id: &amp;#39;abc123&amp;#39;,
              message: &amp;#39;Test commit&amp;#39;,
              author: {
                name: &amp;#39;Test User&amp;#39;,
                email: &amp;#39;test@example.com&amp;#39;,
              },
            },
          ],
          ref: &amp;#39;refs/heads/main&amp;#39;,
        };

  const client &#x3D; new ApiClient(config);

  try {
    console.log(chalk.blue(&#x60;ğŸ§ª Testing ${provider} webhook endpoint...\n&#x60;));

    if (options.dry) {
      console.log(chalk.yellow(&amp;#39;ğŸ” Dry run - would send test payload:&amp;#39;));
      console.log(formatJson(testPayload));
      return 0;
    }

    const result &#x3D; await withProgress({ text: &amp;#39;Sending test webhook...&amp;#39; }, async () &#x3D;&amp;gt; {
      const headers: Record&amp;lt;string, string&amp;gt; &#x3D; {
        &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;,
      };

      // Add provider-specific headers
      if (provider &#x3D;&#x3D;&#x3D; &amp;#39;github&amp;#39;) {
        headers[&amp;#39;x-github-event&amp;#39;] &#x3D; &amp;#39;push&amp;#39;;
        if (options.secret) {
          // For testing, we&amp;#39;ll skip signature generation
          headers[&amp;#39;x-hub-signature-256&amp;#39;] &#x3D; &amp;#39;sha256&#x3D;test&amp;#39;;
        }
      } else {
        headers[&amp;#39;x-gitlab-event&amp;#39;] &#x3D; &amp;#39;Push Hook&amp;#39;;
        if (options.secret) {
          headers[&amp;#39;x-gitlab-token&amp;#39;] &#x3D; options.secret;
        }
      }

      const response &#x3D; await client.request(&#x60;/webhooks/${provider}&#x60;, {
        method: &amp;#39;POST&amp;#39;,
        headers,
        body: JSON.stringify(testPayload),
      });

      return {
        ok: response.ok,
        status: response.status,
        data: await response.json(),
      };
    });

    if (result.ok) {
      console.log(chalk.green(&amp;#39;âœ… Webhook test successful&amp;#39;));
      if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
        console.log(formatJson(result.data));
      } else {
        console.log(&#x60;Status: ${result.status}&#x60;);
        console.log(&#x60;Message: ${result.data.message}&#x60;);
        if (result.data.actions_taken) {
          console.log(&#x60;Actions: ${result.data.actions_taken.join(&amp;#39;, &amp;#39;)}&#x60;);
        }
      }
    } else {
      console.log(chalk.red(&amp;#39;âŒ Webhook test failed&amp;#39;));
      console.log(&#x60;Status: ${result.status}&#x60;);
      console.log(&#x60;Error: ${result.data.message || &amp;#39;Unknown error&amp;#39;}&#x60;);
    }

    return result.ok ? 0 : 1;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Error testing webhook:&amp;#39;),
      error instanceof Error ? error.message : error
    );
    return 1;
  }
}

/**
 * Show webhook setup instructions
 */
export function showWebhookHelp(): void {
  console.log(chalk.blue(&amp;#39;\nğŸ“¡ Webhook Setup Guide\n&amp;#39;));

  console.log(chalk.yellow(&amp;#39;1. Enable webhooks in your Arbiter server:&amp;#39;));
  console.log(&amp;#39;   export WEBHOOKS_ENABLED&#x3D;true&amp;#39;);
  console.log(&amp;#39;   export WEBHOOK_SECRET&#x3D;your-secret-key&amp;#39;);
  console.log(&amp;#39;   export GITHUB_WEBHOOK_SECRET&#x3D;github-specific-secret&amp;#39;);
  console.log(&amp;#39;   export GITLAB_WEBHOOK_SECRET&#x3D;gitlab-specific-secret&amp;#39;);

  console.log(chalk.yellow(&amp;#39;\n2. Set up Cloudflare tunnel for local development:&amp;#39;));
  console.log(&amp;#39;   ./scripts/cloudflare-tunnel.sh start&amp;#39;);

  console.log(chalk.yellow(&amp;#39;\n3. Configure webhook in your repository:&amp;#39;));
  console.log(&amp;#39;   GitHub: Settings â†’ Webhooks â†’ Add webhook&amp;#39;);
  console.log(&amp;#39;   GitLab: Settings â†’ Webhooks â†’ Add webhook&amp;#39;);

  console.log(chalk.yellow(&amp;#39;\n4. Webhook configuration:&amp;#39;));
  console.log(&amp;#39;   URL: https://your-tunnel.cfargotunnel.com/webhooks/github&amp;#39;);
  console.log(&amp;#39;   Content type: application/json&amp;#39;);
  console.log(&amp;#39;   Secret: (your webhook secret)&amp;#39;);
  console.log(&amp;#39;   Events: push, pull requests (GitHub) / push, merge requests (GitLab)&amp;#39;);

  console.log(chalk.yellow(&amp;#39;\n5. Test your webhook:&amp;#39;));
  console.log(&amp;#39;   arbiter webhook test github --secret your-secret&amp;#39;);

  console.log(chalk.blue(&amp;#39;\nğŸ“š Commands:&amp;#39;));
  console.log(&amp;#39;   arbiter webhook list                     - List webhook status&amp;#39;);
  console.log(&amp;#39;   arbiter webhook get &amp;lt;project-id&amp;gt;         - Get webhook config&amp;#39;);
  console.log(&amp;#39;   arbiter webhook set &amp;lt;project-id&amp;gt; [opts]  - Set webhook config&amp;#39;);
  console.log(&amp;#39;   arbiter webhook delete &amp;lt;project-id&amp;gt;      - Delete webhook config&amp;#39;);
  console.log(&amp;#39;   arbiter webhook test &amp;lt;provider&amp;gt;          - Test webhook endpoint&amp;#39;);
  console.log(&amp;#39;   arbiter webhook help                     - Show this help&amp;#39;);
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-67">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/platform-detection.ts</div>
                <div class="file-content">
                    <pre>/**
 * Platform Detection Utilities for Smart Service Configuration
 *
 * Automatically detects platform context from project structure and suggests
 * appropriate service types for Cloudflare, Vercel, and Supabase platforms.
 */

import path from &amp;#39;node:path&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import type { PlatformServiceType } from &amp;#39;../cue/index.js&amp;#39;;

export interface PlatformContext {
  detected: &amp;#39;cloudflare&amp;#39; | &amp;#39;vercel&amp;#39; | &amp;#39;supabase&amp;#39; | &amp;#39;kubernetes&amp;#39; | &amp;#39;unknown&amp;#39;;
  confidence: number; // 0-1 score
  indicators: string[];
  suggestions: PlatformSuggestion[];
}

export interface PlatformSuggestion {
  serviceName: string;
  serviceType: PlatformServiceType;
  reason: string;
}

/**
 * Detect platform context from project structure and files
 */
export async function detectPlatform(projectDir &#x3D; &amp;#39;.&amp;#39;): Promise&amp;lt;PlatformContext&amp;gt; {
  const indicators: string[] &#x3D; [];
  let cloudflareScore &#x3D; 0;
  let vercelScore &#x3D; 0;
  let supabaseScore &#x3D; 0;

  try {
    // Check for Cloudflare indicators
    if (await fs.pathExists(path.join(projectDir, &amp;#39;wrangler.toml&amp;#39;))) {
      cloudflareScore +&#x3D; 0.8;
      indicators.push(&amp;#39;wrangler.toml found&amp;#39;);
    }

    if (await fs.pathExists(path.join(projectDir, &amp;#39;workers&amp;#39;))) {
      cloudflareScore +&#x3D; 0.6;
      indicators.push(&amp;#39;workers/ directory found&amp;#39;);
    }

    // Check for Vercel indicators
    if (await fs.pathExists(path.join(projectDir, &amp;#39;vercel.json&amp;#39;))) {
      vercelScore +&#x3D; 0.8;
      indicators.push(&amp;#39;vercel.json found&amp;#39;);
    }

    if (await fs.pathExists(path.join(projectDir, &amp;#39;.vercel&amp;#39;))) {
      vercelScore +&#x3D; 0.4;
      indicators.push(&amp;#39;.vercel/ directory found&amp;#39;);
    }

    if (await fs.pathExists(path.join(projectDir, &amp;#39;api&amp;#39;))) {
      vercelScore +&#x3D; 0.3;
      indicators.push(&amp;#39;api/ directory found&amp;#39;);
    }

    // Check for Supabase indicators
    if (await fs.pathExists(path.join(projectDir, &amp;#39;supabase&amp;#39;))) {
      supabaseScore +&#x3D; 0.7;
      indicators.push(&amp;#39;supabase/ directory found&amp;#39;);
    }

    if (await fs.pathExists(path.join(projectDir, &amp;#39;.env&amp;#39;))) {
      const envContent &#x3D; await fs.readFile(path.join(projectDir, &amp;#39;.env&amp;#39;), &amp;#39;utf-8&amp;#39;);
      if (envContent.includes(&amp;#39;SUPABASE&amp;#39;)) {
        supabaseScore +&#x3D; 0.5;
        indicators.push(&amp;#39;SUPABASE env vars found&amp;#39;);
      }
      if (envContent.includes(&amp;#39;CLOUDFLARE&amp;#39;)) {
        cloudflareScore +&#x3D; 0.3;
        indicators.push(&amp;#39;CLOUDFLARE env vars found&amp;#39;);
      }
      if (envContent.includes(&amp;#39;VERCEL&amp;#39;)) {
        vercelScore +&#x3D; 0.3;
        indicators.push(&amp;#39;VERCEL env vars found&amp;#39;);
      }
    }

    // Check package.json for platform-specific dependencies
    const packageJsonPath &#x3D; path.join(projectDir, &amp;#39;package.json&amp;#39;);
    if (await fs.pathExists(packageJsonPath)) {
      const packageJson &#x3D; await fs.readJson(packageJsonPath);
      const deps &#x3D; { ...packageJson.dependencies, ...packageJson.devDependencies };

      if (deps[&amp;#39;@cloudflare/workers-types&amp;#39;] || deps.wrangler) {
        cloudflareScore +&#x3D; 0.4;
        indicators.push(&amp;#39;Cloudflare dependencies found&amp;#39;);
      }

      if (deps[&amp;#39;@vercel/node&amp;#39;] || deps.vercel) {
        vercelScore +&#x3D; 0.4;
        indicators.push(&amp;#39;Vercel dependencies found&amp;#39;);
      }

      if (deps[&amp;#39;@supabase/supabase-js&amp;#39;] || deps.supabase) {
        supabaseScore +&#x3D; 0.4;
        indicators.push(&amp;#39;Supabase dependencies found&amp;#39;);
      }
    }
  } catch (error) {
    // Ignore file system errors
  }

  // Determine the detected platform
  const maxScore &#x3D; Math.max(cloudflareScore, vercelScore, supabaseScore);
  let detected: PlatformContext[&amp;#39;detected&amp;#39;] &#x3D; &amp;#39;unknown&amp;#39;;

  if (maxScore &amp;gt;&#x3D; 0.5) {
    if (cloudflareScore &#x3D;&#x3D;&#x3D; maxScore) detected &#x3D; &amp;#39;cloudflare&amp;#39;;
    else if (vercelScore &#x3D;&#x3D;&#x3D; maxScore) detected &#x3D; &amp;#39;vercel&amp;#39;;
    else if (supabaseScore &#x3D;&#x3D;&#x3D; maxScore) detected &#x3D; &amp;#39;supabase&amp;#39;;
  } else if (maxScore &amp;gt; 0) {
    detected &#x3D; &amp;#39;kubernetes&amp;#39;; // Default to Kubernetes if some indicators but low confidence
  }

  const suggestions &#x3D; generatePlatformSuggestions(detected, projectDir);

  return {
    detected,
    confidence: maxScore,
    indicators,
    suggestions,
  };
}

/**
 * Generate platform-specific service suggestions based on detected platform
 */
function generatePlatformSuggestions(
  platform: PlatformContext[&amp;#39;detected&amp;#39;],
  projectDir: string
): PlatformSuggestion[] {
  const suggestions: PlatformSuggestion[] &#x3D; [];

  switch (platform) {
    case &amp;#39;cloudflare&amp;#39;:
      suggestions.push(
        {
          serviceName: &amp;#39;worker&amp;#39;,
          serviceType: &amp;#39;cloudflare_worker&amp;#39;,
          reason: &amp;#39;Cloudflare Worker for API endpoints&amp;#39;,
        },
        {
          serviceName: &amp;#39;database&amp;#39;,
          serviceType: &amp;#39;cloudflare_d1&amp;#39;,
          reason: &amp;#39;D1 SQLite database instead of container&amp;#39;,
        },
        {
          serviceName: &amp;#39;cache&amp;#39;,
          serviceType: &amp;#39;cloudflare_kv&amp;#39;,
          reason: &amp;#39;KV store instead of Redis container&amp;#39;,
        },
        {
          serviceName: &amp;#39;storage&amp;#39;,
          serviceType: &amp;#39;cloudflare_r2&amp;#39;,
          reason: &amp;#39;R2 object storage for files&amp;#39;,
        }
      );
      break;

    case &amp;#39;vercel&amp;#39;:
      suggestions.push(
        {
          serviceName: &amp;#39;api&amp;#39;,
          serviceType: &amp;#39;vercel_function&amp;#39;,
          reason: &amp;#39;Vercel Function for API routes&amp;#39;,
        },
        {
          serviceName: &amp;#39;edge-api&amp;#39;,
          serviceType: &amp;#39;vercel_edge_function&amp;#39;,
          reason: &amp;#39;Edge Function for low-latency endpoints&amp;#39;,
        },
        {
          serviceName: &amp;#39;cache&amp;#39;,
          serviceType: &amp;#39;vercel_kv&amp;#39;,
          reason: &amp;#39;Vercel KV for caching&amp;#39;,
        },
        {
          serviceName: &amp;#39;database&amp;#39;,
          serviceType: &amp;#39;vercel_postgres&amp;#39;,
          reason: &amp;#39;Vercel Postgres instead of container&amp;#39;,
        }
      );
      break;

    case &amp;#39;supabase&amp;#39;:
      suggestions.push(
        {
          serviceName: &amp;#39;database&amp;#39;,
          serviceType: &amp;#39;supabase_database&amp;#39;,
          reason: &amp;#39;Supabase PostgreSQL database&amp;#39;,
        },
        {
          serviceName: &amp;#39;auth&amp;#39;,
          serviceType: &amp;#39;supabase_auth&amp;#39;,
          reason: &amp;#39;Supabase Authentication service&amp;#39;,
        },
        {
          serviceName: &amp;#39;storage&amp;#39;,
          serviceType: &amp;#39;supabase_storage&amp;#39;,
          reason: &amp;#39;Supabase Storage for files&amp;#39;,
        },
        {
          serviceName: &amp;#39;functions&amp;#39;,
          serviceType: &amp;#39;supabase_functions&amp;#39;,
          reason: &amp;#39;Supabase Edge Functions&amp;#39;,
        }
      );
      break;
  }

  return suggestions;
}

/**
 * Get platform-appropriate service configuration defaults
 */
export function getPlatformServiceDefaults(serviceType: PlatformServiceType) {
  const defaults: Partial&amp;lt;any&amp;gt; &#x3D; {};

  switch (serviceType) {
    // Cloudflare services
    case &amp;#39;cloudflare_worker&amp;#39;:
      defaults.platform &#x3D; &amp;#39;cloudflare&amp;#39;;
      defaults.type &#x3D; &amp;#39;serverless&amp;#39;;
      defaults.runtime &#x3D; &amp;#39;worker&amp;#39;;
      break;

    case &amp;#39;cloudflare_durable_object&amp;#39;:
      defaults.platform &#x3D; &amp;#39;cloudflare&amp;#39;;
      defaults.type &#x3D; &amp;#39;serverless&amp;#39;;
      defaults.runtime &#x3D; &amp;#39;durable_object&amp;#39;;
      break;

    case &amp;#39;cloudflare_d1&amp;#39;:
      defaults.platform &#x3D; &amp;#39;cloudflare&amp;#39;;
      defaults.type &#x3D; &amp;#39;managed&amp;#39;;
      defaults.language &#x3D; &amp;#39;sql&amp;#39;;
      break;

    case &amp;#39;cloudflare_kv&amp;#39;:
      defaults.platform &#x3D; &amp;#39;cloudflare&amp;#39;;
      defaults.type &#x3D; &amp;#39;managed&amp;#39;;
      defaults.language &#x3D; &amp;#39;key-value&amp;#39;;
      break;

    case &amp;#39;cloudflare_r2&amp;#39;:
      defaults.platform &#x3D; &amp;#39;cloudflare&amp;#39;;
      defaults.type &#x3D; &amp;#39;managed&amp;#39;;
      defaults.language &#x3D; &amp;#39;object-storage&amp;#39;;
      break;

    // Vercel services
    case &amp;#39;vercel_function&amp;#39;:
      defaults.platform &#x3D; &amp;#39;vercel&amp;#39;;
      defaults.type &#x3D; &amp;#39;serverless&amp;#39;;
      defaults.runtime &#x3D; &amp;#39;nodejs18.x&amp;#39;;
      break;

    case &amp;#39;vercel_edge_function&amp;#39;:
      defaults.platform &#x3D; &amp;#39;vercel&amp;#39;;
      defaults.type &#x3D; &amp;#39;serverless&amp;#39;;
      defaults.runtime &#x3D; &amp;#39;edge-runtime&amp;#39;;
      break;

    case &amp;#39;vercel_kv&amp;#39;:
      defaults.platform &#x3D; &amp;#39;vercel&amp;#39;;
      defaults.type &#x3D; &amp;#39;managed&amp;#39;;
      defaults.language &#x3D; &amp;#39;key-value&amp;#39;;
      break;

    case &amp;#39;vercel_postgres&amp;#39;:
      defaults.platform &#x3D; &amp;#39;vercel&amp;#39;;
      defaults.type &#x3D; &amp;#39;managed&amp;#39;;
      defaults.language &#x3D; &amp;#39;sql&amp;#39;;
      break;

    // Supabase services
    case &amp;#39;supabase_database&amp;#39;:
      defaults.platform &#x3D; &amp;#39;supabase&amp;#39;;
      defaults.type &#x3D; &amp;#39;managed&amp;#39;;
      defaults.language &#x3D; &amp;#39;postgresql&amp;#39;;
      break;

    case &amp;#39;supabase_auth&amp;#39;:
      defaults.platform &#x3D; &amp;#39;supabase&amp;#39;;
      defaults.type &#x3D; &amp;#39;managed&amp;#39;;
      defaults.language &#x3D; &amp;#39;auth&amp;#39;;
      break;

    case &amp;#39;supabase_storage&amp;#39;:
      defaults.platform &#x3D; &amp;#39;supabase&amp;#39;;
      defaults.type &#x3D; &amp;#39;managed&amp;#39;;
      defaults.language &#x3D; &amp;#39;object-storage&amp;#39;;
      break;

    case &amp;#39;supabase_functions&amp;#39;:
      defaults.platform &#x3D; &amp;#39;supabase&amp;#39;;
      defaults.type &#x3D; &amp;#39;serverless&amp;#39;;
      defaults.runtime &#x3D; &amp;#39;deno&amp;#39;;
      break;
  }

  return defaults;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-68">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/utils/logger.ts</div>
                <div class="file-content">
                    <pre>/**
 * Development logging utility with configurable levels and quiet mode
 *
 * Usage:
 * 1. Import: import { createLogger } from &amp;#39;./utils/logger&amp;#39;;
 * 2. Create: const log &#x3D; createLogger(&amp;#39;ComponentName&amp;#39;);
 * 3. Use: log.info(&amp;#39;Message&amp;#39;, data);
 *
 * Log levels (set via VITE_LOG_LEVEL in .env.development):
 * - SILENT (0): No output
 * - ERROR (1): Only errors
 * - WARN (2): Errors and warnings
 * - INFO (3): Errors, warnings, and info (default for quiet dev)
 * - DEBUG (4): Verbose debugging
 * - TRACE (5): Extremely verbose (render state, ping/pong, etc.)
 *
 * Runtime control (in browser console):
 * - __arbiterLogger.setLevel(&amp;#39;DEBUG&amp;#39;) or __arbiterLogger.setLevel(4)
 * - __arbiterLogger.current() - shows current level
 */

export enum LogLevel {
  SILENT &#x3D; 0,
  ERROR &#x3D; 1,
  WARN &#x3D; 2,
  INFO &#x3D; 3,
  DEBUG &#x3D; 4,
  TRACE &#x3D; 5,
}

export interface LoggerConfig {
  level: LogLevel;
  enableColors: boolean;
  enableTimestamps: boolean;
}

class Logger {
  private config: LoggerConfig &#x3D; {
    level: this.getDefaultLogLevel(),
    enableColors: true,
    enableTimestamps: false,
  };

  private getDefaultLogLevel(): LogLevel {
    // Check environment variables
    const envLevel &#x3D; import.meta.env.VITE_LOG_LEVEL;
    if (envLevel) {
      const level &#x3D; LogLevel[envLevel.toUpperCase() as keyof typeof LogLevel];
      if (level !&#x3D;&#x3D; undefined) return level;
    }

    // Default to INFO in development, WARN in production
    return import.meta.env.DEV ? LogLevel.INFO : LogLevel.WARN;
  }

  setLevel(level: LogLevel) {
    this.config.level &#x3D; level;
  }

  setConfig(config: Partial&amp;lt;LoggerConfig&amp;gt;) {
    this.config &#x3D; { ...this.config, ...config };
  }

  private formatMessage(
    level: string,
    category: string,
    message: string,
    ...args: any[]
  ): [string, ...any[]] {
    const parts &#x3D; [];

    if (this.config.enableTimestamps) {
      parts.push(new Date().toISOString().substring(11, 23));
    }

    if (this.config.enableColors) {
      const colors &#x3D; {
        ERROR: &amp;#39;\x1b[31m&amp;#39;, // red
        WARN: &amp;#39;\x1b[33m&amp;#39;, // yellow
        INFO: &amp;#39;\x1b[36m&amp;#39;, // cyan
        DEBUG: &amp;#39;\x1b[32m&amp;#39;, // green
        TRACE: &amp;#39;\x1b[35m&amp;#39;, // magenta
        RESET: &amp;#39;\x1b[0m&amp;#39;,
      };
      parts.push(&#x60;${colors[level as keyof typeof colors] || &amp;#39;&amp;#39;}[${level}]${colors.RESET}&#x60;);
    } else {
      parts.push(&#x60;[${level}]&#x60;);
    }

    if (category) {
      parts.push(&#x60;[${category}]&#x60;);
    }

    parts.push(message);

    return [parts.join(&amp;#39; &amp;#39;), ...args];
  }

  error(category: string, message: string, ...args: any[]) {
    if (this.config.level &amp;gt;&#x3D; LogLevel.ERROR) {
      console.error(...this.formatMessage(&amp;#39;ERROR&amp;#39;, category, message, ...args));
    }
  }

  warn(category: string, message: string, ...args: any[]) {
    if (this.config.level &amp;gt;&#x3D; LogLevel.WARN) {
      console.warn(...this.formatMessage(&amp;#39;WARN&amp;#39;, category, message, ...args));
    }
  }

  info(category: string, message: string, ...args: any[]) {
    if (this.config.level &amp;gt;&#x3D; LogLevel.INFO) {
      console.info(...this.formatMessage(&amp;#39;INFO&amp;#39;, category, message, ...args));
    }
  }

  debug(category: string, message: string, ...args: any[]) {
    if (this.config.level &amp;gt;&#x3D; LogLevel.DEBUG) {
      console.log(...this.formatMessage(&amp;#39;DEBUG&amp;#39;, category, message, ...args));
    }
  }

  trace(category: string, message: string, ...args: any[]) {
    if (this.config.level &amp;gt;&#x3D; LogLevel.TRACE) {
      console.log(...this.formatMessage(&amp;#39;TRACE&amp;#39;, category, message, ...args));
    }
  }

  // Convenience methods for common logging patterns
  wsEvent(event: any) {
    this.debug(&amp;#39;WebSocket&amp;#39;, &amp;#39;Event received:&amp;#39;, event);
  }

  wsConnection(status: &amp;#39;connected&amp;#39; | &amp;#39;disconnected&amp;#39; | &amp;#39;reconnecting&amp;#39;, details?: any) {
    this.info(&amp;#39;WebSocket&amp;#39;, &#x60;Connection ${status}&#x60;, details);
  }

  wsError(message: string, error?: any) {
    this.error(&amp;#39;WebSocket&amp;#39;, message, error);
  }

  appInit(step: string, data?: any) {
    this.debug(&amp;#39;App&amp;#39;, &#x60;Initialization: ${step}&#x60;, data);
  }

  editorSetup(message: string, data?: any) {
    this.debug(&amp;#39;Editor&amp;#39;, message, data);
  }

  apiRequest(method: string, url: string, data?: any) {
    this.trace(&amp;#39;API&amp;#39;, &#x60;${method.toUpperCase()} ${url}&#x60;, data);
  }

  apiResponse(method: string, url: string, status: number, data?: any) {
    if (status &amp;gt;&#x3D; 400) {
      this.error(&amp;#39;API&amp;#39;, &#x60;${method.toUpperCase()} ${url} - ${status}&#x60;, data);
    } else {
      this.trace(&amp;#39;API&amp;#39;, &#x60;${method.toUpperCase()} ${url} - ${status}&#x60;, data);
    }
  }
}

// Export singleton instance
export const logger &#x3D; new Logger();

// Export convenience function to create category-specific loggers
export function createLogger(category: string) {
  return {
    error: (message: string, ...args: any[]) &#x3D;&amp;gt; logger.error(category, message, ...args),
    warn: (message: string, ...args: any[]) &#x3D;&amp;gt; logger.warn(category, message, ...args),
    info: (message: string, ...args: any[]) &#x3D;&amp;gt; logger.info(category, message, ...args),
    debug: (message: string, ...args: any[]) &#x3D;&amp;gt; logger.debug(category, message, ...args),
    trace: (message: string, ...args: any[]) &#x3D;&amp;gt; logger.trace(category, message, ...args),
  };
}

// Export types
export type CategoryLogger &#x3D; ReturnType&amp;lt;typeof createLogger&amp;gt;;

// Development helper: Add to window object for runtime control
if (import.meta.env.DEV &amp;amp;&amp;amp; typeof window !&#x3D;&#x3D; &amp;#39;undefined&amp;#39;) {
  (window as any).__arbiterLogger &#x3D; {
    setLevel: (level: string | number) &#x3D;&amp;gt; {
      const logLevel &#x3D;
        typeof level &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39; ? LogLevel[level.toUpperCase() as keyof typeof LogLevel] : level;
      if (logLevel !&#x3D;&#x3D; undefined) {
        logger.setLevel(logLevel);
        console.log(&#x60;Log level set to: ${LogLevel[logLevel]}&#x60;);
      }
    },
    levels: LogLevel,
    current: () &#x3D;&amp;gt; LogLevel[logger.config.level],
  };
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-69">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/validate.ts</div>
                <div class="file-content">
                    <pre>import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import { ApiClient } from &amp;#39;../api-client.js&amp;#39;;
import type { CLIConfig, ValidateOptions, ValidationResult } from &amp;#39;../types.js&amp;#39;;
import {
  formatErrorDetails,
  formatJson,
  formatSummary,
  formatValidationTable,
  formatWarningDetails,
} from &amp;#39;../utils/formatting.js&amp;#39;;
import { withProgress } from &amp;#39;../utils/progress.js&amp;#39;;

/**
 * Validate command implementation
 * Explicit validation with schema and config options
 */
export async function validateCommand(
  files: string[],
  options: ValidateOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  try {
    if (files.length &#x3D;&#x3D;&#x3D; 0) {
      console.error(chalk.red(&amp;#39;No files specified for validation&amp;#39;));
      return 1;
    }

    // Resolve file paths
    const resolvedFiles &#x3D; await resolveFiles(files, config.projectDir);

    if (resolvedFiles.length &#x3D;&#x3D;&#x3D; 0) {
      console.error(chalk.red(&amp;#39;No valid files found&amp;#39;));
      return 1;
    }

    console.log(chalk.dim(&#x60;Validating ${resolvedFiles.length} files&#x60;));

    // Load schema if specified
    let schemaContent: string | undefined;
    if (options.schema) {
      try {
        schemaContent &#x3D; await fs.readFile(options.schema, &amp;#39;utf-8&amp;#39;);
      } catch (_error) {
        console.error(chalk.red(&#x60;Cannot read schema file: ${options.schema}&#x60;));
        return 1;
      }
    }

    // Load config if specified
    let configContent: string | undefined;
    if (options.config) {
      try {
        configContent &#x3D; await fs.readFile(options.config, &amp;#39;utf-8&amp;#39;);
      } catch (_error) {
        console.error(chalk.red(&#x60;Cannot read config file: ${options.config}&#x60;));
        return 1;
      }
    }

    // Validate files
    const results &#x3D; await validateFiles(
      resolvedFiles,
      config,
      options,
      schemaContent,
      configContent
    );

    // Format and display results
    if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
      console.log(formatJson(results, config.color));
    } else {
      displayResults(results, options, config);
    }

    // Determine exit code
    const hasErrors &#x3D; results.some(r &#x3D;&amp;gt; r.status &#x3D;&#x3D;&#x3D; &amp;#39;invalid&amp;#39; || r.status &#x3D;&#x3D;&#x3D; &amp;#39;error&amp;#39;);
    return hasErrors ? 1 : 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Validate command failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 2;
  }
}

/**
 * Resolve and validate file paths
 */
async function resolveFiles(files: string[], cwd: string): Promise&amp;lt;string[]&amp;gt; {
  const resolved: string[] &#x3D; [];

  for (const file of files) {
    const fullPath &#x3D; path.resolve(cwd, file);

    try {
      const stats &#x3D; await fs.stat(fullPath);
      if (stats.isFile()) {
        resolved.push(fullPath);
      } else if (stats.isDirectory()) {
        // Find .cue files in directory
        const dirFiles &#x3D; await fs.readdir(fullPath);
        const cueFiles &#x3D; dirFiles.filter(f &#x3D;&amp;gt; f.endsWith(&amp;#39;.cue&amp;#39;)).map(f &#x3D;&amp;gt; path.join(fullPath, f));
        resolved.push(...cueFiles);
      }
    } catch (_error) {
      console.warn(chalk.yellow(&#x60;Warning: Cannot access ${file}&#x60;));
    }
  }

  return resolved;
}

/**
 * Validate multiple files with enhanced options
 */
async function validateFiles(
  files: string[],
  config: CLIConfig,
  options: ValidateOptions,
  schemaContent?: string,
  configContent?: string
): Promise&amp;lt;ValidationResult[]&amp;gt; {
  const apiClient &#x3D; await initializeValidationClient(config);

  return withProgress({ text: &#x60;Validating ${files.length} files...&#x60;, color: &amp;#39;blue&amp;#39; }, async () &#x3D;&amp;gt; {
    return await processValidationFiles(files, apiClient, options, schemaContent, configContent);
  });
}

/**
 * Initialize and verify API client for validation
 */
async function initializeValidationClient(config: CLIConfig): Promise&amp;lt;ApiClient&amp;gt; {
  const apiClient &#x3D; new ApiClient(config);

  const healthCheck &#x3D; await apiClient.health();
  if (!healthCheck.success) {
    throw new Error(&#x60;Cannot connect to Arbiter server: ${healthCheck.error}&#x60;);
  }

  return apiClient;
}

/**
 * Process validation for all files
 */
async function processValidationFiles(
  files: string[],
  apiClient: ApiClient,
  options: ValidateOptions,
  schemaContent?: string,
  configContent?: string
): Promise&amp;lt;ValidationResult[]&amp;gt; {
  const results: ValidationResult[] &#x3D; [];

  for (const file of files) {
    const result &#x3D; await validateSingleFile(file, apiClient, options, schemaContent, configContent);
    results.push(result);

    if (options.verbose) {
      displayValidationProgress(result, file);
    }
  }

  return results;
}

/**
 * Display validation progress for a single file
 */
function displayValidationProgress(result: ValidationResult, file: string): void {
  const status &#x3D; getValidationStatusIcon(result.status);
  console.log(&#x60;${status} ${path.basename(file)}&#x60;);
}

/**
 * Get appropriate icon for validation status
 */
function getValidationStatusIcon(status: string): string {
  switch (status) {
    case &amp;#39;valid&amp;#39;:
      return chalk.green(&amp;#39;âœ“&amp;#39;);
    case &amp;#39;invalid&amp;#39;:
      return chalk.red(&amp;#39;âœ—&amp;#39;);
    default:
      return chalk.yellow(&amp;#39;!&amp;#39;);
  }
}

/**
 * Validate a single file with schema and config
 */
async function validateSingleFile(
  filePath: string,
  apiClient: ApiClient,
  options: ValidateOptions,
  schemaContent?: string,
  configContent?: string
): Promise&amp;lt;ValidationResult&amp;gt; {
  const startTime &#x3D; Date.now();

  try {
    // Read file content
    const content &#x3D; await fs.readFile(filePath, &amp;#39;utf-8&amp;#39;);

    // Combine content with schema and config if provided
    let fullContent &#x3D; content;

    if (schemaContent) {
      fullContent &#x3D; &#x60;${schemaContent}\n\n${fullContent}&#x60;;
    }

    if (configContent) {
      fullContent &#x3D; &#x60;${fullContent}\n\n${configContent}&#x60;;
    }

    // Validate using API
    const validationResult &#x3D; await apiClient.validate(fullContent, {
      strict: options.strict,
    });

    if (!validationResult.success || !validationResult.data) {
      return {
        file: path.basename(filePath),
        status: &amp;#39;error&amp;#39;,
        errors: [
          {
            line: 0,
            column: 0,
            message: validationResult.error || &amp;#39;Unknown validation error&amp;#39;,
            severity: &amp;#39;error&amp;#39; as const,
            category: &amp;#39;api&amp;#39;,
          },
        ],
        warnings: [],
        processingTime: Date.now() - startTime,
      };
    }

    const data &#x3D; validationResult.data;

    // Process errors
    const errors &#x3D;
      data.errors?.map(error &#x3D;&amp;gt; ({
        line: error.line || 0,
        column: error.column || 0,
        message: error.message,
        severity: &amp;#39;error&amp;#39; as const,
        category: &amp;#39;validation&amp;#39;,
      })) || [];

    // Process warnings
    const warnings &#x3D;
      data.warnings?.map(warning &#x3D;&amp;gt; ({
        line: warning.line || 0,
        column: warning.column || 0,
        message: warning.message,
        category: &amp;#39;validation&amp;#39;,
      })) || [];

    // In strict mode, treat warnings as errors
    if (options.strict &amp;amp;&amp;amp; warnings.length &amp;gt; 0) {
      warnings.forEach(warning &#x3D;&amp;gt; {
        errors.push({
          line: warning.line,
          column: warning.column,
          message: warning.message,
          severity: &amp;#39;error&amp;#39; as const,
          category: warning.category,
        });
      });
    }

    const status &#x3D; data.success &amp;amp;&amp;amp; (!options.strict || warnings.length &#x3D;&#x3D;&#x3D; 0) ? &amp;#39;valid&amp;#39; : &amp;#39;invalid&amp;#39;;

    return {
      file: path.basename(filePath),
      status,
      errors,
      warnings: options.strict ? [] : warnings, // Clear warnings in strict mode since they become errors
      processingTime: Date.now() - startTime,
    };
  } catch (error) {
    return {
      file: path.basename(filePath),
      status: &amp;#39;error&amp;#39;,
      errors: [
        {
          line: 0,
          column: 0,
          message: error instanceof Error ? error.message : String(error),
          severity: &amp;#39;error&amp;#39; as const,
          category: &amp;#39;system&amp;#39;,
        },
      ],
      warnings: [],
      processingTime: Date.now() - startTime,
    };
  }
}

/**
 * Display validation results with proper formatting
 */
function displayResults(
  results: ValidationResult[],
  options: ValidateOptions,
  _config: CLIConfig
): void {
  // Show table
  console.log(&#x60;\n${formatValidationTable(results)}&#x60;);

  // Show detailed errors if present
  if (options.verbose || results.some(r &#x3D;&amp;gt; r.errors.length &amp;gt; 0)) {
    const errorDetails &#x3D; formatErrorDetails(results);
    if (errorDetails) {
      console.log(errorDetails);
    }
  }

  // Show warnings if verbose and not in strict mode
  if (options.verbose &amp;amp;&amp;amp; !options.strict &amp;amp;&amp;amp; results.some(r &#x3D;&amp;gt; r.warnings.length &amp;gt; 0)) {
    const warningDetails &#x3D; formatWarningDetails(results);
    if (warningDetails) {
      console.log(warningDetails);
    }
  }

  // Show summary
  console.log(formatSummary(results));

  // Show strict mode note if enabled
  if (options.strict) {
    console.log(chalk.dim(&amp;#39;\nNote: Running in strict mode (warnings treated as errors)&amp;#39;));
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-70">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/file-watcher.ts</div>
                <div class="file-content">
                    <pre>import chokidar from &amp;quot;chokidar&amp;quot;;
import { debounce } from &amp;quot;./debounce.js&amp;quot;;

export interface FileWatcherOptions {
  /** Paths or patterns to watch */
  paths: string[];
  /** Debounce delay in milliseconds (250-400ms per spec) */
  debounce?: number;
  /** Whether to output NDJSON for agent consumption */
  agentMode?: boolean;
  /** Custom file patterns to watch */
  patterns?: string[];
  /** Ignore patterns */
  ignored?: string[];
}

export interface WatchEvent {
  type: &amp;quot;add&amp;quot; | &amp;quot;change&amp;quot; | &amp;quot;unlink&amp;quot; | &amp;quot;addDir&amp;quot; | &amp;quot;unlinkDir&amp;quot;;
  path: string;
  timestamp: number;
}

export interface WatchBatch {
  events: WatchEvent[];
  timestamp: number;
  debounceWindow: number;
}

/**
 * Cross-platform file watcher with debouncing and burst coalescing
 * Implements requirements from arbiter.assembly.cue for 250-400ms debouncing
 */
export class FileWatcher {
  private watcher: chokidar.FSWatcher | null &#x3D; null;
  private debouncedHandler: ((...args: any[]) &#x3D;&amp;gt; void) | null &#x3D; null;
  private eventQueue: WatchEvent[] &#x3D; [];
  private options: Required&amp;lt;FileWatcherOptions&amp;gt;;

  constructor(options: FileWatcherOptions) {
    this.options &#x3D; {
      paths: options.paths,
      debounce: Math.max(250, Math.min(400, options.debounce ?? 300)), // Enforce spec limits
      agentMode: options.agentMode ?? false,
      patterns: options.patterns ?? [
        &amp;quot;**/*.cue&amp;quot;,
        &amp;quot;**/arbiter.assembly.cue&amp;quot;,
        &amp;quot;**/*.json&amp;quot;,
        &amp;quot;**/*.yaml&amp;quot;,
        &amp;quot;**/*.yml&amp;quot;,
      ],
      ignored: options.ignored ?? [
        &amp;quot;node_modules/**&amp;quot;,
        &amp;quot;.git/**&amp;quot;,
        &amp;quot;dist/**&amp;quot;,
        &amp;quot;build/**&amp;quot;,
        &amp;quot;target/**&amp;quot;,
        &amp;quot;**/.DS_Store&amp;quot;,
        &amp;quot;**/Thumbs.db&amp;quot;,
      ],
    };
  }

  /**
   * Start watching files
   */
  async start(onBatch: (batch: WatchBatch) &#x3D;&amp;gt; Promise&amp;lt;void&amp;gt;): Promise&amp;lt;void&amp;gt; {
    if (this.watcher) {
      throw new Error(&amp;quot;Watcher is already running&amp;quot;);
    }

    // Create debounced handler for burst coalescing
    this.debouncedHandler &#x3D; debounce(async () &#x3D;&amp;gt; {
      if (this.eventQueue.length &amp;gt; 0) {
        const batch: WatchBatch &#x3D; {
          events: [...this.eventQueue],
          timestamp: Date.now(),
          debounceWindow: this.options.debounce,
        };

        // Clear the queue before processing
        this.eventQueue &#x3D; [];

        try {
          await onBatch(batch);
        } catch (error) {
          if (this.options.agentMode) {
            console.log(
              JSON.stringify({
                type: &amp;quot;error&amp;quot;,
                message: &#x60;Watch batch processing failed: ${error instanceof Error ? error.message : String(error)}&#x60;,
                timestamp: Date.now(),
              }),
            );
          } else {
            console.error(
              &#x60;Watch batch processing failed: ${error instanceof Error ? error.message : String(error)}&#x60;,
            );
          }
        }
      }
    }, this.options.debounce);

    // Initialize chokidar watcher
    this.watcher &#x3D; chokidar.watch(this.options.paths, {
      ignored: this.options.ignored,
      persistent: true,
      ignoreInitial: false,
      followSymlinks: false, // Per spec: no symlinks for exFAT/Windows compatibility
      depth: undefined,
      awaitWriteFinish: {
        stabilityThreshold: 100,
        pollInterval: 50,
      },
      atomic: true, // Support atomic writes
    });

    // Set up event handlers
    const handleEvent &#x3D; (type: WatchEvent[&amp;quot;type&amp;quot;]) &#x3D;&amp;gt; (path: string) &#x3D;&amp;gt; {
      // Filter by patterns if specified
      if (this.options.patterns.length &amp;gt; 0) {
        const matchesPattern &#x3D; this.options.patterns.some((pattern) &#x3D;&amp;gt; {
          // Simple glob matching - could be enhanced with a proper glob library
          const regexPattern &#x3D; pattern
            .replace(/\*\*/g, &amp;quot;.*&amp;quot;)
            .replace(/\*/g, &amp;quot;[^/]*&amp;quot;)
            .replace(/\./g, &amp;quot;\\.&amp;quot;);
          return new RegExp(regexPattern).test(path);
        });

        if (!matchesPattern) {
          return;
        }
      }

      const event: WatchEvent &#x3D; {
        type,
        path,
        timestamp: Date.now(),
      };

      this.eventQueue.push(event);

      if (this.options.agentMode) {
        // Emit individual event for agent consumption
        console.log(
          JSON.stringify({
            type: &amp;quot;file_event&amp;quot;,
            event,
            queueSize: this.eventQueue.length,
          }),
        );
      }

      // Trigger debounced batch processing
      this.debouncedHandler?.();
    };

    this.watcher
      .on(&amp;quot;add&amp;quot;, handleEvent(&amp;quot;add&amp;quot;))
      .on(&amp;quot;change&amp;quot;, handleEvent(&amp;quot;change&amp;quot;))
      .on(&amp;quot;unlink&amp;quot;, handleEvent(&amp;quot;unlink&amp;quot;))
      .on(&amp;quot;addDir&amp;quot;, handleEvent(&amp;quot;addDir&amp;quot;))
      .on(&amp;quot;unlinkDir&amp;quot;, handleEvent(&amp;quot;unlinkDir&amp;quot;))
      .on(&amp;quot;error&amp;quot;, (error) &#x3D;&amp;gt; {
        if (this.options.agentMode) {
          console.log(
            JSON.stringify({
              type: &amp;quot;watcher_error&amp;quot;,
              message: error.message,
              timestamp: Date.now(),
            }),
          );
        } else {
          console.error(&amp;quot;File watcher error:&amp;quot;, error);
        }
      })
      .on(&amp;quot;ready&amp;quot;, () &#x3D;&amp;gt; {
        if (this.options.agentMode) {
          console.log(
            JSON.stringify({
              type: &amp;quot;watcher_ready&amp;quot;,
              paths: this.options.paths,
              patterns: this.options.patterns,
              debounce: this.options.debounce,
              timestamp: Date.now(),
            }),
          );
        } else {
          console.log(
            &#x60;ğŸ” Watching ${this.options.paths.join(&amp;quot;, &amp;quot;)} (debounce: ${this.options.debounce}ms)&#x60;,
          );
        }
      });

    return new Promise((resolve) &#x3D;&amp;gt; {
      this.watcher?.on(&amp;quot;ready&amp;quot;, () &#x3D;&amp;gt; resolve());
    });
  }

  /**
   * Stop the file watcher
   */
  async stop(): Promise&amp;lt;void&amp;gt; {
    if (this.watcher) {
      await this.watcher.close();
      this.watcher &#x3D; null;
    }

    this.debouncedHandler &#x3D; null;
    this.eventQueue &#x3D; [];
  }

  /**
   * Get current watch statistics
   */
  getStats(): {
    isWatching: boolean;
    paths: string[];
    patterns: string[];
    debounce: number;
    queueSize: number;
  } {
    return {
      isWatching: this.watcher !&#x3D;&#x3D; null,
      paths: this.options.paths,
      patterns: this.options.patterns,
      debounce: this.options.debounce,
      queueSize: this.eventQueue.length,
    };
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-71">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/formatting.ts</div>
                <div class="file-content">
                    <pre>import chalk from &amp;#39;chalk&amp;#39;;
import Table from &amp;#39;cli-table3&amp;#39;;
import type { ValidationResult } from &amp;#39;../types.js&amp;#39;;

/**
 * Format validation results as a pretty table
 */
export function formatValidationTable(results: ValidationResult[]): string {
  if (results.length &#x3D;&#x3D;&#x3D; 0) {
    return chalk.green(&amp;#39;âœ“ No files to validate&amp;#39;);
  }

  const table &#x3D; new Table({
    head: [
      chalk.cyan(&amp;#39;File&amp;#39;),
      chalk.cyan(&amp;#39;Status&amp;#39;),
      chalk.cyan(&amp;#39;Errors&amp;#39;),
      chalk.cyan(&amp;#39;Warnings&amp;#39;),
      chalk.cyan(&amp;#39;Time (ms)&amp;#39;),
    ],
    style: {
      head: [],
      border: [&amp;#39;dim&amp;#39;],
    },
  });

  results.forEach(result &#x3D;&amp;gt; {
    const statusColor &#x3D;
      result.status &#x3D;&#x3D;&#x3D; &amp;#39;valid&amp;#39; ? &amp;#39;green&amp;#39; : result.status &#x3D;&#x3D;&#x3D; &amp;#39;invalid&amp;#39; ? &amp;#39;red&amp;#39; : &amp;#39;yellow&amp;#39;;
    const statusSymbol &#x3D; result.status &#x3D;&#x3D;&#x3D; &amp;#39;valid&amp;#39; ? &amp;#39;âœ“&amp;#39; : result.status &#x3D;&#x3D;&#x3D; &amp;#39;invalid&amp;#39; ? &amp;#39;âœ—&amp;#39; : &amp;#39;!&amp;#39;;

    table.push([
      result.file,
      chalk[statusColor](&#x60;${statusSymbol} ${result.status}&#x60;),
      result.errors.length &amp;gt; 0 ? chalk.red(result.errors.length.toString()) : chalk.dim(&amp;#39;0&amp;#39;),
      result.warnings.length &amp;gt; 0 ? chalk.yellow(result.warnings.length.toString()) : chalk.dim(&amp;#39;0&amp;#39;),
      formatTime(result.processingTime),
    ]);
  });

  return table.toString();
}

/**
 * Format detailed error information
 */
export function formatErrorDetails(results: ValidationResult[]): string {
  const errorResults &#x3D; results.filter(r &#x3D;&amp;gt; r.errors.length &amp;gt; 0);

  if (errorResults.length &#x3D;&#x3D;&#x3D; 0) {
    return &amp;#39;&amp;#39;;
  }

  let output &#x3D; &#x60;\n${chalk.red.bold(&amp;#39;Validation Errors:&amp;#39;)}\n&#x60;;

  errorResults.forEach(result &#x3D;&amp;gt; {
    output +&#x3D; &#x60;\n${chalk.underline(result.file)}:\n&#x60;;

    result.errors.forEach(error &#x3D;&amp;gt; {
      const location &#x3D; &#x60;${error.line}:${error.column}&#x60;;
      const category &#x3D; chalk.dim(&#x60;[${error.category}]&#x60;);
      output +&#x3D; &#x60;  ${chalk.red(&amp;#39;error&amp;#39;)} ${category} ${location} ${error.message}\n&#x60;;
    });
  });

  return output;
}

/**
 * Format warning information
 */
export function formatWarningDetails(results: ValidationResult[]): string {
  const warningResults &#x3D; results.filter(r &#x3D;&amp;gt; r.warnings.length &amp;gt; 0);

  if (warningResults.length &#x3D;&#x3D;&#x3D; 0) {
    return &amp;#39;&amp;#39;;
  }

  let output &#x3D; &#x60;\n${chalk.yellow.bold(&amp;#39;Validation Warnings:&amp;#39;)}\n&#x60;;

  warningResults.forEach(result &#x3D;&amp;gt; {
    output +&#x3D; &#x60;\n${chalk.underline(result.file)}:\n&#x60;;

    result.warnings.forEach(warning &#x3D;&amp;gt; {
      const location &#x3D; &#x60;${warning.line}:${warning.column}&#x60;;
      const category &#x3D; chalk.dim(&#x60;[${warning.category}]&#x60;);
      output +&#x3D; &#x60;  ${chalk.yellow(&amp;#39;warning&amp;#39;)} ${category} ${location} ${warning.message}\n&#x60;;
    });
  });

  return output;
}

/**
 * Format summary statistics
 */
export function formatSummary(results: ValidationResult[]): string {
  if (results.length &#x3D;&#x3D;&#x3D; 0) {
    return chalk.dim(&amp;#39;No files processed&amp;#39;);
  }

  const valid &#x3D; results.filter(r &#x3D;&amp;gt; r.status &#x3D;&#x3D;&#x3D; &amp;#39;valid&amp;#39;).length;
  const invalid &#x3D; results.filter(r &#x3D;&amp;gt; r.status &#x3D;&#x3D;&#x3D; &amp;#39;invalid&amp;#39;).length;
  const errors &#x3D; results.filter(r &#x3D;&amp;gt; r.status &#x3D;&#x3D;&#x3D; &amp;#39;error&amp;#39;).length;

  const totalErrors &#x3D; results.reduce((sum, r) &#x3D;&amp;gt; sum + r.errors.length, 0);
  const totalWarnings &#x3D; results.reduce((sum, r) &#x3D;&amp;gt; sum + r.warnings.length, 0);
  const totalTime &#x3D; results.reduce((sum, r) &#x3D;&amp;gt; sum + r.processingTime, 0);

  let summary &#x3D; &#x60;\n${chalk.bold(&amp;#39;Summary:&amp;#39;)} &#x60;;

  if (valid &amp;gt; 0) {
    summary +&#x3D; chalk.green(&#x60;${valid} valid&#x60;);
  }

  if (invalid &amp;gt; 0) {
    if (valid &amp;gt; 0) summary +&#x3D; &amp;#39;, &amp;#39;;
    summary +&#x3D; chalk.red(&#x60;${invalid} invalid&#x60;);
  }

  if (errors &amp;gt; 0) {
    if (valid &amp;gt; 0 || invalid &amp;gt; 0) summary +&#x3D; &amp;#39;, &amp;#39;;
    summary +&#x3D; chalk.yellow(&#x60;${errors} errors&#x60;);
  }

  summary +&#x3D; &#x60; (${results.length} total)&#x60;;

  if (totalErrors &amp;gt; 0) {
    summary +&#x3D; &#x60;\n${chalk.red(&#x60;${totalErrors} errors&#x60;)}&#x60;;
  }

  if (totalWarnings &amp;gt; 0) {
    summary +&#x3D; &#x60;${totalErrors &amp;gt; 0 ? &amp;#39;, &amp;#39; : &amp;#39;\n&amp;#39;}${chalk.yellow(&#x60;${totalWarnings} warnings&#x60;)}&#x60;;
  }

  summary +&#x3D; &#x60;\nProcessed in ${formatTime(totalTime)}&#x60;;

  return summary;
}

/**
 * Format time in milliseconds with appropriate units
 */
export function formatTime(ms: number): string {
  if (ms &amp;lt; 1000) {
    return chalk.dim(&#x60;${ms}ms&#x60;);
  }
  if (ms &amp;lt; 60000) {
    return chalk.dim(&#x60;${(ms / 1000).toFixed(2)}s&#x60;);
  }
  const minutes &#x3D; Math.floor(ms / 60000);
  const seconds &#x3D; ((ms % 60000) / 1000).toFixed(0);
  return chalk.dim(&#x60;${minutes}m ${seconds}s&#x60;);
}

/**
 * Format JSON output with colors
 */
export function formatJson(data: any, color &#x3D; true): string {
  const json &#x3D; JSON.stringify(data, null, 2);

  if (!color) {
    return json;
  }

  // Basic JSON syntax highlighting
  return json
    .replace(/(&amp;quot;.*?&amp;quot;)\s*:/g, (_, key) &#x3D;&amp;gt; &#x60;${chalk.blue(key)}:&#x60;)
    .replace(/:\s*(&amp;quot;.*?&amp;quot;)/g, (_, value) &#x3D;&amp;gt; &#x60;: ${chalk.green(value)}&#x60;)
    .replace(/:\s*(true|false|null)/g, (_, value) &#x3D;&amp;gt; &#x60;: ${chalk.yellow(value)}&#x60;)
    .replace(/:\s*(\d+\.?\d*)/g, (_, value) &#x3D;&amp;gt; &#x60;: ${chalk.magenta(value)}&#x60;);
}

/**
 * Format file size in human readable format
 */
export function formatFileSize(bytes: number): string {
  const sizes &#x3D; [&amp;#39;B&amp;#39;, &amp;#39;KB&amp;#39;, &amp;#39;MB&amp;#39;, &amp;#39;GB&amp;#39;];
  if (bytes &#x3D;&#x3D;&#x3D; 0) return &amp;#39;0 B&amp;#39;;

  const i &#x3D; Math.floor(Math.log(bytes) / Math.log(1024));
  const size &#x3D; (bytes / 1024 ** i).toFixed(1);

  return chalk.dim(&#x60;${size} ${sizes[i]}&#x60;);
}

/**
 * Create a textual progress bar representation
 */
export function createTextProgressBar(current: number, total: number, width &#x3D; 40): string {
  const percentage &#x3D; Math.round((current / total) * 100);
  const filled &#x3D; Math.round((current / total) * width);
  const empty &#x3D; width - filled;

  const bar &#x3D; &amp;#39;â–ˆ&amp;#39;.repeat(filled) + &amp;#39;â–‘&amp;#39;.repeat(empty);

  return &#x60;${chalk.cyan(bar)} ${chalk.bold(&#x60;${percentage}%&#x60;)} (${current}/${total})&#x60;;
}

/**
 * Format exit code message
 */
export function formatExitMessage(exitCode: number, operation: string): string {
  switch (exitCode) {
    case 0:
      return chalk.green(&#x60;âœ“ ${operation} completed successfully&#x60;);
    case 1:
      return chalk.red(&#x60;âœ— ${operation} failed with validation errors&#x60;);
    case 2:
      return chalk.red(&#x60;âœ— ${operation} failed with system errors&#x60;);
    default:
      return chalk.red(&#x60;âœ— ${operation} failed with unknown error (exit code: ${exitCode})&#x60;);
  }
}

/**
 * Format data as a table with headers and rows
 */
export function formatTable(headers: string[], rows: string[][]): string {
  if (rows.length &#x3D;&#x3D;&#x3D; 0) {
    return chalk.dim(&amp;#39;No data to display&amp;#39;);
  }

  const table &#x3D; new Table({
    head: headers.map(header &#x3D;&amp;gt; chalk.cyan(header)),
    style: {
      head: [],
      border: [&amp;#39;dim&amp;#39;],
    },
  });

  rows.forEach(row &#x3D;&amp;gt; {
    table.push(row);
  });

  return table.toString();
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-72">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/add.ts</div>
                <div class="file-content">
                    <pre>/**
 * Add command - Compositional interface for building specifications
 *
 * COMPLETELY REWRITTEN to use proper AST-based CUE manipulation
 * instead of fragile string concatenation.
 *
 * This command allows users to incrementally build up their project specification
 * stored under the .arbiter/ directory through discrete, validated operations
 * using the CUE tool.
 */

import * as path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import { ApiClient } from &amp;#39;../api-client.js&amp;#39;;
import {
  type DatabaseConfig,
  type EndpointConfig,
  type FlowConfig,
  type PlatformServiceType,
  type RouteConfig,
  type ServiceConfig,
  createCUEManipulator,
  formatCUE,
  validateCUE,
} from &amp;#39;../cue/index.js&amp;#39;;
import {
  type VariableContext,
  extractVariablesFromCue,
  templateManager,
} from &amp;#39;../templates/index.js&amp;#39;;
import type { CLIConfig } from &amp;#39;../types.js&amp;#39;;
import { detectPlatform, getPlatformServiceDefaults } from &amp;#39;../utils/platform-detection.js&amp;#39;;

export interface AddOptions {
  verbose?: boolean;
  dryRun?: boolean;
  force?: boolean;
  template?: string;
}

/**
 * Main add command dispatcher
 */
export async function addCommand(
  subcommand: string,
  name: string,
  options: AddOptions &amp;amp; Record&amp;lt;string, any&amp;gt;,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  const manipulator &#x3D; createCUEManipulator();

  try {
    console.log(chalk.blue(&#x60;ğŸ”§ Adding ${subcommand}: ${name}&#x60;));

    // Get existing assembly content from sharded storage in service
    const assemblyPath &#x3D; path.resolve(&amp;#39;.arbiter&amp;#39;, &amp;#39;assembly.cue&amp;#39;); // Move to .arbiter directory
    let assemblyContent &#x3D; &amp;#39;&amp;#39;;

    // Initialize API client to try getting existing specification from sharded storage
    const apiClient &#x3D; new ApiClient(config);

    try {
      // First try to get the specification from the service&amp;#39;s sharded storage
      const storedSpec &#x3D; await apiClient.getSpecification(&amp;#39;assembly&amp;#39;, assemblyPath);
      if (storedSpec.success &amp;amp;&amp;amp; storedSpec.data &amp;amp;&amp;amp; storedSpec.data.content) {
        assemblyContent &#x3D; storedSpec.data.content;
        if (options.verbose) {
          console.log(
            chalk.dim(&amp;#39;ğŸ“¡ Retrieved existing specification from service (sharded storage)&amp;#39;)
          );
        }
      } else {
        throw new Error(&amp;#39;No stored specification found&amp;#39;);
      }
    } catch (_apiError) {
      // Fallback to local .arbiter storage only
      if (fs.existsSync(assemblyPath)) {
        assemblyContent &#x3D; fs.readFileSync(assemblyPath, &amp;#39;utf-8&amp;#39;);
        if (options.verbose) {
          console.log(chalk.dim(&amp;#39;ğŸ“ Retrieved existing specification from .arbiter directory&amp;#39;));
        }
      } else {
        // Initialize with basic structure
        console.log(
          chalk.yellow(&amp;#39;âš ï¸  No existing specification found. Creating new specification...&amp;#39;)
        );
        assemblyContent &#x3D; await initializeAssembly();
      }
    }

    let updatedContent &#x3D; assemblyContent;

    // Route to appropriate handler using AST-based manipulation
    switch (subcommand) {
      case &amp;#39;service&amp;#39;:
        updatedContent &#x3D; await addService(manipulator, assemblyContent, name, options);
        break;
      case &amp;#39;endpoint&amp;#39;:
        updatedContent &#x3D; await addEndpoint(manipulator, assemblyContent, name, options);
        break;
      case &amp;#39;route&amp;#39;:
        updatedContent &#x3D; await addRoute(manipulator, assemblyContent, name, options);
        break;
      case &amp;#39;flow&amp;#39;:
        updatedContent &#x3D; await addFlow(manipulator, assemblyContent, name, options);
        break;
      case &amp;#39;load-balancer&amp;#39;:
        updatedContent &#x3D; await addLoadBalancer(manipulator, assemblyContent, options);
        break;
      case &amp;#39;database&amp;#39;:
        updatedContent &#x3D; await addDatabase(manipulator, assemblyContent, name, options);
        break;
      case &amp;#39;cache&amp;#39;:
        updatedContent &#x3D; await addCache(manipulator, assemblyContent, name, options);
        break;
      case &amp;#39;locator&amp;#39;:
        updatedContent &#x3D; await addLocator(manipulator, assemblyContent, name, options);
        break;
      case &amp;#39;schema&amp;#39;:
        updatedContent &#x3D; await addSchema(manipulator, assemblyContent, name, options);
        break;
      case &amp;#39;package&amp;#39;:
        updatedContent &#x3D; await addPackage(manipulator, assemblyContent, name, options);
        break;
      case &amp;#39;component&amp;#39;:
        updatedContent &#x3D; await addComponent(manipulator, assemblyContent, name, options);
        break;
      case &amp;#39;module&amp;#39;:
        updatedContent &#x3D; await addModule(manipulator, assemblyContent, name, options);
        break;
      default:
        console.error(chalk.red(&#x60;âŒ Unknown subcommand: ${subcommand}&#x60;));
        console.log(
          chalk.dim(
            &amp;#39;Available subcommands: service, endpoint, route, flow, load-balancer, database, cache, locator, schema, package, component, module&amp;#39;
          )
        );
        return 1;
    }

    // Validate the updated content using CUE tool
    const validationResult &#x3D; await validateCUE(updatedContent);
    if (!validationResult.valid) {
      console.error(chalk.red(&amp;#39;âŒ CUE validation failed:&amp;#39;));
      validationResult.errors.forEach(error &#x3D;&amp;gt; {
        console.error(chalk.red(&#x60;  â€¢ ${error}&#x60;));
      });
      return 1;
    }

    // Store specification in service or preview changes
    if (options.dryRun) {
      console.log(chalk.yellow(&amp;#39;ğŸ” Dry run - changes that would be made:&amp;#39;));
      console.log(chalk.dim(showDiff(assemblyContent, updatedContent)));
    } else {
      // Initialize API client and store specification in service database
      const apiClient &#x3D; new ApiClient(config);

      try {
        // Determine shard type based on subcommand
        const shardType &#x3D; getShardTypeForSubcommand(subcommand);

        // Store the updated CUE specification in the service with sharding
        const storeResult &#x3D; await apiClient.storeSpecification({
          content: updatedContent,
          type: shardType,
          path: assemblyPath,
          shard: shardType, // Use shard type as shard identifier
        });

        if (storeResult.success) {
          console.log(chalk.green(&#x60;âœ… Updated specification in service (${subcommand}: ${name})&#x60;));
          console.log(
            chalk.dim(&amp;#39;ğŸ’¡ CUE files will be generated to .arbiter/ when specification is complete&amp;#39;)
          );

          if (storeResult.data?.shard) {
            console.log(chalk.dim(&#x60;   Stored in shard: ${storeResult.data.shard}&#x60;));
          }

          if (options.verbose) {
            console.log(chalk.dim(&amp;#39;Added configuration:&amp;#39;));
            console.log(chalk.dim(showDiff(assemblyContent, updatedContent)));
          }
        } else {
          throw new Error(storeResult.error || &amp;#39;Failed to store specification&amp;#39;);
        }
      } catch (apiError) {
        // Fallback to file system if API is not available
        console.log(chalk.yellow(&amp;#39;âš ï¸  Service unavailable, storing locally as fallback&amp;#39;));

        // Ensure .arbiter directory exists
        await fs.ensureDir(&amp;#39;.arbiter&amp;#39;);

        // Write to .arbiter directory
        await fs.writeFile(assemblyPath, updatedContent, &amp;#39;utf-8&amp;#39;);
        console.log(chalk.green(&#x60;âœ… Updated ${path.basename(assemblyPath)} (local fallback)&#x60;));
      }
    }

    return 0;
  } catch (error) {
    console.error(chalk.red(&amp;#39;âŒ Failed to add component:&amp;#39;));
    console.error(chalk.red(error instanceof Error ? error.message : String(error)));
    return 1;
  } finally {
    await manipulator.cleanup();
  }
}

/**
 * Initialize a new assembly file with basic structure
 */
async function initializeAssembly(): Promise&amp;lt;string&amp;gt; {
  const projectName &#x3D; path.basename(process.cwd());

  const content &#x3D; &#x60;package ${projectName.replace(/[^a-zA-Z0-9]/g, &amp;#39;&amp;#39;)}

// Auto-generated arbiter.assembly.cue
// Build your specification incrementally with: arbiter add &amp;lt;component&amp;gt;

product: {
  name: &amp;quot;${toTitleCase(projectName)}&amp;quot;
  goals: [&amp;quot;Application goals will be defined here&amp;quot;]
}

ui: routes: []

locators: {}

flows: []

// V1 compatibility structure
config: {
  language: &amp;quot;typescript&amp;quot;
  kind: &amp;quot;service&amp;quot;
}

metadata: {
  name: &amp;quot;${projectName}&amp;quot;
  version: &amp;quot;1.0.0&amp;quot;
}

deployment: {
  target: &amp;quot;kubernetes&amp;quot;
}

services: {}&#x60;;

  // Format using CUE tool
  return await formatCUE(content);
}

/**
 * Add a service using AST-based manipulation
 */
async function addService(
  manipulator: any,
  content: string,
  serviceName: string,
  options: {
    language?: string;
    port?: number;
    image?: string;
    directory?: string;
    template?: string;
    platform?: &amp;#39;cloudflare&amp;#39; | &amp;#39;vercel&amp;#39; | &amp;#39;supabase&amp;#39; | &amp;#39;kubernetes&amp;#39;;
    serviceType?: PlatformServiceType;
    [key: string]: any;
  }
): Promise&amp;lt;string&amp;gt; {
  const { language &#x3D; &amp;#39;typescript&amp;#39;, port, image, directory, template } &#x3D; options;

  // If template is specified, use template-based generation
  if (template) {
    return await addServiceWithTemplate(manipulator, content, serviceName, options);
  }

  // Detect platform context if not explicitly specified
  let platformContext;
  if (!options.platform &amp;amp;&amp;amp; !options.serviceType) {
    platformContext &#x3D; await detectPlatform();

    if (platformContext.detected !&#x3D;&#x3D; &amp;#39;unknown&amp;#39; &amp;amp;&amp;amp; platformContext.confidence &amp;gt; 0.3) {
      console.log(
        chalk.cyan(
          &#x60;ğŸ” Detected ${platformContext.detected} platform (${Math.round(platformContext.confidence * 100)}% confidence)&#x60;
        )
      );

      // Show platform-specific suggestions
      if (platformContext.suggestions.length &amp;gt; 0) {
        console.log(chalk.dim(&amp;#39;ğŸ’¡ Platform-specific suggestions:&amp;#39;));
        for (const suggestion of platformContext.suggestions) {
          console.log(
            chalk.dim(&#x60;  â€¢ Use --service-type ${suggestion.serviceType} for ${suggestion.reason}&#x60;)
          );
        }
        console.log(
          chalk.dim(&amp;#39;  â€¢ Or use --platform kubernetes for traditional container deployment&amp;#39;)
        );
      }
    }
  }

  // Determine service type and create proper config
  const isPrebuilt &#x3D; !!image;
  let serviceConfig: ServiceConfig;

  if (options.serviceType) {
    // Use explicitly specified platform-specific service type
    const platformDefaults &#x3D; getPlatformServiceDefaults(options.serviceType);
    serviceConfig &#x3D; {
      serviceType: options.serviceType,
      language: platformDefaults.language || language,
      type: platformDefaults.type || &amp;#39;serverless&amp;#39;,
      ...(platformDefaults.platform &amp;amp;&amp;amp; { platform: platformDefaults.platform }),
      ...(platformDefaults.runtime &amp;amp;&amp;amp; { runtime: platformDefaults.runtime }),
      ...(directory &amp;amp;&amp;amp; { sourceDirectory: directory }),
      ...(port &amp;amp;&amp;amp; { ports: [{ name: &amp;#39;http&amp;#39;, port, targetPort: port }] }),
    };
  } else if (isPrebuilt) {
    // Container-based service
    serviceConfig &#x3D; {
      serviceType: &amp;#39;prebuilt&amp;#39;,
      language: &amp;#39;container&amp;#39;,
      type:
        image &amp;amp;&amp;amp; (image.includes(&amp;#39;postgres&amp;#39;) || image.includes(&amp;#39;mysql&amp;#39;))
          ? &amp;#39;statefulset&amp;#39;
          : &amp;#39;deployment&amp;#39;,
      image: image!,
      ...(port &amp;amp;&amp;amp; { ports: [{ name: &amp;#39;main&amp;#39;, port, targetPort: port }] }),
    };
  } else {
    // Traditional bespoke service
    serviceConfig &#x3D; {
      serviceType: &amp;#39;bespoke&amp;#39;,
      language,
      type: &amp;#39;deployment&amp;#39;,
      sourceDirectory: directory || &#x60;./src/${serviceName}&#x60;,
      ...(port &amp;amp;&amp;amp; { ports: [{ name: &amp;#39;http&amp;#39;, port, targetPort: port }] }),
    };
  }

  // Add service using AST manipulation
  let updatedContent &#x3D; await manipulator.addService(content, serviceName, serviceConfig);

  // If this creates a UI service, add route to v2 structure
  if (!isPrebuilt &amp;amp;&amp;amp; (language &#x3D;&#x3D;&#x3D; &amp;#39;typescript&amp;#39; || language &#x3D;&#x3D;&#x3D; &amp;#39;javascript&amp;#39;)) {
    const routeConfig: RouteConfig &#x3D; {
      id: &#x60;${serviceName}:main&#x60;,
      path: port &#x3D;&#x3D;&#x3D; 3000 ? &amp;#39;/&amp;#39; : &#x60;/${serviceName}&#x60;,
      capabilities: [&amp;#39;view&amp;#39;],
      components: [&#x60;${toTitleCase(serviceName)}Page&#x60;],
    };
    updatedContent &#x3D; await manipulator.addRoute(updatedContent, routeConfig);

    // Add basic locator
    const locatorKey &#x3D; &#x60;page:${serviceName}&#x60;;
    const locatorValue &#x3D; &#x60;[data-testid&#x3D;&amp;quot;${serviceName}-page&amp;quot;]&#x60;;
    updatedContent &#x3D; await manipulator.addToSection(
      updatedContent,
      &amp;#39;locators&amp;#39;,
      locatorKey,
      locatorValue
    );
  }

  return updatedContent;
}

/**
 * Service template options
 */
interface ServiceTemplateOptions {
  language?: string;
  port?: number;
  image?: string;
  directory?: string;
  template?: string;
  [key: string]: any;
}

/**
 * Add a service using a template (with AST-based CUE manipulation)
 */
async function addServiceWithTemplate(
  manipulator: any,
  content: string,
  serviceName: string,
  options: ServiceTemplateOptions
): Promise&amp;lt;string&amp;gt; {
  const { template, directory &#x3D; &#x60;./src/${serviceName}&#x60; } &#x3D; options;

  if (!template) {
    throw new Error(&amp;#39;Template name is required for template-based generation&amp;#39;);
  }

  try {
    await validateTemplateExists(template);
    await executeTemplate(serviceName, template, content, directory, options);
    const serviceConfig &#x3D; createTemplateServiceConfig(serviceName, directory, options);

    let updatedContent &#x3D; await manipulator.addService(content, serviceName, serviceConfig);

    if (shouldAddUIComponents(options)) {
      updatedContent &#x3D; await addUIComponentsForService(
        manipulator,
        updatedContent,
        serviceName,
        options
      );
    }

    return updatedContent;
  } catch (error) {
    throw new Error(
      &#x60;Template generation failed: ${error instanceof Error ? error.message : String(error)}&#x60;
    );
  }
}

/**
 * Validate that template exists in template manager
 */
async function validateTemplateExists(template: string): Promise&amp;lt;void&amp;gt; {
  await templateManager.loadConfig();

  const alias &#x3D; templateManager.getAlias(template);
  if (!alias) {
    const availableTemplates &#x3D; Object.keys(templateManager.getAliases());
    throw new Error(
      &#x60;Template &amp;#39;${template}&amp;#39; not found. Available templates: ${availableTemplates.join(&amp;#39;, &amp;#39;)}&#x60;
    );
  }
}

/**
 * Execute template generation
 */
async function executeTemplate(
  serviceName: string,
  template: string,
  content: string,
  directory: string,
  options: ServiceTemplateOptions
): Promise&amp;lt;void&amp;gt; {
  console.log(chalk.blue(&#x60;ğŸ”§ Generating service &amp;#39;${serviceName}&amp;#39; using template &amp;#39;${template}&amp;#39;&#x60;));

  const variables &#x3D; extractVariablesFromCue(content, serviceName);
  variables.serviceName &#x3D; serviceName;
  if (options.language) variables.language &#x3D; options.language;
  if (options.port) variables.port &#x3D; options.port;

  await fs.ensureDir(path.resolve(directory));
  await templateManager.executeTemplate(template, path.resolve(directory), variables);

  console.log(chalk.green(&#x60;âœ… Template &amp;#39;${template}&amp;#39; applied successfully to &amp;#39;${directory}&amp;#39;&#x60;));
}

/**
 * Create service configuration for template-based service
 */
function createTemplateServiceConfig(
  serviceName: string,
  directory: string,
  options: ServiceTemplateOptions
): ServiceConfig {
  return {
    serviceType: &amp;#39;bespoke&amp;#39;,
    language: options.language || &amp;#39;typescript&amp;#39;,
    type: &amp;#39;deployment&amp;#39;,
    sourceDirectory: directory,
    template: options.template!,
    ...(options.port &amp;amp;&amp;amp; {
      ports: [{ name: &amp;#39;http&amp;#39;, port: options.port, targetPort: options.port }],
    }),
  };
}

/**
 * Check if UI components should be added
 */
function shouldAddUIComponents(options: ServiceTemplateOptions): boolean {
  return !options.image &amp;amp;&amp;amp; (options.language &#x3D;&#x3D;&#x3D; &amp;#39;typescript&amp;#39; || options.language &#x3D;&#x3D;&#x3D; &amp;#39;javascript&amp;#39;);
}

/**
 * Add UI components and routes for service
 */
async function addUIComponentsForService(
  manipulator: any,
  content: string,
  serviceName: string,
  options: ServiceTemplateOptions
): Promise&amp;lt;string&amp;gt; {
  const routeConfig: RouteConfig &#x3D; {
    id: &#x60;${serviceName}:main&#x60;,
    path: options.port &#x3D;&#x3D;&#x3D; 3000 ? &amp;#39;/&amp;#39; : &#x60;/${serviceName}&#x60;,
    capabilities: [&amp;#39;view&amp;#39;],
    components: [&#x60;${toTitleCase(serviceName)}Page&#x60;],
  };

  let updatedContent &#x3D; await manipulator.addRoute(content, routeConfig);

  const locatorKey &#x3D; &#x60;page:${serviceName}&#x60;;
  const locatorValue &#x3D; &#x60;[data-testid&#x3D;&amp;quot;${serviceName}-page&amp;quot;]&#x60;;
  updatedContent &#x3D; await manipulator.addToSection(
    updatedContent,
    &amp;#39;locators&amp;#39;,
    locatorKey,
    locatorValue
  );

  return updatedContent;
}

/**
 * Add an API endpoint using AST-based manipulation
 */
async function addEndpoint(
  manipulator: any,
  content: string,
  endpoint: string,
  options: {
    service?: string;
    method?: string;
    returns?: string;
    accepts?: string;
    [key: string]: any;
  }
): Promise&amp;lt;string&amp;gt; {
  const { service &#x3D; &amp;#39;api&amp;#39;, method &#x3D; &amp;#39;GET&amp;#39;, returns, accepts } &#x3D; options;

  // Ensure the service exists by parsing the content
  try {
    const ast &#x3D; await manipulator.parse(content);
    if (!ast.services || !ast.services[service]) {
      throw new Error(
        &#x60;Service &amp;quot;${service}&amp;quot; not found. Add it first with: arbiter add service ${service}&#x60;
      );
    }
  } catch (parseError) {
    // Fallback check for service existence
    if (!content.includes(&#x60;${service}:&#x60;)) {
      throw new Error(
        &#x60;Service &amp;quot;${service}&amp;quot; not found. Add it first with: arbiter add service ${service}&#x60;
      );
    }
  }

  // Build endpoint configuration
  const endpointConfig: EndpointConfig &#x3D; {
    method,
    ...(accepts &amp;amp;&amp;amp; { request: { $ref: &#x60;#/components/schemas/${accepts}&#x60; } }),
    ...(returns &amp;amp;&amp;amp; { response: { $ref: &#x60;#/components/schemas/${returns}&#x60; } }),
  };

  // Add endpoint using AST manipulation
  let updatedContent &#x3D; await manipulator.addEndpoint(content, endpoint, endpointConfig);

  // Add health check validation for health endpoints
  if (endpoint &#x3D;&#x3D;&#x3D; &amp;#39;/health&amp;#39; || endpoint.endsWith(&amp;#39;/health&amp;#39;)) {
    const healthCheck &#x3D; {
      path: endpoint,
      port: 3000,
    };

    // Update the service with health check info
    try {
      const ast &#x3D; await manipulator.parse(updatedContent);
      if (!ast.services[service].healthCheck) {
        ast.services[service].healthCheck &#x3D; healthCheck;
        updatedContent &#x3D; await manipulator.serialize(ast, updatedContent);
      }
    } catch (error) {
      // Fallback: try to add health check directly
      console.warn(&amp;#39;Could not add health check via AST, health endpoint added to paths only&amp;#39;);
    }
  }

  return updatedContent;
}

/**
 * Add a UI route using AST-based manipulation
 */
async function addRoute(
  manipulator: any,
  content: string,
  routePath: string,
  options: { id?: string; capabilities?: string; components?: string; [key: string]: any }
): Promise&amp;lt;string&amp;gt; {
  const routeId &#x3D; options.id || generateRouteId(routePath);
  const capabilities &#x3D; options.capabilities
    ? options.capabilities.split(&amp;#39;,&amp;#39;).map((s: string) &#x3D;&amp;gt; s.trim())
    : [&amp;#39;view&amp;#39;];
  const components &#x3D; options.components
    ? options.components.split(&amp;#39;,&amp;#39;).map((s: string) &#x3D;&amp;gt; s.trim())
    : [];

  const routeConfig: RouteConfig &#x3D; {
    id: routeId,
    path: routePath,
    capabilities,
    ...(components.length &amp;gt; 0 &amp;amp;&amp;amp; { components }),
  };

  return await manipulator.addRoute(content, routeConfig);
}

/**
 * Flow configuration options
 */
interface FlowOptions {
  from?: string;
  to?: string;
  endpoint?: string;
  expect?: string;
  steps?: string;
  [key: string]: any;
}

/**
 * Flow step types
 */
type FlowStep &#x3D;
  | { visit: string }
  | { click: string }
  | { expect: { locator: string; state: string } }
  | { expect_api: { method: string; path: string; status: number } };

/**
 * Add a user flow using AST-based manipulation
 */
async function addFlow(
  manipulator: any,
  content: string,
  flowId: string,
  options: FlowOptions
): Promise&amp;lt;string&amp;gt; {
  const flowSteps &#x3D; generateFlowSteps(options);
  const flowConfig: FlowConfig &#x3D; {
    id: flowId,
    steps: flowSteps,
  };

  return await manipulator.addFlow(content, flowConfig);
}

/**
 * Generate flow steps based on options
 */
function generateFlowSteps(options: FlowOptions): FlowStep[] {
  if (options.steps) {
    return parseCustomSteps(options.steps);
  }

  if (options.from &amp;amp;&amp;amp; options.to) {
    return generateNavigationFlow(options.from, options.to);
  }

  if (options.endpoint) {
    return generateApiHealthFlow(options.endpoint, options.expect || &amp;#39;200&amp;#39;);
  }

  throw new Error(&amp;#39;Flow must specify either --from/--to, --endpoint, or --steps&amp;#39;);
}

/**
 * Parse custom steps from JSON string
 */
function parseCustomSteps(stepsJson: string): FlowStep[] {
  try {
    return JSON.parse(stepsJson);
  } catch {
    throw new Error(&amp;#39;Invalid steps format. Expected JSON array.&amp;#39;);
  }
}

/**
 * Generate navigation flow between pages
 */
function generateNavigationFlow(from: string, to: string): FlowStep[] {
  return [
    { visit: from },
    { click: &#x60;btn:goto-${to}&#x60; },
    { expect: { locator: &#x60;page:${to}&#x60;, state: &amp;#39;visible&amp;#39; } },
  ];
}

/**
 * Generate API health check flow
 */
function generateApiHealthFlow(endpoint: string, expectedStatus: string): FlowStep[] {
  return [
    { expect_api: { method: &amp;#39;GET&amp;#39;, path: endpoint, status: Number.parseInt(expectedStatus) } },
  ];
}

/**
 * Validate that target service exists in content
 */
function validateTargetServiceExists(
  manipulator: any,
  content: string,
  target: string
): Promise&amp;lt;boolean&amp;gt; {
  return new Promise(async resolve &#x3D;&amp;gt; {
    try {
      const ast &#x3D; await manipulator.parse(content);
      resolve(!!ast.services?.[target]);
    } catch {
      resolve(content.includes(&#x60;${target}:&#x60;));
    }
  });
}

/**
 * Create load balancer service configuration
 */
function createLoadBalancerConfig(): ServiceConfig {
  return {
    serviceType: &amp;#39;prebuilt&amp;#39;,
    language: &amp;#39;container&amp;#39;,
    type: &amp;#39;deployment&amp;#39;,
    image: &amp;#39;nginx:alpine&amp;#39;,
    ports: [{ name: &amp;#39;http&amp;#39;, port: 80, targetPort: 80 }],
    template: &amp;#39;nginx-loadbalancer&amp;#39;,
  };
}

/**
 * Add health check to target service
 */
async function addHealthCheckToTarget(
  manipulator: any,
  content: string,
  target: string,
  healthCheck: string
): Promise&amp;lt;string&amp;gt; {
  try {
    const ast &#x3D; await manipulator.parse(content);
    if (!ast.services[target].healthCheck) {
      ast.services[target].healthCheck &#x3D; {
        path: healthCheck,
        port: 3000,
      };
      return await manipulator.serialize(ast, content);
    }
  } catch (error) {
    console.warn(&#x60;Could not add health check to target service ${target}&#x60;);
  }
  return content;
}

/**
 * Load balancer options interface
 */
interface LoadBalancerOptions {
  target?: string;
  healthCheck?: string;
  [key: string]: any;
}

/**
 * Load balancer configuration parameters
 */
interface LoadBalancerParams {
  target: string;
  healthCheck: string;
}

/**
 * Add load balancer using AST-based manipulation
 */
async function addLoadBalancer(
  manipulator: any,
  content: string,
  options: LoadBalancerOptions
): Promise&amp;lt;string&amp;gt; {
  const params &#x3D; validateAndNormalizeLoadBalancerOptions(options);
  await ensureTargetServiceExists(manipulator, content, params.target);

  return await createLoadBalancerWithHealthCheck(manipulator, content, params);
}

/**
 * Validate and normalize load balancer options
 */
function validateAndNormalizeLoadBalancerOptions(options: LoadBalancerOptions): LoadBalancerParams {
  const { target, healthCheck &#x3D; &amp;#39;/health&amp;#39; } &#x3D; options;

  if (!target) {
    throw new Error(&amp;#39;Load balancer requires --target service&amp;#39;);
  }

  return { target, healthCheck };
}

/**
 * Ensure target service exists, throw error if not found
 */
async function ensureTargetServiceExists(
  manipulator: any,
  content: string,
  target: string
): Promise&amp;lt;void&amp;gt; {
  const targetExists &#x3D; await validateTargetServiceExists(manipulator, content, target);
  if (!targetExists) {
    throw new Error(&#x60;Target service &amp;quot;${target}&amp;quot; not found&#x60;);
  }
}

/**
 * Create load balancer service and configure health check
 */
async function createLoadBalancerWithHealthCheck(
  manipulator: any,
  content: string,
  params: LoadBalancerParams
): Promise&amp;lt;string&amp;gt; {
  const lbConfig &#x3D; createLoadBalancerConfig();
  let updatedContent &#x3D; await manipulator.addService(content, &amp;#39;loadbalancer&amp;#39;, lbConfig);

  updatedContent &#x3D; await addHealthCheckToTarget(
    manipulator,
    updatedContent,
    params.target,
    params.healthCheck
  );

  return updatedContent;
}

/**
 * Add database using AST-based manipulation
 */
async function addDatabase(
  manipulator: any,
  content: string,
  dbName: string,
  options: DatabaseAddOptions
): Promise&amp;lt;string&amp;gt; {
  const dbOptions &#x3D; normalizeDatabaseOptions(options);

  if (dbOptions.template) {
    await handleTemplateBasedDatabaseCreation(dbName, content, dbOptions);
  }

  const dbConfig &#x3D; createDatabaseConfiguration(dbName, dbOptions);
  return await manipulator.addDatabase(content, dbName, dbConfig);
}

/**
 * Database add options interface
 */
interface DatabaseAddOptions {
  attachTo?: string;
  image?: string;
  port?: number;
  template?: string;
  serviceType?: PlatformServiceType;
  platform?: &amp;#39;cloudflare&amp;#39; | &amp;#39;vercel&amp;#39; | &amp;#39;supabase&amp;#39; | &amp;#39;kubernetes&amp;#39;;
  [key: string]: any;
}

/**
 * Normalized database options with defaults
 */
interface NormalizedDatabaseOptions {
  attachTo?: string;
  image: string;
  port: number;
  template?: string;
  serviceType?: PlatformServiceType;
  platform?: &amp;#39;cloudflare&amp;#39; | &amp;#39;vercel&amp;#39; | &amp;#39;supabase&amp;#39; | &amp;#39;kubernetes&amp;#39;;
}

/**
 * Database configuration defaults
 */
const DATABASE_DEFAULTS &#x3D; {
  image: &amp;#39;postgres:15&amp;#39;,
  port: 5432,
  volumeSize: &amp;#39;50Gi&amp;#39;,
} as const;

/**
 * Normalize database options with defaults
 */
function normalizeDatabaseOptions(options: DatabaseAddOptions): NormalizedDatabaseOptions {
  return {
    attachTo: options.attachTo,
    image: options.image ?? DATABASE_DEFAULTS.image,
    port: options.port ?? DATABASE_DEFAULTS.port,
    template: options.template,
    serviceType: options.serviceType,
    platform: options.platform,
  };
}

/**
 * Handle template-based database creation
 */
async function handleTemplateBasedDatabaseCreation(
  dbName: string,
  content: string,
  options: NormalizedDatabaseOptions
): Promise&amp;lt;void&amp;gt; {
  try {
    await templateManager.loadConfig();

    validateTemplateExistsSync(options.template!);

    console.log(
      chalk.blue(&#x60;ğŸ”§ Generating database &amp;#39;${dbName}&amp;#39; using template &amp;#39;${options.template}&amp;#39;&#x60;)
    );

    const variables &#x3D; prepareTemplateVariables(content, dbName, options);
    const targetDir &#x3D; &#x60;./database/${dbName}&#x60;;

    await templateManager.executeTemplate(options.template!, path.resolve(targetDir), variables);

    console.log(
      chalk.green(&#x60;âœ… Database template &amp;#39;${options.template}&amp;#39; applied to &amp;#39;${targetDir}&amp;#39;&#x60;)
    );
  } catch (error) {
    throw new Error(
      &#x60;Database template generation failed: ${error instanceof Error ? error.message : String(error)}&#x60;
    );
  }
}

/**
 * Validate template exists synchronously and throw error if not found
 */
function validateTemplateExistsSync(template: string): void {
  const alias &#x3D; templateManager.getAlias(template);
  if (!alias) {
    const availableTemplates &#x3D; Object.keys(templateManager.getAliases());
    throw new Error(
      &#x60;Template &amp;#39;${template}&amp;#39; not found. Available templates: ${availableTemplates.join(&amp;#39;, &amp;#39;)}&#x60;
    );
  }
}

/**
 * Prepare template variables for database generation
 */
function prepareTemplateVariables(
  content: string,
  dbName: string,
  options: NormalizedDatabaseOptions
): VariableContext {
  const variables &#x3D; extractVariablesFromCue(content, dbName);

  variables.databaseName &#x3D; dbName;
  variables.attachTo &#x3D; options.attachTo;
  variables.image &#x3D; options.image;
  variables.port &#x3D; options.port;
  variables.database &#x3D; {
    type: options.serviceType || &amp;#39;postgres&amp;#39;,
    name: dbName,
    port: options.port,
  };

  if (options.serviceType) {
    variables.serviceType &#x3D; options.serviceType;
  }

  if (options.platform) {
    variables.platform &#x3D; options.platform;
  }

  if (!variables.projectName) {
    variables.projectName &#x3D; dbName;
  }

  if (!variables.serviceName) {
    variables.serviceName &#x3D; dbName;
  }

  return variables;
}

/**
 * Create database configuration object
 */
function createDatabaseConfiguration(
  dbName: string,
  options: NormalizedDatabaseOptions
): DatabaseConfig {
  // Check for platform-specific service types
  if (options.serviceType &amp;amp;&amp;amp; options.serviceType !&#x3D;&#x3D; &amp;#39;prebuilt&amp;#39;) {
    const platformDefaults &#x3D; getPlatformServiceDefaults(options.serviceType);
    return {
      serviceType: options.serviceType,
      language: platformDefaults.language || &amp;#39;sql&amp;#39;,
      type: platformDefaults.type || &amp;#39;managed&amp;#39;,
      ...(platformDefaults.platform &amp;amp;&amp;amp; { platform: platformDefaults.platform }),
      ...(platformDefaults.runtime &amp;amp;&amp;amp; { runtime: platformDefaults.runtime }),
      ...(options.attachTo &amp;amp;&amp;amp; { attachTo: options.attachTo }),
      // Platform-managed services don&amp;#39;t need traditional container config
    };
  }

  // Traditional container-based database
  return {
    serviceType: &amp;#39;prebuilt&amp;#39;,
    language: &amp;#39;container&amp;#39;,
    type: &amp;#39;statefulset&amp;#39;,
    image: options.image,
    ports: [{ name: &amp;#39;db&amp;#39;, port: options.port, targetPort: options.port }],
    volumes: [createDatabaseVolume(options.image)],
    env: generateDbEnvVars(options.image, dbName),
    ...(options.attachTo &amp;amp;&amp;amp; { attachTo: options.attachTo }),
  };
}

/**
 * Create database volume configuration based on image type
 */
function createDatabaseVolume(image: string): VolumeConfig {
  if (!image) {
    // Default path for undefined image
    return {
      name: &amp;#39;data&amp;#39;,
      path: &amp;#39;/var/lib/data&amp;#39;,
      size: DATABASE_DEFAULTS.volumeSize,
      type: &amp;#39;persistentVolumeClaim&amp;#39;,
    };
  }

  const dataPath &#x3D; image.includes(&amp;#39;postgres&amp;#39;) ? &amp;#39;/var/lib/postgresql/data&amp;#39; : &amp;#39;/var/lib/mysql&amp;#39;;

  return {
    name: &amp;#39;data&amp;#39;,
    path: dataPath,
    size: DATABASE_DEFAULTS.volumeSize,
    type: &amp;#39;persistentVolumeClaim&amp;#39;,
  };
}

/**
 * Volume configuration interface
 */
interface VolumeConfig {
  name: string;
  path: string;
  size: string;
  type: string;
}

/**
 * Cache service configuration options
 */
interface CacheServiceOptions {
  attachTo?: string;
  image?: string;
  port?: number;
  serviceType?: PlatformServiceType;
  platform?: &amp;#39;cloudflare&amp;#39; | &amp;#39;vercel&amp;#39; | &amp;#39;supabase&amp;#39; | &amp;#39;kubernetes&amp;#39;;
  [key: string]: any;
}

/**
 * Cache configuration with defaults
 */
interface CacheConfig {
  attachTo?: string;
  image?: string;
  port?: number;
  serviceType?: PlatformServiceType;
  platform?: &amp;#39;cloudflare&amp;#39; | &amp;#39;vercel&amp;#39; | &amp;#39;supabase&amp;#39; | &amp;#39;kubernetes&amp;#39;;
}

/**
 * Default cache configuration
 */
const CACHE_DEFAULTS &#x3D; {
  image: &amp;#39;redis:7-alpine&amp;#39;,
  port: 6379,
  volumeSize: &amp;#39;10Gi&amp;#39;,
} as const;

/**
 * Add cache service using AST-based manipulation
 */
async function addCache(
  manipulator: any,
  content: string,
  cacheName: string,
  options: CacheServiceOptions
): Promise&amp;lt;string&amp;gt; {
  const cacheConfig &#x3D; normalizeCacheOptions(options);
  const serviceConfig &#x3D; createCacheServiceConfig(cacheConfig);

  let updatedContent &#x3D; await manipulator.addService(content, cacheName, serviceConfig);

  if (cacheConfig.attachTo) {
    updatedContent &#x3D; await attachCacheToService(
      manipulator,
      updatedContent,
      cacheName,
      cacheConfig
    );
  }

  return updatedContent;
}

/**
 * Normalize cache options with defaults
 */
function normalizeCacheOptions(options: CacheServiceOptions): CacheConfig {
  return {
    attachTo: options.attachTo,
    image: options.image ?? (options.serviceType ? undefined : CACHE_DEFAULTS.image),
    port: options.port ?? (options.serviceType ? undefined : CACHE_DEFAULTS.port),
    serviceType: options.serviceType,
    platform: options.platform,
  };
}

/**
 * Create cache service configuration
 */
function createCacheServiceConfig(config: CacheConfig): ServiceConfig {
  // Check for platform-specific service types
  if (config.serviceType &amp;amp;&amp;amp; config.serviceType !&#x3D;&#x3D; &amp;#39;prebuilt&amp;#39;) {
    const platformDefaults &#x3D; getPlatformServiceDefaults(config.serviceType);
    return {
      serviceType: config.serviceType,
      language: platformDefaults.language || &amp;#39;key-value&amp;#39;,
      type: platformDefaults.type || &amp;#39;managed&amp;#39;,
      ...(platformDefaults.platform &amp;amp;&amp;amp; { platform: platformDefaults.platform }),
      ...(platformDefaults.runtime &amp;amp;&amp;amp; { runtime: platformDefaults.runtime }),
      ...(config.attachTo &amp;amp;&amp;amp; { attachTo: config.attachTo }),
      // Platform-managed caches don&amp;#39;t need traditional container config
    };
  }

  // Traditional container-based cache
  return {
    serviceType: &amp;#39;prebuilt&amp;#39;,
    language: &amp;#39;container&amp;#39;,
    type: &amp;#39;deployment&amp;#39;,
    image: config.image!,
    ports: [{ name: &amp;#39;cache&amp;#39;, port: config.port!, targetPort: config.port! }],
    volumes: [{ name: &amp;#39;data&amp;#39;, path: &amp;#39;/data&amp;#39;, size: CACHE_DEFAULTS.volumeSize }],
  };
}

/**
 * Attach cache connection to target service
 */
async function attachCacheToService(
  manipulator: any,
  content: string,
  cacheName: string,
  config: CacheConfig
): Promise&amp;lt;string&amp;gt; {
  try {
    const ast &#x3D; await manipulator.parse(content);
    if (ast.services?.[config.attachTo!]) {
      if (!ast.services[config.attachTo!].env) {
        ast.services[config.attachTo!].env &#x3D; {};
      }

      // Generate environment variables based on cache type
      let envVars: Record&amp;lt;string, string&amp;gt; &#x3D; {};

      if (config.serviceType &amp;amp;&amp;amp; config.serviceType !&#x3D;&#x3D; &amp;#39;prebuilt&amp;#39;) {
        // Platform-managed cache - use platform-specific env vars
        envVars &#x3D; generatePlatformCacheEnvVars(config.serviceType, cacheName);
      } else {
        // Traditional container-based cache
        envVars &#x3D; { REDIS_URL: &#x60;redis://${cacheName}:${config.port}&#x60; };
      }

      Object.assign(ast.services[config.attachTo!].env, envVars);
      return await manipulator.serialize(ast, content);
    }
  } catch (error) {
    console.warn(&#x60;Could not add cache connection to service ${config.attachTo}&#x60;);
  }
  return content;
}

/**
 * Add locator using AST-based manipulation
 */
async function addLocator(
  manipulator: any,
  content: string,
  locatorKey: string,
  options: { selector?: string; [key: string]: any }
): Promise&amp;lt;string&amp;gt; {
  const { selector } &#x3D; options;

  if (!selector) {
    throw new Error(&amp;#39;Locator requires --selector&amp;#39;);
  }

  return await manipulator.addToSection(content, &amp;#39;locators&amp;#39;, locatorKey, selector);
}

/**
 * Add schema using AST-based manipulation
 */
async function addSchema(
  manipulator: any,
  content: string,
  schemaName: string,
  options: { example?: string; rules?: string; [key: string]: any }
): Promise&amp;lt;string&amp;gt; {
  const { example, rules } &#x3D; options;

  const schemaConfig: any &#x3D; {};

  if (example) {
    try {
      schemaConfig.example &#x3D; JSON.parse(example);
    } catch {
      throw new Error(&amp;#39;Invalid example format. Expected JSON.&amp;#39;);
    }
  }

  if (rules) {
    try {
      schemaConfig.rules &#x3D; JSON.parse(rules);
    } catch {
      throw new Error(&amp;#39;Invalid rules format. Expected JSON.&amp;#39;);
    }
  }

  return await manipulator.addToSection(content, &amp;#39;components.schemas&amp;#39;, schemaName, schemaConfig);
}

/**
 * Add a reusable package/library
 */
async function addPackage(
  manipulator: any,
  content: string,
  name: string,
  options: AddOptions &amp;amp; {
    language?: string;
    directory?: string;
    exports?: string;
    version?: string;
  }
): Promise&amp;lt;string&amp;gt; {
  const packageName &#x3D; name.toLowerCase().replace(/[^a-z0-9-]/g, &amp;#39;-&amp;#39;);

  const packageConfig: any &#x3D; {
    name: packageName,
    type: &amp;#39;package&amp;#39;,
    language: options.language || &amp;#39;typescript&amp;#39;,
    version: options.version || &amp;#39;0.1.0&amp;#39;,
    directory: options.directory || &#x60;packages/${packageName}&#x60;,
  };

  if (options.exports) {
    packageConfig.exports &#x3D; options.exports.split(&amp;#39;,&amp;#39;).map(e &#x3D;&amp;gt; e.trim());
  }

  return await manipulator.addToSection(content, &amp;#39;components.packages&amp;#39;, packageName, packageConfig);
}

/**
 * Add a UI component
 */
async function addComponent(
  manipulator: any,
  content: string,
  name: string,
  options: AddOptions &amp;amp; {
    framework?: string;
    directory?: string;
    props?: string;
    stories?: boolean;
  }
): Promise&amp;lt;string&amp;gt; {
  const componentName &#x3D; name.toLowerCase().replace(/[^a-z0-9-]/g, &amp;#39;-&amp;#39;);

  const componentConfig: any &#x3D; {
    name: componentName,
    type: &amp;#39;component&amp;#39;,
    framework: options.framework || &amp;#39;react&amp;#39;,
    directory: options.directory || &#x60;src/components/${componentName}&#x60;,
  };

  if (options.props) {
    componentConfig.props &#x3D; options.props.split(&amp;#39;,&amp;#39;).map(p &#x3D;&amp;gt; p.trim());
  }

  if (options.stories) {
    componentConfig.storybook &#x3D; true;
  }

  return await manipulator.addToSection(content, &amp;#39;components.ui&amp;#39;, componentName, componentConfig);
}

/**
 * Add a standalone module
 */
async function addModule(
  manipulator: any,
  content: string,
  name: string,
  options: AddOptions &amp;amp; {
    language?: string;
    directory?: string;
    functions?: string;
    types?: string;
  }
): Promise&amp;lt;string&amp;gt; {
  const moduleName &#x3D; name.toLowerCase().replace(/[^a-z0-9-]/g, &amp;#39;-&amp;#39;);

  const moduleConfig: any &#x3D; {
    name: moduleName,
    type: &amp;#39;module&amp;#39;,
    language: options.language || &amp;#39;typescript&amp;#39;,
    directory: options.directory || &#x60;src/modules/${moduleName}&#x60;,
  };

  if (options.functions) {
    moduleConfig.functions &#x3D; options.functions.split(&amp;#39;,&amp;#39;).map(f &#x3D;&amp;gt; f.trim());
  }

  if (options.types) {
    moduleConfig.types &#x3D; options.types.split(&amp;#39;,&amp;#39;).map(t &#x3D;&amp;gt; t.trim());
  }

  return await manipulator.addToSection(content, &amp;#39;components.modules&amp;#39;, moduleName, moduleConfig);
}

// Helper functions
function generateDbEnvVars(image: string, dbName: string): Record&amp;lt;string, string&amp;gt; {
  if (!image) return {};

  if (image.includes(&amp;#39;postgres&amp;#39;)) {
    return {
      POSTGRES_DB: dbName,
      POSTGRES_USER: &amp;#39;user&amp;#39;,
      POSTGRES_PASSWORD: &amp;#39;password&amp;#39;,
    };
  }
  if (image.includes(&amp;#39;mysql&amp;#39;)) {
    return {
      MYSQL_DATABASE: dbName,
      MYSQL_USER: &amp;#39;user&amp;#39;,
      MYSQL_PASSWORD: &amp;#39;password&amp;#39;,
      MYSQL_ROOT_PASSWORD: &amp;#39;rootpassword&amp;#39;,
    };
  }
  return {};
}

/**
 * Generate platform-specific cache environment variables
 */
function generatePlatformCacheEnvVars(
  serviceType: string,
  cacheName: string
): Record&amp;lt;string, string&amp;gt; {
  switch (serviceType) {
    case &amp;#39;cloudflare_kv&amp;#39;:
      return {
        KV_NAMESPACE_ID: &#x60;${cacheName}_namespace_id&#x60;,
        KV_BINDING_NAME: cacheName.toUpperCase(),
        CACHE_URL: &#x60;kv://${cacheName}&#x60;,
      };
    case &amp;#39;vercel_kv&amp;#39;:
      return {
        KV_REST_API_URL: &#x60;https://${cacheName}.kv.vercel-storage.com&#x60;,
        KV_REST_API_TOKEN: &#x60;${cacheName}_token&#x60;,
        KV_URL: &#x60;redis://${cacheName}&#x60;,
        CACHE_URL: &#x60;vercel-kv://${cacheName}&#x60;,
      };
    default:
      return {
        CACHE_URL: &#x60;${serviceType}://${cacheName}&#x60;,
      };
  }
}

function generateRouteId(path: string): string {
  const segments &#x3D; path.split(&amp;#39;/&amp;#39;).filter(Boolean);
  if (segments.length &#x3D;&#x3D;&#x3D; 0) return &amp;#39;home:main&amp;#39;;
  if (segments.length &#x3D;&#x3D;&#x3D; 1) return &#x60;${segments[0]}:main&#x60;;
  return segments.join(&amp;#39;:&amp;#39;);
}

function toTitleCase(str: string): string {
  return str.replace(/\w\S*/g, txt &#x3D;&amp;gt; txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
}

function showDiff(oldContent: string, newContent: string): string {
  // Simple diff showing what was added
  const oldLines &#x3D; oldContent.split(&amp;#39;\n&amp;#39;);
  const newLines &#x3D; newContent.split(&amp;#39;\n&amp;#39;);

  const addedLines &#x3D; newLines.filter(line &#x3D;&amp;gt; !oldLines.includes(line));
  return addedLines.map(line &#x3D;&amp;gt; &#x60;+ ${line}&#x60;).join(&amp;#39;\n&amp;#39;);
}

/**
 * Determine shard type based on add subcommand for better organization
 */
function getShardTypeForSubcommand(subcommand: string): string {
  const shardMapping: Record&amp;lt;string, string&amp;gt; &#x3D; {
    service: &amp;#39;services&amp;#39;,
    endpoint: &amp;#39;endpoints&amp;#39;,
    route: &amp;#39;routes&amp;#39;,
    flow: &amp;#39;flows&amp;#39;,
    database: &amp;#39;services&amp;#39;, // Databases go with services
    &amp;#39;load-balancer&amp;#39;: &amp;#39;services&amp;#39;, // Load balancers go with services
    schema: &amp;#39;schemas&amp;#39;,
    locator: &amp;#39;locators&amp;#39;,
  };

  return shardMapping[subcommand] || &amp;#39;assembly&amp;#39;;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-73">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/watch.ts</div>
                <div class="file-content">
                    <pre>import { readFile } from &amp;#39;node:fs/promises&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import { ApiClient } from &amp;#39;../api-client.js&amp;#39;;
import type { CLIConfig } from &amp;#39;../types.js&amp;#39;;
import { FileWatcher, type WatchBatch } from &amp;#39;../utils/file-watcher.js&amp;#39;;
import { createOutputManager, shouldUseAgentMode } from &amp;#39;../utils/standardized-output.js&amp;#39;;
import type { StandardizedOutputManager } from &amp;#39;../utils/standardized-output.js&amp;#39;;

export interface WatchOptions {
  /** Path to watch (default: current directory) */
  path?: string;
  /** Enable agent mode (NDJSON output) */
  agentMode?: boolean;
  /** Output NDJSON to file instead of stdout */
  ndjsonOutput?: string;
  /** Debounce delay in milliseconds */
  debounce?: number;
  /** Custom patterns to watch */
  patterns?: string[];
  /** Run validation pipeline on changes */
  validate?: boolean;
  /** Run planning pipeline on changes */
  plan?: boolean;
}

/**
 * Watch command implementation
 * Monitors files and runs validation/planning pipelines according to the spec
 */
export async function watchCommand(options: WatchOptions, config: CLIConfig): Promise&amp;lt;number&amp;gt; {
  const watchPath &#x3D; options.path || &amp;#39;.&amp;#39;;
  const agentMode &#x3D; shouldUseAgentMode(options);
  const debounce &#x3D; options.debounce || 300;

  // Create output manager
  const outputManager &#x3D; createOutputManager(&amp;#39;watch&amp;#39;, agentMode, options.ndjsonOutput);

  try {
    const apiClient &#x3D; new ApiClient(config);

    // Test API connection first
    const healthResult &#x3D; await apiClient.health();
    if (!healthResult.success) {
      if (agentMode) {
        outputManager.emitEvent({
          phase: &amp;#39;watch&amp;#39;,
          status: &amp;#39;error&amp;#39;,
          error: &amp;#39;connection_failed&amp;#39;,
          data: {
            message: &#x60;API server unavailable: ${healthResult.error}&#x60;,
          },
        });
      } else {
        console.error(chalk.red(&amp;#39;âŒ API server unavailable:&amp;#39;), healthResult.error);
        console.error(chalk.dim(&amp;#39;Make sure the Arbiter server is running&amp;#39;));
      }
      return 1;
    }

    // Emit watch start event
    outputManager.emitEvent({
      phase: &amp;#39;watch&amp;#39;,
      status: &amp;#39;start&amp;#39;,
      data: {
        path: watchPath,
        debounce,
        patterns: options.patterns || [
          &amp;#39;**/*.cue&amp;#39;,
          &amp;#39;**/.arbiter/**/*.cue&amp;#39;,
          &amp;#39;**/*.json&amp;#39;,
          &amp;#39;**/*.yaml&amp;#39;,
          &amp;#39;**/*.yml&amp;#39;,
          &amp;#39;**/*.ts&amp;#39;,
          &amp;#39;**/*.js&amp;#39;,
          &amp;#39;**/*.py&amp;#39;,
          &amp;#39;**/*.rs&amp;#39;,
          &amp;#39;**/*.go&amp;#39;,
        ],
      },
    });

    if (!agentMode) {
      console.log(chalk.green(&amp;#39;âœ… Connected to Arbiter API&amp;#39;));
      console.log(chalk.blue(&#x60;ğŸ” Starting file watcher for: ${watchPath}&#x60;));
      console.log(chalk.dim(&#x60;Debounce: ${debounce}ms | Agent mode: ${agentMode}&#x60;));
    }

    const watcher &#x3D; new FileWatcher({
      paths: [watchPath],
      debounce,
      agentMode,
      patterns: options.patterns || [
        &amp;#39;**/*.cue&amp;#39;,
        &amp;#39;**/.arbiter/**/*.cue&amp;#39;,
        &amp;#39;**/*.json&amp;#39;,
        &amp;#39;**/*.yaml&amp;#39;,
        &amp;#39;**/*.yml&amp;#39;,
        &amp;#39;**/*.ts&amp;#39;,
        &amp;#39;**/*.js&amp;#39;,
        &amp;#39;**/*.py&amp;#39;,
        &amp;#39;**/*.rs&amp;#39;,
        &amp;#39;**/*.go&amp;#39;,
      ],
    });

    // Set up graceful shutdown
    const cleanup &#x3D; async () &#x3D;&amp;gt; {
      if (agentMode) {
        outputManager.emitEvent({
          phase: &amp;#39;watch&amp;#39;,
          status: &amp;#39;complete&amp;#39;,
          data: { reason: &amp;#39;shutdown_requested&amp;#39; },
        });
      } else {
        console.log(chalk.yellow(&amp;#39;\nğŸ›‘ Shutting down file watcher...&amp;#39;));
      }
      await watcher.stop();
      outputManager.close();
      process.exit(0);
    };

    process.on(&amp;#39;SIGINT&amp;#39;, cleanup);
    process.on(&amp;#39;SIGTERM&amp;#39;, cleanup);

    // Start watching with batch processing
    await watcher.start(async (batch: WatchBatch) &#x3D;&amp;gt; {
      await processBatch(batch, apiClient, options, config, outputManager);
    });

    // Keep the process running
    return new Promise&amp;lt;number&amp;gt;(() &#x3D;&amp;gt; {
      // Never resolve - this runs indefinitely until interrupted
    });
  } catch (error) {
    const errorMessage &#x3D; error instanceof Error ? error.message : String(error);
    if (agentMode) {
      outputManager.emitEvent({
        phase: &amp;#39;watch&amp;#39;,
        status: &amp;#39;error&amp;#39;,
        error: &amp;#39;watch_failed&amp;#39;,
        data: {
          message: &#x60;Watch command failed: ${errorMessage}&#x60;,
        },
      });
    } else {
      console.error(chalk.red(&amp;#39;âŒ Watch command failed:&amp;#39;), errorMessage);
    }
    outputManager.close();
    return 1;
  }
}

/**
 * Process a batch of file change events
 */
async function processBatch(
  batch: WatchBatch,
  apiClient: ApiClient,
  options: WatchOptions,
  _config: CLIConfig,
  outputManager: StandardizedOutputManager
): Promise&amp;lt;void&amp;gt; {
  const agentMode &#x3D; shouldUseAgentMode(options);

  // Get changed file paths for event data
  const changedFiles &#x3D; batch.events
    .filter(e &#x3D;&amp;gt; e.type !&#x3D;&#x3D; &amp;#39;unlink&amp;#39; &amp;amp;&amp;amp; e.type !&#x3D;&#x3D; &amp;#39;unlinkDir&amp;#39;)
    .map(e &#x3D;&amp;gt; e.path);

  // Emit watch change event
  outputManager.emitEvent({
    phase: &amp;#39;watch&amp;#39;,
    status: &amp;#39;progress&amp;#39;,
    data: {
      changed: changedFiles,
      eventCount: batch.events.length,
      debounceWindow: batch.debounceWindow,
    },
  });

  if (!agentMode) {
    console.log(chalk.cyan(&#x60;\nğŸ“ Processing ${batch.events.length} file changes...&#x60;));
  }

  // Group events by file type for efficient processing
  const cueFiles: string[] &#x3D; [];
  const otherFiles: string[] &#x3D; [];

  for (const event of batch.events) {
    if (event.type &#x3D;&#x3D;&#x3D; &amp;#39;unlink&amp;#39; || event.type &#x3D;&#x3D;&#x3D; &amp;#39;unlinkDir&amp;#39;) {
      continue; // Skip deleted files
    }

    if (event.path.endsWith(&amp;#39;.cue&amp;#39;)) {
      cueFiles.push(event.path);
    } else {
      otherFiles.push(event.path);
    }
  }

  let validateResult: any &#x3D; null;
  let surfaceResult: any &#x3D; null;
  let planResult: any &#x3D; null;

  // Process CUE files first (validation)
  if (cueFiles.length &amp;gt; 0 &amp;amp;&amp;amp; options.validate !&#x3D;&#x3D; false) {
    validateResult &#x3D; await validateFiles(cueFiles, apiClient, agentMode);
  }

  // Run planning if requested and assembly file changed
  const assemblyChanged &#x3D; batch.events.some(e &#x3D;&amp;gt; {
    if (e.type &#x3D;&#x3D;&#x3D; &amp;#39;unlink&amp;#39;) return false;
    if (!e.path.endsWith(&amp;#39;assembly.cue&amp;#39;)) return false;
    return e.path.includes(&#x60;${path.sep}.arbiter${path.sep}&#x60;) || e.path.includes(&#x60;.arbiter/&#x60;);
  });

  if (assemblyChanged &amp;amp;&amp;amp; options.plan) {
    planResult &#x3D; await runPlanning(apiClient, agentMode);
  }

  // Surface analysis for code files
  const codeFiles &#x3D; otherFiles.filter(f &#x3D;&amp;gt; /\.(ts|js|py|rs|go)$/.test(f));

  if (codeFiles.length &amp;gt; 0) {
    surfaceResult &#x3D; await analyzeSurface(codeFiles, agentMode);
  }

  // Emit final watch event with results
  outputManager.emitEvent({
    phase: &amp;#39;watch&amp;#39;,
    status: &amp;#39;complete&amp;#39;,
    data: {
      changed: changedFiles,
      validate: validateResult,
      surface: surfaceResult,
      gates: planResult,
      processedFiles: {
        cue: cueFiles.length,
        code: codeFiles.length,
        other: otherFiles.length - codeFiles.length,
      },
    },
  });

  if (!agentMode) {
    console.log(chalk.green(&amp;#39;âœ… Batch processing complete&amp;#39;));
  }
}

/**
 * Validate CUE files
 */
async function validateFiles(
  files: string[],
  apiClient: ApiClient,
  agentMode: boolean
): Promise&amp;lt;{ valid: number; invalid: number; errors: string[] }&amp;gt; {
  const results &#x3D; { valid: 0, invalid: 0, errors: [] as string[] };

  for (const file of files) {
    await validateSingleFileInWatch(file, apiClient, agentMode, results);
  }

  return results;
}

/**
 * Validate a single file during watch mode
 */
async function validateSingleFileInWatch(
  file: string,
  apiClient: ApiClient,
  agentMode: boolean,
  results: { valid: number; invalid: number; errors: string[] }
): Promise&amp;lt;void&amp;gt; {
  try {
    const content &#x3D; await readFile(file, &amp;#39;utf-8&amp;#39;);
    const result &#x3D; await apiClient.validate(content);

    if (result.success) {
      handleValidationSuccess(file, agentMode, results);
    } else {
      handleValidationFailure(file, result, agentMode, results);
    }
  } catch (error) {
    handleValidationError(file, error, agentMode, results);
  }
}

/**
 * Handle successful validation
 */
function handleValidationSuccess(
  file: string,
  agentMode: boolean,
  results: { valid: number; invalid: number; errors: string[] }
): void {
  results.valid++;
  if (!agentMode) {
    console.log(chalk.green(&#x60;  âœ… ${file} - Valid&#x60;));
  }
}

/**
 * Handle validation failure
 */
function handleValidationFailure(
  file: string,
  result: any,
  agentMode: boolean,
  results: { valid: number; invalid: number; errors: string[] }
): void {
  results.invalid++;
  const error &#x3D; &#x60;${file}: ${result.error || &amp;#39;Validation failed&amp;#39;}&#x60;;
  results.errors.push(error);

  if (!agentMode) {
    console.log(chalk.red(&#x60;  âŒ ${file} - ${result.error || &amp;#39;Validation failed&amp;#39;}&#x60;));
    displayValidationErrors(result.data?.errors);
  }
}

/**
 * Display detailed validation errors
 */
function displayValidationErrors(errors?: string[]): void {
  if (errors) {
    errors.forEach(error &#x3D;&amp;gt; {
      console.log(chalk.red(&#x60;     ${error}&#x60;));
    });
  }
}

/**
 * Handle file read or processing errors
 */
function handleValidationError(
  file: string,
  error: unknown,
  agentMode: boolean,
  results: { valid: number; invalid: number; errors: string[] }
): void {
  results.invalid++;
  const errorMsg &#x3D; &#x60;${file}: Read error - ${error instanceof Error ? error.message : String(error)}&#x60;;
  results.errors.push(errorMsg);

  if (!agentMode) {
    console.log(
      chalk.red(
        &#x60;  âŒ ${file} - Read error: ${error instanceof Error ? error.message : String(error)}&#x60;
      )
    );
  }
}

/**
 * Run planning pipeline
 */
async function runPlanning(
  _apiClient: ApiClient,
  agentMode: boolean
): Promise&amp;lt;{ status: string; message: string }&amp;gt; {
  if (!agentMode) {
    console.log(chalk.blue(&amp;#39;  ğŸ“‹ Running planning pipeline...&amp;#39;));
  }

  // This would integrate with the planning API when available
  // For now, just return the status
  const result &#x3D; {
    status: &amp;#39;not_implemented&amp;#39;,
    message: &amp;#39;Planning pipeline not yet implemented&amp;#39;,
  };

  if (!agentMode) {
    console.log(chalk.yellow(&amp;#39;  âš ï¸  Planning pipeline not yet implemented&amp;#39;));
  }

  return result;
}

/**
 * Analyze API surface of code files
 */
async function analyzeSurface(
  files: string[],
  agentMode: boolean
): Promise&amp;lt;{ status: string; message: string; files: number }&amp;gt; {
  if (!agentMode) {
    console.log(chalk.blue(&#x60;  ğŸ” Analyzing API surface for ${files.length} code files...&#x60;));
  }

  // This would integrate with the surface analysis when implemented
  // For now, just return the status
  const result &#x3D; {
    status: &amp;#39;not_implemented&amp;#39;,
    message: &amp;#39;Surface analysis not yet implemented&amp;#39;,
    files: files.length,
  };

  if (!agentMode) {
    console.log(chalk.yellow(&amp;#39;  âš ï¸  Surface analysis not yet implemented&amp;#39;));
  }

  return result;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-74">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/ide.ts</div>
                <div class="file-content">
                    <pre>import fs from &amp;#39;node:fs/promises&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import type { CLIConfig, IDEOptions } from &amp;#39;../types.js&amp;#39;;

interface ProjectLanguage {
  name: string;
  detected: boolean;
  files: string[];
  extensions: string[];
}

/**
 * Detect project languages based on file patterns
 */
async function detectProjectLanguages(projectPath: string): Promise&amp;lt;ProjectLanguage[]&amp;gt; {
  const languages: ProjectLanguage[] &#x3D; [
    {
      name: &amp;#39;cue&amp;#39;,
      detected: false,
      files: [],
      extensions: [&amp;#39;bradleyjkemp.vscode-cue&amp;#39;],
    },
    {
      name: &amp;#39;typescript&amp;#39;,
      detected: false,
      files: [],
      extensions: [&amp;#39;ms-vscode.vscode-typescript-next&amp;#39;, &amp;#39;bradlc.vscode-tailwindcss&amp;#39;],
    },
    {
      name: &amp;#39;python&amp;#39;,
      detected: false,
      files: [],
      extensions: [&amp;#39;ms-python.python&amp;#39;, &amp;#39;ms-python.black-formatter&amp;#39;],
    },
    {
      name: &amp;#39;rust&amp;#39;,
      detected: false,
      files: [],
      extensions: [&amp;#39;rust-lang.rust-analyzer&amp;#39;, &amp;#39;serayuzgur.crates&amp;#39;],
    },
    {
      name: &amp;#39;go&amp;#39;,
      detected: false,
      files: [],
      extensions: [&amp;#39;golang.go&amp;#39;],
    },
    {
      name: &amp;#39;bash&amp;#39;,
      detected: false,
      files: [],
      extensions: [&amp;#39;timonwong.shellcheck&amp;#39;, &amp;#39;foxundermoon.shell-format&amp;#39;],
    },
  ];

  async function scanDirectory(dir: string): Promise&amp;lt;void&amp;gt; {
    try {
      const entries &#x3D; await fs.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath &#x3D; path.join(dir, entry.name);
        const relativePath &#x3D; path.relative(projectPath, fullPath);

        if (entry.isDirectory()) {
          // Skip common ignore directories
          if (
            [&amp;#39;node_modules&amp;#39;, &amp;#39;.git&amp;#39;, &amp;#39;dist&amp;#39;, &amp;#39;build&amp;#39;, &amp;#39;target&amp;#39;, &amp;#39;.next&amp;#39;, &amp;#39;__pycache__&amp;#39;].includes(
              entry.name
            )
          ) {
            continue;
          }
          await scanDirectory(fullPath);
        } else {
          // Check file extensions and patterns
          const ext &#x3D; path.extname(entry.name).toLowerCase();
          const basename &#x3D; entry.name.toLowerCase();

          // CUE files
          if (ext &#x3D;&#x3D;&#x3D; &amp;#39;.cue&amp;#39;) {
            languages[0].detected &#x3D; true;
            languages[0].files.push(relativePath);
          }
          // TypeScript/JavaScript
          else if (
            [&amp;#39;.ts&amp;#39;, &amp;#39;.tsx&amp;#39;, &amp;#39;.js&amp;#39;, &amp;#39;.jsx&amp;#39;].includes(ext) ||
            [&amp;#39;package.json&amp;#39;, &amp;#39;tsconfig.json&amp;#39;].includes(basename)
          ) {
            languages[1].detected &#x3D; true;
            languages[1].files.push(relativePath);
          }
          // Python
          else if (ext &#x3D;&#x3D;&#x3D; &amp;#39;.py&amp;#39; || [&amp;#39;pyproject.toml&amp;#39;, &amp;#39;requirements.txt&amp;#39;].includes(basename)) {
            languages[2].detected &#x3D; true;
            languages[2].files.push(relativePath);
          }
          // Rust
          else if (ext &#x3D;&#x3D;&#x3D; &amp;#39;.rs&amp;#39; || [&amp;#39;cargo.toml&amp;#39;, &amp;#39;cargo.lock&amp;#39;].includes(basename)) {
            languages[3].detected &#x3D; true;
            languages[3].files.push(relativePath);
          }
          // Go
          else if (ext &#x3D;&#x3D;&#x3D; &amp;#39;.go&amp;#39; || [&amp;#39;go.mod&amp;#39;, &amp;#39;go.sum&amp;#39;].includes(basename)) {
            languages[4].detected &#x3D; true;
            languages[4].files.push(relativePath);
          }
          // Bash
          else if (ext &#x3D;&#x3D;&#x3D; &amp;#39;.sh&amp;#39; || basename &#x3D;&#x3D;&#x3D; &amp;#39;makefile&amp;#39;) {
            languages[5].detected &#x3D; true;
            languages[5].files.push(relativePath);
          }
        }
      }
    } catch (_error) {
      // Skip directories we can&amp;#39;t read
      return;
    }
  }

  await scanDirectory(projectPath);
  return languages.filter(lang &#x3D;&amp;gt; lang.detected);
}

/**
 * Generate VS Code configuration
 */
async function generateVSCodeConfig(
  languages: ProjectLanguage[],
  projectPath: string,
  force: boolean,
  outputDir?: string
): Promise&amp;lt;void&amp;gt; {
  const vscodeDir &#x3D; path.join(outputDir || projectPath, &amp;#39;.vscode&amp;#39;);
  await fs.mkdir(vscodeDir, { recursive: true });

  // Generate all VS Code configuration files
  await generateExtensionsConfig(languages, vscodeDir, force);
  await generateTasksConfig(languages, vscodeDir, force);
}

/**
 * Generate extensions.json configuration
 */
async function generateExtensionsConfig(
  languages: ProjectLanguage[],
  vscodeDir: string,
  force: boolean
): Promise&amp;lt;void&amp;gt; {
  const allExtensions &#x3D; collectRequiredExtensions(languages);
  const extensionsConfig &#x3D; {
    recommendations: Array.from(allExtensions).sort(),
  };

  const extensionsPath &#x3D; path.join(vscodeDir, &amp;#39;extensions.json&amp;#39;);
  await writeConfigFile(extensionsPath, extensionsConfig, force);
}

/**
 * Collect all required VS Code extensions for detected languages
 */
function collectRequiredExtensions(languages: ProjectLanguage[]): Set&amp;lt;string&amp;gt; {
  const allExtensions &#x3D; new Set&amp;lt;string&amp;gt;();

  // Add recommended extensions for detected languages
  for (const lang of languages) {
    for (const ext of lang.extensions) {
      allExtensions.add(ext);
    }
  }

  // Add Arbiter-specific extensions
  allExtensions.add(&amp;#39;bradleyjkemp.vscode-cue&amp;#39;); // CUE language support
  allExtensions.add(&amp;#39;ms-vscode.vscode-json&amp;#39;); // JSON support
  allExtensions.add(&amp;#39;redhat.vscode-yaml&amp;#39;); // YAML support

  return allExtensions;
}

/**
 * Write a configuration file, respecting the force flag
 */
async function writeConfigFile(filePath: string, config: any, force: boolean): Promise&amp;lt;void&amp;gt; {
  let shouldWrite &#x3D; force;

  if (!force) {
    try {
      const existingContent &#x3D; JSON.parse(await fs.readFile(filePath, &amp;#39;utf8&amp;#39;));
      // Merge with existing config
      Object.assign(existingContent, config);
      await fs.writeFile(filePath, JSON.stringify(existingContent, null, 2));
      console.log(chalk.green(&#x60;âœ… Merged configuration into ${filePath}&#x60;));
      return;
    } catch {
      shouldWrite &#x3D; true;
    }
  }

  if (shouldWrite) {
    await fs.writeFile(filePath, JSON.stringify(config, null, 2));
    console.log(chalk.green(&#x60;âœ… Generated ${filePath}&#x60;));
  }
}

/**
 * Create base Arbiter tasks for VS Code
 */
function createArbiterTasks(): any[] {
  return [
    {
      label: &amp;#39;Arbiter: Check&amp;#39;,
      type: &amp;#39;shell&amp;#39;,
      command: &amp;#39;arbiter&amp;#39;,
      args: [&amp;#39;check&amp;#39;, &amp;#39;--format&amp;#39;, &amp;#39;json&amp;#39;],
      group: &amp;#39;build&amp;#39;,
      presentation: {
        echo: true,
        reveal: &amp;#39;always&amp;#39;,
        focus: false,
        panel: &amp;#39;shared&amp;#39;,
        clear: true,
      },
      problemMatcher: {
        owner: &amp;#39;arbiter-check&amp;#39;,
        fileLocation: [&amp;#39;relative&amp;#39;, &amp;#39;${workspaceFolder}&amp;#39;],
        pattern: [
          {
            regexp: &amp;#39;^ERROR\\s+(.*):(\\d+):(\\d+)\\s+(.*)$&amp;#39;,
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            severity: &amp;#39;error&amp;#39;,
          },
        ],
      },
    },
    {
      label: &amp;#39;Arbiter: Watch&amp;#39;,
      type: &amp;#39;shell&amp;#39;,
      command: &amp;#39;arbiter&amp;#39;,
      args: [&amp;#39;watch&amp;#39;],
      group: &amp;#39;build&amp;#39;,
      isBackground: true,
      presentation: {
        echo: true,
        reveal: &amp;#39;always&amp;#39;,
        focus: false,
        panel: &amp;#39;shared&amp;#39;,
      },
      problemMatcher: {
        owner: &amp;#39;arbiter-watch&amp;#39;,
        fileLocation: [&amp;#39;relative&amp;#39;, &amp;#39;${workspaceFolder}&amp;#39;],
        background: {
          activeOnStart: true,
          beginsPattern: &amp;#39;^ğŸ” Watching for changes&amp;#39;,
          endsPattern: &amp;#39;^âœ… All files validated&amp;#39;,
        },
      },
    },
  ];
}

/**
 * Create language-specific tasks
 */
function createLanguageSpecificTasks(languages: ProjectLanguage[]): any[] {
  const tasks &#x3D; [];

  for (const lang of languages) {
    if (lang.name &#x3D;&#x3D;&#x3D; &amp;#39;typescript&amp;#39;) {
      tasks.push({
        label: &#x60;${lang.name}: Build&#x60;,
        type: &amp;#39;shell&amp;#39;,
        command: &amp;#39;npm&amp;#39;,
        args: [&amp;#39;run&amp;#39;, &amp;#39;build&amp;#39;],
        group: &amp;#39;build&amp;#39;,
      });
    } else if (lang.name &#x3D;&#x3D;&#x3D; &amp;#39;python&amp;#39;) {
      tasks.push({
        label: &#x60;${lang.name}: Test&#x60;,
        type: &amp;#39;shell&amp;#39;,
        command: &amp;#39;python&amp;#39;,
        args: [&amp;#39;-m&amp;#39;, &amp;#39;pytest&amp;#39;],
        group: &amp;#39;test&amp;#39;,
      });
    }
    // Add more language-specific tasks as needed
  }

  return tasks;
}

/**
 * Generate tasks.json configuration
 */
async function generateTasksConfig(
  languages: ProjectLanguage[],
  vscodeDir: string,
  force: boolean
): Promise&amp;lt;void&amp;gt; {
  const baseTasks &#x3D; createArbiterTasks();
  const languageTasks &#x3D; createLanguageSpecificTasks(languages);

  const tasksConfig: any &#x3D; {
    tasks: [
      {
        label: &amp;#39;Arbiter: Check&amp;#39;,
        type: &amp;#39;shell&amp;#39;,
        command: &amp;#39;arbiter&amp;#39;,
        args: [&amp;#39;check&amp;#39;, &amp;#39;--format&amp;#39;, &amp;#39;json&amp;#39;],
        group: &amp;#39;build&amp;#39;,
        presentation: {
          echo: true,
          reveal: &amp;#39;always&amp;#39;,
          focus: false,
          panel: &amp;#39;shared&amp;#39;,
          clear: true,
        },
        problemMatcher: {
          owner: &amp;#39;arbiter-check&amp;#39;,
          fileLocation: [&amp;#39;relative&amp;#39;, &amp;#39;${workspaceFolder}&amp;#39;],
          pattern: [
            {
              regexp: &amp;#39;^ERROR\\s+(.*):(\\d+):(\\d+)\\s+(.*)$&amp;#39;,
              file: 1,
              line: 2,
              column: 3,
              message: 4,
              severity: &amp;#39;error&amp;#39;,
            },
            {
              regexp: &amp;#39;^WARNING\\s+(.*):(\\d+):(\\d+)\\s+(.*)$&amp;#39;,
              file: 1,
              line: 2,
              column: 3,
              message: 4,
              severity: &amp;#39;warning&amp;#39;,
            },
            {
              regexp: &amp;#39;^(.*):(\\d+):(\\d+):\\s+(error|warning):\\s+(.*)$&amp;#39;,
              file: 1,
              line: 2,
              column: 3,
              severity: 4,
              message: 5,
            },
          ],
        },
      },
      {
        label: &amp;#39;CUE: Format&amp;#39;,
        type: &amp;#39;shell&amp;#39;,
        command: &amp;#39;cue&amp;#39;,
        args: [&amp;#39;fmt&amp;#39;, &amp;#39;${file}&amp;#39;],
        group: &amp;#39;build&amp;#39;,
        presentation: {
          echo: false,
          reveal: &amp;#39;never&amp;#39;,
          focus: false,
          panel: &amp;#39;shared&amp;#39;,
        },
        problemMatcher: [],
      },
      {
        label: &amp;#39;CUE: Format All&amp;#39;,
        type: &amp;#39;shell&amp;#39;,
        command: &amp;#39;cue&amp;#39;,
        args: [&amp;#39;fmt&amp;#39;, &amp;#39;./...&amp;#39;],
        group: &amp;#39;build&amp;#39;,
        presentation: {
          echo: true,
          reveal: &amp;#39;silent&amp;#39;,
          focus: false,
          panel: &amp;#39;shared&amp;#39;,
        },
        problemMatcher: [],
      },
      {
        label: &amp;#39;Arbiter: Watch&amp;#39;,
        type: &amp;#39;shell&amp;#39;,
        command: &amp;#39;arbiter&amp;#39;,
        args: [&amp;#39;watch&amp;#39;, &amp;#39;--agent-mode&amp;#39;],
        group: &amp;#39;build&amp;#39;,
        isBackground: true,
        presentation: {
          echo: true,
          reveal: &amp;#39;always&amp;#39;,
          focus: false,
          panel: &amp;#39;dedicated&amp;#39;,
          clear: true,
        },
        problemMatcher: {
          owner: &amp;#39;arbiter-watch&amp;#39;,
          fileLocation: [&amp;#39;relative&amp;#39;, &amp;#39;${workspaceFolder}&amp;#39;],
          pattern: [
            {
              regexp:
                &amp;#39;^\\s*&amp;quot;file&amp;quot;:\\s*&amp;quot;([^&amp;quot;]+)&amp;quot;,\\s*&amp;quot;line&amp;quot;:\\s*(\\d+),\\s*&amp;quot;column&amp;quot;:\\s*(\\d+),\\s*&amp;quot;severity&amp;quot;:\\s*&amp;quot;([^&amp;quot;]+)&amp;quot;,\\s*&amp;quot;message&amp;quot;:\\s*&amp;quot;([^&amp;quot;]+)&amp;quot;&amp;#39;,
              file: 1,
              line: 2,
              column: 3,
              severity: 4,
              message: 5,
            },
          ],
          background: {
            activeOnStart: true,
            beginsPattern: &amp;#39;^.*&amp;quot;event&amp;quot;:\\s*&amp;quot;watch_start&amp;quot;.*$&amp;#39;,
            endsPattern: &amp;#39;^.*&amp;quot;event&amp;quot;:\\s*&amp;quot;validation_complete&amp;quot;.*$&amp;#39;,
          },
        },
      },
      {
        label: &amp;#39;Arbiter: Generate Surface&amp;#39;,
        type: &amp;#39;shell&amp;#39;,
        command: &amp;#39;arbiter&amp;#39;,
        args: [&amp;#39;surface&amp;#39;, &amp;#39;typescript&amp;#39;, &amp;#39;--output&amp;#39;, &amp;#39;surface.json&amp;#39;, &amp;#39;--verbose&amp;#39;],
        group: &amp;#39;build&amp;#39;,
        presentation: {
          echo: true,
          reveal: &amp;#39;always&amp;#39;,
          focus: false,
          panel: &amp;#39;shared&amp;#39;,
        },
        problemMatcher: {
          owner: &amp;#39;arbiter-surface&amp;#39;,
          fileLocation: [&amp;#39;relative&amp;#39;, &amp;#39;${workspaceFolder}&amp;#39;],
          pattern: {
            regexp: &amp;#39;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&amp;#39;,
            file: 1,
            line: 2,
            column: 3,
            severity: 4,
            message: 5,
          },
        },
      },
      {
        label: &amp;#39;Arbiter: Sync Manifests&amp;#39;,
        type: &amp;#39;shell&amp;#39;,
        command: &amp;#39;arbiter&amp;#39;,
        args: [&amp;#39;sync&amp;#39;, &amp;#39;--all&amp;#39;],
        group: &amp;#39;build&amp;#39;,
        presentation: {
          echo: true,
          reveal: &amp;#39;always&amp;#39;,
          focus: false,
          panel: &amp;#39;shared&amp;#39;,
        },
      },
      {
        label: &amp;#39;Arbiter: Generate CI&amp;#39;,
        type: &amp;#39;shell&amp;#39;,
        command: &amp;#39;arbiter&amp;#39;,
        args: [&amp;#39;integrate&amp;#39;, &amp;#39;--force&amp;#39;],
        group: &amp;#39;build&amp;#39;,
        presentation: {
          echo: true,
          reveal: &amp;#39;always&amp;#39;,
          focus: false,
          panel: &amp;#39;shared&amp;#39;,
        },
      },
    ],
  };

  // Add language-specific tasks
  if (languages.some(l &#x3D;&amp;gt; l.name &#x3D;&#x3D;&#x3D; &amp;#39;typescript&amp;#39;)) {
    tasksConfig.tasks.push({
      label: &amp;#39;TypeScript: Build&amp;#39;,
      type: &amp;#39;typescript&amp;#39;,
      tsconfig: &amp;#39;tsconfig.json&amp;#39;,
      group: &amp;#39;build&amp;#39;,
      presentation: {
        echo: true,
        reveal: &amp;#39;silent&amp;#39;,
        focus: false,
        panel: &amp;#39;shared&amp;#39;,
      },
      problemMatcher: &amp;#39;$tsc&amp;#39;,
    });
  }

  const tasksPath &#x3D; path.join(vscodeDir, &amp;#39;tasks.json&amp;#39;);
  let shouldWriteTasks &#x3D; force;

  if (!force) {
    try {
      await fs.access(tasksPath);
      console.log(chalk.yellow(&#x60;âš ï¸  ${tasksPath} already exists. Use --force to overwrite.&#x60;));
    } catch {
      shouldWriteTasks &#x3D; true;
    }
  }

  if (shouldWriteTasks) {
    await fs.writeFile(tasksPath, JSON.stringify(tasksConfig, null, 2));
    console.log(chalk.green(&#x60;âœ… Generated ${tasksPath}&#x60;));
  }

  // Generate settings.json with enhanced CUE support and save-time formatting
  const settings: any &#x3D; {
    &amp;#39;[cue]&amp;#39;: {
      &amp;#39;editor.insertSpaces&amp;#39;: true,
      &amp;#39;editor.tabSize&amp;#39;: 2,
      &amp;#39;editor.detectIndentation&amp;#39;: false,
      &amp;#39;editor.formatOnSave&amp;#39;: true,
      &amp;#39;editor.formatOnType&amp;#39;: true,
      &amp;#39;editor.formatOnPaste&amp;#39;: true,
      &amp;#39;editor.defaultFormatter&amp;#39;: &amp;#39;bradleyjkemp.vscode-cue&amp;#39;,
    },
    &amp;#39;files.associations&amp;#39;: {
      &amp;#39;*.cue&amp;#39;: &amp;#39;cue&amp;#39;,
      &amp;#39;arbiter.assembly.cue&amp;#39;: &amp;#39;cue&amp;#39;,
      &amp;#39;*.assembly.cue&amp;#39;: &amp;#39;cue&amp;#39;,
    },
    &amp;#39;cue.useLanguageServer&amp;#39;: true,
    &amp;#39;cue.formatting.enabled&amp;#39;: true,
    &amp;#39;editor.rulers&amp;#39;: [80, 120],
    &amp;#39;editor.quickSuggestions&amp;#39;: {
      other: true,
      comments: false,
      strings: true,
    },
    &amp;#39;editor.suggestSelection&amp;#39;: &amp;#39;first&amp;#39;,
    &amp;#39;editor.wordBasedSuggestions&amp;#39;: false,
    // Save actions for CUE files
    &amp;#39;editor.codeActionsOnSave&amp;#39;: {
      &amp;#39;source.organizeImports&amp;#39;: true,
      &amp;#39;source.fixAll&amp;#39;: true,
    },
    // Arbiter-specific file associations
    &amp;#39;files.exclude&amp;#39;: {
      &amp;#39;**/*.log&amp;#39;: true,
      &amp;#39;**/node_modules&amp;#39;: true,
      &amp;#39;**/dist&amp;#39;: true,
      &amp;#39;**/build&amp;#39;: true,
      &amp;#39;**/.git&amp;#39;: true,
    },
    // Problem matcher integration
    &amp;#39;problemMatcher.pattern&amp;#39;: [
      {
        name: &amp;#39;arbiter-cue&amp;#39;,
        regexp: &amp;#39;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&amp;#39;,
        file: 1,
        line: 2,
        column: 3,
        severity: 4,
        message: 5,
      },
    ],
    // Workspace-specific Arbiter settings
    &amp;#39;arbiter.autoFormat&amp;#39;: true,
    &amp;#39;arbiter.validateOnSave&amp;#39;: true,
    &amp;#39;arbiter.showInlineErrors&amp;#39;: true,
  };

  const settingsPath &#x3D; path.join(vscodeDir, &amp;#39;settings.json&amp;#39;);
  let shouldWriteSettings &#x3D; force;

  if (!force) {
    try {
      const existingSettings &#x3D; JSON.parse(await fs.readFile(settingsPath, &amp;#39;utf8&amp;#39;));
      // Merge with existing settings
      Object.assign(existingSettings, settings);
      await fs.writeFile(settingsPath, JSON.stringify(existingSettings, null, 2));
      console.log(chalk.green(&#x60;âœ… Merged settings into ${settingsPath}&#x60;));
    } catch {
      shouldWriteSettings &#x3D; true;
    }
  }

  if (shouldWriteSettings) {
    await fs.writeFile(settingsPath, JSON.stringify(settings, null, 2));
    console.log(chalk.green(&#x60;âœ… Generated ${settingsPath}&#x60;));
  }
}

/**
 * Generate JetBrains IDE configuration (IntelliJ IDEA, etc.)
 */
async function generateIDEAConfig(
  _languages: ProjectLanguage[],
  projectPath: string,
  force: boolean,
  outputDir?: string
): Promise&amp;lt;void&amp;gt; {
  const ideaDir &#x3D; path.join(outputDir || projectPath, &amp;#39;.idea&amp;#39;);

  try {
    await fs.mkdir(ideaDir, { recursive: true });

    // Generate file watcher for CUE files
    const watchersConfig &#x3D; &#x60;&amp;lt;?xml version&#x3D;&amp;quot;1.0&amp;quot; encoding&#x3D;&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project version&#x3D;&amp;quot;4&amp;quot;&amp;gt;
  &amp;lt;component name&#x3D;&amp;quot;ProjectTasksOptions&amp;quot;&amp;gt;
    &amp;lt;TaskOptions isEnabled&#x3D;&amp;quot;true&amp;quot;&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;arguments&amp;quot; value&#x3D;&amp;quot;check&amp;quot; /&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;checkSyntaxErrors&amp;quot; value&#x3D;&amp;quot;true&amp;quot; /&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;description&amp;quot; value&#x3D;&amp;quot;Arbiter CUE validation&amp;quot; /&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;exitCodeBehavior&amp;quot; value&#x3D;&amp;quot;ERROR&amp;quot; /&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;fileExtension&amp;quot; value&#x3D;&amp;quot;cue&amp;quot; /&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;immediateSync&amp;quot; value&#x3D;&amp;quot;false&amp;quot; /&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;name&amp;quot; value&#x3D;&amp;quot;Arbiter Check&amp;quot; /&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;output&amp;quot; value&#x3D;&amp;quot;$FileDir$&amp;quot; /&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;outputFilters&amp;quot;&amp;gt;
        &amp;lt;array /&amp;gt;
      &amp;lt;/option&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;outputFromStdout&amp;quot; value&#x3D;&amp;quot;false&amp;quot; /&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;program&amp;quot; value&#x3D;&amp;quot;arbiter&amp;quot; /&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;runOnExternalChanges&amp;quot; value&#x3D;&amp;quot;false&amp;quot; /&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;scopeName&amp;quot; value&#x3D;&amp;quot;Project Files&amp;quot; /&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;trackOnlyRoot&amp;quot; value&#x3D;&amp;quot;true&amp;quot; /&amp;gt;
      &amp;lt;option name&#x3D;&amp;quot;workingDir&amp;quot; value&#x3D;&amp;quot;$ProjectFileDir$&amp;quot; /&amp;gt;
      &amp;lt;envs /&amp;gt;
    &amp;lt;/TaskOptions&amp;gt;
  &amp;lt;/component&amp;gt;
&amp;lt;/project&amp;gt;&#x60;;

    const watchersPath &#x3D; path.join(ideaDir, &amp;#39;watchers.xml&amp;#39;);
    if (
      force ||
      !(await fs.access(watchersPath).then(
        () &#x3D;&amp;gt; true,
        () &#x3D;&amp;gt; false
      ))
    ) {
      await fs.writeFile(watchersPath, watchersConfig);
      console.log(chalk.green(&#x60;âœ… Generated ${watchersPath}&#x60;));
    } else {
      console.log(chalk.yellow(&#x60;âš ï¸  ${watchersPath} already exists. Use --force to overwrite.&#x60;));
    }
  } catch (_error) {
    console.log(chalk.yellow(&amp;#39;âš ï¸  Could not generate IntelliJ IDEA configuration&amp;#39;));
  }
}

/**
 * Generate Vim configuration
 */
async function generateVimConfig(
  _languages: ProjectLanguage[],
  projectPath: string,
  force: boolean,
  outputDir?: string
): Promise&amp;lt;void&amp;gt; {
  const vimrcPath &#x3D; path.join(outputDir || projectPath, &amp;#39;.vimrc.local&amp;#39;);

  const vimConfig &#x3D; &#x60;&amp;quot; Arbiter CUE configuration for Vim
&amp;quot; Install cue.vim plugin: https://github.com/jjo/vim-cue

&amp;quot; CUE file settings
autocmd BufNewFile,BufRead *.cue set filetype&#x3D;cue
autocmd FileType cue setlocal tabstop&#x3D;2 shiftwidth&#x3D;2 expandtab

&amp;quot; Arbiter integration
command! ArbiterCheck !arbiter check
command! ArbiterWatch !arbiter watch &amp;amp;

&amp;quot; Key mappings
nnoremap &amp;lt;leader&amp;gt;ac :ArbiterCheck&amp;lt;CR&amp;gt;
nnoremap &amp;lt;leader&amp;gt;aw :ArbiterWatch&amp;lt;CR&amp;gt;
&#x60;;

  if (
    force ||
    !(await fs.access(vimrcPath).then(
      () &#x3D;&amp;gt; true,
      () &#x3D;&amp;gt; false
    ))
  ) {
    await fs.writeFile(vimrcPath, vimConfig);
    console.log(chalk.green(&#x60;âœ… Generated ${vimrcPath}&#x60;));
    console.log(
      chalk.dim(&amp;#39;   Add &amp;quot;source .vimrc.local&amp;quot; to your ~/.vimrc to use this configuration&amp;#39;)
    );
  } else {
    console.log(chalk.yellow(&#x60;âš ï¸  ${vimrcPath} already exists. Use --force to overwrite.&#x60;));
  }
}

/**
 * IDE recommend command implementation
 */
export async function ideCommand(options: IDEOptions, _config: CLIConfig): Promise&amp;lt;number&amp;gt; {
  try {
    const projectPath &#x3D; process.cwd();
    console.log(chalk.blue(&amp;#39;ğŸ”§ Arbiter IDE recommendation system&amp;#39;));
    console.log(chalk.dim(&#x60;Project: ${projectPath}&#x60;));

    // Detect project languages
    console.log(chalk.blue(&amp;#39;ğŸ” Detecting project languages...&amp;#39;));
    const languages &#x3D; await detectProjectLanguages(projectPath);

    if (languages.length &#x3D;&#x3D;&#x3D; 0) {
      console.log(chalk.yellow(&amp;#39;âš ï¸  No supported languages detected in project&amp;#39;));
      console.log(chalk.dim(&amp;#39;Supported: CUE, TypeScript, Python, Rust, Go, Bash&amp;#39;));
      return 1;
    }

    console.log(chalk.green(&#x60;âœ… Detected ${languages.length} language(s):&#x60;));
    for (const lang of languages) {
      console.log(chalk.dim(&#x60;  â€¢ ${lang.name} (${lang.files.length} files)&#x60;));
    }

    // If only detecting, return early
    if (options.detect) {
      console.log(chalk.cyan(&amp;#39;\nğŸ“‹ Language Detection Summary:&amp;#39;));
      for (const lang of languages) {
        console.log(
          &#x60;${chalk.bold(lang.name)}: ${chalk.green(&amp;#39;âœ“&amp;#39;)} (${lang.files.slice(0, 3).join(&amp;#39;, &amp;#39;)}${lang.files.length &amp;gt; 3 ? &amp;#39;...&amp;#39; : &amp;#39;&amp;#39;})&#x60;
        );
      }
      return 0;
    }

    // Generate IDE configurations
    const editor &#x3D; options.editor || &amp;#39;vscode&amp;#39;;
    const force &#x3D; options.force || false;
    const outputDir &#x3D; options.outputDir || options.output;

    if (outputDir) {
      console.log(chalk.blue(&#x60;\nğŸ› ï¸  Generating ${editor} configuration in ${outputDir}...&#x60;));
    } else {
      console.log(chalk.blue(&#x60;\nğŸ› ï¸  Generating ${editor} configuration...&#x60;));
    }

    switch (editor) {
      case &amp;#39;vscode&amp;#39;:
        await generateVSCodeConfig(languages, projectPath, force, outputDir);
        break;
      case &amp;#39;idea&amp;#39;:
        await generateIDEAConfig(languages, projectPath, force, outputDir);
        break;
      case &amp;#39;vim&amp;#39;:
        await generateVimConfig(languages, projectPath, force, outputDir);
        break;
      case &amp;#39;all&amp;#39;:
        await generateVSCodeConfig(languages, projectPath, force, outputDir);
        await generateIDEAConfig(languages, projectPath, force, outputDir);
        await generateVimConfig(languages, projectPath, force, outputDir);
        break;
      default:
        console.log(chalk.red(&#x60;âŒ Unknown editor: ${editor}&#x60;));
        return 1;
    }

    console.log(chalk.green(&amp;#39;\nğŸ‰ IDE configuration generated successfully!&amp;#39;));
    console.log(chalk.cyan(&amp;#39;Next steps:&amp;#39;));

    if (editor &#x3D;&#x3D;&#x3D; &amp;#39;vscode&amp;#39; || editor &#x3D;&#x3D;&#x3D; &amp;#39;all&amp;#39;) {
      console.log(chalk.dim(&amp;#39;  1. Restart VS Code to load new configuration&amp;#39;));
      console.log(chalk.dim(&amp;#39;  2. Install recommended extensions when prompted&amp;#39;));
      console.log(chalk.dim(&amp;#39;  3. Use Ctrl+Shift+P â†’ &amp;quot;Tasks: Run Task&amp;quot; â†’ &amp;quot;Arbiter: Check&amp;quot;&amp;#39;));
    }

    if (editor &#x3D;&#x3D;&#x3D; &amp;#39;idea&amp;#39; || editor &#x3D;&#x3D;&#x3D; &amp;#39;all&amp;#39;) {
      console.log(chalk.dim(&amp;#39;  1. Restart IntelliJ IDEA&amp;#39;));
      console.log(chalk.dim(&amp;#39;  2. Enable file watchers in Settings â†’ Tools â†’ File Watchers&amp;#39;));
    }

    if (editor &#x3D;&#x3D;&#x3D; &amp;#39;vim&amp;#39; || editor &#x3D;&#x3D;&#x3D; &amp;#39;all&amp;#39;) {
      console.log(chalk.dim(&amp;#39;  1. Install cue.vim plugin for CUE syntax highlighting&amp;#39;));
      console.log(chalk.dim(&amp;#39;  2. Add &amp;quot;source .vimrc.local&amp;quot; to your ~/.vimrc&amp;#39;));
    }

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;âŒ IDE configuration failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-75">
                <div class="file-header">ğŸ“„ apps/api/src/migrations/run.ts</div>
                <div class="file-content">
                    <pre>#!/usr/bin/env bun
/**
 * Database migration runner
 */
import { Database } from &amp;#39;bun:sqlite&amp;#39;;
import { existsSync } from &amp;#39;node:fs&amp;#39;;
import { drizzle } from &amp;#39;drizzle-orm/bun-sqlite&amp;#39;;
import { migrate } from &amp;#39;drizzle-orm/bun-sqlite/migrator&amp;#39;;
import { logger } from &amp;#39;../utils.ts&amp;#39;;

interface Migration {
  id: string;
  name: string;
  up: string;
  down?: string;
}

const migrations: Migration[] &#x3D; [
  {
    id: &amp;#39;001&amp;#39;,
    name: &amp;#39;initial_schema&amp;#39;,
    up: &#x60;
      -- Enable WAL mode for better concurrent access
      PRAGMA journal_mode &#x3D; WAL;
      PRAGMA synchronous &#x3D; NORMAL;
      PRAGMA cache_size &#x3D; 1000;
      PRAGMA temp_store &#x3D; memory;

      -- Create tables
      CREATE TABLE IF NOT EXISTS projects (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        updated_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;))
      );

      CREATE TABLE IF NOT EXISTS fragments (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        path TEXT NOT NULL,
        content TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        updated_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        FOREIGN KEY (project_id) REFERENCES projects (id) ON DELETE CASCADE,
        UNIQUE (project_id, path)
      );

      CREATE TABLE IF NOT EXISTS versions (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        spec_hash TEXT NOT NULL,
        resolved_json TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        FOREIGN KEY (project_id) REFERENCES projects (id) ON DELETE CASCADE,
        UNIQUE (project_id, spec_hash)
      );

      CREATE TABLE IF NOT EXISTS events (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        event_type TEXT NOT NULL,
        data TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        FOREIGN KEY (project_id) REFERENCES projects (id) ON DELETE CASCADE
      );

      -- Create indices for performance
      CREATE INDEX IF NOT EXISTS idx_fragments_project_id ON fragments (project_id);
      CREATE INDEX IF NOT EXISTS idx_fragments_path ON fragments (project_id, path);
      CREATE INDEX IF NOT EXISTS idx_versions_project_id ON versions (project_id);
      CREATE INDEX IF NOT EXISTS idx_versions_hash ON versions (spec_hash);
      CREATE INDEX IF NOT EXISTS idx_events_project_id ON events (project_id);
      CREATE INDEX IF NOT EXISTS idx_events_created_at ON events (created_at DESC);

      -- Trigger to update updated_at on projects
      CREATE TRIGGER IF NOT EXISTS update_projects_updated_at
      AFTER UPDATE ON projects
      FOR EACH ROW
      BEGIN
        UPDATE projects SET updated_at &#x3D; datetime(&amp;#39;now&amp;#39;) WHERE id &#x3D; NEW.id;
      END;

      -- Trigger to update updated_at on fragments
      CREATE TRIGGER IF NOT EXISTS update_fragments_updated_at
      AFTER UPDATE ON fragments
      FOR EACH ROW
      BEGIN
        UPDATE fragments SET updated_at &#x3D; datetime(&amp;#39;now&amp;#39;) WHERE id &#x3D; NEW.id;
      END;
    &#x60;,
    down: &#x60;
      DROP TRIGGER IF EXISTS update_fragments_updated_at;
      DROP TRIGGER IF EXISTS update_projects_updated_at;
      DROP INDEX IF EXISTS idx_events_created_at;
      DROP INDEX IF EXISTS idx_events_project_id;
      DROP INDEX IF EXISTS idx_versions_hash;
      DROP INDEX IF EXISTS idx_versions_project_id;
      DROP INDEX IF EXISTS idx_fragments_path;
      DROP INDEX IF EXISTS idx_fragments_project_id;
      DROP TABLE IF EXISTS events;
      DROP TABLE IF EXISTS versions;
      DROP TABLE IF EXISTS fragments;
      DROP TABLE IF EXISTS projects;
    &#x60;,
  },
];

class MigrationRunner {
  private db: Database;

  constructor(dbPath: string) {
    this.db &#x3D; new Database(dbPath, { create: true });
    this.initializeMigrationTable();
  }

  private initializeMigrationTable(): void {
    this.db.exec(&#x60;
      CREATE TABLE IF NOT EXISTS migrations (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        applied_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;))
      )
    &#x60;);
  }

  private getAppliedMigrations(): Set&amp;lt;string&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT id FROM migrations&amp;#39;);
    const results &#x3D; stmt.all() as { id: string }[];
    return new Set(results.map(r &#x3D;&amp;gt; r.id));
  }

  private recordMigration(id: string, name: string): void {
    const stmt &#x3D; this.db.prepare(&amp;#39;INSERT INTO migrations (id, name) VALUES (?, ?)&amp;#39;);
    stmt.run(id, name);
  }

  private removeMigration(id: string): void {
    const stmt &#x3D; this.db.prepare(&amp;#39;DELETE FROM migrations WHERE id &#x3D; ?&amp;#39;);
    stmt.run(id);
  }

  async runMigrations(): Promise&amp;lt;void&amp;gt; {
    await this.runDrizzleMigrations();

    const applied &#x3D; this.getAppliedMigrations();
    const pending &#x3D; migrations.filter(m &#x3D;&amp;gt; !applied.has(m.id));

    if (pending.length &#x3D;&#x3D;&#x3D; 0) {
      logger.info(&amp;#39;No pending migrations&amp;#39;);
      return;
    }

    logger.info(&#x60;Running ${pending.length} pending migrations&#x60;);

    for (const migration of pending) {
      try {
        logger.info(&#x60;Applying migration: ${migration.id} - ${migration.name}&#x60;);

        // Execute migration (some commands can&amp;#39;t be in transactions)
        this.db.exec(migration.up);
        this.recordMigration(migration.id, migration.name);

        logger.info(&#x60;âœ… Migration ${migration.id} applied successfully&#x60;);
      } catch (error) {
        logger.error(
          &#x60;âŒ Migration ${migration.id} failed&#x60;,
          error instanceof Error ? error : undefined
        );
        throw error;
      }
    }

    logger.info(&amp;#39;All migrations completed successfully&amp;#39;);
  }

  private async runDrizzleMigrations(): Promise&amp;lt;void&amp;gt; {
    const migrationsDir &#x3D; new URL(&amp;#39;../../drizzle&amp;#39;, import.meta.url).pathname;

    if (!existsSync(migrationsDir)) {
      return;
    }

    logger.info(&amp;#39;Running Drizzle migrations&amp;#39;, { migrationsDir });

    try {
      await migrate(drizzle(this.db), { migrationsFolder: migrationsDir });
      logger.info(&amp;#39;Drizzle migrations completed successfully&amp;#39;);
    } catch (error) {
      logger.error(&amp;#39;Drizzle migrations failed&amp;#39;, error instanceof Error ? error : undefined);
      throw error;
    }
  }

  async rollbackMigration(id: string): Promise&amp;lt;void&amp;gt; {
    const migration &#x3D; migrations.find(m &#x3D;&amp;gt; m.id &#x3D;&#x3D;&#x3D; id);

    if (!migration) {
      throw new Error(&#x60;Migration ${id} not found&#x60;);
    }

    if (!migration.down) {
      throw new Error(&#x60;Migration ${id} has no rollback script&#x60;);
    }

    const applied &#x3D; this.getAppliedMigrations();

    if (!applied.has(id)) {
      throw new Error(&#x60;Migration ${id} has not been applied&#x60;);
    }

    try {
      logger.info(&#x60;Rolling back migration: ${migration.id} - ${migration.name}&#x60;);

      // Execute rollback
      this.db.exec(migration.down!);
      this.removeMigration(migration.id);

      logger.info(&#x60;âœ… Migration ${migration.id} rolled back successfully&#x60;);
    } catch (error) {
      logger.error(
        &#x60;âŒ Rollback of migration ${migration.id} failed&#x60;,
        error instanceof Error ? error : undefined
      );
      throw error;
    }
  }

  listMigrations(): void {
    const applied &#x3D; this.getAppliedMigrations();

    logger.info(&amp;#39;Migration Status:&amp;#39;);
    console.log(&amp;#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&amp;#39;);

    for (const migration of migrations) {
      const status &#x3D; applied.has(migration.id) ? &amp;#39;âœ… Applied&amp;#39; : &amp;#39;â³ Pending&amp;#39;;
      console.log(&#x60;${status} ${migration.id} - ${migration.name}&#x60;);
    }
  }

  close(): void {
    this.db.close();
  }
}

// CLI interface
async function main() {
  const dbPath &#x3D; process.env.DATABASE_PATH || &amp;#39;./spec_workbench.db&amp;#39;;
  const runner &#x3D; new MigrationRunner(dbPath);

  try {
    const command &#x3D; process.argv[2];

    switch (command) {
      case &amp;#39;up&amp;#39;:
        await runner.runMigrations();
        break;

      case &amp;#39;down&amp;#39;: {
        const migrationId &#x3D; process.argv[3];
        if (!migrationId) {
          console.error(&amp;#39;Usage: bun run migrate down &amp;lt;migration_id&amp;gt;&amp;#39;);
          process.exit(1);
        }
        await runner.rollbackMigration(migrationId);
        break;
      }

      case &amp;#39;status&amp;#39;:
        runner.listMigrations();
        break;

      default:
        // Default to running migrations
        await runner.runMigrations();
        break;
    }
  } catch (error) {
    logger.error(&amp;#39;Migration failed&amp;#39;, error instanceof Error ? error : undefined);
    process.exit(1);
  } finally {
    runner.close();
  }
}

if (import.meta.main) {
  main();
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-76">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/debounce.ts</div>
                <div class="file-content">
                    <pre>/**
 * Debounce utility function
 * Delays function execution until after a specified delay has elapsed since its last invocation
 */
export function debounce&amp;lt;T extends (...args: any[]) &#x3D;&amp;gt; any&amp;gt;(
  func: T,
  delay: number,
): (...args: Parameters&amp;lt;T&amp;gt;) &#x3D;&amp;gt; void {
  let timeoutId: NodeJS.Timeout | null &#x3D; null;

  return function debounced(...args: Parameters&amp;lt;T&amp;gt;) {
    if (timeoutId !&#x3D;&#x3D; null) {
      clearTimeout(timeoutId);
    }

    timeoutId &#x3D; setTimeout(() &#x3D;&amp;gt; {
      func(...args);
      timeoutId &#x3D; null;
    }, delay);
  };
}

/**
 * Throttle utility function
 * Ensures function is called at most once per specified interval
 */
export function throttle&amp;lt;T extends (...args: any[]) &#x3D;&amp;gt; any&amp;gt;(
  func: T,
  interval: number,
): (...args: Parameters&amp;lt;T&amp;gt;) &#x3D;&amp;gt; void {
  let lastCallTime &#x3D; 0;
  let timeoutId: NodeJS.Timeout | null &#x3D; null;

  return function throttled(...args: Parameters&amp;lt;T&amp;gt;) {
    const now &#x3D; Date.now();
    const timeSinceLastCall &#x3D; now - lastCallTime;

    if (timeSinceLastCall &amp;gt;&#x3D; interval) {
      lastCallTime &#x3D; now;
      func(...args);
    } else if (timeoutId &#x3D;&#x3D;&#x3D; null) {
      const remainingTime &#x3D; interval - timeSinceLastCall;
      timeoutId &#x3D; setTimeout(() &#x3D;&amp;gt; {
        lastCallTime &#x3D; Date.now();
        func(...args);
        timeoutId &#x3D; null;
      }, remainingTime);
    }
  };
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-77">
                <div class="file-header">ğŸ“„ apps/web/frontend/.storybook/main.ts</div>
                <div class="file-content">
                    <pre>import type { StorybookConfig } from &amp;quot;@storybook/react-vite&amp;quot;;

const config: StorybookConfig &#x3D; {
  stories: [&amp;quot;../src/**/*.stories.@(js|jsx|ts|tsx)&amp;quot;],
  addons: [
    &amp;quot;@storybook/addon-essentials&amp;quot;,
    &amp;quot;@storybook/addon-a11y&amp;quot;,
    &amp;quot;@storybook/addon-docs&amp;quot;,
    &amp;quot;@storybook/addon-interactions&amp;quot;,
  ],
  framework: {
    name: &amp;quot;@storybook/react-vite&amp;quot;,
    options: {},
  },
  typescript: {
    check: false,
  },
  core: {
    disableTelemetry: true,
  },
};

export default config;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-78">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/vite-env.d.ts</div>
                <div class="file-content">
                    <pre>/// &amp;lt;reference types&#x3D;&amp;quot;vite/client&amp;quot; /&amp;gt;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-79">
                <div class="file-header">ğŸ“„ apps/api/src/specEngine.ts</div>
                <div class="file-content">
                    <pre>/**
 * Spec validation engine with CUE and jq integration
 */
import { join } from &amp;#39;node:path&amp;#39;;
import type {
  CoverageGap,
  Duplicate,
  ExternalToolResult,
  Fragment,
  GapSet,
  ServerConfig,
  TokenReference,
  ValidationError,
  ValidationWarning,
} from &amp;#39;./types.ts&amp;#39;;
import { CueRunner, type CueDiagnostic } from &amp;#39;@arbiter/cue-runner&amp;#39;;
import { computeSpecHash, ensureDir, executeCommand, formatCUE, generateId, logger } from &amp;#39;./utils.ts&amp;#39;;

/**
 * Interface for assertion configurations
 */
interface AssertionConfig {
  query: string;
  description: string;
  threshold?: number;
  type?: string;
}

/**
 * Interface for assertion commands
 */
interface AssertionCommand {
  execute(tempFilePath: string, jqBinaryPath: string): Promise&amp;lt;ValidationError | null&amp;gt;;
  getConfig(): AssertionConfig;
}

/**
 * Result of assertion processing
 */
interface AssertionResult {
  success: boolean;
  value?: number;
  error?: string;
}

/**
 * Manages temporary file creation and cleanup
 */
class TempFileManager {
  private tempFile: string;

  constructor(_data: Record&amp;lt;string, unknown&amp;gt;) {
    this.tempFile &#x3D; &#x60;/tmp/resolved_${generateId()}.json&#x60;;
  }

  async create(data: Record&amp;lt;string, unknown&amp;gt;): Promise&amp;lt;void&amp;gt; {
    const resolvedJson &#x3D; JSON.stringify(data, null, 2);
    await Bun.write(this.tempFile, resolvedJson);
  }

  getPath(): string {
    return this.tempFile;
  }

  async cleanup(): Promise&amp;lt;void&amp;gt; {
    try {
      const exists &#x3D; await Bun.file(this.tempFile).exists();
      if (exists) {
        await Bun.write(this.tempFile, &amp;#39;&amp;#39;);
      }
    } catch {
      // Ignore cleanup errors
    }
  }
}

/**
 * Processes and parses assertion results
 */
class AssertionResultProcessor {
  static processCommandResult(result: any): AssertionResult {
    if (result.success) {
      const value &#x3D; Number.parseInt(result.stdout.trim(), 10) || 0;
      return { success: true, value };
    }
    return { success: false, error: result.stderr };
  }

  static createValidationError(
    config: AssertionConfig,
    result: AssertionResult,
    errorType:
      | &amp;#39;execution&amp;#39;
      | &amp;#39;command_failed&amp;#39;
      | &amp;#39;threshold_exceeded&amp;#39;
      | &amp;#39;minimum_not_met&amp;#39; &#x3D; &amp;#39;threshold_exceeded&amp;#39;,
    error?: Error
  ): ValidationError {
    if (error) {
      return {
        type: &amp;#39;assertion&amp;#39;,
        message: &#x60;jq execution error for ${config.description}&#x60;,
        details: {
          query: config.query,
          error: error.message,
        },
      };
    }

    if (!result.success) {
      return {
        type: &amp;#39;assertion&amp;#39;,
        message: &#x60;jq assertion failed: ${config.description}&#x60;,
        details: {
          query: config.query,
          error: result.error,
        },
      };
    }

    // Create appropriate error message based on error type
    let message: string;
    switch (errorType) {
      case &amp;#39;threshold_exceeded&amp;#39;:
        message &#x3D; &#x60;${config.description}: expected &amp;lt;&#x3D; ${config.threshold}, got ${result.value}&#x60;;
        break;
      case &amp;#39;minimum_not_met&amp;#39;:
        message &#x3D; &#x60;${config.description}: expected &amp;gt;&#x3D; ${config.threshold}, got ${result.value}&#x60;;
        break;
      default:
        message &#x3D; &#x60;${config.description}: assertion failed&#x60;;
    }

    return {
      type: &amp;#39;assertion&amp;#39;,
      message,
      details: {
        query: config.query,
        value: result.value,
        threshold: config.threshold,
      },
    };
  }
}

/**
 * Base template for assertion execution
 */
abstract class AbstractAssertionCommand implements AssertionCommand {
  protected config: AssertionConfig;

  constructor(config: AssertionConfig) {
    this.config &#x3D; config;
  }

  async execute(tempFilePath: string, jqBinaryPath: string): Promise&amp;lt;ValidationError | null&amp;gt; {
    try {
      const commandResult &#x3D; await this.executeJqCommand(tempFilePath, jqBinaryPath);
      const result &#x3D; AssertionResultProcessor.processCommandResult(commandResult);

      if (!result.success) {
        return AssertionResultProcessor.createValidationError(
          this.config,
          result,
          &amp;#39;command_failed&amp;#39;
        );
      }

      if (this.shouldCreateError(result)) {
        return AssertionResultProcessor.createValidationError(
          this.config,
          result,
          this.getErrorType()
        );
      }

      return null;
    } catch (error) {
      return AssertionResultProcessor.createValidationError(
        this.config,
        { success: false },
        &amp;#39;execution&amp;#39;,
        error instanceof Error ? error : new Error(&amp;#39;Unknown error&amp;#39;)
      );
    }
  }

  protected abstract shouldCreateError(result: AssertionResult): boolean;
  protected abstract getErrorType(): &amp;#39;threshold_exceeded&amp;#39; | &amp;#39;minimum_not_met&amp;#39;;

  protected async executeJqCommand(tempFilePath: string, jqBinaryPath: string): Promise&amp;lt;any&amp;gt; {
    return executeCommand(jqBinaryPath, [this.config.query, tempFilePath], { timeout: 5000 });
  }

  getConfig(): AssertionConfig {
    return this.config;
  }
}

/**
 * Command for threshold-based assertions
 */
class ThresholdAssertionCommand extends AbstractAssertionCommand {
  protected shouldCreateError(result: AssertionResult): boolean {
    // For threshold assertions, we fail when the value exceeds the threshold
    // For &amp;quot;unresolved tokens&amp;quot;, threshold&#x3D;0 means we fail if there are ANY (&amp;gt;0)
    return (
      this.config.threshold !&#x3D;&#x3D; undefined &amp;amp;&amp;amp;
      result.value !&#x3D;&#x3D; undefined &amp;amp;&amp;amp;
      result.value &amp;gt; this.config.threshold
    );
  }

  protected getErrorType(): &amp;#39;threshold_exceeded&amp;#39; | &amp;#39;minimum_not_met&amp;#39; {
    return &amp;#39;threshold_exceeded&amp;#39;;
  }
}

/**
 * Command for minimum threshold assertions (must be &amp;gt;&#x3D; threshold)
 */
class MinimumThresholdCommand extends AbstractAssertionCommand {
  protected shouldCreateError(result: AssertionResult): boolean {
    return (
      this.config.threshold !&#x3D;&#x3D; undefined &amp;amp;&amp;amp;
      result.value !&#x3D;&#x3D; undefined &amp;amp;&amp;amp;
      result.value &amp;lt; this.config.threshold
    );
  }

  protected getErrorType(): &amp;#39;threshold_exceeded&amp;#39; | &amp;#39;minimum_not_met&amp;#39; {
    return &amp;#39;minimum_not_met&amp;#39;;
  }
}

/**
 * Command for existence-based assertions
 */
class ExistenceAssertionCommand extends AbstractAssertionCommand {
  protected shouldCreateError(result: AssertionResult): boolean {
    return result.value &#x3D;&#x3D;&#x3D; 0; // Fail if nothing exists
  }

  protected getErrorType(): &amp;#39;threshold_exceeded&amp;#39; | &amp;#39;minimum_not_met&amp;#39; {
    return &amp;#39;minimum_not_met&amp;#39;; // Existence is essentially minimum threshold of 1
  }
}

/**
 * Builder for creating assertion commands
 */
class AssertionCommandBuilder {
  private config: Partial&amp;lt;AssertionConfig&amp;gt; &#x3D; {};

  static create(): AssertionCommandBuilder {
    return new AssertionCommandBuilder();
  }

  query(query: string): AssertionCommandBuilder {
    this.config.query &#x3D; query;
    return this;
  }

  description(description: string): AssertionCommandBuilder {
    this.config.description &#x3D; description;
    return this;
  }

  threshold(threshold: number): AssertionCommandBuilder {
    this.config.threshold &#x3D; threshold;
    return this;
  }

  type(type: string): AssertionCommandBuilder {
    this.config.type &#x3D; type;
    return this;
  }

  buildThreshold(): ThresholdAssertionCommand {
    if (!this.config.query || !this.config.description) {
      throw new Error(&amp;#39;Query and description are required&amp;#39;);
    }
    return new ThresholdAssertionCommand(this.config as AssertionConfig);
  }

  buildMinimum(): MinimumThresholdCommand {
    if (!this.config.query || !this.config.description) {
      throw new Error(&amp;#39;Query and description are required&amp;#39;);
    }
    return new MinimumThresholdCommand(this.config as AssertionConfig);
  }

  buildExistence(): ExistenceAssertionCommand {
    if (!this.config.query || !this.config.description) {
      throw new Error(&amp;#39;Query and description are required&amp;#39;);
    }
    return new ExistenceAssertionCommand(this.config as AssertionConfig);
  }
}

/**
 * Strategy for different assertion execution approaches
 */
interface AssertionExecutionStrategy {
  execute(
    commands: AssertionCommand[],
    tempFilePath: string,
    jqBinaryPath: string
  ): Promise&amp;lt;ValidationError[]&amp;gt;;
}

/**
 * Sequential execution strategy
 */
class SequentialExecutionStrategy implements AssertionExecutionStrategy {
  async execute(
    commands: AssertionCommand[],
    tempFilePath: string,
    jqBinaryPath: string
  ): Promise&amp;lt;ValidationError[]&amp;gt; {
    const errors: ValidationError[] &#x3D; [];

    for (const command of commands) {
      const error &#x3D; await command.execute(tempFilePath, jqBinaryPath);
      if (error) {
        errors.push(error);
      }
    }

    return errors;
  }
}

/**
 * Parallel execution strategy
 */
class ParallelExecutionStrategy implements AssertionExecutionStrategy {
  async execute(
    commands: AssertionCommand[],
    tempFilePath: string,
    jqBinaryPath: string
  ): Promise&amp;lt;ValidationError[]&amp;gt; {
    const promises &#x3D; commands.map(command &#x3D;&amp;gt; command.execute(tempFilePath, jqBinaryPath));

    const results &#x3D; await Promise.all(promises);
    return results.filter((error): error is ValidationError &#x3D;&amp;gt; error !&#x3D;&#x3D; null);
  }
}

/**
 * Main assertion executor class
 */
class AssertionExecutor {
  private strategy: AssertionExecutionStrategy;
  private commands: AssertionCommand[];

  constructor(private config: ServerConfig) {
    this.strategy &#x3D; new SequentialExecutionStrategy(); // Default to sequential
    this.commands &#x3D; this.buildDefaultAssertions();
  }

  setStrategy(strategy: AssertionExecutionStrategy): void {
    this.strategy &#x3D; strategy;
  }

  addCommand(command: AssertionCommand): void {
    this.commands.push(command);
  }

  async execute(resolved: Record&amp;lt;string, unknown&amp;gt;): Promise&amp;lt;ValidationError[]&amp;gt; {
    const tempFileManager &#x3D; new TempFileManager(resolved);

    try {
      await tempFileManager.create(resolved);

      return await this.strategy.execute(
        this.commands,
        tempFileManager.getPath(),
        this.config.jq_binary_path
      );
    } catch (error) {
      return [
        {
          type: &amp;#39;assertion&amp;#39;,
          message: &amp;#39;Failed to create temporary file for jq processing&amp;#39;,
          details: {
            error: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
          },
        },
      ];
    } finally {
      await tempFileManager.cleanup();
    }
  }

  private buildDefaultAssertions(): AssertionCommand[] {
    return [
      AssertionCommandBuilder.create()
        .query(
          &amp;#39;[paths(scalars) as $p | select(getpath($p) | type &#x3D;&#x3D; &amp;quot;string&amp;quot; and test(&amp;quot;[$][{][^}]+[}]&amp;quot;)) | $p] | length&amp;#39;
        )
        .description(&amp;#39;Check for unresolved template tokens&amp;#39;)
        .threshold(0)
        .buildThreshold(), // Fail if &amp;gt; 0 tokens found

      // Note: Capabilities validation is handled by custom validators, not jq assertions
      // This keeps the jq assertions focused on structural checks
    ];
  }
}

export class SpecEngine {
  constructor(private config: ServerConfig) {}

  /**
   * Get the project directory path
   */
  private getProjectDir(projectId: string): string {
    return join(this.config.spec_workdir, projectId);
  }

  /**
   * Get the fragments directory path
   */
  private getFragmentsDir(projectId: string): string {
    return join(this.getProjectDir(projectId), &amp;#39;fragments&amp;#39;);
  }

  private createCueRunner(projectId: string): CueRunner {
    return new CueRunner({
      cueBinaryPath: this.config.cue_binary_path,
      cwd: this.getFragmentsDir(projectId),
      timeoutMs: this.config.external_tool_timeout_ms,
    });
  }

  private cueDiagnosticsToValidationErrors(diagnostics: CueDiagnostic[]): ValidationError[] {
    return diagnostics.map(diag &#x3D;&amp;gt; {
      const detailEntries: Record&amp;lt;string, unknown&amp;gt; &#x3D; {
        raw: diag.raw,
      };

      if (diag.file) {
        detailEntries.file &#x3D; diag.file;
      }
      if (typeof diag.line &#x3D;&#x3D;&#x3D; &amp;#39;number&amp;#39;) {
        detailEntries.line &#x3D; diag.line;
      }
      if (typeof diag.column &#x3D;&#x3D;&#x3D; &amp;#39;number&amp;#39;) {
        detailEntries.column &#x3D; diag.column;
      }
      if (diag.summary) {
        detailEntries.summary &#x3D; diag.summary;
      }

      const location &#x3D; diag.file
        ? &#x60;${diag.file}:${diag.line ?? 0}:${diag.column ?? 0}&#x60;
        : undefined;

      return {
        type: &amp;#39;schema&amp;#39; as const,
        message: diag.message,
        ...(location ? { location } : {}),
        details: detailEntries,
      };
    });
  }

  /**
   * Write fragments to filesystem for CUE processing
   */
  private async writeFragmentsToFS(projectId: string, fragments: Fragment[]): Promise&amp;lt;void&amp;gt; {
    const fragmentsDir &#x3D; this.getFragmentsDir(projectId);
    await ensureDir(fragmentsDir);

    // Write each fragment to its path
    for (const fragment of fragments) {
      // Ensure fragment path has .cue extension
      const fragmentFileName &#x3D; fragment.path.endsWith(&amp;#39;.cue&amp;#39;)
        ? fragment.path
        : &#x60;${fragment.path}.cue&#x60;;
      const fragmentPath &#x3D; join(fragmentsDir, fragmentFileName);
      const fragmentDir &#x3D; join(fragmentPath, &amp;#39;..&amp;#39;);

      await ensureDir(fragmentDir);
      await Bun.write(fragmentPath, fragment.content);
    }

    logger.debug(&amp;#39;Wrote fragments to filesystem&amp;#39;, {
      projectId,
      fragmentCount: fragments.length,
    });
  }

  /**
   * Format CUE fragment content
   */
  async formatFragment(
    content: string
  ): Promise&amp;lt;{ formatted: string; success: boolean; error?: string }&amp;gt; {
    return formatCUE(content, this.config.cue_binary_path);
  }

  /**
   * Run CUE validation (cue vet)
   */
  private async runCueValidation(projectId: string): Promise&amp;lt;ValidationError[]&amp;gt; {
    try {
      const runner &#x3D; this.createCueRunner(projectId);
      const vetResult &#x3D; await runner.vet();

      this.logCueValidationResult(projectId, vetResult.raw, vetResult.diagnostics);

      if (vetResult.success) {
        return [];
      }

      const diagnostics &#x3D; this.cueDiagnosticsToValidationErrors(vetResult.diagnostics);
      if (diagnostics.length &amp;gt; 0) {
        return diagnostics;
      }

      return [
        {
          type: &amp;#39;schema&amp;#39;,
          message: vetResult.raw.stderr || &amp;#39;CUE validation failed&amp;#39;,
        },
      ];
    } catch (error) {
      return this.handleCueValidationError(projectId, error);
    }
  }

  /**
   * Log CUE validation completion
   */
  private logCueValidationResult(
    projectId: string,
    result: ExternalToolResult,
    diagnostics: CueDiagnostic[],
  ): void {
    logger.debug(&amp;#39;CUE validation completed&amp;#39;, {
      projectId,
      success: result.success,
      errorCount: diagnostics.length,
      duration: result.duration_ms,
    });
  }

  /**
   * Handle CUE validation errors
   */
  private handleCueValidationError(projectId: string, error: unknown): ValidationError[] {
    const validationError: ValidationError &#x3D; {
      type: &amp;#39;schema&amp;#39;,
      message: &#x60;CUE validation failed: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;,
    };

    logger.error(&amp;#39;CUE validation error&amp;#39;, error instanceof Error ? error : undefined, {
      projectId,
    });

    return [validationError];
  }

  /**
   * Export resolved specification (cue export)
   */
  private async exportResolvedSpec(projectId: string): Promise&amp;lt;{
    success: boolean;
    resolved?: Record&amp;lt;string, unknown&amp;gt;;
    error?: string;
    diagnostics?: CueDiagnostic[];
  }&amp;gt; {
    try {
      const runner &#x3D; this.createCueRunner(projectId);
      const exportResult &#x3D; await runner.exportJson();

      if (exportResult.success &amp;amp;&amp;amp; exportResult.value) {
        logger.debug(&amp;#39;CUE export completed&amp;#39;, {
          projectId,
          duration: exportResult.raw.duration_ms,
        });

        return { success: true, resolved: exportResult.value };
      }

      return {
        success: false,
        error: exportResult.error,
        diagnostics: exportResult.diagnostics,
      };
    } catch (error) {
      logger.error(&amp;#39;CUE export error&amp;#39;, error instanceof Error ? error : undefined, { projectId });

      return {
        success: false,
        error: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
      };
    }
  }

  /**
   * Run jq assertions on resolved specification
   */
  private async runJqAssertions(resolved: Record&amp;lt;string, unknown&amp;gt;): Promise&amp;lt;ValidationError[]&amp;gt; {
    const executor &#x3D; new AssertionExecutor(this.config);
    return executor.execute(resolved);
  }

  /**
   * Run custom TypeScript validators
   */
  private async runCustomValidators(
    resolved: Record&amp;lt;string, unknown&amp;gt;
  ): Promise&amp;lt;{ errors: ValidationError[]; warnings: ValidationWarning[] }&amp;gt; {
    const errors: ValidationError[] &#x3D; [];
    const warnings: ValidationWarning[] &#x3D; [];

    try {
      // Validate duplicates
      const duplicateCheck &#x3D; this.findDuplicates(resolved);
      duplicateCheck.forEach(duplicate &#x3D;&amp;gt; {
        warnings.push({
          type: &amp;#39;duplicate&amp;#39;,
          message: &#x60;Duplicate ${duplicate.type}: ${duplicate.name}&#x60;,
          location: duplicate.locations.join(&amp;#39;, &amp;#39;),
        });
      });

      // Check for undefined capabilities
      if (typeof resolved &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp; resolved !&#x3D;&#x3D; null) {
        const capabilities &#x3D; (resolved as any).capabilities;

        if (!capabilities || Object.keys(capabilities).length &#x3D;&#x3D;&#x3D; 0) {
          errors.push({
            type: &amp;#39;custom&amp;#39;,
            message: &amp;#39;No capabilities defined in specification&amp;#39;,
          });
        }
      }

      // Add more custom validations as needed
    } catch (error) {
      errors.push({
        type: &amp;#39;custom&amp;#39;,
        message: &#x60;Custom validator error: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;,
      });
    }

    return { errors, warnings };
  }

  /**
   * Find duplicates in the resolved specification
   */
  private findDuplicates(resolved: Record&amp;lt;string, unknown&amp;gt;): Duplicate[] {
    const duplicates: Duplicate[] &#x3D; [];

    try {
      // This is a simplified implementation
      // In a real system, you&amp;#39;d want more sophisticated duplicate detection

      if (typeof resolved &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp; resolved !&#x3D;&#x3D; null) {
        const capabilities &#x3D; (resolved as any).capabilities || {};
        const capabilityNames &#x3D; Object.keys(capabilities);
        const nameCount: Record&amp;lt;string, string[]&amp;gt; &#x3D; {};

        // Count occurrences of capability names
        capabilityNames.forEach(name &#x3D;&amp;gt; {
          const parts &#x3D; name.split(&amp;#39;.&amp;#39;);
          parts.forEach(part &#x3D;&amp;gt; {
            if (!nameCount[part]) nameCount[part] &#x3D; [];
            nameCount[part].push(name);
          });
        });

        // Find duplicates
        Object.entries(nameCount).forEach(([name, locations]) &#x3D;&amp;gt; {
          if (locations.length &amp;gt; 1) {
            duplicates.push({
              type: &amp;#39;capability&amp;#39;,
              name,
              locations,
            });
          }
        });
      }
    } catch (error) {
      logger.error(&amp;#39;Error finding duplicates&amp;#39;, error instanceof Error ? error : undefined);
    }

    return duplicates;
  }

  /**
   * Complete validation pipeline
   */
  async validateProject(
    projectId: string,
    fragments: Fragment[]
  ): Promise&amp;lt;{
    success: boolean;
    specHash: string;
    resolved?: Record&amp;lt;string, unknown&amp;gt;;
    errors: ValidationError[];
    warnings: ValidationWarning[];
  }&amp;gt; {
    const startTime &#x3D; Date.now();

    try {
      // Execute the main validation workflow
      const result &#x3D; await this.executeValidationWorkflow(projectId, fragments);

      // Log completion metrics
      this.logValidationCompletion(projectId, result, Date.now() - startTime);

      return result;
    } catch (error) {
      return this.handleValidationError(projectId, error, Date.now() - startTime);
    }
  }

  /**
   * Execute the core validation workflow steps
   */
  private async executeValidationWorkflow(
    projectId: string,
    fragments: Fragment[]
  ): Promise&amp;lt;{
    success: boolean;
    specHash: string;
    resolved?: Record&amp;lt;string, unknown&amp;gt;;
    errors: ValidationError[];
    warnings: ValidationWarning[];
  }&amp;gt; {
    // Step 1: Write fragments to filesystem
    await this.writeFragmentsToFS(projectId, fragments);

    // Step 2: Run CUE validation
    let schemaErrors &#x3D; await this.runCueValidation(projectId);

    // Step 3: Export resolved specification
    const exportResult &#x3D; await this.exportResolvedSpec(projectId);

    // Handle export failure early
    if (!exportResult.success || !exportResult.resolved) {
      if (exportResult.diagnostics &amp;amp;&amp;amp; exportResult.diagnostics.length &amp;gt; 0) {
        schemaErrors &#x3D; schemaErrors.concat(
          this.cueDiagnosticsToValidationErrors(exportResult.diagnostics)
        );
      }

      return this.createFailureResult(schemaErrors, exportResult.error);
    }

    // Step 4-6: Process successful export
    return await this.processSuccessfulExport(exportResult.resolved, schemaErrors);
  }

  /**
   * Create validation result for export failures
   */
  private createFailureResult(
    errors: ValidationError[],
    exportError?: string
  ): {
    success: boolean;
    specHash: string;
    resolved?: Record&amp;lt;string, unknown&amp;gt;;
    errors: ValidationError[];
    warnings: ValidationWarning[];
  } {
    const aggregated &#x3D; [...errors];

    if (exportError) {
      aggregated.push({
        type: &amp;#39;schema&amp;#39;,
        message: exportError,
      });
    }

    return {
      success: false,
      specHash: &amp;#39;&amp;#39;,
      errors: aggregated,
      warnings: [],
    };
  }

  /**
   * Process successful spec export through remaining validation steps
   */
  private async processSuccessfulExport(
    resolved: Record&amp;lt;string, unknown&amp;gt;,
    schemaErrors: ValidationError[]
  ): Promise&amp;lt;{
    success: boolean;
    specHash: string;
    resolved?: Record&amp;lt;string, unknown&amp;gt;;
    errors: ValidationError[];
    warnings: ValidationWarning[];
  }&amp;gt; {
    // Compute spec hash
    const specHash &#x3D; computeSpecHash(JSON.stringify(resolved));

    // Run remaining validation steps
    const assertionErrors &#x3D; await this.runJqAssertions(resolved);
    const customValidation &#x3D; await this.runCustomValidators(resolved);

    // Aggregate all results
    const allErrors &#x3D; [...schemaErrors, ...assertionErrors, ...customValidation.errors];
    const success &#x3D; allErrors.length &#x3D;&#x3D;&#x3D; 0;

    return {
      success,
      specHash,
      resolved,
      errors: allErrors,
      warnings: customValidation.warnings,
    };
  }

  /**
   * Log validation completion metrics
   */
  private logValidationCompletion(
    projectId: string,
    result: {
      success: boolean;
      specHash: string;
      errors: ValidationError[];
      warnings: ValidationWarning[];
    },
    duration: number
  ): void {
    // Reduced logging - only log validation failures or significant events
    const errorCount &#x3D; result.errors.length;
    const warningCount &#x3D; result.warnings.length;
    if (!result.success || errorCount &amp;gt; 0) {
      logger.info(&amp;#39;Validation completed&amp;#39;, {
        projectId,
        success: result.success,
        specHash: result.specHash,
        errorCount,
        warningCount,
        duration,
      });
    }
  }

  /**
   * Handle validation pipeline errors
   */
  private handleValidationError(
    projectId: string,
    error: unknown,
    duration: number
  ): {
    success: boolean;
    specHash: string;
    resolved?: Record&amp;lt;string, unknown&amp;gt;;
    errors: ValidationError[];
    warnings: ValidationWarning[];
  } {
    logger.error(&amp;#39;Validation pipeline error&amp;#39;, error instanceof Error ? error : undefined, {
      projectId,
      duration,
    });

    return {
      success: false,
      specHash: &amp;#39;&amp;#39;,
      errors: [
        {
          type: &amp;#39;custom&amp;#39;,
          message: &#x60;Validation pipeline failed: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;,
        },
      ],
      warnings: [],
    };
  }

  /**
   * Generate gap analysis
   */
  async generateGapSet(resolved: Record&amp;lt;string, unknown&amp;gt;): Promise&amp;lt;GapSet&amp;gt; {
    try {
      const gapData &#x3D; this.initializeGapData(resolved);
      const orphanedTokens &#x3D; this.findOrphanedTokens(resolved);
      const coverageGaps &#x3D; this.analyzeCoverageGaps(resolved);

      return this.buildGapSet(gapData.duplicates, orphanedTokens, coverageGaps);
    } catch (error) {
      logger.error(&amp;#39;Gap analysis error&amp;#39;, error instanceof Error ? error : undefined);
      return this.createEmptyGapSet();
    }
  }

  /**
   * Initialize gap data with duplicates
   */
  private initializeGapData(resolved: Record&amp;lt;string, unknown&amp;gt;): {
    duplicates: Duplicate[];
  } {
    return {
      duplicates: this.findDuplicates(resolved),
    };
  }

  /**
   * Find orphaned tokens in resolved specification
   */
  private findOrphanedTokens(resolved: Record&amp;lt;string, unknown&amp;gt;): TokenReference[] {
    const jsonStr &#x3D; JSON.stringify(resolved);
    const tokenMatches &#x3D; jsonStr.match(/\$\{[^}]+\}/g) || [];

    return tokenMatches.map(token &#x3D;&amp;gt; ({
      token,
      defined_in: [],
      referenced_in: [&amp;#39;resolved.json&amp;#39;],
    }));
  }

  /**
   * Analyze coverage gaps between capabilities and tests
   */
  private analyzeCoverageGaps(resolved: Record&amp;lt;string, unknown&amp;gt;): CoverageGap[] {
    if (typeof resolved !&#x3D;&#x3D; &amp;#39;object&amp;#39; || resolved &#x3D;&#x3D;&#x3D; null) {
      return [];
    }

    const capabilities &#x3D; (resolved as any).capabilities || {};
    const tests &#x3D; (resolved as any).tests || {};
    const coverageGaps: CoverageGap[] &#x3D; [];

    Object.keys(capabilities).forEach(capability &#x3D;&amp;gt; {
      if (!this.hasTestCoverage(capability, tests)) {
        coverageGaps.push({
          capability,
          expected_coverage: 100,
          actual_coverage: 0,
          missing_scenarios: [&amp;#39;basic&amp;#39;, &amp;#39;error_handling&amp;#39;, &amp;#39;edge_cases&amp;#39;],
        });
      }
    });

    return coverageGaps;
  }

  /**
   * Check if a capability has test coverage
   */
  private hasTestCoverage(capability: string, tests: Record&amp;lt;string, any&amp;gt;): boolean {
    return Object.keys(tests).some(
      test &#x3D;&amp;gt; test.includes(capability) || tests[test]?.covers?.includes(capability)
    );
  }

  /**
   * Build the final gap set result
   */
  private buildGapSet(
    duplicates: Duplicate[],
    orphanedTokens: TokenReference[],
    coverageGaps: CoverageGap[]
  ): GapSet {
    return {
      missing_capabilities: [], // Simplified implementation
      orphaned_tokens: orphanedTokens,
      coverage_gaps: coverageGaps,
      duplicates,
    };
  }

  /**
   * Create empty gap set for error cases
   */
  private createEmptyGapSet(): GapSet {
    return {
      missing_capabilities: [],
      orphaned_tokens: [],
      coverage_gaps: [],
      duplicates: [],
    };
  }

  /**
   * Clean up project workspace
   */
  async cleanupProject(projectId: string): Promise&amp;lt;void&amp;gt; {
    try {
      const projectDir &#x3D; this.getProjectDir(projectId);
      await executeCommand(&amp;#39;rm&amp;#39;, [&amp;#39;-rf&amp;#39;, projectDir]);

      logger.debug(&amp;#39;Cleaned up project workspace&amp;#39;, { projectId });
    } catch (error) {
      logger.error(
        &amp;#39;Failed to cleanup project workspace&amp;#39;,
        error instanceof Error ? error : undefined,
        {
          projectId,
        }
      );
    }
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-80">
                <div class="file-header">ğŸ“„ tests/e2e-docker-compose/src/index.ts</div>
                <div class="file-content">
                    <pre>/**
 * unknown - Generated by Arbiter
 * Version: 1.0.0
 */

export function main(): void {
  console.log(&amp;#39;Hello from unknown!&amp;#39;);
}

// Auto-run if this file is executed directly
if (import.meta.url &#x3D;&#x3D;&#x3D; &#x60;file://${process.argv[1]}&#x60;) {
  main();
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-81">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/check-connection.ts</div>
                <div class="file-content">
                    <pre>import chalk from &amp;#39;chalk&amp;#39;;
import { Command } from &amp;#39;commander&amp;#39;;
import { ApiClient } from &amp;#39;../api-client.js&amp;#39;;
import { loadConfig } from &amp;#39;../config.js&amp;#39;;
import { ConnectionValidator } from &amp;#39;../connection-validator.js&amp;#39;;

/**
 * Command to check server connectivity and diagnose connection issues
 */
export function createCheckConnectionCommand(): Command {
  const cmd &#x3D; new Command(&amp;#39;check&amp;#39;)
    .description(&amp;#39;Check server connectivity and diagnose connection issues&amp;#39;)
    .option(&amp;#39;--detailed&amp;#39;, &amp;#39;Show detailed diagnostics&amp;#39;)
    .option(&amp;#39;--config &amp;lt;path&amp;gt;&amp;#39;, &amp;#39;Path to configuration file&amp;#39;)
    .action(async options &#x3D;&amp;gt; {
      try {
        const config &#x3D; await loadConfig(options.config);
        const validator &#x3D; new ConnectionValidator(config);
        const apiClient &#x3D; new ApiClient(config);

        console.log(chalk.blue(&amp;#39;ğŸ” Checking Arbiter server connection...\n&amp;#39;));

        // Test current configuration
        console.log(chalk.cyan(&amp;#39;Configuration:&amp;#39;));
        console.log(&#x60;  API URL: ${config.apiUrl}&#x60;);
        console.log(&#x60;  Timeout: ${config.timeout}ms\n&#x60;);

        // Validate connection
        const validation &#x3D; await validator.validateConnection();

        if (validation.success) {
          console.log(chalk.green(&amp;#39;âœ… Connection successful!&amp;#39;));
          console.log(&#x60;   Server found at: ${validation.url}&#x60;);

          // Test health endpoint
          const health &#x3D; await apiClient.health();
          if (health.success) {
            console.log(&#x60;   Server status: ${health.data?.status || &amp;#39;healthy&amp;#39;}&#x60;);
            console.log(&#x60;   Timestamp: ${health.data?.timestamp || new Date().toISOString()}&#x60;);
          }

          const url &#x3D; new URL(config.apiUrl);
          const configuredPort &#x3D; url.port || (url.protocol &#x3D;&#x3D;&#x3D; &amp;#39;https:&amp;#39; ? &amp;#39;443&amp;#39; : &amp;#39;80&amp;#39;);
          const detectedPort &#x3D; validation.port ? String(validation.port) : undefined;

          if (detectedPort &amp;amp;&amp;amp; detectedPort !&#x3D;&#x3D; configuredPort) {
            console.log(
              chalk.yellow(
                &#x60;\nğŸ’¡ Note: Server found on port ${detectedPort}, but your config uses ${configuredPort}&#x60;
              )
            );
            console.log(
              &#x60;   Consider updating your config: arbiter config set apiUrl http://localhost:${detectedPort}&#x60;
            );
          }
        } else {
          console.log(chalk.red(&amp;#39;âŒ Connection failed&amp;#39;));
          console.log(&#x60;   ${validation.error}\n&#x60;);

          if (validation.suggestions &amp;amp;&amp;amp; validation.suggestions.length &amp;gt; 0) {
            console.log(chalk.yellow(&amp;#39;ğŸ’¡ Troubleshooting suggestions:&amp;#39;));
            for (const suggestion of validation.suggestions) {
              console.log(&#x60;   â€¢ ${suggestion}&#x60;);
            }
          }
        }

        // Show detailed diagnostics if requested
        if (options.detailed) {
          console.log(chalk.blue(&amp;#39;\nğŸ”¬ Detailed Diagnostics:&amp;#39;));

          const diagnostics &#x3D; await validator.getDiagnostics();

          console.log(&#x60;\nTesting common ports on ${new URL(diagnostics.configuredUrl).hostname}:&#x60;);

          for (const test of diagnostics.networkTests) {
            const icon &#x3D;
              test.status &#x3D;&#x3D;&#x3D; &amp;#39;success&amp;#39;
                ? &amp;#39;âœ…&amp;#39;
                : test.status &#x3D;&#x3D;&#x3D; &amp;#39;timeout&amp;#39;
                  ? &amp;#39;â±ï¸&amp;#39;
                  : test.status &#x3D;&#x3D;&#x3D; &amp;#39;refused&amp;#39;
                    ? &amp;#39;ğŸš«&amp;#39;
                    : &amp;#39;âŒ&amp;#39;;

            const statusColor &#x3D;
              test.status &#x3D;&#x3D;&#x3D; &amp;#39;success&amp;#39;
                ? chalk.green
                : test.status &#x3D;&#x3D;&#x3D; &amp;#39;timeout&amp;#39;
                  ? chalk.yellow
                  : test.status &#x3D;&#x3D;&#x3D; &amp;#39;refused&amp;#39;
                    ? chalk.red
                    : chalk.red;

            console.log(
              &#x60;  ${icon} Port ${test.port}: ${statusColor(test.status)} (${test.responseTime}ms)&#x60;
            );
            if (test.error) {
              console.log(&#x60;     ${chalk.gray(test.error)}&#x60;);
            }
          }

          console.log(chalk.blue(&amp;#39;\nğŸ› ï¸  Quick Start Commands:&amp;#39;));
          console.log(&#x60;  Start development server: ${chalk.cyan(&amp;#39;bun run dev&amp;#39;)}&#x60;);
          console.log(&#x60;  Start with Docker:        ${chalk.cyan(&amp;#39;docker-compose up&amp;#39;)}&#x60;);
          console.log(
            &#x60;  Check server logs:        ${chalk.cyan(&amp;#39;docker-compose logs spec-workbench&amp;#39;)}&#x60;
          );
        }

        process.exit(validation.success ? 0 : 1);
      } catch (error) {
        console.error(
          chalk.red(&amp;#39;Error checking connection:&amp;#39;),
          error instanceof Error ? error.message : String(error)
        );
        process.exit(2);
      }
    });

  return cmd;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-82">
                <div class="file-header">ğŸ“„ packages/cli/src/language-plugins/index.ts</div>
                <div class="file-content">
                    <pre>/**
 * Language Plugin System for Arbiter CLI
 * Provides pluggable code generation for multiple programming languages
 */

// Core types for the plugin system
export interface ComponentProp {
  name: string;
  type: string;
  required: boolean;
}

export interface ComponentConfig {
  name: string;
  type: &amp;#39;page&amp;#39; | &amp;#39;component&amp;#39; | &amp;#39;layout&amp;#39; | &amp;#39;hook&amp;#39; | &amp;#39;util&amp;#39;;
  props?: ComponentProp[];
  dependencies?: string[];
  styles?: boolean;
  tests?: boolean;
  testId?: string;
}

export interface ServiceConfig {
  name: string;
  type: &amp;#39;api&amp;#39; | &amp;#39;service&amp;#39; | &amp;#39;handler&amp;#39; | &amp;#39;middleware&amp;#39; | &amp;#39;model&amp;#39;;
  endpoints?: string[];
  database?: boolean;
  auth?: boolean;
  validation?: boolean;
  methods?: Array&amp;lt;Record&amp;lt;string, any&amp;gt;&amp;gt;;
}

export interface ProjectConfig {
  name: string;
  description?: string;
  features: string[];
  database?: &amp;#39;sqlite&amp;#39; | &amp;#39;postgres&amp;#39; | &amp;#39;mysql&amp;#39; | &amp;#39;mongodb&amp;#39;;
  auth?: &amp;#39;jwt&amp;#39; | &amp;#39;session&amp;#39; | &amp;#39;oauth&amp;#39;;
  testing?: boolean;
  docker?: boolean;
}

export interface BuildConfig {
  target: &amp;#39;development&amp;#39; | &amp;#39;production&amp;#39; | &amp;#39;test&amp;#39;;
  optimization?: boolean;
  bundling?: boolean;
  typeChecking?: boolean;
}

export interface GeneratedFile {
  path: string;
  content: string;
  executable?: boolean;
}

export interface GenerationResult {
  files: GeneratedFile[];
  instructions?: string[];
  dependencies?: string[];
  scripts?: Record&amp;lt;string, string&amp;gt;;
}

export interface LanguagePluginCapabilities {
  components?: boolean;
  services?: boolean;
  testing?: boolean;
  api?: boolean;
  infrastructure?: boolean;
  [capability: string]: boolean | undefined;
}

// Main plugin interface
export interface LanguagePlugin {
  readonly name: string;
  readonly language: string;
  readonly version: string;
  readonly description: string;
  readonly supportedFeatures: string[];
  readonly capabilities?: LanguagePluginCapabilities;

  // Component generation (primarily for frontend languages)
  generateComponent?(config: ComponentConfig): Promise&amp;lt;GenerationResult&amp;gt;;

  // Service/API scaffolding
  generateService(config: ServiceConfig): Promise&amp;lt;GenerationResult&amp;gt;;

  // Project structure setup
  initializeProject(config: ProjectConfig): Promise&amp;lt;GenerationResult&amp;gt;;

  // Build configuration
  generateBuildConfig(config: BuildConfig): Promise&amp;lt;GenerationResult&amp;gt;;

  // Language-specific utilities
  validateConfig?(config: any): Promise&amp;lt;boolean&amp;gt;;
  getTemplates?(): string[];
  getDependencies?(features: string[]): string[];
}

// Plugin registry
export class LanguageRegistry {
  private plugins &#x3D; new Map&amp;lt;string, LanguagePlugin&amp;gt;();

  register(plugin: LanguagePlugin): void {
    this.plugins.set(plugin.language.toLowerCase(), plugin);
  }

  get(language: string): LanguagePlugin | undefined {
    return this.plugins.get(language.toLowerCase());
  }

  list(): LanguagePlugin[] {
    return Array.from(this.plugins.values());
  }

  getSupportedLanguages(): string[] {
    return Array.from(this.plugins.keys());
  }

  hasSupport(language: string, feature: string): boolean {
    const plugin &#x3D; this.get(language);
    return plugin?.supportedFeatures.includes(feature) ?? false;
  }
}

// Global registry instance
export const registry &#x3D; new LanguageRegistry();

// Plugin registration helper
export function registerPlugin(plugin: LanguagePlugin): void {
  registry.register(plugin);
}

// Convenience functions
export async function generateComponent(
  language: string,
  config: ComponentConfig
): Promise&amp;lt;GenerationResult&amp;gt; {
  const plugin &#x3D; registry.get(language);
  if (!plugin) {
    throw new Error(&#x60;No plugin found for language: ${language}&#x60;);
  }

  if (!plugin.generateComponent) {
    throw new Error(&#x60;Component generation not supported for language: ${language}&#x60;);
  }

  return plugin.generateComponent(config);
}

export async function generateService(
  language: string,
  config: ServiceConfig
): Promise&amp;lt;GenerationResult&amp;gt; {
  const plugin &#x3D; registry.get(language);
  if (!plugin) {
    throw new Error(&#x60;No plugin found for language: ${language}&#x60;);
  }

  return plugin.generateService(config);
}

export async function initializeProject(
  language: string,
  config: ProjectConfig
): Promise&amp;lt;GenerationResult&amp;gt; {
  const plugin &#x3D; registry.get(language);
  if (!plugin) {
    throw new Error(&#x60;No plugin found for language: ${language}&#x60;);
  }

  return plugin.initializeProject(config);
}

export async function generateBuildConfig(
  language: string,
  config: BuildConfig
): Promise&amp;lt;GenerationResult&amp;gt; {
  const plugin &#x3D; registry.get(language);
  if (!plugin) {
    throw new Error(&#x60;No plugin found for language: ${language}&#x60;);
  }

  return plugin.generateBuildConfig(config);
}

import { GoPlugin } from &amp;#39;./go.js&amp;#39;;
import { PythonPlugin } from &amp;#39;./python.js&amp;#39;;
import { RustPlugin } from &amp;#39;./rust.js&amp;#39;;
// Import and register all plugins
import { TypeScriptPlugin } from &amp;#39;./typescript.js&amp;#39;;

// Auto-register plugins
registerPlugin(new TypeScriptPlugin());
registerPlugin(new PythonPlugin());
registerPlugin(new GoPlugin());
registerPlugin(new RustPlugin());

// Export plugin instances for direct access
export { TypeScriptPlugin, PythonPlugin, GoPlugin, RustPlugin };
</pre>
                </div>
            </div>
            <div class="file-section" id="file-83">
                <div class="file-header">ğŸ“„ apps/api/src/handlers/examples/push-handler.ts</div>
                <div class="file-content">
                    <pre>/**
 * Example: Push event handler
 * Demonstrates the handler API and common patterns
 */

import type { HandlerModule, HandlerResult, WebhookHandler } from &amp;#39;../types.js&amp;#39;;

// Handler function implementation
const handlePush: WebhookHandler &#x3D; async (payload, context) &#x3D;&amp;gt; {
  const { logger, services, projectId } &#x3D; context;
  const { parsed } &#x3D; payload;

  logger.info(&amp;#39;Processing push event&amp;#39;, {
    repository: parsed.repository.fullName,
    ref: payload.ref,
    commits: parsed.commits?.length || 0,
  });

  const actions: string[] &#x3D; [];

  try {
    // Example: Check for spec file changes
    const specChanges &#x3D; parsed.commits?.some(
      commit &#x3D;&amp;gt;
        commit.modified.some(file &#x3D;&amp;gt; file.endsWith(&amp;#39;.cue&amp;#39;)) ||
        commit.added.some(file &#x3D;&amp;gt; file.endsWith(&amp;#39;.cue&amp;#39;))
    );

    if (specChanges) {
      logger.info(&amp;#39;Spec files changed, triggering validation&amp;#39;);

      // Trigger spec validation through events
      await services.events.broadcastToProject(projectId, {
        project_id: projectId,
        event_type: &amp;#39;validation_started&amp;#39;,
        data: {
          trigger: &amp;#39;push_handler&amp;#39;,
          repository: parsed.repository.fullName,
          ref: payload.ref,
          commits: parsed.commits?.length || 0,
        },
      });

      actions.push(&amp;#39;Triggered spec validation&amp;#39;);
    }

    // Example: Send notification for main branch pushes
    if (payload.ref &#x3D;&#x3D;&#x3D; &#x60;refs/heads/${parsed.repository.defaultBranch}&#x60;) {
      const slackWebhook &#x3D; context.config.secrets.SLACK_WEBHOOK;
      if (slackWebhook) {
        await services.notifications.sendSlack(slackWebhook, {
          text: &#x60;ğŸ“ New commits pushed to ${parsed.repository.fullName}&#x60;,
          blocks: [
            {
              type: &amp;#39;section&amp;#39;,
              text: {
                type: &amp;#39;mrkdwn&amp;#39;,
                text: &#x60;*${parsed.commits?.length || 0} new commits* in &amp;lt;${parsed.repository.url}|${parsed.repository.fullName}&amp;gt;&#x60;,
              },
            },
            {
              type: &amp;#39;section&amp;#39;,
              fields:
                parsed.commits?.slice(0, 3).map(commit &#x3D;&amp;gt; ({
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;â€¢ ${commit.message}\n  _by ${commit.author}_&#x60;,
                })) || [],
            },
          ],
        });
        actions.push(&amp;#39;Sent Slack notification&amp;#39;);
      }
    }

    // Example: Auto-create issues for breaking changes
    if (parsed.commits?.some(commit &#x3D;&amp;gt; commit.message.toLowerCase().includes(&amp;#39;breaking&amp;#39;))) {
      // This would integrate with the repository&amp;#39;s issue tracker
      logger.info(&amp;#39;Breaking changes detected, consider creating tracking issue&amp;#39;);
      actions.push(&amp;#39;Detected breaking changes&amp;#39;);
    }

    return {
      success: true,
      message: &#x60;Processed ${parsed.commits?.length || 0} commits&#x60;,
      actions,
      data: {
        repository: parsed.repository.fullName,
        ref: payload.ref,
        commitsProcessed: parsed.commits?.length || 0,
        specFilesChanged: specChanges,
      },
    };
  } catch (error) {
    logger.error(&amp;#39;Push handler failed&amp;#39;, error as Error);

    return {
      success: false,
      message: &amp;#39;Push handler execution failed&amp;#39;,
      errors: [
        {
          code: &amp;#39;HANDLER_EXECUTION_ERROR&amp;#39;,
          message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
          stack: error instanceof Error ? error.stack : undefined,
        },
      ],
    };
  }
};

// Handler module export
const handlerModule: HandlerModule &#x3D; {
  handler: handlePush,
  config: {
    enabled: true,
    timeout: 30000, // 30 seconds
    retries: 2,
    environment: {},
    secrets: {},
  },
  metadata: {
    name: &amp;#39;Push Event Handler&amp;#39;,
    description: &amp;#39;Handles Git push events with spec validation and notifications&amp;#39;,
    version: &amp;#39;1.0.0&amp;#39;,
    author: &amp;#39;Arbiter Team&amp;#39;,
    supportedEvents: [&amp;#39;push&amp;#39;, &amp;#39;Push Hook&amp;#39;],
    requiredPermissions: [&amp;#39;events:publish&amp;#39;, &amp;#39;notifications:send&amp;#39;],
  },
};

export default handlerModule;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-84">
                <div class="file-header">ğŸ“„ scripts/update-version.js</div>
                <div class="file-content">
                    <pre>#!/usr/bin/env node

/**
 * Update version script for Arbiter monorepo
 * Usage: node update-version.js &amp;lt;new-version&amp;gt;
 */

const fs &#x3D; require(&amp;#39;node:fs&amp;#39;);
const path &#x3D; require(&amp;#39;node:path&amp;#39;);

function updatePackageJson(filePath, newVersion) {
  if (!fs.existsSync(filePath)) {
    console.log(&#x60;âš ï¸  Package file not found: ${filePath}&#x60;);
    return false;
  }

  try {
    const content &#x3D; fs.readFileSync(filePath, &amp;#39;utf8&amp;#39;);
    const pkg &#x3D; JSON.parse(content);
    const oldVersion &#x3D; pkg.version;

    pkg.version &#x3D; newVersion;

    fs.writeFileSync(filePath, &#x60;${JSON.stringify(pkg, null, 2)}\n&#x60;);
    console.log(&#x60;âœ… Updated ${filePath}: ${oldVersion} â†’ ${newVersion}&#x60;);
    return true;
  } catch (error) {
    console.error(&#x60;âŒ Failed to update ${filePath}:&#x60;, error.message);
    return false;
  }
}

function main() {
  const newVersion &#x3D; process.argv[2];

  if (!newVersion) {
    console.error(&amp;#39;âŒ Usage: node update-version.js &amp;lt;new-version&amp;gt;&amp;#39;);
    console.error(&amp;#39;   Example: node update-version.js 1.2.3&amp;#39;);
    process.exit(1);
  }

  // Validate semver format
  const semverRegex &#x3D; /^(\d+)\.(\d+)\.(\d+)(?:-([a-zA-Z0-9\-\.]+))?(?:\+([a-zA-Z0-9\-\.]+))?$/;
  if (!semverRegex.test(newVersion)) {
    console.error(&#x60;âŒ Invalid semver format: ${newVersion}&#x60;);
    console.error(&amp;#39;   Expected format: MAJOR.MINOR.PATCH[-prerelease][+buildmetadata]&amp;#39;);
    process.exit(1);
  }

  console.log(&#x60;ğŸ”„ Updating all packages to version ${newVersion}...&#x60;);

  const packageFiles &#x3D; [
    &amp;#39;./package.json&amp;#39;,
    &amp;#39;./packages/cli/package.json&amp;#39;,
    &amp;#39;./packages/shared/package.json&amp;#39;,
    &amp;#39;./apps/api/package.json&amp;#39;,
  ];

  // Check for additional package.json files
  const additionalPackages &#x3D; [];
  try {
    const { execSync } &#x3D; require(&amp;#39;node:child_process&amp;#39;);
    const findOutput &#x3D; execSync(
      &amp;#39;find apps/ packages/ -name package.json -not -path &amp;quot;*/node_modules/*&amp;quot;&amp;#39;,
      { encoding: &amp;#39;utf8&amp;#39; }
    );
    const foundPackages &#x3D; findOutput
      .trim()
      .split(&amp;#39;\n&amp;#39;)
      .filter(p &#x3D;&amp;gt; p &amp;amp;&amp;amp; !packageFiles.includes(p));
    additionalPackages.push(...foundPackages);
  } catch (e) {
    console.log(&amp;#39;â„¹ï¸  Could not search for additional packages&amp;#39;);
  }

  const allPackages &#x3D; [...packageFiles, ...additionalPackages];
  let successCount &#x3D; 0;
  let totalCount &#x3D; 0;

  for (const packageFile of allPackages) {
    totalCount++;
    if (updatePackageJson(packageFile, newVersion)) {
      successCount++;
    }
  }

  console.log(&amp;#39;\nğŸ“Š Summary:&amp;#39;);
  console.log(&#x60;   Updated: ${successCount}/${totalCount} packages&#x60;);

  if (successCount &#x3D;&#x3D;&#x3D; totalCount) {
    console.log(&amp;#39;âœ… All packages updated successfully!&amp;#39;);
    process.exit(0);
  } else {
    console.log(&amp;#39;âš ï¸  Some packages failed to update&amp;#39;);
    process.exit(1);
  }
}

main();
</pre>
                </div>
            </div>
            <div class="file-section" id="file-85">
                <div class="file-header">ğŸ“„ packages/shared/src/version.ts</div>
                <div class="file-content">
                    <pre>/**
 * Version compatibility and management types
 */

export interface VersionSet {
  arbiter: string;
  cue: string;
  node?: string;
  [key: string]: string | undefined;
}

export interface CompatibilityResult {
  compatible: boolean;
  issues: Array&amp;lt;{
    component: string;
    currentVersion: string;
    requiredVersion: string;
    severity: &amp;#39;error&amp;#39; | &amp;#39;warning&amp;#39; | &amp;#39;info&amp;#39;;
    message: string;
  }&amp;gt;;
  recommendations?: string[];
  version_mismatches?: Array&amp;lt;{
    component: string;
    expected: string;
    actual: string;
    [key: string]: any;
  }&amp;gt;;
  migration_required?: boolean;
  migration_path?: {
    fromVersion: string;
    toVersion: string;
    steps: string[];
  };
  timestamp?: string;
}

export const CURRENT_VERSIONS: VersionSet &#x3D; {
  arbiter: &amp;#39;1.0.0&amp;#39;,
  cue: &amp;#39;0.6.0&amp;#39;,
  node: &amp;#39;20.0.0&amp;#39;,
};

export async function checkCompatibility(
  _versions: Partial&amp;lt;VersionSet&amp;gt;,
  _allowCompat?: boolean
): Promise&amp;lt;CompatibilityResult&amp;gt; {
  // Stub implementation
  return {
    compatible: true,
    issues: [],
    version_mismatches: [],
    migration_required: false,
    timestamp: new Date().toISOString(),
  };
}

export async function executeMigration(
  _component: string,
  _fromVersion: string,
  _toVersion: string
): Promise&amp;lt;{
  success: boolean;
  operations_performed: string[];
  warnings: string[];
  timestamp: string;
}&amp;gt; {
  // Stub implementation
  return {
    success: true,
    operations_performed: [&#x60;Migration from ${_fromVersion} to ${_toVersion} for ${_component}&#x60;],
    warnings: [],
    timestamp: new Date().toISOString(),
  };
}

export function getRuntimeVersionInfo(): {
  versions: VersionSet;
  build_info: {
    timestamp: string;
    commit_hash?: string;
    deterministic: boolean;
    reproducible: boolean;
  };
  compatibility: {
    strict_mode: boolean;
    allow_compat_flag: boolean;
    migration_support: boolean;
  };
} {
  return {
    versions: {
      arbiter: CURRENT_VERSIONS.arbiter,
      cue: CURRENT_VERSIONS.cue,
      node: process.version,
    },
    build_info: {
      timestamp: new Date().toISOString(),
      commit_hash: undefined,
      deterministic: false,
      reproducible: false,
    },
    compatibility: {
      strict_mode: false,
      allow_compat_flag: true,
      migration_support: true,
    },
  };
}

export function validateVersionSet(versions: VersionSet): boolean {
  return versions.arbiter !&#x3D;&#x3D; undefined &amp;amp;&amp;amp; versions.cue !&#x3D;&#x3D; undefined;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-86">
                <div class="file-header">ğŸ“„ scripts/sync-versions.ts</div>
                <div class="file-content">
                    <pre>#!/usr/bin/env bun

/**
 * Version synchronization script for Arbiter monorepo
 * Ensures all packages have consistent version numbers
 */

import path from &amp;#39;node:path&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import { glob } from &amp;#39;glob&amp;#39;;

interface PackageJson {
  name: string;
  version: string;
  [key: string]: any;
}

async function syncVersions() {
  console.log(&amp;#39;ğŸ”„ Syncing versions across Arbiter monorepo...&amp;#39;);

  // Read root package.json for the canonical version
  const rootPackagePath &#x3D; path.resolve(&amp;#39;package.json&amp;#39;);
  const rootPackage: PackageJson &#x3D; await fs.readJson(rootPackagePath);
  const targetVersion &#x3D; rootPackage.version;

  console.log(&#x60;ğŸ“¦ Target version: ${targetVersion}&#x60;);

  // Find all package.json files in packages/* and apps/*
  const packagePaths &#x3D; await glob(&amp;#39;@(packages|apps)/*/package.json&amp;#39;, {
    cwd: process.cwd(),
  });

  let updatedCount &#x3D; 0;
  const errors: string[] &#x3D; [];

  for (const packagePath of packagePaths) {
    try {
      const fullPath &#x3D; path.resolve(packagePath);
      const packageJson: PackageJson &#x3D; await fs.readJson(fullPath);

      // Only update @arbiter/* packages
      if (packageJson.name?.startsWith(&amp;#39;@arbiter/&amp;#39;)) {
        if (packageJson.version !&#x3D;&#x3D; targetVersion) {
          console.log(
            &#x60;  âœï¸  Updating ${packageJson.name}: ${packageJson.version} â†’ ${targetVersion}&#x60;
          );

          packageJson.version &#x3D; targetVersion;
          await fs.writeJson(fullPath, packageJson, { spaces: 2 });
          updatedCount++;
        } else {
          console.log(&#x60;  âœ… ${packageJson.name}: already at ${targetVersion}&#x60;);
        }
      } else {
        console.log(&#x60;  â­ï¸  Skipping ${packageJson.name || packagePath}: not an @arbiter package&#x60;);
      }
    } catch (error) {
      const errorMsg &#x3D; &#x60;Failed to process ${packagePath}: ${error instanceof Error ? error.message : String(error)}&#x60;;
      errors.push(errorMsg);
      console.error(&#x60;  âŒ ${errorMsg}&#x60;);
    }
  }

  // Summary
  console.log(&amp;#39;\nğŸ“Š Summary:&amp;#39;);
  console.log(&#x60;  â€¢ Updated packages: ${updatedCount}&#x60;);
  console.log(&#x60;  â€¢ Errors: ${errors.length}&#x60;);

  if (errors.length &amp;gt; 0) {
    console.log(&amp;#39;\nâŒ Errors encountered:&amp;#39;);
    errors.forEach(error &#x3D;&amp;gt; console.log(&#x60;  â€¢ ${error}&#x60;));
    process.exit(1);
  }

  console.log(&amp;#39;\nğŸ‰ Version synchronization complete!&amp;#39;);
}

// Version validation function
export function validateVersionConsistency(): boolean {
  console.log(&amp;#39;ğŸ” Validating version consistency...&amp;#39;);

  try {
    const rootPackage: PackageJson &#x3D; JSON.parse(fs.readFileSync(&amp;#39;package.json&amp;#39;, &amp;#39;utf-8&amp;#39;));
    const targetVersion &#x3D; rootPackage.version;

    const packagePaths &#x3D; glob.sync(&amp;#39;@(packages|apps)/*/package.json&amp;#39;);
    let isConsistent &#x3D; true;

    for (const packagePath of packagePaths) {
      const packageJson: PackageJson &#x3D; JSON.parse(fs.readFileSync(packagePath, &amp;#39;utf-8&amp;#39;));

      if (packageJson.name?.startsWith(&amp;#39;@arbiter/&amp;#39;)) {
        if (packageJson.version !&#x3D;&#x3D; targetVersion) {
          console.log(
            &#x60;âŒ Version mismatch: ${packageJson.name} has ${packageJson.version}, expected ${targetVersion}&#x60;
          );
          isConsistent &#x3D; false;
        }
      }
    }

    if (isConsistent) {
      console.log(&#x60;âœ… All @arbiter packages are at version ${targetVersion}&#x60;);
    }

    return isConsistent;
  } catch (error) {
    console.error(
      &#x60;âŒ Validation failed: ${error instanceof Error ? error.message : String(error)}&#x60;
    );
    return false;
  }
}

// CLI interface
if (import.meta.main) {
  const command &#x3D; process.argv[2];

  switch (command) {
    case &amp;#39;sync&amp;#39;:
      await syncVersions();
      break;
    case &amp;#39;validate&amp;#39;: {
      const isValid &#x3D; validateVersionConsistency();
      process.exit(isValid ? 0 : 1);
      break;
    }
    default:
      console.log(&#x60;
Usage: bun scripts/sync-versions.ts &amp;lt;command&amp;gt;

Commands:
  sync      Sync all @arbiter package versions to match root package.json
  validate  Check if all @arbiter package versions are consistent

Examples:
  bun scripts/sync-versions.ts sync
  bun scripts/sync-versions.ts validate
&#x60;);
      process.exit(1);
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-87">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/design-system/index.ts</div>
                <div class="file-content">
                    <pre>/**
 * Design System - Graphite Theme
 * Professional minimal design system for developer tools
 */

export type { BreadcrumbItem, BreadcrumbsProps } from &amp;quot;./components/Breadcrumbs&amp;quot;;
export { breadcrumbIcons, default as Breadcrumbs } from &amp;quot;./components/Breadcrumbs&amp;quot;;
export type { ButtonProps } from &amp;quot;./components/Button&amp;quot;;
// Components
export { default as Button } from &amp;quot;./components/Button&amp;quot;;
export type { CardProps } from &amp;quot;./components/Card&amp;quot;;
export { default as Card } from &amp;quot;./components/Card&amp;quot;;
export type { CheckboxProps } from &amp;quot;./components/Checkbox&amp;quot;;
export { default as Checkbox } from &amp;quot;./components/Checkbox&amp;quot;;
export type {
  AlertDialogProps,
  ConfirmDialogProps,
  DialogAction,
  DialogProps,
  UseDialogReturn,
} from &amp;quot;./components/Dialog&amp;quot;;
export { AlertDialog, ConfirmDialog, default as Dialog, useDialog } from &amp;quot;./components/Dialog&amp;quot;;
export type { InputProps } from &amp;quot;./components/Input&amp;quot;;
export { default as Input } from &amp;quot;./components/Input&amp;quot;;
export type { ModalProps } from &amp;quot;./components/Modal&amp;quot;;
export { default as Modal } from &amp;quot;./components/Modal&amp;quot;;
export type { NavGroupProps, NavItemProps } from &amp;quot;./components/NavItem&amp;quot;;
export { default as NavItem, NavGroup } from &amp;quot;./components/NavItem&amp;quot;;
export type { RadioGroupProps, RadioOption, RadioProps } from &amp;quot;./components/Radio&amp;quot;;
export { default as Radio, RadioGroup } from &amp;quot;./components/Radio&amp;quot;;
export type { SelectOption, SelectProps } from &amp;quot;./components/Select&amp;quot;;
export { default as Select } from &amp;quot;./components/Select&amp;quot;;
export type { SidebarNavItem, SidebarProps } from &amp;quot;./components/Sidebar&amp;quot;;
export { default as Sidebar, sidebarIcons } from &amp;quot;./components/Sidebar&amp;quot;;
export type { StatusBadgeProps } from &amp;quot;./components/StatusBadge&amp;quot;;
export { default as StatusBadge } from &amp;quot;./components/StatusBadge&amp;quot;;
export type { TabItem, TabsProps } from &amp;quot;./components/Tabs&amp;quot;;
export { default as Tabs } from &amp;quot;./components/Tabs&amp;quot;;
export type { ToastContainerProps, ToastProps } from &amp;quot;./components/Toast&amp;quot;;
export { default as Toast, ToastContainer } from &amp;quot;./components/Toast&amp;quot;;
// Tokens and variants
export * from &amp;quot;./tokens&amp;quot;;
export * from &amp;quot;./variants&amp;quot;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-88">
                <div class="file-header">ğŸ“„ apps/web/frontend/playwright.config.ts</div>
                <div class="file-content">
                    <pre>import { defineConfig, devices } from &amp;quot;@playwright/test&amp;quot;;

/**
 * @see https://playwright.dev/docs/test-configuration
 */
export default defineConfig({
  testDir: &amp;quot;./tests&amp;quot;,
  /* Run tests in files in parallel */
  fullyParallel: true,
  /* Fail the build on CI if you accidentally left test.only in the source code. */
  forbidOnly: !!process.env.CI,
  /* Retry on CI only */
  retries: process.env.CI ? 2 : 0,
  /* Opt out of parallel tests on CI. */
  workers: process.env.CI ? 1 : undefined,
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: [[&amp;quot;html&amp;quot;], [&amp;quot;json&amp;quot;, { outputFile: &amp;quot;test-results/results.json&amp;quot; }], [&amp;quot;list&amp;quot;]],
  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Base URL to use in actions like &#x60;await page.goto(&amp;#39;/&amp;#39;)&#x60;. */
    baseURL: &amp;quot;http://localhost:6007&amp;quot;,
    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: &amp;quot;on-first-retry&amp;quot;,
    /* Take screenshot on failure */
    screenshot: &amp;quot;only-on-failure&amp;quot;,
    /* Record video on failure */
    video: &amp;quot;retain-on-failure&amp;quot;,
  },

  /* Configure projects for major browsers */
  projects: [
    {
      name: &amp;quot;chromium&amp;quot;,
      use: { ...devices[&amp;quot;Desktop Chrome&amp;quot;] },
    },

    {
      name: &amp;quot;firefox&amp;quot;,
      use: { ...devices[&amp;quot;Desktop Firefox&amp;quot;] },
    },

    {
      name: &amp;quot;webkit&amp;quot;,
      use: { ...devices[&amp;quot;Desktop Safari&amp;quot;] },
    },

    /* Test against mobile viewports. */
    {
      name: &amp;quot;Mobile Chrome&amp;quot;,
      use: { ...devices[&amp;quot;Pixel 5&amp;quot;] },
    },
    {
      name: &amp;quot;Mobile Safari&amp;quot;,
      use: { ...devices[&amp;quot;iPhone 12&amp;quot;] },
    },
  ],

  /* Run your local dev server before starting the tests */
  webServer: {
    command: &amp;quot;npm run storybook&amp;quot;,
    port: 6007,
    reuseExistingServer: !process.env.CI,
    timeout: 120000,
  },

  /* Global test timeout */
  timeout: 30000,
  expect: {
    timeout: 10000,
  },
});
</pre>
                </div>
            </div>
            <div class="file-section" id="file-89">
                <div class="file-header">ğŸ“„ apps/web/frontend/tailwind.config.js</div>
                <div class="file-content">
                    <pre>/** @type {import(&amp;#39;tailwindcss&amp;#39;).Config} */
export default {
  content: [&amp;quot;./index.html&amp;quot;, &amp;quot;./src/**/*.{js,ts,jsx,tsx}&amp;quot;, &amp;quot;./.storybook/**/*.{js,ts,jsx,tsx}&amp;quot;],
  theme: {
    extend: {
      fontFamily: {
        mono: [&amp;quot;Fira Code&amp;quot;, &amp;quot;Consolas&amp;quot;, &amp;quot;Monaco&amp;quot;, &amp;quot;Courier New&amp;quot;, &amp;quot;monospace&amp;quot;],
        sans: [
          &amp;quot;ui-sans-serif&amp;quot;,
          &amp;quot;system-ui&amp;quot;,
          &amp;quot;-apple-system&amp;quot;,
          &amp;quot;BlinkMacSystemFont&amp;quot;,
          &amp;quot;Segoe UI&amp;quot;,
          &amp;quot;Roboto&amp;quot;,
          &amp;quot;Helvetica Neue&amp;quot;,
          &amp;quot;Arial&amp;quot;,
          &amp;quot;sans-serif&amp;quot;,
        ],
      },
      colors: {
        // Graphite scale - Primary brand colors
        graphite: {
          50: &amp;quot;#f8fafc&amp;quot;,
          100: &amp;quot;#f1f5f9&amp;quot;,
          200: &amp;quot;#e2e8f0&amp;quot;,
          300: &amp;quot;#cbd5e1&amp;quot;,
          400: &amp;quot;#94a3b8&amp;quot;,
          500: &amp;quot;#64748b&amp;quot;,
          600: &amp;quot;#475569&amp;quot;,
          700: &amp;quot;#334155&amp;quot;,
          800: &amp;quot;#1e293b&amp;quot;,
          900: &amp;quot;#0f172a&amp;quot;,
        },
        // Custom colors for diagrams and editor
        editor: {
          bg: &amp;quot;#fafafa&amp;quot;,
          line: &amp;quot;#f5f5f5&amp;quot;,
        },
      },
      zIndex: {
        dropdown: &amp;quot;1000&amp;quot;,
        sticky: &amp;quot;1020&amp;quot;,
        fixed: &amp;quot;1030&amp;quot;,
        modal: &amp;quot;1040&amp;quot;,
        popover: &amp;quot;1050&amp;quot;,
        tooltip: &amp;quot;1060&amp;quot;,
        toast: &amp;quot;1070&amp;quot;,
      },
      animation: {
        &amp;quot;spin-slow&amp;quot;: &amp;quot;spin 3s linear infinite&amp;quot;,
        // Storybook-compatible animations
        in: &amp;quot;enter 200ms ease-out&amp;quot;,
        out: &amp;quot;exit 150ms ease-in forwards&amp;quot;,
      },
      keyframes: {
        enter: {
          from: { opacity: &amp;quot;0&amp;quot;, transform: &amp;quot;scale(0.95)&amp;quot; },
          to: { opacity: &amp;quot;1&amp;quot;, transform: &amp;quot;scale(1)&amp;quot; },
        },
        exit: {
          from: { opacity: &amp;quot;1&amp;quot;, transform: &amp;quot;scale(1)&amp;quot; },
          to: { opacity: &amp;quot;0&amp;quot;, transform: &amp;quot;scale(0.95)&amp;quot; },
        },
      },
    },
  },
  plugins: [],
};
</pre>
                </div>
            </div>
            <div class="file-section" id="file-90">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/rename.ts</div>
                <div class="file-content">
                    <pre>/**
 * Rename command - Migrate existing files to smart naming
 *
 * Helps users transition from generic file names (arbiter.assembly.cue, surface.json)
 * to project-specific names (myproject.assembly.cue, myproject-surface.json)
 */

import fs from &amp;#39;node:fs&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import type { CLIConfig } from &amp;#39;../types.js&amp;#39;;
import {
  FILE_PATTERNS,
  type FileType,
  detectNamingPreferences,
  migrateExistingFiles,
  resolveSmartNaming,
} from &amp;#39;../utils/smart-naming.js&amp;#39;;

export interface RenameOptions {
  /** Show what would be renamed without doing it */
  dryRun?: boolean;
  /** Apply the renaming changes */
  apply?: boolean;
  /** Force overwrite existing files */
  force?: boolean;
  /** Show verbose output */
  verbose?: boolean;
  /** Specific file types to rename */
  types?: string[];
}

/**
 * Rename command implementation
 */
export async function renameCommand(options: RenameOptions, _config: CLIConfig): Promise&amp;lt;number&amp;gt; {
  try {
    console.log(chalk.blue(&amp;#39;ğŸ”„ Analyzing files for smart naming migration...&amp;#39;));

    // Detect current naming preferences
    const preferences &#x3D; await detectNamingPreferences();

    if (preferences.usesProjectNames) {
      console.log(chalk.green(&amp;#39;âœ… Project already uses project-specific naming&amp;#39;));
      console.log(chalk.dim(&amp;#39;Current naming patterns:&amp;#39;));
      for (const pattern of preferences.existingPatterns) {
        console.log(chalk.dim(&#x60;  ${pattern.type}: ${pattern.filename}&#x60;));
      }

      if (!options.force) {
        console.log(
          chalk.dim(&amp;#39;\nUse --force to rename anyway, or --dry-run to see what would happen&amp;#39;)
        );
        return 0;
      }
    }

    // Show current vs. proposed naming
    console.log(chalk.cyan(&amp;#39;\nFile naming analysis:&amp;#39;));

    const fileTypes &#x3D; options.types
      ? (options.types.filter(type &#x3D;&amp;gt; type in FILE_PATTERNS) as FileType[])
      : (Object.keys(FILE_PATTERNS) as FileType[]);

    let hasChanges &#x3D; false;
    const proposedChanges: Array&amp;lt;{ from: string; to: string; type: FileType }&amp;gt; &#x3D; [];

    for (const fileType of fileTypes) {
      const currentDefault &#x3D; FILE_PATTERNS[fileType].default;
      const smartNaming &#x3D; await resolveSmartNaming(fileType, { useGenericNames: false });

      if (currentDefault !&#x3D;&#x3D; smartNaming.filename) {
        hasChanges &#x3D; true;
        proposedChanges.push({
          from: currentDefault,
          to: smartNaming.filename,
          type: fileType,
        });

        const exists &#x3D; fs.existsSync(currentDefault);
        const status &#x3D; exists ? chalk.yellow(&amp;#39;EXISTS&amp;#39;) : chalk.gray(&amp;#39;N/A&amp;#39;);

        console.log(chalk.dim(&#x60;  ${fileType}:&#x60;));
        console.log(chalk.dim(&#x60;    Current:  ${currentDefault} ${status}&#x60;));
        console.log(chalk.dim(&#x60;    Proposed: ${smartNaming.filename}&#x60;));

        if (smartNaming.context.name &amp;amp;&amp;amp; options.verbose) {
          console.log(chalk.dim(&#x60;    Project:  ${smartNaming.context.name}&#x60;));
        }
      }
    }

    if (!hasChanges) {
      console.log(chalk.green(&amp;#39;âœ… No naming changes needed&amp;#39;));
      return 0;
    }

    // Perform migration
    const migrations &#x3D; await migrateExistingFiles(process.cwd(), options.dryRun || !options.apply);

    if (options.dryRun || !options.apply) {
      console.log(chalk.yellow(&amp;#39;\nğŸ” Dry run - files that would be renamed:&amp;#39;));
      for (const migration of migrations) {
        console.log(chalk.dim(&#x60;  ${migration.from} â†’ ${migration.to}&#x60;));
      }

      if (!options.dryRun) {
        console.log(chalk.dim(&amp;#39;\nUse --apply to execute the renaming&amp;#39;));
      }
    } else {
      console.log(chalk.green(&amp;#39;\nâœ… Migration complete:&amp;#39;));
      let renamedCount &#x3D; 0;

      for (const migration of migrations) {
        if (migration.migrated) {
          console.log(chalk.green(&#x60;  âœ“ ${migration.from} â†’ ${migration.to}&#x60;));
          renamedCount++;
        } else {
          console.log(chalk.yellow(&#x60;  âš  ${migration.from} (not migrated - file may not exist)&#x60;));
        }
      }

      console.log(chalk.green(&#x60;\nRenamed ${renamedCount} files to use project-specific naming&#x60;));
    }

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;âŒ Rename command failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

/**
 * Show naming help and examples
 */
export function showNamingHelp(): void {
  console.log(chalk.cyan(&amp;#39;Smart Naming Examples:&amp;#39;));
  console.log(chalk.dim(&amp;#39;&amp;#39;));
  console.log(chalk.dim(&amp;#39;Generic naming (old):&amp;#39;));
  console.log(chalk.dim(&amp;#39;  arbiter.assembly.cue&amp;#39;));
  console.log(chalk.dim(&amp;#39;  surface.json&amp;#39;));
  console.log(chalk.dim(&amp;#39;  version_plan.json&amp;#39;));
  console.log(chalk.dim(&amp;#39;&amp;#39;));
  console.log(chalk.dim(&amp;#39;Project-specific naming (new):&amp;#39;));
  console.log(chalk.dim(&amp;#39;  myproject.assembly.cue&amp;#39;));
  console.log(chalk.dim(&amp;#39;  myproject-surface.json&amp;#39;));
  console.log(chalk.dim(&amp;#39;  myproject-version-plan.json&amp;#39;));
  console.log(chalk.dim(&amp;#39;&amp;#39;));
  console.log(chalk.cyan(&amp;#39;Project name detection:&amp;#39;));
  console.log(chalk.dim(&amp;quot;  1. package.json &amp;#39;name&amp;#39; field&amp;quot;));
  console.log(chalk.dim(&amp;quot;  2. Assembly file &amp;#39;name&amp;#39; field&amp;quot;));
  console.log(chalk.dim(&amp;#39;  3. Directory name&amp;#39;));
  console.log(chalk.dim(&amp;#39;  4. Manual override with --project-name&amp;#39;));
  console.log(chalk.dim(&amp;#39;&amp;#39;));
  console.log(chalk.cyan(&amp;#39;Backward compatibility:&amp;#39;));
  console.log(chalk.dim(&amp;#39;  Use --generic-names flag to keep old naming&amp;#39;));
  console.log(chalk.dim(&amp;#39;  Existing tools will find files automatically&amp;#39;));
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-91">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/diagrams/CueShowcase.stories.tsx</div>
                <div class="file-content">
                    <pre>import type { Meta, StoryObj } from &amp;#39;@storybook/react&amp;#39;;
import { CueShowcase } from &amp;#39;./CueShowcase&amp;#39;;

const meta: Meta&amp;lt;typeof CueShowcase&amp;gt; &#x3D; {
  title: &amp;#39;Components/CUE Visualization/CueShowcase&amp;#39;,
  component: CueShowcase,
  parameters: {
    layout: &amp;#39;fullscreen&amp;#39;,
    docs: {
      description: {
        component: &#x60;
# CUE Showcase

The CueShowcase component provides a comprehensive demonstration of CUE file visualization capabilities in the Arbiter frontend.

## Features

- **Multiple CUE Examples**: Requirements, assembly specs, validation errors, TypeScript projects, and Rust services
- **Interactive Visualization**: Switch between overview, source code, resolved data, and split views
- **Syntax Highlighting**: Full CUE syntax highlighting with Monaco Editor
- **Validation Display**: Visual indication of validation errors, warnings, and info messages
- **Metadata Analysis**: Automatic extraction of package info, imports, definitions, and line counts
- **Resolved Data**: Side-by-side comparison of CUE source and resolved JSON output

## Use Cases

1. **Requirements Engineering**: Visualize security, performance, and compliance requirements
2. **System Assembly**: Review microservices architecture and deployment specifications
3. **Validation &amp;amp; Debugging**: Identify and fix CUE validation errors with detailed error messages
4. **Project Documentation**: Present complex project specifications in an interactive format
5. **Service Configuration**: Display high-performance service configurations with metadata

## Technical Integration

The showcase integrates with:
- Monaco Editor for syntax highlighting and editing
- Design system components for consistent UI
- Validation engine for error detection
- Resolution engine for CUE evaluation

This component serves as both a demonstration tool and a production-ready interface for CUE file management in the Arbiter platform.
        &#x60;,
      },
    },
  },
  tags: [&amp;#39;autodocs&amp;#39;],
};

export default meta;
type Story &#x3D; StoryObj&amp;lt;typeof CueShowcase&amp;gt;;

/**
 * Default showcase with all CUE examples available.
 * Users can navigate between different types of CUE files and view modes.
 */
export const Default: Story &#x3D; {
  args: {},
};

/**
 * Full-screen showcase for presentations and detailed review.
 * Optimized for larger displays and comprehensive examination of CUE files.
 */
export const FullScreen: Story &#x3D; {
  args: {},
  parameters: {
    layout: &amp;#39;fullscreen&amp;#39;,
    viewport: {
      viewports: {
        fullHD: {
          name: &amp;#39;Full HD&amp;#39;,
          styles: {
            width: &amp;#39;1920px&amp;#39;,
            height: &amp;#39;1080px&amp;#39;,
          },
        },
      },
      defaultViewport: &amp;#39;fullHD&amp;#39;,
    },
  },
};

/**
 * Compact version suitable for dashboard integration or smaller containers.
 */
export const Compact: Story &#x3D; {
  args: {
    className: &amp;#39;max-w-4xl mx-auto&amp;#39;,
  },
  parameters: {
    viewport: {
      viewports: {
        tablet: {
          name: &amp;#39;Tablet&amp;#39;,
          styles: {
            width: &amp;#39;768px&amp;#39;,
            height: &amp;#39;1024px&amp;#39;,
          },
        },
      },
      defaultViewport: &amp;#39;tablet&amp;#39;,
    },
  },
};
</pre>
                </div>
            </div>
            <div class="file-section" id="file-92">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/diagrams/index.ts</div>
                <div class="file-content">
                    <pre>// Core Data Visualization
export { DataViewer } from &amp;#39;./DataViewer&amp;#39;;
export { default as ResolvedViewer } from &amp;#39;./ResolvedViewer&amp;#39;;

// CUE Visualization Components
export { CueViewer } from &amp;#39;./CueViewer&amp;#39;;
export { CueShowcase } from &amp;#39;./CueShowcase&amp;#39;;
export { default as PrettyCueDiagram } from &amp;#39;./PrettyCueDiagram&amp;#39;;

// Diagram Components
export { default as FlowDiagram } from &amp;#39;./FlowDiagram&amp;#39;;
export { default as FriendlyDiagram } from &amp;#39;./FriendlyDiagram&amp;#39;;
export { default as SourceDiagram } from &amp;#39;./SourceDiagram&amp;#39;;
export { default as FsmDiagram } from &amp;#39;./FsmDiagram&amp;#39;;
export { default as GapsChecklist } from &amp;#39;./GapsChecklist&amp;#39;;
export { MermaidRenderer } from &amp;#39;./MermaidRenderer&amp;#39;;
export { NetworkDiagram } from &amp;#39;./NetworkDiagram&amp;#39;;
export { default as SiteDiagram } from &amp;#39;./SiteDiagram&amp;#39;;
export { default as ViewDiagram } from &amp;#39;./ViewDiagram&amp;#39;;

// Split View Components
export { SplitViewShowcase } from &amp;#39;./SplitViewShowcase&amp;#39;;

// System Architecture
export { default as ArchitectureDiagram } from &amp;#39;./ArchitectureDiagram&amp;#39;;
export {
  CueDrivenArchitectureDiagram,
  default as CueDrivenArchitectureDiagramDefault,
} from &amp;#39;./CueDrivenArchitectureDiagram&amp;#39;;
export {
  CueDrivenArchitectureIntegration,
  default as CueDrivenArchitectureIntegrationDefault,
} from &amp;#39;./CueDrivenArchitectureIntegration&amp;#39;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-93">
                <div class="file-header">ğŸ“„ docs/webhooks.md</div>
                <div class="file-content">
                    <pre># Arbiter Webhooks

Arbiter now supports GitLab and GitHub webhooks for automatic spec
synchronization and validation when repository events occur.

## ğŸš€ Quick Start

### 1. Enable Webhooks

Set environment variables for your Arbiter server:

&#x60;&#x60;&#x60;bash
export WEBHOOKS_ENABLED&#x3D;true
export WEBHOOK_SECRET&#x3D;your-secure-secret-key
export GITHUB_WEBHOOK_SECRET&#x3D;github-specific-secret  # Optional: provider-specific
export GITLAB_WEBHOOK_SECRET&#x3D;gitlab-specific-secret  # Optional: provider-specific
&#x60;&#x60;&#x60;

### 2. Start Secure Cloudflare Tunnel (for local development)

&#x60;&#x60;&#x60;bash
# Install cloudflared if not already installed
# macOS: brew install cloudflare/cloudflare/cloudflared
# Linux: Download from https://github.com/cloudflare/cloudflared/releases

# Login to Cloudflare (one-time setup)
cloudflared tunnel login

# Start secure tunnel (webhook-only mode - RECOMMENDED)
TUNNEL_MODE&#x3D;webhook-only ./scripts/cloudflare-tunnel.sh start

# Alternative: Full API access (LESS SECURE)
TUNNEL_MODE&#x3D;full-api ./scripts/cloudflare-tunnel.sh start
&#x60;&#x60;&#x60;

**ğŸ”’ Security Modes:**

- **&#x60;webhook-only&#x60; (Default &amp;amp; Recommended)**: Only webhook endpoints exposed
  - âœ… IP filtering for GitHub/GitLab sources only
  - âœ… Path-based access control (only &#x60;/webhooks/*&#x60; and &#x60;/health&#x60;)
  - âœ… Reverse proxy with security filtering
- **&#x60;full-api&#x60; (Less Secure)**: All API endpoints exposed
  - âš ï¸ Exposes entire Arbiter API to internet
  - âš ï¸ Use only for development/testing

The secure tunnel will output your protected webhook URLs:

- GitHub: &#x60;https://your-tunnel.cfargotunnel.com/webhooks/github&#x60;
- GitLab: &#x60;https://your-tunnel.cfargotunnel.com/webhooks/gitlab&#x60;

### 3. Configure Repository Webhooks

#### GitHub

1. Go to your repository â†’ Settings â†’ Webhooks
2. Click &amp;quot;Add webhook&amp;quot;
3. Set Payload URL to: &#x60;https://your-tunnel.cfargotunnel.com/webhooks/github&#x60;
4. Set Content type to: &#x60;application/json&#x60;
5. Set Secret to your &#x60;WEBHOOK_SECRET&#x60; or &#x60;GITHUB_WEBHOOK_SECRET&#x60;
6. Select events: &#x60;push&#x60;, &#x60;pull requests&#x60;
7. Click &amp;quot;Add webhook&amp;quot;

#### GitLab

1. Go to your project â†’ Settings â†’ Webhooks
2. Set URL to: &#x60;https://your-tunnel.cfargotunnel.com/webhooks/gitlab&#x60;
3. Set Secret Token to your &#x60;WEBHOOK_SECRET&#x60; or &#x60;GITLAB_WEBHOOK_SECRET&#x60;
4. Select triggers: &#x60;Push events&#x60;, &#x60;Merge request events&#x60;
5. Click &amp;quot;Add webhook&amp;quot;

## ğŸ› ï¸ Configuration

### Environment Variables

| Variable                    | Description                                  | Default   |
| --------------------------- | -------------------------------------------- | --------- |
| &#x60;WEBHOOKS_ENABLED&#x60;          | Enable/disable webhook processing            | &#x60;false&#x60;   |
| &#x60;WEBHOOK_SECRET&#x60;            | Universal webhook secret                     | -         |
| &#x60;GITHUB_WEBHOOK_SECRET&#x60;     | GitHub-specific secret (overrides universal) | -         |
| &#x60;GITLAB_WEBHOOK_SECRET&#x60;     | GitLab-specific secret (overrides universal) | -         |
| &#x60;WEBHOOK_ALLOWED_REPOS&#x60;     | Comma-separated list of allowed repo names   | All repos |
| &#x60;WEBHOOK_SYNC_ON_PUSH&#x60;      | Auto-sync specs on push events               | &#x60;true&#x60;    |
| &#x60;WEBHOOK_VALIDATE_ON_MERGE&#x60; | Auto-validate on merge/PR close              | &#x60;true&#x60;    |

### Project Configuration

Use the Arbiter CLI to configure webhooks per project:

&#x60;&#x60;&#x60;bash
# List webhook status
arbiter webhook list

# Configure webhook for a project
arbiter webhook set my-project \
  --provider github \
  --repository https://github.com/user/repo.git \
  --events push,pull_request \
  --secret your-secret

# Get webhook configuration
arbiter webhook get my-project

# Delete webhook configuration
arbiter webhook delete my-project --force
&#x60;&#x60;&#x60;

## ğŸ§ª Testing

### Test Webhook Endpoints

&#x60;&#x60;&#x60;bash
# Test GitHub webhook
arbiter webhook test github --secret your-secret

# Test GitLab webhook
arbiter webhook test gitlab --secret your-secret

# Run comprehensive test suite
./scripts/test-webhooks.sh all
&#x60;&#x60;&#x60;

### Manual Testing with curl

&#x60;&#x60;&#x60;bash
# Test GitHub push webhook
curl -X POST http://localhost:5050/webhooks/github \
  -H &amp;quot;Content-Type: application/json&amp;quot; \
  -H &amp;quot;X-GitHub-Event: push&amp;quot; \
  -H &amp;quot;X-Hub-Signature-256: sha256&#x3D;your-signature&amp;quot; \
  -d @test-github-payload.json

# Test GitLab push webhook
curl -X POST http://localhost:5050/webhooks/gitlab \
  -H &amp;quot;Content-Type: application/json&amp;quot; \
  -H &amp;quot;X-Gitlab-Event: Push Hook&amp;quot; \
  -H &amp;quot;X-Gitlab-Token: your-secret&amp;quot; \
  -d @test-gitlab-payload.json
&#x60;&#x60;&#x60;

## ğŸ”’ Security

### Multi-Layer Security Architecture

Arbiter implements comprehensive webhook security through multiple layers:

#### 1. **Tunnel-Level Security (Recommended)**

**Webhook-Only Mode (Default)**:

- **Path Filtering**: Only &#x60;/webhooks/*&#x60; and &#x60;/health&#x60; endpoints exposed
- **IP Whitelisting**: Restricts access to GitHub/GitLab IP ranges only
- **Reverse Proxy**: Built-in filtering proxy validates all requests
- **Zero Trust**: No other API endpoints accessible from internet

&#x60;&#x60;&#x60;bash
# Secure mode (default)
TUNNEL_MODE&#x3D;webhook-only ./scripts/cloudflare-tunnel.sh start
&#x60;&#x60;&#x60;

**GitHub/GitLab IP Ranges Supported**:

- GitHub: &#x60;140.82.112.0/20&#x60;, &#x60;142.250.0.0/15&#x60;, &#x60;143.55.64.0/20&#x60;,
  &#x60;192.30.252.0/22&#x60;, &#x60;185.199.108.0/22&#x60;
- GitLab: &#x60;34.74.90.64/28&#x60;, &#x60;34.74.226.0/24&#x60;, &#x60;35.231.147.226/32&#x60;,
  &#x60;35.243.134.0/24&#x60;

#### 2. **Application-Level Security**

**Signature Verification**:

- **GitHub**: Uses HMAC SHA-256 with &#x60;X-Hub-Signature-256&#x60; header
- **GitLab**: Uses HMAC SHA-256 with &#x60;X-Gitlab-Token&#x60; header
- **Cryptographic Validation**: All webhook payloads cryptographically verified

**Repository Filtering**:

Restrict webhooks to specific repositories using &#x60;WEBHOOK_ALLOWED_REPOS&#x60;:

&#x60;&#x60;&#x60;bash
export WEBHOOK_ALLOWED_REPOS&#x3D;&amp;quot;user/repo1,org/repo2,company/project&amp;quot;
&#x60;&#x60;&#x60;

#### 3. **Security Best Practices**

**Production Deployment**:

1. **Use webhook-only mode**: &#x60;TUNNEL_MODE&#x3D;webhook-only&#x60; (default and
   recommended)
2. **Strong secrets**: Generate cryptographically secure webhook secrets (32+
   chars)
3. **HTTPS only**: Always use HTTPS for webhook URLs in production
4. **Repository filtering**: Use &#x60;WEBHOOK_ALLOWED_REPOS&#x60; to restrict access
5. **Monitor logs**: Review webhook processing and proxy logs regularly
6. **Rotate secrets**: Periodically update webhook secrets and tunnel
   credentials

**Development Recommendations**:

&#x60;&#x60;&#x60;bash
# Generate secure webhook secret
openssl rand -hex 32

# Start with maximum security
TUNNEL_MODE&#x3D;webhook-only TUNNEL_NAME&#x3D;my-project ./scripts/cloudflare-tunnel.sh start

# Monitor security logs
./scripts/cloudflare-tunnel.sh logs  # Tunnel logs
tail -f /tmp/webhook-proxy.log       # Proxy security logs
&#x60;&#x60;&#x60;

**Security Validation**:

- âœ… Webhook endpoints accessible:
  &#x60;curl https://your-tunnel.example.com/webhooks/github&#x60;
- âœ… API endpoints blocked: &#x60;curl https://your-tunnel.example.com/api/projects&#x60;
  (should return 404)
- âœ… Non-webhook paths blocked: &#x60;curl https://your-tunnel.example.com/&#x60; (should
  return 404)
- âœ… Health endpoint accessible: &#x60;curl https://your-tunnel.example.com/health&#x60;

## ğŸ“¡ API Endpoints

### Webhook Endpoints

| Endpoint           | Method | Description             |
| ------------------ | ------ | ----------------------- |
| &#x60;/webhooks/github&#x60; | POST   | GitHub webhook receiver |
| &#x60;/webhooks/gitlab&#x60; | POST   | GitLab webhook receiver |

### Management API

| Endpoint                   | Method | Description                  |
| -------------------------- | ------ | ---------------------------- |
| &#x60;/api/webhooks&#x60;            | GET    | List webhook status          |
| &#x60;/api/webhooks&#x60;            | POST   | Create/update webhook config |
| &#x60;/api/webhooks/:projectId&#x60; | GET    | Get project webhook config   |
| &#x60;/api/webhooks/:projectId&#x60; | DELETE | Delete webhook config        |

## ğŸ”„ Event Processing

### Supported Events

#### GitHub

- **push**: Code pushed to repository
- **pull_request**: Pull request opened/closed/merged

#### GitLab

- **Push Hook**: Code pushed to repository
- **Merge Request Hook**: Merge request opened/closed/merged

### Event Actions

When webhooks are received, Arbiter can:

1. **Sync specifications**: Pull latest spec changes from repository
2. **Validate specs**: Run CUE validation on updated specifications
3. **Broadcast events**: Notify connected WebSocket clients
4. **Log activity**: Record webhook events for auditing

Configure actions via environment variables:

- &#x60;WEBHOOK_SYNC_ON_PUSH&#x3D;true&#x60; - Sync specs on push events
- &#x60;WEBHOOK_VALIDATE_ON_MERGE&#x3D;true&#x60; - Validate specs on merge events

## ğŸ› ï¸ Troubleshooting

### Common Issues

#### Webhook not receiving events

1. Check if tunnel is running: &#x60;./scripts/cloudflare-tunnel.sh status&#x60;
2. Verify webhook URL in repository settings
3. Check server logs: &#x60;./scripts/cloudflare-tunnel.sh logs&#x60;
4. Test webhook endpoint: &#x60;arbiter webhook test github&#x60;

#### Signature verification failed

1. Verify webhook secret matches between Arbiter and repository
2. Check environment variables: &#x60;WEBHOOK_SECRET&#x60;, &#x60;GITHUB_WEBHOOK_SECRET&#x60;,
   &#x60;GITLAB_WEBHOOK_SECRET&#x60;
3. Test with known payload: &#x60;./scripts/test-webhooks.sh security&#x60;

#### Server not processing webhooks

1. Ensure &#x60;WEBHOOKS_ENABLED&#x3D;true&#x60;
2. Check server logs for errors
3. Verify Arbiter server is running: &#x60;arbiter health&#x60;
4. Test API endpoints: &#x60;./scripts/test-webhooks.sh api&#x60;

### Debug Mode

Enable verbose logging:

&#x60;&#x60;&#x60;bash
export DEBUG&#x3D;arbiter:webhooks
bun run dev
&#x60;&#x60;&#x60;

### Log Files

- **Cloudflare tunnel logs**: &#x60;/tmp/cloudflare-tunnel.log&#x60;
- **Arbiter server logs**: stdout when running &#x60;bun run dev&#x60;
- **Test results**: Check exit codes from test scripts

## ğŸ“š CLI Commands Reference

&#x60;&#x60;&#x60;bash
# Webhook management
arbiter webhook list                          # List webhook status
arbiter webhook help                          # Show setup guide
arbiter webhook get &amp;lt;project-id&amp;gt;              # Get project webhook config
arbiter webhook set &amp;lt;project-id&amp;gt; [options]   # Set webhook configuration
arbiter webhook delete &amp;lt;project-id&amp;gt; --force  # Delete webhook config
arbiter webhook test &amp;lt;provider&amp;gt; [options]    # Test webhook endpoint

# Cloudflare tunnel management
./scripts/cloudflare-tunnel.sh start         # Start tunnel
./scripts/cloudflare-tunnel.sh stop          # Stop tunnel
./scripts/cloudflare-tunnel.sh status        # Check tunnel status
./scripts/cloudflare-tunnel.sh logs          # View tunnel logs
./scripts/cloudflare-tunnel.sh delete        # Delete tunnel

# Testing
./scripts/test-webhooks.sh all              # Run all tests
./scripts/test-webhooks.sh github           # Test GitHub webhooks
./scripts/test-webhooks.sh gitlab           # Test GitLab webhooks
./scripts/test-webhooks.sh api              # Test webhook API
./scripts/test-webhooks.sh security         # Test security features
&#x60;&#x60;&#x60;

## ğŸš€ Production Deployment

### Docker Configuration

Add webhook environment variables to your Docker setup:

&#x60;&#x60;&#x60;dockerfile
ENV WEBHOOKS_ENABLED&#x3D;true
ENV WEBHOOK_SECRET&#x3D;your-production-secret
ENV GITHUB_WEBHOOK_SECRET&#x3D;github-prod-secret
ENV GITLAB_WEBHOOK_SECRET&#x3D;gitlab-prod-secret
&#x60;&#x60;&#x60;

### Load Balancer Configuration

Ensure webhook endpoints are accessible:

- Route &#x60;/webhooks/*&#x60; to Arbiter instances
- Preserve original headers for signature verification
- Use sticky sessions if needed for WebSocket connections

### Monitoring

Monitor webhook processing:

- Track webhook event counts
- Monitor signature verification failures
- Alert on processing errors
- Log webhook response times

### High Availability

For production deployments:

- Use multiple Arbiter instances behind a load balancer
- Store webhook configurations in shared database
- Implement webhook event deduplication
- Set up monitoring and alerting

## ğŸ”— Related Documentation

- [Arbiter API Documentation](./api.md)
- [Project Configuration](./configuration.md)
- [Development Setup](./development.md)
- [Cloudflare Tunnel Documentation](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/)

## ğŸ’¡ Tips &amp;amp; Tricks

### Development Workflow

1. Start Arbiter server: &#x60;bun run dev&#x60;
2. Start Cloudflare tunnel: &#x60;./scripts/cloudflare-tunnel.sh start&#x60;
3. Configure repository webhooks with tunnel URL
4. Test with: &#x60;arbiter webhook test github&#x60;
5. Monitor logs: &#x60;./scripts/cloudflare-tunnel.sh logs&#x60;

### Multiple Projects

Use different webhook secrets per project for better security:

&#x60;&#x60;&#x60;bash
arbiter webhook set project1 --secret secret1 --provider github
arbiter webhook set project2 --secret secret2 --provider gitlab
&#x60;&#x60;&#x60;

### Staging Environment

Use different tunnel names for different environments:

&#x60;&#x60;&#x60;bash
TUNNEL_NAME&#x3D;arbiter-staging ./scripts/cloudflare-tunnel.sh start
&#x60;&#x60;&#x60;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-94">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/design-system/components/Button.tsx</div>
                <div class="file-content">
                    <pre>/**
 * Button Component - Design System
 * Professional button with comprehensive variants and states
 */

import React, { forwardRef, type ButtonHTMLAttributes, type ReactNode } from &amp;#39;react&amp;#39;;
import { clsx } from &amp;#39;clsx&amp;#39;;
import { buttonVariants, sizeVariants, cn } from &amp;#39;../variants&amp;#39;;

export interface ButtonProps extends Omit&amp;lt;ButtonHTMLAttributes&amp;lt;HTMLButtonElement&amp;gt;, &amp;#39;size&amp;#39;&amp;gt; {
  /** Button variant determines the visual style */
  variant?: &amp;#39;primary&amp;#39; | &amp;#39;secondary&amp;#39; | &amp;#39;ghost&amp;#39; | &amp;#39;danger&amp;#39;;

  /** Button size affects padding and font size */
  size?: &amp;#39;xs&amp;#39; | &amp;#39;sm&amp;#39; | &amp;#39;md&amp;#39; | &amp;#39;lg&amp;#39; | &amp;#39;xl&amp;#39;;

  /** Whether the button should take full width of container */
  fullWidth?: boolean;

  /** Icon to display before the text */
  leftIcon?: ReactNode;

  /** Icon to display after the text */
  rightIcon?: ReactNode;

  /** Whether the button is in a loading state */
  loading?: boolean;

  /** Custom className for additional styling */
  className?: string;

  /** Button content */
  children?: ReactNode;
}

export const Button &#x3D; forwardRef&amp;lt;HTMLButtonElement, ButtonProps&amp;gt;(
  (
    {
      variant &#x3D; &amp;#39;primary&amp;#39;,
      size &#x3D; &amp;#39;md&amp;#39;,
      fullWidth &#x3D; false,
      leftIcon,
      rightIcon,
      loading &#x3D; false,
      disabled,
      className,
      children,
      ...props
    },
    ref
  ) &#x3D;&amp;gt; {
    const buttonClasses &#x3D; cn(
      // Base styles
      &amp;#39;inline-flex items-center justify-center gap-2&amp;#39;,
      &amp;#39;font-medium text-sm&amp;#39;,
      &amp;#39;border rounded-md&amp;#39;,
      &amp;#39;transition-all duration-150 ease-in-out&amp;#39;,
      &amp;#39;focus:outline-none focus:ring-2 focus:ring-offset-2&amp;#39;,
      &amp;#39;disabled:pointer-events-none disabled:opacity-60&amp;#39;,

      // Variant styles
      buttonVariants[variant],

      // Size styles
      sizeVariants.button[size],

      // Full width
      fullWidth &amp;amp;&amp;amp; &amp;#39;w-full&amp;#39;,

      // Loading state
      loading &amp;amp;&amp;amp; &amp;#39;relative text-transparent&amp;#39;,

      // Custom className
      className
    );

    return (
      &amp;lt;button ref&#x3D;{ref} className&#x3D;{buttonClasses} disabled&#x3D;{disabled || loading} {...props}&amp;gt;
        {/* Loading spinner */}
        {loading &amp;amp;&amp;amp; (
          &amp;lt;div className&#x3D;&amp;quot;absolute inset-0 flex items-center justify-center&amp;quot;&amp;gt;
            &amp;lt;div className&#x3D;&amp;quot;h-4 w-4 animate-spin rounded-full border-2 border-current border-t-transparent&amp;quot; /&amp;gt;
          &amp;lt;/div&amp;gt;
        )}

        {/* Left icon */}
        {!loading &amp;amp;&amp;amp; leftIcon &amp;amp;&amp;amp; (
          &amp;lt;span className&#x3D;{cn(&amp;#39;flex-shrink-0&amp;#39;, sizeVariants.icon[size])}&amp;gt;{leftIcon}&amp;lt;/span&amp;gt;
        )}

        {/* Button text */}
        {children &amp;amp;&amp;amp; &amp;lt;span&amp;gt;{children}&amp;lt;/span&amp;gt;}

        {/* Right icon */}
        {!loading &amp;amp;&amp;amp; rightIcon &amp;amp;&amp;amp; (
          &amp;lt;span className&#x3D;{cn(&amp;#39;flex-shrink-0&amp;#39;, sizeVariants.icon[size])}&amp;gt;{rightIcon}&amp;lt;/span&amp;gt;
        )}
      &amp;lt;/button&amp;gt;
    );
  }
);

Button.displayName &#x3D; &amp;#39;Button&amp;#39;;

export default Button;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-95">
                <div class="file-header">ğŸ“„ apps/web/frontend/vite.config.ts</div>
                <div class="file-content">
                    <pre>import react from &amp;#39;@vitejs/plugin-react&amp;#39;;
import { defineConfig } from &amp;#39;vite&amp;#39;;
import monacoEditorPlugin from &amp;#39;vite-plugin-monaco-editor&amp;#39;;

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    react(),
    monacoEditorPlugin({
      languageWorkers: [&amp;#39;editorWorkerService&amp;#39;, &amp;#39;json&amp;#39;, &amp;#39;css&amp;#39;, &amp;#39;html&amp;#39;, &amp;#39;typescript&amp;#39;],
    }),
  ],
  server: {
    port: 3000,
    host: &amp;#39;0.0.0.0&amp;#39;,
    proxy: {
      &amp;#39;/api&amp;#39;: {
        target: &amp;#39;http://localhost:5050&amp;#39;,
        changeOrigin: true,
        ws: true,
      },
    },
  },
  build: {
    target: &amp;#39;es2022&amp;#39;,
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks: {
          &amp;#39;monaco-editor&amp;#39;: [&amp;#39;monaco-editor&amp;#39;],
        },
      },
    },
  },
  optimizeDeps: {
    include: [&amp;#39;monaco-editor/esm/vs/editor/editor.api&amp;#39;],
  },
  define: {
    global: &amp;#39;globalThis&amp;#39;,
    &amp;#39;process.env&amp;#39;: {},
  },
  worker: {
    format: &amp;#39;es&amp;#39;,
  },
});
</pre>
                </div>
            </div>
            <div class="file-section" id="file-96">
                <div class="file-header">ğŸ“„ packages/shared/src/migration.ts</div>
                <div class="file-content">
                    <pre>/**
 * Migration management types and utilities
 */

export interface MigrationPath {
  fromVersion: string;
  toVersion: string;
  steps: MigrationStep[];
  estimatedDuration: number;
}

export interface MigrationStep {
  id: string;
  description: string;
  type: &amp;#39;schema&amp;#39; | &amp;#39;data&amp;#39; | &amp;#39;config&amp;#39; | &amp;#39;file&amp;#39;;
  required: boolean;
  risk: &amp;#39;low&amp;#39; | &amp;#39;medium&amp;#39; | &amp;#39;high&amp;#39;;
}

export function getAvailableMigrationPaths(_component: string): string[] {
  // Stub implementation
  return [&#x60;${_component}: v1.0.0 -&amp;gt; v2.0.0&#x60;];
}

export function hasMigrationPath(
  _component: string,
  _fromVersion: string,
  _toVersion: string
): boolean {
  // Stub implementation
  return true;
}

export function estimateMigrationDuration(
  _component: string,
  _fromVersion: string,
  _toVersion: string
): number {
  // Stub implementation - return milliseconds
  return 60000; // 1 minute default
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-97">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/Handlers/Handlers.tsx</div>
                <div class="file-content">
                    <pre>/**
 * Main Handlers Component
 * Manages webhook handlers with list, editor, and stats views
 */

import React, { useState, useCallback } from &amp;#39;react&amp;#39;;
import HandlersList from &amp;#39;./HandlersList&amp;#39;;
import HandlerEditor from &amp;#39;./HandlerEditor&amp;#39;;
import HandlerStats from &amp;#39;./HandlerStats&amp;#39;;
import HandlersErrorBoundary from &amp;#39;./HandlersErrorBoundary&amp;#39;;
import type { WebhookHandler } from &amp;#39;../../types/api&amp;#39;;

type ViewMode &#x3D; &amp;#39;list&amp;#39; | &amp;#39;editor&amp;#39; | &amp;#39;stats&amp;#39;;

export function Handlers() {
  const [currentView, setCurrentView] &#x3D; useState&amp;lt;ViewMode&amp;gt;(&amp;#39;list&amp;#39;);
  const [selectedHandler, setSelectedHandler] &#x3D; useState&amp;lt;WebhookHandler | null&amp;gt;(null);

  // Handle switching to editor view (new or edit)
  const handleEditHandler &#x3D; useCallback((handler?: WebhookHandler) &#x3D;&amp;gt; {
    setSelectedHandler(handler || null);
    setCurrentView(&amp;#39;editor&amp;#39;);
  }, []);

  // Handle switching to stats view
  const handleViewStats &#x3D; useCallback((handler: WebhookHandler) &#x3D;&amp;gt; {
    setSelectedHandler(handler);
    setCurrentView(&amp;#39;stats&amp;#39;);
  }, []);

  // Handle creating a new handler
  const handleCreateHandler &#x3D; useCallback(() &#x3D;&amp;gt; {
    setSelectedHandler(null);
    setCurrentView(&amp;#39;editor&amp;#39;);
  }, []);

  // Handle returning to list view
  const handleBackToList &#x3D; useCallback(() &#x3D;&amp;gt; {
    setSelectedHandler(null);
    setCurrentView(&amp;#39;list&amp;#39;);
  }, []);

  // Handle successful save from editor
  const handleSaveHandler &#x3D; useCallback((handler: WebhookHandler) &#x3D;&amp;gt; {
    setSelectedHandler(handler);
    setCurrentView(&amp;#39;list&amp;#39;);
  }, []);

  return (
    &amp;lt;HandlersErrorBoundary
      fallbackTitle&#x3D;&amp;quot;Webhook Handlers Error&amp;quot;
      fallbackMessage&#x3D;&amp;quot;Failed to load the webhook handlers interface. This might be due to a connection issue or an internal error.&amp;quot;
      onReset&#x3D;{() &#x3D;&amp;gt; {
        setCurrentView(&amp;#39;list&amp;#39;);
        setSelectedHandler(null);
      }}
    &amp;gt;
      &amp;lt;div className&#x3D;&amp;quot;h-full&amp;quot;&amp;gt;
        {currentView &#x3D;&#x3D;&#x3D; &amp;#39;list&amp;#39; &amp;amp;&amp;amp; (
          &amp;lt;HandlersList
            onEditHandler&#x3D;{handleEditHandler}
            onViewStats&#x3D;{handleViewStats}
            onCreateHandler&#x3D;{handleCreateHandler}
          /&amp;gt;
        )}

        {currentView &#x3D;&#x3D;&#x3D; &amp;#39;editor&amp;#39; &amp;amp;&amp;amp; (
          &amp;lt;HandlerEditor
            handler&#x3D;{selectedHandler}
            onSave&#x3D;{handleSaveHandler}
            onCancel&#x3D;{handleBackToList}
          /&amp;gt;
        )}

        {currentView &#x3D;&#x3D;&#x3D; &amp;#39;stats&amp;#39; &amp;amp;&amp;amp; selectedHandler &amp;amp;&amp;amp; (
          &amp;lt;HandlerStats handler&#x3D;{selectedHandler} onClose&#x3D;{handleBackToList} /&amp;gt;
        )}
      &amp;lt;/div&amp;gt;
    &amp;lt;/HandlersErrorBoundary&amp;gt;
  );
}

export default Handlers;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-98">
                <div class="file-header">ğŸ“„ packages/cli/src/index.ts</div>
                <div class="file-content">
                    <pre>/**
 * Arbiter CLI - Main entry point
 *
 * This module exports the main CLI components for programmatic use
 * while the cli.ts file is used for direct command-line execution.
 */

export * from &amp;quot;./api-client.js&amp;quot;;
// Main CLI program for programmatic use
export { default as program } from &amp;quot;./cli.js&amp;quot;;
// Commands
export { checkCommand } from &amp;quot;./commands/check.js&amp;quot;;
export { exportCommand, listFormats } from &amp;quot;./commands/export.js&amp;quot;;
export { initCommand, listTemplates } from &amp;quot;./commands/init.js&amp;quot;;
export { validateCommand } from &amp;quot;./commands/validate.js&amp;quot;;
export * from &amp;quot;./config.js&amp;quot;;
export * from &amp;quot;./types.js&amp;quot;;
// Utilities
export * from &amp;quot;./utils/formatting.js&amp;quot;;
export * from &amp;quot;./utils/progress.js&amp;quot;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-99">
                <div class="file-header">ğŸ“„ apps/web/frontend/eslint.config.js</div>
                <div class="file-content">
                    <pre>import js from &amp;#39;@eslint/js&amp;#39;;
import reactHooks from &amp;#39;eslint-plugin-react-hooks&amp;#39;;
import reactRefresh from &amp;#39;eslint-plugin-react-refresh&amp;#39;;
import { globalIgnores } from &amp;#39;eslint/config&amp;#39;;
import globals from &amp;#39;globals&amp;#39;;
import tseslint from &amp;#39;typescript-eslint&amp;#39;;

export default tseslint.config([
  globalIgnores([&amp;#39;dist&amp;#39;]),
  {
    files: [&amp;#39;**/*.{ts,tsx}&amp;#39;],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs[&amp;#39;recommended-latest&amp;#39;],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
]);
</pre>
                </div>
            </div>
            <div class="file-section" id="file-100">
                <div class="file-header">ğŸ“„ demo-project/src/App.tsx</div>
                <div class="file-content">
                    <pre>import &amp;#39;./App.css&amp;#39;;

function App() {
  const name &#x3D; &amp;#39;demo-project&amp;#39;;

  return (
    &amp;lt;div className&#x3D;&amp;quot;App&amp;quot;&amp;gt;
      &amp;lt;h1&amp;gt;Welcome to {name}&amp;lt;/h1&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}

export default App;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-101">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/diagrams/DataViewer.tsx</div>
                <div class="file-content">
                    <pre>import React, { useState } from &amp;#39;react&amp;#39;;
import { Copy, Check } from &amp;#39;lucide-react&amp;#39;;

interface DataViewerProps {
  data: string | object;
  language?: &amp;#39;yaml&amp;#39; | &amp;#39;json&amp;#39; | &amp;#39;javascript&amp;#39; | &amp;#39;typescript&amp;#39; | &amp;#39;cue&amp;#39;;
  title?: string;
  className?: string;
  showCopyButton?: boolean;
}

export const DataViewer: React.FC&amp;lt;DataViewerProps&amp;gt; &#x3D; ({
  data,
  language &#x3D; &amp;#39;yaml&amp;#39;,
  title,
  className &#x3D; &amp;#39;&amp;#39;,
  showCopyButton &#x3D; true,
}) &#x3D;&amp;gt; {
  const [copied, setCopied] &#x3D; useState(false);

  const dataString &#x3D; typeof data &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39; ? data : JSON.stringify(data, null, 2);

  const handleCopy &#x3D; async () &#x3D;&amp;gt; {
    try {
      await navigator.clipboard.writeText(dataString);
      setCopied(true);
      setTimeout(() &#x3D;&amp;gt; setCopied(false), 2000);
    } catch (err) {
      console.error(&amp;#39;Failed to copy:&amp;#39;, err);
    }
  };

  const getLanguageClass &#x3D; () &#x3D;&amp;gt; {
    switch (language) {
      case &amp;#39;json&amp;#39;:
        return &amp;#39;language-json&amp;#39;;
      case &amp;#39;javascript&amp;#39;:
        return &amp;#39;language-javascript&amp;#39;;
      case &amp;#39;typescript&amp;#39;:
        return &amp;#39;language-typescript&amp;#39;;
      case &amp;#39;cue&amp;#39;:
        return &amp;#39;language-cue&amp;#39;;
      default:
        return &amp;#39;language-yaml&amp;#39;;
    }
  };

  return (
    &amp;lt;div className&#x3D;{&#x60;relative ${className}&#x60;}&amp;gt;
      {title &amp;amp;&amp;amp; (
        &amp;lt;div className&#x3D;&amp;quot;flex items-center justify-between mb-3&amp;quot;&amp;gt;
          &amp;lt;h4 className&#x3D;&amp;quot;text-sm font-semibold text-gray-700&amp;quot;&amp;gt;{title}&amp;lt;/h4&amp;gt;
          {showCopyButton &amp;amp;&amp;amp; (
            &amp;lt;button
              onClick&#x3D;{handleCopy}
              className&#x3D;&amp;quot;flex items-center gap-1 px-2 py-1 text-xs text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded transition-colors&amp;quot;
              title&#x3D;{copied ? &amp;#39;Copied!&amp;#39; : &amp;#39;Copy to clipboard&amp;#39;}
            &amp;gt;
              {copied ? (
                &amp;lt;&amp;gt;
                  &amp;lt;Check className&#x3D;&amp;quot;w-3 h-3&amp;quot; /&amp;gt;
                  Copied
                &amp;lt;/&amp;gt;
              ) : (
                &amp;lt;&amp;gt;
                  &amp;lt;Copy className&#x3D;&amp;quot;w-3 h-3&amp;quot; /&amp;gt;
                  Copy
                &amp;lt;/&amp;gt;
              )}
            &amp;lt;/button&amp;gt;
          )}
        &amp;lt;/div&amp;gt;
      )}

      &amp;lt;div className&#x3D;&amp;quot;bg-gray-900 text-gray-100 p-4 rounded-lg overflow-auto max-h-96 text-sm font-mono&amp;quot;&amp;gt;
        &amp;lt;pre className&#x3D;{getLanguageClass()}&amp;gt;
          &amp;lt;code&amp;gt;{dataString}&amp;lt;/code&amp;gt;
        &amp;lt;/pre&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default DataViewer;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-102">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/Handlers/index.ts</div>
                <div class="file-content">
                    <pre>/**
 * Webhook Handlers Components
 */

export { default as Handlers } from &amp;#39;./Handlers&amp;#39;;
export { default as HandlersList } from &amp;#39;./HandlersList&amp;#39;;
export { default as HandlerEditor } from &amp;#39;./HandlerEditor&amp;#39;;
export { default as HandlerStats } from &amp;#39;./HandlerStats&amp;#39;;
export { default as HandlersErrorBoundary } from &amp;#39;./HandlersErrorBoundary&amp;#39;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-103">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/Layout/Tabs.tsx</div>
                <div class="file-content">
                    <pre>/**
 * Tab component for organizing content
 */

import React from &amp;#39;react&amp;#39;;
import { clsx } from &amp;#39;clsx&amp;#39;;
import type { TabsProps, TabItem } from &amp;#39;../../types/ui&amp;#39;;

export function Tabs({ activeTab, onTabChange, tabs, className }: TabsProps) {
  const activeTabContent &#x3D; tabs.find(tab &#x3D;&amp;gt; tab.id &#x3D;&#x3D;&#x3D; activeTab)?.content;

  return (
    &amp;lt;div className&#x3D;{clsx(&amp;#39;flex flex-col h-full min-h-0&amp;#39;, className)}&amp;gt;
      {/* Tab headers */}
      &amp;lt;div className&#x3D;&amp;quot;flex border-b border-gray-200 bg-gray-50&amp;quot;&amp;gt;
        {tabs.map(tab &#x3D;&amp;gt; (
          &amp;lt;TabHeader
            key&#x3D;{tab.id}
            tab&#x3D;{tab}
            isActive&#x3D;{tab.id &#x3D;&#x3D;&#x3D; activeTab}
            onClick&#x3D;{() &#x3D;&amp;gt; !tab.disabled &amp;amp;&amp;amp; onTabChange(tab.id)}
          /&amp;gt;
        ))}
      &amp;lt;/div&amp;gt;

      {/* Tab content */}
      &amp;lt;div className&#x3D;&amp;quot;flex-1 min-h-0 min-w-0 overflow-hidden&amp;quot;&amp;gt;{activeTabContent}&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}

interface TabHeaderProps {
  tab: TabItem;
  isActive: boolean;
  onClick: () &#x3D;&amp;gt; void;
}

function TabHeader({ tab, isActive, onClick }: TabHeaderProps) {
  return (
    &amp;lt;button
      type&#x3D;&amp;quot;button&amp;quot;
      className&#x3D;{clsx(
        &amp;#39;px-4 py-2 font-medium text-sm border-b-2 transition-colors duration-150&amp;#39;,
        &amp;#39;focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-inset&amp;#39;,
        isActive
          ? &amp;#39;border-blue-500 text-blue-600 bg-white&amp;#39;
          : &amp;#39;border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300&amp;#39;,
        tab.disabled &amp;amp;&amp;amp; &amp;#39;opacity-50 cursor-not-allowed&amp;#39;
      )}
      onClick&#x3D;{onClick}
      disabled&#x3D;{tab.disabled}
      aria-selected&#x3D;{isActive}
      role&#x3D;&amp;quot;tab&amp;quot;
    &amp;gt;
      &amp;lt;span className&#x3D;&amp;quot;flex items-center gap-2&amp;quot;&amp;gt;
        {tab.label}
        {tab.badge &amp;amp;&amp;amp; (
          &amp;lt;span
            className&#x3D;{clsx(
              &amp;#39;inline-flex items-center justify-center px-2 py-0.5 rounded-full text-xs font-medium&amp;#39;,
              isActive ? &amp;#39;bg-blue-100 text-blue-800&amp;#39; : &amp;#39;bg-gray-200 text-gray-600&amp;#39;
            )}
          &amp;gt;
            {tab.badge}
          &amp;lt;/span&amp;gt;
        )}
      &amp;lt;/span&amp;gt;
    &amp;lt;/button&amp;gt;
  );
}

export default Tabs;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-104">
                <div class="file-header">ğŸ“„ demo-project/vite.config.ts</div>
                <div class="file-content">
                    <pre>import react from &amp;#39;@vitejs/plugin-react&amp;#39;;
import { defineConfig } from &amp;#39;vite&amp;#39;;

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
  },
  build: {
    target: &amp;#39;es2022&amp;#39;,
    sourcemap: true,
  },
  test: {
    globals: true,
    environment: &amp;#39;jsdom&amp;#39;,
    setupFiles: [&amp;#39;./src/test-setup.ts&amp;#39;],
  },
});
</pre>
                </div>
            </div>
            <div class="file-section" id="file-105">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/diagrams/SplitViewShowcase.tsx</div>
                <div class="file-content">
                    <pre>import React from &amp;#39;react&amp;#39;;
import { Card } from &amp;#39;../../design-system/components/Card&amp;#39;;

interface SplitViewShowcaseProps {
  title: string;
  description?: string;
  dataPanel: React.ReactNode;
  diagramPanel: React.ReactNode;
  dataPanelTitle?: string;
  diagramPanelTitle?: string;
  className?: string;
}

export const SplitViewShowcase: React.FC&amp;lt;SplitViewShowcaseProps&amp;gt; &#x3D; ({
  title,
  description,
  dataPanel,
  diagramPanel,
  dataPanelTitle &#x3D; &amp;#39;Specification Data&amp;#39;,
  diagramPanelTitle &#x3D; &amp;#39;Generated Diagram&amp;#39;,
  className &#x3D; &amp;#39;&amp;#39;,
}) &#x3D;&amp;gt; {
  return (
    &amp;lt;div className&#x3D;{&#x60;w-full h-full ${className}&#x60;}&amp;gt;
      {/* Header */}
      &amp;lt;div className&#x3D;&amp;quot;mb-6&amp;quot;&amp;gt;
        &amp;lt;h2 className&#x3D;&amp;quot;text-2xl font-bold text-gray-900 mb-2&amp;quot;&amp;gt;{title}&amp;lt;/h2&amp;gt;
        {description &amp;amp;&amp;amp; &amp;lt;p className&#x3D;&amp;quot;text-gray-600&amp;quot;&amp;gt;{description}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      {/* Split View */}
      &amp;lt;div className&#x3D;&amp;quot;grid grid-cols-1 lg:grid-cols-2 gap-6 h-[calc(100vh-200px)] min-h-[600px]&amp;quot;&amp;gt;
        {/* Data Panel */}
        &amp;lt;Card className&#x3D;&amp;quot;flex flex-col&amp;quot;&amp;gt;
          &amp;lt;div className&#x3D;&amp;quot;border-b border-gray-200 px-4 py-3&amp;quot;&amp;gt;
            &amp;lt;h3 className&#x3D;&amp;quot;text-lg font-semibold text-gray-900 flex items-center&amp;quot;&amp;gt;
              &amp;lt;span className&#x3D;&amp;quot;inline-block w-3 h-3 bg-blue-500 rounded-full mr-2&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
              {dataPanelTitle}
            &amp;lt;/h3&amp;gt;
          &amp;lt;/div&amp;gt;
          &amp;lt;div className&#x3D;&amp;quot;flex-1 overflow-auto p-4&amp;quot;&amp;gt;{dataPanel}&amp;lt;/div&amp;gt;
        &amp;lt;/Card&amp;gt;

        {/* Diagram Panel */}
        &amp;lt;Card className&#x3D;&amp;quot;flex flex-col&amp;quot;&amp;gt;
          &amp;lt;div className&#x3D;&amp;quot;border-b border-gray-200 px-4 py-3&amp;quot;&amp;gt;
            &amp;lt;h3 className&#x3D;&amp;quot;text-lg font-semibold text-gray-900 flex items-center&amp;quot;&amp;gt;
              &amp;lt;span className&#x3D;&amp;quot;inline-block w-3 h-3 bg-green-500 rounded-full mr-2&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
              {diagramPanelTitle}
            &amp;lt;/h3&amp;gt;
          &amp;lt;/div&amp;gt;
          &amp;lt;div className&#x3D;&amp;quot;flex-1 overflow-auto p-4 bg-gray-50&amp;quot;&amp;gt;{diagramPanel}&amp;lt;/div&amp;gt;
        &amp;lt;/Card&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default SplitViewShowcase;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-106">
                <div class="file-header">ğŸ“„ packages/shared/src/index.ts</div>
                <div class="file-content">
                    <pre>/**
 * Shared types and utilities for Arbiter
 */

export * from &amp;quot;./migration&amp;quot;;
// Re-export all shared types and utilities
export * from &amp;quot;./types&amp;quot;;
export * from &amp;quot;./utils&amp;quot;;
export * from &amp;quot;./version&amp;quot;;

</pre>
                </div>
            </div>
            <div class="file-section" id="file-107">
                <div class="file-header">ğŸ“„ apps/api/src/handlers/types.ts</div>
                <div class="file-content">
                    <pre>/**
 * Custom webhook handler types and interfaces
 */

// Handler execution context
export interface HandlerContext {
  projectId: string;
  config: HandlerConfig;
  logger: Logger;
  services: HandlerServices;
  metadata: HandlerMetadata;
}

// Handler configuration
export interface HandlerConfig {
  enabled: boolean;
  timeout: number; // milliseconds
  retries: number;
  environment: Record&amp;lt;string, string&amp;gt;;
  secrets: Record&amp;lt;string, string&amp;gt;; // Encrypted secrets
}

// Available services for handlers
export interface HandlerServices {
  events: EventService;
  db: SpecWorkbenchDB;
  http: HttpClient;
  notifications: NotificationService;
  git: GitService;
}

// Handler metadata
export interface HandlerMetadata {
  handlerPath: string;
  version: string;
  executionId: string;
  timestamp: string;
}

// Handler result
export interface HandlerResult {
  success: boolean;
  message: string;
  data?: Record&amp;lt;string, unknown&amp;gt;;
  actions?: string[];
  errors?: HandlerError[];
  duration?: number;
}

// Handler error
export interface HandlerError {
  code: string;
  message: string;
  details?: Record&amp;lt;string, unknown&amp;gt;;
  stack?: string;
}

// Enhanced webhook payload with parsed data
export interface EnhancedWebhookPayload extends WebhookPayload {
  parsed: {
    eventType: string;
    action?: string;
    author: {
      name: string;
      email?: string;
      username?: string;
    };
    repository: {
      name: string;
      fullName: string;
      owner: string;
      url: string;
      defaultBranch: string;
      isPrivate: boolean;
    };
    commits?: Array&amp;lt;{
      sha: string;
      message: string;
      author: string;
      url: string;
      timestamp: string;
      added: string[];
      modified: string[];
      removed: string[];
    }&amp;gt;;
    pullRequest?: {
      id: number;
      title: string;
      body: string;
      state: string;
      baseBranch: string;
      headBranch: string;
      url: string;
      merged: boolean;
      mergeable: boolean;
    };
    issue?: {
      id: number;
      title: string;
      body: string;
      state: string;
      labels: string[];
      assignees: string[];
      url: string;
    };
  };
}

// Handler function signature
export type WebhookHandler &#x3D; (
  payload: EnhancedWebhookPayload,
  context: HandlerContext
) &#x3D;&amp;gt; Promise&amp;lt;HandlerResult&amp;gt;;

// Handler module interface
export interface HandlerModule {
  handler: WebhookHandler;
  config?: Partial&amp;lt;HandlerConfig&amp;gt;;
  metadata?: {
    name: string;
    description: string;
    version: string;
    author?: string;
    supportedEvents: string[];
    requiredPermissions: string[];
  };
}

// Logger interface for handlers
export interface Logger {
  info(message: string, meta?: Record&amp;lt;string, unknown&amp;gt;): void;
  warn(message: string, meta?: Record&amp;lt;string, unknown&amp;gt;): void;
  error(message: string, error?: Error, meta?: Record&amp;lt;string, unknown&amp;gt;): void;
  debug(message: string, meta?: Record&amp;lt;string, unknown&amp;gt;): void;
}

// HTTP client interface
export interface HttpClient {
  get(url: string, options?: RequestOptions): Promise&amp;lt;HttpResponse&amp;gt;;
  post(url: string, data?: unknown, options?: RequestOptions): Promise&amp;lt;HttpResponse&amp;gt;;
  put(url: string, data?: unknown, options?: RequestOptions): Promise&amp;lt;HttpResponse&amp;gt;;
  delete(url: string, options?: RequestOptions): Promise&amp;lt;HttpResponse&amp;gt;;
}

export interface RequestOptions {
  headers?: Record&amp;lt;string, string&amp;gt;;
  timeout?: number;
  retries?: number;
}

export interface HttpResponse {
  status: number;
  statusText: string;
  data: unknown;
  headers: Record&amp;lt;string, string&amp;gt;;
}

// Notification service interface
export interface NotificationService {
  sendSlack(webhook: string, message: SlackMessage): Promise&amp;lt;void&amp;gt;;
  sendEmail(to: string, subject: string, body: string): Promise&amp;lt;void&amp;gt;;
  sendWebhook(url: string, payload: unknown): Promise&amp;lt;void&amp;gt;;
}

export interface SlackMessage {
  text?: string;
  blocks?: unknown[];
  channel?: string;
  username?: string;
  iconEmoji?: string;
}

// Git service interface
export interface GitService {
  cloneRepository(url: string, path: string): Promise&amp;lt;void&amp;gt;;
  getCommitDiff(sha: string): Promise&amp;lt;FileDiff[]&amp;gt;;
  getFileContent(path: string, ref?: string): Promise&amp;lt;string&amp;gt;;
  createBranch(name: string, from?: string): Promise&amp;lt;void&amp;gt;;
  createPullRequest(title: string, body: string, base: string, head: string): Promise&amp;lt;unknown&amp;gt;;
}

export interface FileDiff {
  path: string;
  status: &amp;#39;added&amp;#39; | &amp;#39;modified&amp;#39; | &amp;#39;deleted&amp;#39; | &amp;#39;renamed&amp;#39;;
  additions: number;
  deletions: number;
  patch?: string;
}

// Handler registry types
export interface RegisteredHandler {
  id: string;
  provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;;
  event: string;
  handlerPath: string;
  enabled: boolean;
  config: HandlerConfig;
  lastExecuted?: string;
  executionCount: number;
  errorCount: number;
  metadata: HandlerModule[&amp;#39;metadata&amp;#39;];
}

export interface HandlerCreationOptions {
  provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;;
  event: string;
  code: string;
  config?: Partial&amp;lt;HandlerConfig&amp;gt;;
  metadata?: {
    name: string;
    description: string;
    version?: string;
    author?: string;
  };
}

export interface HandlerExecution {
  id: string;
  handlerId: string;
  projectId: string;
  provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;;
  event: string;
  payload: EnhancedWebhookPayload;
  result: HandlerResult;
  startedAt: string;
  completedAt: string;
  duration: number;
}

// Configuration for handler discovery
export interface HandlerDiscoveryConfig {
  handlersDirectory: string;
  enableAutoReload: boolean;
  maxConcurrentExecutions: number;
  defaultTimeout: number;
  defaultRetries: number;
  sandboxEnabled: boolean;
  allowedModules: string[];
  enableMetrics: boolean;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-108">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/charts/index.ts</div>
                <div class="file-content">
                    <pre>// Chart components for rendering visualizations from CUE specifications
export { Chart, type ChartData } from &amp;#39;./Chart&amp;#39;;
export { CuePlotViewer } from &amp;#39;./CuePlotViewer&amp;#39;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-109">
                <div class="file-header">ğŸ“„ packages/api-types/src/index.ts</div>
                <div class="file-content">
                    <pre>/**
 * Deprecated: use @arbiter/shared-types/api for shared API contracts.
 */
export * from &amp;#39;@arbiter/shared-types/api&amp;#39;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-110">
                <div class="file-header">ğŸ“„ apps/web/frontend/postcss.config.js</div>
                <div class="file-content">
                    <pre>export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</pre>
                </div>
            </div>
            <div class="file-section" id="file-111">
                <div class="file-header">ğŸ“„ demo-project/src/vite-env.d.ts</div>
                <div class="file-content">
                    <pre>/// &amp;lt;reference types&#x3D;&amp;quot;vite/client&amp;quot; /&amp;gt;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-112">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/Layout/TopBar.stories.tsx</div>
                <div class="file-content">
                    <pre>/**
 * TopBar Component Stories
 * Showcase of the enhanced TopBar with Graphite Design System
 */

import type { Meta, StoryObj } from &amp;#39;@storybook/react&amp;#39;;
import { TopBar } from &amp;#39;./TopBar&amp;#39;;

const meta &#x3D; {
  title: &amp;#39;Components/TopBar&amp;#39;,
  component: TopBar,
  parameters: {
    layout: &amp;#39;fullscreen&amp;#39;,
    docs: {
      description: {
        component:
          &amp;#39;Enhanced top navigation bar for the Spec Workbench application. Features project selector, connection status, validation state, and action buttons with professional graphite styling.&amp;#39;,
      },
    },
  },
  tags: [&amp;#39;autodocs&amp;#39;],
} satisfies Meta&amp;lt;typeof TopBar&amp;gt;;

export default meta;
type Story &#x3D; StoryObj&amp;lt;typeof meta&amp;gt;;

// Mock the required context providers
const mockContextValue &#x3D; {
  state: {
    projects: [{ id: &amp;#39;1&amp;#39;, name: &amp;#39;Sample Project&amp;#39;, description: &amp;#39;A sample project&amp;#39; }],
    currentProjectId: &amp;#39;1&amp;#39;,
    fragments: [
      {
        id: &amp;#39;1&amp;#39;,
        path: &amp;#39;api/routes.cue&amp;#39;,
        content: &amp;#39;package api&amp;#39;,
        project_id: &amp;#39;1&amp;#39;,
        created_at: &amp;#39;&amp;#39;,
        updated_at: &amp;#39;&amp;#39;,
      },
      {
        id: &amp;#39;2&amp;#39;,
        path: &amp;#39;schemas/user.cue&amp;#39;,
        content: &amp;#39;package schemas&amp;#39;,
        project_id: &amp;#39;1&amp;#39;,
        created_at: &amp;#39;&amp;#39;,
        updated_at: &amp;#39;&amp;#39;,
      },
    ],
    unsavedChanges: new Set([&amp;#39;1&amp;#39;]),
    activeFragmentId: &amp;#39;1&amp;#39;,
    editorContent: {},
    loading: false,
    error: null,
    connectionStatus: {
      isConnected: true,
      reconnectAttempts: 0,
      lastSync: new Date().toISOString(),
    },
    validationState: {
      errors: [],
      warnings: [],
      isValidating: false,
      lastValidation: null,
      specHash: null,
    },
  },
  dispatch: () &#x3D;&amp;gt; {},
  setActiveFragment: () &#x3D;&amp;gt; {},
  setLoading: () &#x3D;&amp;gt; {},
  setError: () &#x3D;&amp;gt; {},
};

// Default state - connected and valid
export const Default: Story &#x3D; {
  decorators: [
    Story &#x3D;&amp;gt; (
      &amp;lt;div className&#x3D;&amp;quot;min-h-screen bg-gray-50&amp;quot;&amp;gt;
        &amp;lt;Story /&amp;gt;
      &amp;lt;/div&amp;gt;
    ),
  ],
};

// With unsaved changes
export const WithUnsavedChanges: Story &#x3D; {
  decorators: [
    Story &#x3D;&amp;gt; (
      &amp;lt;div className&#x3D;&amp;quot;min-h-screen bg-gray-50&amp;quot;&amp;gt;
        &amp;lt;Story /&amp;gt;
      &amp;lt;/div&amp;gt;
    ),
  ],
};

// Disconnected state
export const Disconnected: Story &#x3D; {
  decorators: [
    Story &#x3D;&amp;gt; (
      &amp;lt;div className&#x3D;&amp;quot;min-h-screen bg-gray-50&amp;quot;&amp;gt;
        &amp;lt;Story /&amp;gt;
      &amp;lt;/div&amp;gt;
    ),
  ],
};

// Validation errors
export const WithValidationErrors: Story &#x3D; {
  decorators: [
    Story &#x3D;&amp;gt; (
      &amp;lt;div className&#x3D;&amp;quot;min-h-screen bg-gray-50&amp;quot;&amp;gt;
        &amp;lt;Story /&amp;gt;
      &amp;lt;/div&amp;gt;
    ),
  ],
};

// Loading/validating state
export const Validating: Story &#x3D; {
  decorators: [
    Story &#x3D;&amp;gt; (
      &amp;lt;div className&#x3D;&amp;quot;min-h-screen bg-gray-50&amp;quot;&amp;gt;
        &amp;lt;Story /&amp;gt;
      &amp;lt;/div&amp;gt;
    ),
  ],
};

// No project selected
export const NoProject: Story &#x3D; {
  decorators: [
    Story &#x3D;&amp;gt; (
      &amp;lt;div className&#x3D;&amp;quot;min-h-screen bg-gray-50&amp;quot;&amp;gt;
        &amp;lt;Story /&amp;gt;
      &amp;lt;/div&amp;gt;
    ),
  ],
};

// Note: The TopBar component requires React context providers that aren&amp;#39;t available in Storybook stories.
// In a real implementation, you would need to wrap these stories with mock providers or create a
// standalone version of the TopBar for Storybook that doesn&amp;#39;t depend on context.
</pre>
                </div>
            </div>
            <div class="file-section" id="file-113">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/Handlers/HandlersErrorBoundary.tsx</div>
                <div class="file-content">
                    <pre>/**
 * Error Boundary for Handlers Components
 * Provides graceful error handling and recovery
 */

import React, { Component, ReactNode } from &amp;#39;react&amp;#39;;
import { AlertTriangle, RefreshCw, Home } from &amp;#39;lucide-react&amp;#39;;
import { Button, Card } from &amp;#39;../../design-system&amp;#39;;

interface Props {
  children: ReactNode;
  fallbackTitle?: string;
  fallbackMessage?: string;
  onReset?: () &#x3D;&amp;gt; void;
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
}

export class HandlersErrorBoundary extends Component&amp;lt;Props, State&amp;gt; {
  constructor(props: Props) {
    super(props);
    this.state &#x3D; {
      hasError: false,
      error: null,
      errorInfo: null,
    };
  }

  static getDerivedStateFromError(error: Error): Partial&amp;lt;State&amp;gt; {
    // Update state so the next render will show the fallback UI
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Log the error for debugging
    console.error(&amp;#39;HandlersErrorBoundary caught an error:&amp;#39;, error, errorInfo);

    this.setState({
      error,
      errorInfo,
    });
  }

  handleReset &#x3D; () &#x3D;&amp;gt; {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    });

    if (this.props.onReset) {
      this.props.onReset();
    }
  };

  render() {
    if (this.state.hasError) {
      const {
        fallbackTitle &#x3D; &amp;#39;Something went wrong with handlers&amp;#39;,
        fallbackMessage &#x3D; &amp;#39;An error occurred while loading the webhook handlers interface. Please try refreshing or contact support if the issue persists.&amp;#39;,
      } &#x3D; this.props;

      return (
        &amp;lt;div className&#x3D;&amp;quot;h-full flex items-center justify-center p-6&amp;quot;&amp;gt;
          &amp;lt;Card className&#x3D;&amp;quot;max-w-md w-full p-8 text-center&amp;quot;&amp;gt;
            &amp;lt;div className&#x3D;&amp;quot;mb-6&amp;quot;&amp;gt;
              &amp;lt;div className&#x3D;&amp;quot;mx-auto w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mb-4&amp;quot;&amp;gt;
                &amp;lt;AlertTriangle className&#x3D;&amp;quot;w-8 h-8 text-red-600&amp;quot; /&amp;gt;
              &amp;lt;/div&amp;gt;

              &amp;lt;h2 className&#x3D;&amp;quot;text-xl font-semibold text-gray-900 mb-2&amp;quot;&amp;gt;{fallbackTitle}&amp;lt;/h2&amp;gt;

              &amp;lt;p className&#x3D;&amp;quot;text-gray-600 text-sm mb-6&amp;quot;&amp;gt;{fallbackMessage}&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;

            &amp;lt;div className&#x3D;&amp;quot;space-y-3&amp;quot;&amp;gt;
              &amp;lt;Button
                onClick&#x3D;{this.handleReset}
                className&#x3D;&amp;quot;w-full&amp;quot;
                leftIcon&#x3D;{&amp;lt;RefreshCw className&#x3D;&amp;quot;w-4 h-4&amp;quot; /&amp;gt;}
              &amp;gt;
                Try Again
              &amp;lt;/Button&amp;gt;

              &amp;lt;Button
                variant&#x3D;&amp;quot;secondary&amp;quot;
                onClick&#x3D;{() &#x3D;&amp;gt; window.location.reload()}
                className&#x3D;&amp;quot;w-full&amp;quot;
                leftIcon&#x3D;{&amp;lt;Home className&#x3D;&amp;quot;w-4 h-4&amp;quot; /&amp;gt;}
              &amp;gt;
                Reload Page
              &amp;lt;/Button&amp;gt;
            &amp;lt;/div&amp;gt;

            {/* Error details for debugging (only in development) */}
            {process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &amp;#39;development&amp;#39; &amp;amp;&amp;amp; this.state.error &amp;amp;&amp;amp; (
              &amp;lt;details className&#x3D;&amp;quot;mt-6 text-left&amp;quot;&amp;gt;
                &amp;lt;summary className&#x3D;&amp;quot;cursor-pointer text-gray-500 hover:text-gray-700 text-sm mb-2&amp;quot;&amp;gt;
                  Error Details (Development)
                &amp;lt;/summary&amp;gt;
                &amp;lt;div className&#x3D;&amp;quot;bg-gray-100 p-3 rounded text-xs font-mono overflow-auto max-h-32&amp;quot;&amp;gt;
                  &amp;lt;div className&#x3D;&amp;quot;mb-2&amp;quot;&amp;gt;
                    &amp;lt;strong&amp;gt;Error:&amp;lt;/strong&amp;gt; {this.state.error.message}
                  &amp;lt;/div&amp;gt;
                  &amp;lt;div className&#x3D;&amp;quot;mb-2&amp;quot;&amp;gt;
                    &amp;lt;strong&amp;gt;Stack:&amp;lt;/strong&amp;gt;
                    &amp;lt;pre className&#x3D;&amp;quot;whitespace-pre-wrap text-xs&amp;quot;&amp;gt;{this.state.error.stack}&amp;lt;/pre&amp;gt;
                  &amp;lt;/div&amp;gt;
                  {this.state.errorInfo &amp;amp;&amp;amp; (
                    &amp;lt;div&amp;gt;
                      &amp;lt;strong&amp;gt;Component Stack:&amp;lt;/strong&amp;gt;
                      &amp;lt;pre className&#x3D;&amp;quot;whitespace-pre-wrap text-xs&amp;quot;&amp;gt;
                        {this.state.errorInfo.componentStack}
                      &amp;lt;/pre&amp;gt;
                    &amp;lt;/div&amp;gt;
                  )}
                &amp;lt;/div&amp;gt;
              &amp;lt;/details&amp;gt;
            )}
          &amp;lt;/Card&amp;gt;
        &amp;lt;/div&amp;gt;
      );
    }

    return this.props.children;
  }
}

export default HandlersErrorBoundary;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-114">
                <div class="file-header">ğŸ“„ scripts/local-ci.sh</div>
                <div class="file-content">
                    <pre>#!/usr/bin/env bash
# Ensure the script aborts on errors, unset variables, or failed pipelines
set -euo pipefail

ROOT_DIR&#x3D;&amp;quot;$(cd &amp;quot;$(dirname &amp;quot;${BASH_SOURCE[0]}&amp;quot;)/..&amp;quot; &amp;amp;&amp;amp; pwd)&amp;quot;
cd &amp;quot;${ROOT_DIR}&amp;quot;

TOTAL_STEPS&#x3D;6
STEP&#x3D;1

print_header() {
  printf &amp;#39;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&amp;#39;
  printf &amp;#39;%s\n&amp;#39; &amp;quot;$1&amp;quot;
  printf &amp;#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&amp;#39;
}

run_step() {
  local title&#x3D;$1
  shift
  local cmd&#x3D;(&amp;quot;$@&amp;quot;)

  printf &amp;#39;\n[%d/%d] %s\n&amp;#39; &amp;quot;${STEP}&amp;quot; &amp;quot;${TOTAL_STEPS}&amp;quot; &amp;quot;${title}&amp;quot;
  printf &amp;#39;----------------------------------------\n&amp;#39;
  if &amp;quot;${cmd[@]}&amp;quot;; then
    printf &amp;#39;âœ… %s\n&amp;#39; &amp;quot;${title}&amp;quot;
  else
    local status&#x3D;$?
    printf &amp;#39;âŒ %s (exit code %d)\n&amp;#39; &amp;quot;${title}&amp;quot; &amp;quot;${status}&amp;quot;
    exit &amp;quot;${status}&amp;quot;
  fi
  STEP&#x3D;$((STEP + 1))
}

print_header &amp;quot;Arbiter Local CI&amp;quot;

run_step &amp;quot;Install dependencies&amp;quot; bun install --frozen-lockfile
run_step &amp;quot;Check formatting &amp;amp; linting&amp;quot; bun run check:ci
run_step &amp;quot;Type check (TS project references)&amp;quot; bun run typecheck
run_step &amp;quot;Run unit and integration tests&amp;quot; bun run test
run_step &amp;quot;Build workspaces&amp;quot; bun run build
run_step &amp;quot;Audit dependencies&amp;quot; bun audit

printf &amp;#39;\nAll checks passed âœ…\n&amp;#39;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-115">
                <div class="file-header">ğŸ“„ apps/web/frontend/.storybook/decorators.tsx</div>
                <div class="file-content">
                    <pre>import React from &amp;#39;react&amp;#39;;
import type { Decorator } from &amp;#39;@storybook/react&amp;#39;;

/**
 * Design System Context Decorator
 * Applies theme classes and design system context to all stories
 */
export const DesignSystemDecorator: Decorator &#x3D; (Story, context) &#x3D;&amp;gt; {
  // Apply theme class based on toolbar selection
  const theme &#x3D; context.globals.designSystem || &amp;#39;default&amp;#39;;
  const colorScheme &#x3D; context.globals.colorScheme || &amp;#39;light&amp;#39;;

  return (
    &amp;lt;div
      className&#x3D;{&#x60;storybook-decorator ${theme} ${colorScheme}&#x60;}
      style&#x3D;{{
        fontFamily: &amp;#39;&amp;quot;Inter&amp;quot;, -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, sans-serif&amp;#39;,
        colorScheme: colorScheme,
        minHeight: &amp;#39;100vh&amp;#39;,
        backgroundColor: colorScheme &#x3D;&#x3D;&#x3D; &amp;#39;dark&amp;#39; ? &amp;#39;#0f172a&amp;#39; : &amp;#39;#ffffff&amp;#39;,
        color: colorScheme &#x3D;&#x3D;&#x3D; &amp;#39;dark&amp;#39; ? &amp;#39;#f8fafc&amp;#39; : &amp;#39;#0f172a&amp;#39;,
      }}
    &amp;gt;
      &amp;lt;Story /&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};
</pre>
                </div>
            </div>
            <div class="file-section" id="file-116">
                <div class="file-header">ğŸ“„ apps/web/frontend/tsconfig.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;files&amp;quot;: [],
  &amp;quot;references&amp;quot;: [
    { &amp;quot;path&amp;quot;: &amp;quot;./tsconfig.app.json&amp;quot; },
    { &amp;quot;path&amp;quot;: &amp;quot;./tsconfig.node.json&amp;quot; }
  ]
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-117">
                <div class="file-header">ğŸ“„ packages/shared/package.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;name&amp;quot;: &amp;quot;@arbiter/shared&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;Shared types and utilities for Arbiter&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;./dist/index.js&amp;quot;,
  &amp;quot;types&amp;quot;: &amp;quot;./dist/index.d.ts&amp;quot;,
  &amp;quot;exports&amp;quot;: {
    &amp;quot;.&amp;quot;: {
      &amp;quot;types&amp;quot;: &amp;quot;./dist/index.d.ts&amp;quot;,
      &amp;quot;import&amp;quot;: &amp;quot;./dist/index.js&amp;quot;
    }
  },
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;build&amp;quot;: &amp;quot;tsc&amp;quot;,
    &amp;quot;dev&amp;quot;: &amp;quot;tsc --watch&amp;quot;,
    &amp;quot;typecheck&amp;quot;: &amp;quot;tsc --noEmit&amp;quot;,
    &amp;quot;clean&amp;quot;: &amp;quot;rm -rf dist&amp;quot;
  },
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;@types/node&amp;quot;: &amp;quot;^20.11.0&amp;quot;,
    &amp;quot;typescript&amp;quot;: &amp;quot;^5.3.3&amp;quot;
  },
  &amp;quot;engines&amp;quot;: {
    &amp;quot;bun&amp;quot;: &amp;quot;&amp;gt;&#x3D;1.0.0&amp;quot;
  },
  &amp;quot;keywords&amp;quot;: [
    &amp;quot;arbiter&amp;quot;,
    &amp;quot;shared&amp;quot;,
    &amp;quot;types&amp;quot;,
    &amp;quot;utilities&amp;quot;
  ],
  &amp;quot;author&amp;quot;: &amp;quot;Nathan Rice&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;@arbiter/shared-types&amp;quot;: &amp;quot;workspace:*&amp;quot;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-118">
                <div class="file-header">ğŸ“„ biome.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;$schema&amp;quot;: &amp;quot;https://biomejs.dev/schemas/1.9.4/schema.json&amp;quot;,
  &amp;quot;linter&amp;quot;: {
    &amp;quot;enabled&amp;quot;: true,
    &amp;quot;rules&amp;quot;: {
      &amp;quot;recommended&amp;quot;: false,
      &amp;quot;suspicious&amp;quot;: {
        &amp;quot;noExplicitAny&amp;quot;: &amp;quot;off&amp;quot;,
        &amp;quot;noArrayIndexKey&amp;quot;: &amp;quot;off&amp;quot;
      },
      &amp;quot;style&amp;quot;: {
        &amp;quot;noNonNullAssertion&amp;quot;: &amp;quot;off&amp;quot;,
        &amp;quot;useTemplate&amp;quot;: &amp;quot;off&amp;quot;
      },
      &amp;quot;complexity&amp;quot;: {
        &amp;quot;noForEach&amp;quot;: &amp;quot;off&amp;quot;,
        &amp;quot;noStaticOnlyClass&amp;quot;: &amp;quot;off&amp;quot;
      },
      &amp;quot;correctness&amp;quot;: {
        &amp;quot;useExhaustiveDependencies&amp;quot;: &amp;quot;off&amp;quot;
      }
    }
  },
  &amp;quot;formatter&amp;quot;: {
    &amp;quot;enabled&amp;quot;: true,
    &amp;quot;formatWithErrors&amp;quot;: false,
    &amp;quot;indentStyle&amp;quot;: &amp;quot;space&amp;quot;,
    &amp;quot;indentWidth&amp;quot;: 2,
    &amp;quot;lineWidth&amp;quot;: 100,
    &amp;quot;lineEnding&amp;quot;: &amp;quot;lf&amp;quot;
  },
  &amp;quot;javascript&amp;quot;: {
    &amp;quot;formatter&amp;quot;: {
      &amp;quot;jsxQuoteStyle&amp;quot;: &amp;quot;double&amp;quot;,
      &amp;quot;quoteProperties&amp;quot;: &amp;quot;asNeeded&amp;quot;,
      &amp;quot;trailingCommas&amp;quot;: &amp;quot;all&amp;quot;,
      &amp;quot;semicolons&amp;quot;: &amp;quot;always&amp;quot;,
      &amp;quot;arrowParentheses&amp;quot;: &amp;quot;always&amp;quot;,
      &amp;quot;bracketSpacing&amp;quot;: true,
      &amp;quot;bracketSameLine&amp;quot;: false,
      &amp;quot;quoteStyle&amp;quot;: &amp;quot;double&amp;quot;
    },
    &amp;quot;globals&amp;quot;: [
      &amp;quot;describe&amp;quot;,
      &amp;quot;it&amp;quot;,
      &amp;quot;expect&amp;quot;,
      &amp;quot;beforeAll&amp;quot;,
      &amp;quot;afterAll&amp;quot;,
      &amp;quot;beforeEach&amp;quot;,
      &amp;quot;afterEach&amp;quot;,
      &amp;quot;test&amp;quot;,
      &amp;quot;vi&amp;quot;,
      &amp;quot;pending&amp;quot;,
      &amp;quot;Bun&amp;quot;,
      &amp;quot;process&amp;quot;,
      &amp;quot;console&amp;quot;,
      &amp;quot;Buffer&amp;quot;
    ]
  },
  &amp;quot;files&amp;quot;: {
    &amp;quot;include&amp;quot;: [
      &amp;quot;apps/**/*.ts&amp;quot;,
      &amp;quot;apps/**/*.js&amp;quot;,
      &amp;quot;apps/**/*.mjs&amp;quot;,
      &amp;quot;packages/**/*.ts&amp;quot;,
      &amp;quot;packages/**/*.js&amp;quot;,
      &amp;quot;packages/**/*.mjs&amp;quot;,
      &amp;quot;scripts/**/*.ts&amp;quot;,
      &amp;quot;scripts/**/*.js&amp;quot;,
      &amp;quot;scripts/**/*.mjs&amp;quot;,
      &amp;quot;*.ts&amp;quot;,
      &amp;quot;*.js&amp;quot;,
      &amp;quot;*.mjs&amp;quot;
    ],
    &amp;quot;ignore&amp;quot;: [
      &amp;quot;**/dist/**&amp;quot;,
      &amp;quot;**/node_modules/**&amp;quot;,
      &amp;quot;apps/web/frontend/dist/**&amp;quot;,
      &amp;quot;packages/cli/dist/**&amp;quot;,
      &amp;quot;arbiter-cli&amp;quot;,
      &amp;quot;packages/arbiter-core/src/handlers/ai/examples/custom-agent.js&amp;quot;
    ],
    &amp;quot;ignoreUnknown&amp;quot;: true,
    &amp;quot;maxSize&amp;quot;: 10485760
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-119">
                <div class="file-header">ğŸ“„ apps/web/frontend/tsconfig.node.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;tsBuildInfoFile&amp;quot;: &amp;quot;./node_modules/.tmp/tsconfig.node.tsbuildinfo&amp;quot;,
    &amp;quot;target&amp;quot;: &amp;quot;ES2023&amp;quot;,
    &amp;quot;lib&amp;quot;: [&amp;quot;ES2023&amp;quot;],
    &amp;quot;module&amp;quot;: &amp;quot;ESNext&amp;quot;,
    &amp;quot;skipLibCheck&amp;quot;: true,

    /* Bundler mode */
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;bundler&amp;quot;,
    &amp;quot;allowImportingTsExtensions&amp;quot;: true,
    &amp;quot;verbatimModuleSyntax&amp;quot;: true,
    &amp;quot;moduleDetection&amp;quot;: &amp;quot;force&amp;quot;,
    &amp;quot;noEmit&amp;quot;: true,

    /* Linting */
    &amp;quot;strict&amp;quot;: true,
    &amp;quot;noUnusedLocals&amp;quot;: true,
    &amp;quot;noUnusedParameters&amp;quot;: true,
    &amp;quot;erasableSyntaxOnly&amp;quot;: true,
    &amp;quot;noFallthroughCasesInSwitch&amp;quot;: true,
    &amp;quot;noUncheckedSideEffectImports&amp;quot;: true
  },
  &amp;quot;include&amp;quot;: [&amp;quot;vite.config.ts&amp;quot;]
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-120">
                <div class="file-header">ğŸ“„ packages/api-types/package.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;name&amp;quot;: &amp;quot;@arbiter/api-types&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;Shared TypeScript types for Arbiter API&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;./dist/index.js&amp;quot;,
  &amp;quot;types&amp;quot;: &amp;quot;./dist/index.d.ts&amp;quot;,
  &amp;quot;exports&amp;quot;: {
    &amp;quot;.&amp;quot;: {
      &amp;quot;import&amp;quot;: &amp;quot;./dist/index.js&amp;quot;,
      &amp;quot;types&amp;quot;: &amp;quot;./dist/index.d.ts&amp;quot;
    }
  },
  &amp;quot;files&amp;quot;: [
    &amp;quot;dist&amp;quot;,
    &amp;quot;src&amp;quot;
  ],
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;build&amp;quot;: &amp;quot;tsc&amp;quot;,
    &amp;quot;clean&amp;quot;: &amp;quot;rm -rf dist&amp;quot;,
    &amp;quot;typecheck&amp;quot;: &amp;quot;tsc --noEmit&amp;quot;,
    &amp;quot;dev&amp;quot;: &amp;quot;tsc --watch&amp;quot;
  },
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;typescript&amp;quot;: &amp;quot;^5.3.3&amp;quot;
  },
  &amp;quot;keywords&amp;quot;: [
    &amp;quot;arbiter&amp;quot;,
    &amp;quot;api&amp;quot;,
    &amp;quot;types&amp;quot;,
    &amp;quot;typescript&amp;quot;
  ],
  &amp;quot;author&amp;quot;: &amp;quot;Nathan Rice&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;hono&amp;quot;: &amp;quot;^4.9.8&amp;quot;,
    &amp;quot;@arbiter/shared-types&amp;quot;: &amp;quot;workspace:*&amp;quot;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-121">
                <div class="file-header">ğŸ“„ packages/cli/tsconfig.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;extends&amp;quot;: &amp;quot;../../tsconfig.json&amp;quot;,
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;outDir&amp;quot;: &amp;quot;./dist&amp;quot;,
    &amp;quot;rootDir&amp;quot;: &amp;quot;./src&amp;quot;,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;bundler&amp;quot;,
    &amp;quot;target&amp;quot;: &amp;quot;ES2022&amp;quot;,
    &amp;quot;module&amp;quot;: &amp;quot;ESNext&amp;quot;,
    &amp;quot;declaration&amp;quot;: true,
    &amp;quot;declarationMap&amp;quot;: true,
    &amp;quot;sourceMap&amp;quot;: true,
    &amp;quot;esModuleInterop&amp;quot;: true,
    &amp;quot;allowSyntheticDefaultImports&amp;quot;: true,
    &amp;quot;strict&amp;quot;: false,
    &amp;quot;noImplicitAny&amp;quot;: false,
    &amp;quot;noImplicitReturns&amp;quot;: false,
    &amp;quot;noImplicitThis&amp;quot;: false,
    &amp;quot;noUnusedLocals&amp;quot;: false,
    &amp;quot;noUnusedParameters&amp;quot;: false,
    &amp;quot;skipLibCheck&amp;quot;: true,
    &amp;quot;forceConsistentCasingInFileNames&amp;quot;: true,
    &amp;quot;resolveJsonModule&amp;quot;: true,
    &amp;quot;noEmit&amp;quot;: false,
    &amp;quot;types&amp;quot;: [
      &amp;quot;node&amp;quot;,
      &amp;quot;bun-types&amp;quot;
    ],
    &amp;quot;composite&amp;quot;: true,
    &amp;quot;baseUrl&amp;quot;: &amp;quot;.&amp;quot;,
    &amp;quot;paths&amp;quot;: {
      &amp;quot;@arbiter/shared&amp;quot;: [
        &amp;quot;../shared/src/index.ts&amp;quot;
      ],
      &amp;quot;@arbiter/shared/*&amp;quot;: [
        &amp;quot;../shared/src/*&amp;quot;
      ],
      &amp;quot;@/*&amp;quot;: [
        &amp;quot;./src/*&amp;quot;
      ],
      &amp;quot;@/commands/*&amp;quot;: [
        &amp;quot;./src/commands/*&amp;quot;
      ],
      &amp;quot;@/templates/*&amp;quot;: [
        &amp;quot;./src/templates/*&amp;quot;
      ],
      &amp;quot;@/cue/*&amp;quot;: [
        &amp;quot;./src/cue/*&amp;quot;
      ],
      &amp;quot;@/types&amp;quot;: [
        &amp;quot;./src/types.ts&amp;quot;
      ],
      &amp;quot;@/config&amp;quot;: [
        &amp;quot;./src/config.ts&amp;quot;
      ],
      &amp;quot;@arbiter/core&amp;quot;: [
        &amp;quot;../arbiter-core/src/index.ts&amp;quot;
      ],
      &amp;quot;@arbiter/core/*&amp;quot;: [
        &amp;quot;../arbiter-core/src/*&amp;quot;
      ]
    }
  },
  &amp;quot;references&amp;quot;: [
    {
      &amp;quot;path&amp;quot;: &amp;quot;../shared&amp;quot;
    },
    {
      &amp;quot;path&amp;quot;: &amp;quot;../arbiter-core&amp;quot;
    }
  ],
  &amp;quot;include&amp;quot;: [
    &amp;quot;src/**/*&amp;quot;
  ],
  &amp;quot;exclude&amp;quot;: [
    &amp;quot;node_modules&amp;quot;,
    &amp;quot;dist&amp;quot;,
    &amp;quot;**/*.test.ts&amp;quot;
  ]
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-122">
                <div class="file-header">ğŸ“„ apps/web/frontend/tsconfig.app.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;tsBuildInfoFile&amp;quot;: &amp;quot;./node_modules/.tmp/tsconfig.app.tsbuildinfo&amp;quot;,
    &amp;quot;target&amp;quot;: &amp;quot;ES2022&amp;quot;,
    &amp;quot;useDefineForClassFields&amp;quot;: true,
    &amp;quot;lib&amp;quot;: [&amp;quot;ES2022&amp;quot;, &amp;quot;DOM&amp;quot;, &amp;quot;DOM.Iterable&amp;quot;],
    &amp;quot;module&amp;quot;: &amp;quot;ESNext&amp;quot;,
    &amp;quot;skipLibCheck&amp;quot;: true,

    /* Bundler mode */
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;bundler&amp;quot;,
    &amp;quot;allowImportingTsExtensions&amp;quot;: true,
    &amp;quot;verbatimModuleSyntax&amp;quot;: true,
    &amp;quot;moduleDetection&amp;quot;: &amp;quot;force&amp;quot;,
    &amp;quot;noEmit&amp;quot;: true,
    &amp;quot;jsx&amp;quot;: &amp;quot;react-jsx&amp;quot;,

    /* Linting */
    &amp;quot;strict&amp;quot;: true,
    &amp;quot;noUncheckedIndexedAccess&amp;quot;: true,
    &amp;quot;exactOptionalPropertyTypes&amp;quot;: true,
    &amp;quot;noImplicitReturns&amp;quot;: true,
    &amp;quot;noUnusedLocals&amp;quot;: true,
    &amp;quot;noUnusedParameters&amp;quot;: true,
    &amp;quot;erasableSyntaxOnly&amp;quot;: true,
    &amp;quot;noFallthroughCasesInSwitch&amp;quot;: true,
    &amp;quot;noUncheckedSideEffectImports&amp;quot;: true
  },
  &amp;quot;include&amp;quot;: [&amp;quot;src&amp;quot;]
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-123">
                <div class="file-header">ğŸ“„ packages/api-types/tsconfig.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;extends&amp;quot;: &amp;quot;../../tsconfig.json&amp;quot;,
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;outDir&amp;quot;: &amp;quot;./dist&amp;quot;,
    &amp;quot;rootDir&amp;quot;: &amp;quot;./src&amp;quot;,
    &amp;quot;declaration&amp;quot;: true,
    &amp;quot;declarationMap&amp;quot;: true,
    &amp;quot;sourceMap&amp;quot;: true,
    &amp;quot;composite&amp;quot;: true
  },
  &amp;quot;include&amp;quot;: [
    &amp;quot;src/**/*&amp;quot;
  ],
  &amp;quot;exclude&amp;quot;: [
    &amp;quot;dist&amp;quot;,
    &amp;quot;node_modules&amp;quot;
  ],
  &amp;quot;references&amp;quot;: [
    {
      &amp;quot;path&amp;quot;: &amp;quot;../shared-types&amp;quot;
    }
  ]
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-124">
                <div class="file-header">ğŸ“„ .prettierrc.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;semi&amp;quot;: true,
  &amp;quot;trailingComma&amp;quot;: &amp;quot;es5&amp;quot;,
  &amp;quot;singleQuote&amp;quot;: true,
  &amp;quot;printWidth&amp;quot;: 100,
  &amp;quot;tabWidth&amp;quot;: 2,
  &amp;quot;useTabs&amp;quot;: false,
  &amp;quot;quoteProps&amp;quot;: &amp;quot;as-needed&amp;quot;,
  &amp;quot;bracketSpacing&amp;quot;: true,
  &amp;quot;bracketSameLine&amp;quot;: false,
  &amp;quot;arrowParens&amp;quot;: &amp;quot;avoid&amp;quot;,
  &amp;quot;endOfLine&amp;quot;: &amp;quot;lf&amp;quot;,
  &amp;quot;overrides&amp;quot;: [
    {
      &amp;quot;files&amp;quot;: [&amp;quot;*.json&amp;quot;, &amp;quot;*.jsonc&amp;quot;],
      &amp;quot;options&amp;quot;: {
        &amp;quot;printWidth&amp;quot;: 80,
        &amp;quot;tabWidth&amp;quot;: 2
      }
    },
    {
      &amp;quot;files&amp;quot;: [&amp;quot;*.md&amp;quot;, &amp;quot;*.mdx&amp;quot;],
      &amp;quot;options&amp;quot;: {
        &amp;quot;printWidth&amp;quot;: 80,
        &amp;quot;proseWrap&amp;quot;: &amp;quot;always&amp;quot;
      }
    },
    {
      &amp;quot;files&amp;quot;: [&amp;quot;*.yml&amp;quot;, &amp;quot;*.yaml&amp;quot;],
      &amp;quot;options&amp;quot;: {
        &amp;quot;printWidth&amp;quot;: 80,
        &amp;quot;tabWidth&amp;quot;: 2
      }
    }
  ]
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-125">
                <div class="file-header">ğŸ“„ tsconfig.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;ES2022&amp;quot;,
    &amp;quot;module&amp;quot;: &amp;quot;ESNext&amp;quot;,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;bundler&amp;quot;,
    &amp;quot;strict&amp;quot;: true,
    &amp;quot;esModuleInterop&amp;quot;: true,
    &amp;quot;skipLibCheck&amp;quot;: true,
    &amp;quot;forceConsistentCasingInFileNames&amp;quot;: true,
    &amp;quot;composite&amp;quot;: true,
    &amp;quot;baseUrl&amp;quot;: &amp;quot;.&amp;quot;,
    &amp;quot;paths&amp;quot;: {
      &amp;quot;@arbiter/shared&amp;quot;: [
        &amp;quot;./packages/shared/src&amp;quot;
      ],
      &amp;quot;@arbiter/cue-runner&amp;quot;: [
        &amp;quot;./packages/cue-runner/src&amp;quot;
      ],
      &amp;quot;@arbiter/cli&amp;quot;: [
        &amp;quot;./packages/cli/src&amp;quot;
      ],
      &amp;quot;@arbiter/api-types&amp;quot;: [
        &amp;quot;./packages/api-types/src&amp;quot;
      ],
      &amp;quot;@arbiter/core&amp;quot;: [
        &amp;quot;./packages/arbiter-core/src&amp;quot;
      ],
      &amp;quot;@arbiter/shared-types&amp;quot;: [
        &amp;quot;./packages/shared-types/src&amp;quot;
      ],
      &amp;quot;@arbiter/shared-types/*&amp;quot;: [
        &amp;quot;./packages/shared-types/src/*&amp;quot;
      ]
    }
  },
  &amp;quot;files&amp;quot;: [],
  &amp;quot;references&amp;quot;: [
    {
      &amp;quot;path&amp;quot;: &amp;quot;./packages/shared&amp;quot;
    },
    {
      &amp;quot;path&amp;quot;: &amp;quot;./packages/cue-runner&amp;quot;
    },
    {
      &amp;quot;path&amp;quot;: &amp;quot;./packages/shared-types&amp;quot;
    },
    {
      &amp;quot;path&amp;quot;: &amp;quot;./packages/cli&amp;quot;
    },
    {
      &amp;quot;path&amp;quot;: &amp;quot;./packages/arbiter-core&amp;quot;
    },
    {
      &amp;quot;path&amp;quot;: &amp;quot;./packages/api-types&amp;quot;
    },
    {
      &amp;quot;path&amp;quot;: &amp;quot;./apps/api&amp;quot;
    },
    {
      &amp;quot;path&amp;quot;: &amp;quot;./apps/web&amp;quot;
    }
  ],
  &amp;quot;exclude&amp;quot;: [
    &amp;quot;node_modules&amp;quot;,
    &amp;quot;dist&amp;quot;,
    &amp;quot;**/dist/**&amp;quot;,
    &amp;quot;**/node_modules/**&amp;quot;
  ]
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-126">
                <div class="file-header">ğŸ“„ packages/cli/example-templates.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;engines&amp;quot;: {
    &amp;quot;cookiecutter&amp;quot;: {
      &amp;quot;command&amp;quot;: &amp;quot;cookiecutter&amp;quot;,
      &amp;quot;defaultArgs&amp;quot;: [&amp;quot;--no-input&amp;quot;],
      &amp;quot;timeout&amp;quot;: 300000
    },
    &amp;quot;script&amp;quot;: {
      &amp;quot;command&amp;quot;: &amp;quot;sh&amp;quot;,
      &amp;quot;defaultArgs&amp;quot;: [],
      &amp;quot;timeout&amp;quot;: 60000
    }
  },
  &amp;quot;aliases&amp;quot;: {
    &amp;quot;bun-hono&amp;quot;: {
      &amp;quot;engine&amp;quot;: &amp;quot;cookiecutter&amp;quot;,
      &amp;quot;source&amp;quot;: &amp;quot;https://github.com/arbiter-templates/bun-hono.git&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;Bun + Hono API service with Drizzle ORM&amp;quot;,
      &amp;quot;variables&amp;quot;: {
        &amp;quot;project_name&amp;quot;: &amp;quot;{{cookiecutter.serviceName}}&amp;quot;,
        &amp;quot;use_typescript&amp;quot;: true,
        &amp;quot;use_drizzle&amp;quot;: true
      },
      &amp;quot;prerequisites&amp;quot;: [&amp;quot;bun&amp;quot;, &amp;quot;git&amp;quot;]
    },
    &amp;quot;rust-axum&amp;quot;: {
      &amp;quot;engine&amp;quot;: &amp;quot;cookiecutter&amp;quot;, 
      &amp;quot;source&amp;quot;: &amp;quot;gh:arbiter-templates/rust-axum&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;Rust + Axum service with SQLx&amp;quot;,
      &amp;quot;variables&amp;quot;: {
        &amp;quot;project_name&amp;quot;: &amp;quot;{{cookiecutter.serviceName}}&amp;quot;,
        &amp;quot;use_sqlx&amp;quot;: true,
        &amp;quot;use_tokio&amp;quot;: true
      },
      &amp;quot;prerequisites&amp;quot;: [&amp;quot;cargo&amp;quot;, &amp;quot;git&amp;quot;]
    },
    &amp;quot;react-vite&amp;quot;: {
      &amp;quot;engine&amp;quot;: &amp;quot;cookiecutter&amp;quot;,
      &amp;quot;source&amp;quot;: &amp;quot;/local/path/to/react-template&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;React + Vite frontend with Tailwind&amp;quot;,
      &amp;quot;variables&amp;quot;: {
        &amp;quot;project_name&amp;quot;: &amp;quot;{{cookiecutter.serviceName}}&amp;quot;,
        &amp;quot;use_typescript&amp;quot;: true,
        &amp;quot;use_tailwind&amp;quot;: true
      },
      &amp;quot;prerequisites&amp;quot;: [&amp;quot;node&amp;quot;, &amp;quot;npm&amp;quot;]
    },
    &amp;quot;python-fastapi&amp;quot;: {
      &amp;quot;engine&amp;quot;: &amp;quot;cookiecutter&amp;quot;,
      &amp;quot;source&amp;quot;: &amp;quot;https://github.com/fastapi-users/fastapi-users-cookiecutter.git&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;FastAPI service with async SQLAlchemy&amp;quot;,
      &amp;quot;variables&amp;quot;: {
        &amp;quot;project_name&amp;quot;: &amp;quot;{{cookiecutter.serviceName}}&amp;quot;,
        &amp;quot;use_async&amp;quot;: true,
        &amp;quot;use_sqlalchemy&amp;quot;: true
      },
      &amp;quot;prerequisites&amp;quot;: [&amp;quot;python3&amp;quot;, &amp;quot;pip&amp;quot;]
    },
    &amp;quot;postgres-setup&amp;quot;: {
      &amp;quot;engine&amp;quot;: &amp;quot;script&amp;quot;,
      &amp;quot;source&amp;quot;: &amp;quot;./scripts/setup-postgres.sh&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;PostgreSQL database setup with migrations&amp;quot;,
      &amp;quot;variables&amp;quot;: {
        &amp;quot;db_name&amp;quot;: &amp;quot;{{cookiecutter.databaseName}}&amp;quot;,
        &amp;quot;db_port&amp;quot;: 5432
      },
      &amp;quot;prerequisites&amp;quot;: [&amp;quot;psql&amp;quot;, &amp;quot;docker&amp;quot;]
    }
  },
  &amp;quot;settings&amp;quot;: {
    &amp;quot;defaultEngine&amp;quot;: &amp;quot;cookiecutter&amp;quot;,
    &amp;quot;cacheDir&amp;quot;: &amp;quot;~/.arbiter/template-cache&amp;quot;,
    &amp;quot;timeout&amp;quot;: 300000
  }
}</pre>
                </div>
            </div>
            <div class="file-section" id="file-127">
                <div class="file-header">ğŸ“„ demo-project/package.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;name&amp;quot;: &amp;quot;demo-project&amp;quot;,
  &amp;quot;private&amp;quot;: true,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.0&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;Application goals will be defined here&amp;quot;,
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;dev&amp;quot;: &amp;quot;vite&amp;quot;,
    &amp;quot;build&amp;quot;: &amp;quot;tsc &amp;amp;&amp;amp; vite build&amp;quot;,
    &amp;quot;preview&amp;quot;: &amp;quot;vite preview&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;vitest&amp;quot;,
    &amp;quot;test:ui&amp;quot;: &amp;quot;vitest --ui&amp;quot;,
    &amp;quot;lint&amp;quot;: &amp;quot;eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0&amp;quot;,
    &amp;quot;type-check&amp;quot;: &amp;quot;tsc --noEmit&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {},
  &amp;quot;devDependencies&amp;quot;: {},
  &amp;quot;engines&amp;quot;: {
    &amp;quot;node&amp;quot;: &amp;quot;&amp;gt;&#x3D;18.0.0&amp;quot;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-128">
                <div class="file-header">ğŸ“„ apps/api/tsconfig.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;extends&amp;quot;: &amp;quot;../../tsconfig.json&amp;quot;,
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;outDir&amp;quot;: &amp;quot;./dist&amp;quot;,
    &amp;quot;rootDir&amp;quot;: &amp;quot;./src&amp;quot;,
    &amp;quot;composite&amp;quot;: true,
    &amp;quot;noEmit&amp;quot;: false,
    &amp;quot;baseUrl&amp;quot;: &amp;quot;.&amp;quot;,
    &amp;quot;paths&amp;quot;: {
      &amp;quot;@arbiter/shared&amp;quot;: [
        &amp;quot;../../packages/shared/src/index.ts&amp;quot;
      ],
      &amp;quot;@arbiter/shared/*&amp;quot;: [
        &amp;quot;../../packages/shared/src/*&amp;quot;
      ],
      &amp;quot;@arbiter/core&amp;quot;: [
        &amp;quot;../../packages/arbiter-core/src/index.ts&amp;quot;
      ],
      &amp;quot;@arbiter/core/*&amp;quot;: [
        &amp;quot;../../packages/arbiter-core/src/*&amp;quot;
      ],
      &amp;quot;@arbiter/api-types&amp;quot;: [
        &amp;quot;../../packages/api-types/src/index.ts&amp;quot;
      ],
      &amp;quot;@arbiter/api-types/*&amp;quot;: [
        &amp;quot;../../packages/api-types/src/*&amp;quot;
      ]
    }
  },
  &amp;quot;references&amp;quot;: [
    {
      &amp;quot;path&amp;quot;: &amp;quot;../../packages/shared&amp;quot;
    },
    {
      &amp;quot;path&amp;quot;: &amp;quot;../../packages/arbiter-core&amp;quot;
    },
    {
      &amp;quot;path&amp;quot;: &amp;quot;../../packages/api-types&amp;quot;
    }
  ],
  &amp;quot;include&amp;quot;: [
    &amp;quot;src/**/*&amp;quot;
  ],
  &amp;quot;exclude&amp;quot;: [
    &amp;quot;node_modules&amp;quot;,
    &amp;quot;dist&amp;quot;,
    &amp;quot;**/*.test.ts&amp;quot;
  ]
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-129">
                <div class="file-header">ğŸ“„ docker-compose.yml</div>
                <div class="file-content">
                    <pre>version: &amp;#39;3.8&amp;#39;

services:
  # Spec Workbench Backend
  spec-workbench:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - &amp;#39;5050:5050&amp;#39;
    environment:
      - NODE_ENV&#x3D;development
      - PORT&#x3D;5050
      - NATS_URL&#x3D;nats://nats:4222
      - DATABASE_PATH&#x3D;/app/data/spec_workbench.db
    volumes:
      - ./data:/app/data
      - ./examples:/app/examples:ro
    depends_on:
      - nats
    networks:
      - spec-workbench

  # NATS Server for external agent communication
  nats:
    image: nats:2.10-alpine
    ports:
      - &amp;#39;4222:4222&amp;#39; # Client connections
      - &amp;#39;6222:6222&amp;#39; # Cluster connections
      - &amp;#39;8222:8222&amp;#39; # HTTP monitoring
    command:
      - &amp;#39;--cluster_name&#x3D;spec-workbench&amp;#39;
      - &amp;#39;--cluster&#x3D;nats://0.0.0.0:6222&amp;#39;
      - &amp;#39;--http_port&#x3D;8222&amp;#39;
      - &amp;#39;--port&#x3D;4222&amp;#39;
      - &amp;#39;--server_name&#x3D;nats-server&amp;#39;
    networks:
      - spec-workbench

  # NATS Monitoring Dashboard (optional)
  nats-surveyor:
    image: natsio/nats-surveyor:latest
    ports:
      - &amp;#39;7777:7777&amp;#39;
    command:
      - &amp;#39;-s&amp;#39;
      - &amp;#39;http://nats:8222&amp;#39;
      - &amp;#39;-p&amp;#39;
      - &amp;#39;7777&amp;#39;
    depends_on:
      - nats
    networks:
      - spec-workbench

  # Example External Agent
  example-agent:
    build:
      context: .
      dockerfile: Dockerfile.agent
    environment:
      - NATS_URL&#x3D;nats://nats:4222
      - AGENT_NAME&#x3D;ExampleAnalysisAgent
    depends_on:
      - nats
      - spec-workbench
    networks:
      - spec-workbench
    profiles:
      - agents # Only start with --profile agents

networks:
  spec-workbench:
    driver: bridge

volumes:
  spec-data:
    driver: local
</pre>
                </div>
            </div>
            <div class="file-section" id="file-130">
                <div class="file-header">ğŸ“„ packages/shared/tsconfig.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;extends&amp;quot;: &amp;quot;../../tsconfig.json&amp;quot;,
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;outDir&amp;quot;: &amp;quot;./dist&amp;quot;,
    &amp;quot;rootDir&amp;quot;: &amp;quot;./src&amp;quot;,
    &amp;quot;declaration&amp;quot;: true,
    &amp;quot;declarationMap&amp;quot;: true,
    &amp;quot;composite&amp;quot;: true,
    &amp;quot;noEmit&amp;quot;: false
  },
  &amp;quot;include&amp;quot;: [
    &amp;quot;src/**/*&amp;quot;
  ],
  &amp;quot;exclude&amp;quot;: [
    &amp;quot;node_modules&amp;quot;,
    &amp;quot;dist&amp;quot;,
    &amp;quot;**/*.test.ts&amp;quot;
  ],
  &amp;quot;references&amp;quot;: [
    {
      &amp;quot;path&amp;quot;: &amp;quot;../shared-types&amp;quot;
    }
  ]
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-131">
                <div class="file-header">ğŸ“„ .arbiter/skald-config.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;enabled&amp;quot;: true,
  &amp;quot;storePath&amp;quot;: &amp;quot;/media/nathan/Seagate Hub/Projects/arbiter/.arbiter/survey/skald_feedback.db&amp;quot;,
  &amp;quot;invitePolicy&amp;quot;: {
    &amp;quot;error&amp;quot;: true,
    &amp;quot;timeout&amp;quot;: true,
    &amp;quot;p95_ms&amp;quot;: 100,
    &amp;quot;large_output_kb&amp;quot;: 0.1
  },
  &amp;quot;sampleNeutral&amp;quot;: 1,
  &amp;quot;ttlHours&amp;quot;: 168,
  &amp;quot;maxVerbosity&amp;quot;: true,
  &amp;quot;alwaysReport&amp;quot;: true
}</pre>
                </div>
            </div>
            <div class="file-section" id="file-132">
                <div class="file-header">ğŸ“„ .lintstagedrc.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;*.{ts,tsx,js,jsx,json,md,yml,yaml,css,scss}&amp;quot;: &amp;quot;bunx prettier --write&amp;quot;,
  &amp;quot;*.{ts,tsx,js,jsx}&amp;quot;: &amp;quot;bunx @biomejs/biome@1.9.4 check --write&amp;quot;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-133">
                <div class="file-header">ğŸ“„ demo-project/tsconfig.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;ES2022&amp;quot;,
    &amp;quot;lib&amp;quot;: [&amp;quot;ES2023&amp;quot;, &amp;quot;DOM&amp;quot;, &amp;quot;DOM.Iterable&amp;quot;],
    &amp;quot;module&amp;quot;: &amp;quot;ESNext&amp;quot;,
    &amp;quot;skipLibCheck&amp;quot;: true,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;bundler&amp;quot;,
    &amp;quot;allowImportingTsExtensions&amp;quot;: true,
    &amp;quot;resolveJsonModule&amp;quot;: true,
    &amp;quot;isolatedModules&amp;quot;: true,
    &amp;quot;noEmit&amp;quot;: true,
    &amp;quot;jsx&amp;quot;: &amp;quot;react-jsx&amp;quot;,
    &amp;quot;strict&amp;quot;: true,
    &amp;quot;noUnusedLocals&amp;quot;: true,
    &amp;quot;noUnusedParameters&amp;quot;: true,
    &amp;quot;noFallthroughCasesInSwitch&amp;quot;: true
  },
  &amp;quot;include&amp;quot;: [&amp;quot;src&amp;quot;],
  &amp;quot;references&amp;quot;: [
    {
      &amp;quot;path&amp;quot;: &amp;quot;./tsconfig.node.json&amp;quot;
    }
  ]
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-134">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/App.css</div>
                <div class="file-content">
                    <pre>#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-135">
                <div class="file-header">ğŸ“„ examples/sample-tasks.json</div>
                <div class="file-content">
                    <pre>[
  {
    &amp;quot;name&amp;quot;: &amp;quot;Design Epic and Task Schema&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;Create comprehensive CUE schemas for epic and task management with ordering support&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;feature&amp;quot;,
    &amp;quot;priority&amp;quot;: &amp;quot;high&amp;quot;,
    &amp;quot;order&amp;quot;: 0,
    &amp;quot;assignee&amp;quot;: &amp;quot;architect&amp;quot;,
    &amp;quot;acceptanceCriteria&amp;quot;: [
      &amp;quot;CUE schema validates epic structure&amp;quot;,
      &amp;quot;Task ordering is enforced&amp;quot;,
      &amp;quot;Dependencies are properly modeled&amp;quot;
    ]
  },
  {
    &amp;quot;name&amp;quot;: &amp;quot;Implement Sharded Storage&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;Create sharded CUE file storage architecture for better organization&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;feature&amp;quot;,
    &amp;quot;priority&amp;quot;: &amp;quot;high&amp;quot;,
    &amp;quot;order&amp;quot;: 1,
    &amp;quot;dependsOn&amp;quot;: [&amp;quot;design-epic-and-task-schema&amp;quot;],
    &amp;quot;assignee&amp;quot;: &amp;quot;backend-dev&amp;quot;,
    &amp;quot;acceptanceCriteria&amp;quot;: [
      &amp;quot;Files are sharded based on configurable limits&amp;quot;,
      &amp;quot;Manifest tracks shard contents&amp;quot;,
      &amp;quot;Cross-shard queries work correctly&amp;quot;
    ]
  },
  {
    &amp;quot;name&amp;quot;: &amp;quot;Add CLI Commands&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;Implement CLI commands for epic and task management&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;feature&amp;quot;,
    &amp;quot;priority&amp;quot;: &amp;quot;medium&amp;quot;,
    &amp;quot;order&amp;quot;: 2,
    &amp;quot;dependsOn&amp;quot;: [&amp;quot;implement-sharded-storage&amp;quot;],
    &amp;quot;assignee&amp;quot;: &amp;quot;frontend-dev&amp;quot;,
    &amp;quot;acceptanceCriteria&amp;quot;: [
      &amp;quot;Epic CRUD operations work&amp;quot;,
      &amp;quot;Task CRUD operations work&amp;quot;,
      &amp;quot;Batch task creation via JSON works&amp;quot;,
      &amp;quot;Proper error handling and validation&amp;quot;
    ]
  },
  {
    &amp;quot;name&amp;quot;: &amp;quot;Write Comprehensive Tests&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;Add unit and integration tests for all epic/task functionality&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;test&amp;quot;,
    &amp;quot;priority&amp;quot;: &amp;quot;medium&amp;quot;,
    &amp;quot;order&amp;quot;: 3,
    &amp;quot;dependsOn&amp;quot;: [&amp;quot;add-cli-commands&amp;quot;],
    &amp;quot;assignee&amp;quot;: &amp;quot;qa-engineer&amp;quot;,
    &amp;quot;acceptanceCriteria&amp;quot;: [
      &amp;quot;90%+ test coverage&amp;quot;,
      &amp;quot;Golden file tests for CLI output&amp;quot;,
      &amp;quot;Integration tests with actual CUE files&amp;quot;,
      &amp;quot;Error case testing&amp;quot;
    ]
  },
  {
    &amp;quot;name&amp;quot;: &amp;quot;Add Documentation&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;Create user documentation and examples for epic/task management&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;docs&amp;quot;,
    &amp;quot;priority&amp;quot;: &amp;quot;low&amp;quot;,
    &amp;quot;order&amp;quot;: 4,
    &amp;quot;dependsOn&amp;quot;: [&amp;quot;write-comprehensive-tests&amp;quot;],
    &amp;quot;assignee&amp;quot;: &amp;quot;technical-writer&amp;quot;,
    &amp;quot;acceptanceCriteria&amp;quot;: [
      &amp;quot;User guide for epic/task workflow&amp;quot;,
      &amp;quot;CLI command reference&amp;quot;,
      &amp;quot;JSON schema documentation for batch operations&amp;quot;,
      &amp;quot;Example workflows and use cases&amp;quot;
    ]
  },
  {
    &amp;quot;name&amp;quot;: &amp;quot;Performance Optimization&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;Optimize sharded storage performance and memory usage&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;refactor&amp;quot;,
    &amp;quot;priority&amp;quot;: &amp;quot;low&amp;quot;,
    &amp;quot;order&amp;quot;: 5,
    &amp;quot;canRunInParallel&amp;quot;: true,
    &amp;quot;assignee&amp;quot;: &amp;quot;performance-engineer&amp;quot;,
    &amp;quot;acceptanceCriteria&amp;quot;: [
      &amp;quot;Sub-100ms query times for typical operations&amp;quot;,
      &amp;quot;Memory usage scales linearly with shard count&amp;quot;,
      &amp;quot;Large epic/task lists handle smoothly&amp;quot;
    ]
  }
]
</pre>
                </div>
            </div>
            <div class="file-section" id="file-136">
                <div class="file-header">ğŸ“„ demo-project/src/main.tsx</div>
                <div class="file-content">
                    <pre>import React from &amp;#39;react&amp;#39;;
import ReactDOM from &amp;#39;react-dom/client&amp;#39;;
import App from &amp;#39;./App&amp;#39;;
import &amp;#39;./index.css&amp;#39;;

ReactDOM.createRoot(document.getElementById(&amp;#39;root&amp;#39;)!).render(
  &amp;lt;React.StrictMode&amp;gt;
    &amp;lt;App /&amp;gt;
  &amp;lt;/React.StrictMode&amp;gt;
);
</pre>
                </div>
            </div>
            <div class="file-section" id="file-137">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/types/ui.ts</div>
                <div class="file-content">
                    <pre>/**
 * UI-specific types for frontend state management
 */

import type {
  Fragment,
  GapSet,
  IRResponse,
  Project,
  ValidationError,
  ValidationWarning,
} from &amp;#39;./api&amp;#39;;

// Application state
export interface AppState {
  // Core data
  currentProject: Project | null;
  projects: Project[];
  fragments: Fragment[];
  resolved: Record&amp;lt;string, unknown&amp;gt; | null;
  gaps: GapSet | null;
  irs: Record&amp;lt;string, IRResponse&amp;gt;;

  // UI state
  activeFragmentId: string | null;
  isLoading: boolean;
  error: string | null;

  // Editor state
  unsavedChanges: Set&amp;lt;string&amp;gt;;
  editorContent: Record&amp;lt;string, string&amp;gt;;

  // Connection state
  isConnected: boolean;
  reconnectAttempts: number;
  lastSync: string | null;

  // Validation state
  validationErrors: ValidationError[];
  validationWarnings: ValidationWarning[];
  isValidating: boolean;
  lastValidation: string | null;
  specHash: string | null;

  // CUE file state
  selectedCueFile: string | null;
  availableCueFiles: string[];
}

// Tab types - separate left and right tab groups
export type LeftTab &#x3D; &amp;#39;source&amp;#39; | &amp;#39;friendly&amp;#39;;
export type RightTab &#x3D;
  | &amp;#39;flow&amp;#39;
  | &amp;#39;site&amp;#39;
  | &amp;#39;fsm&amp;#39;
  | &amp;#39;view&amp;#39;
  | &amp;#39;gaps&amp;#39;
  | &amp;#39;resolved&amp;#39;
  | &amp;#39;architecture&amp;#39;
  | &amp;#39;handlers&amp;#39;;

// Legacy type for backwards compatibility
export type DiagramTab &#x3D; LeftTab | RightTab;

// UI actions
export type AppAction &#x3D;
  | { type: &amp;#39;SET_PROJECT&amp;#39;; payload: Project | null }
  | { type: &amp;#39;SET_PROJECTS&amp;#39;; payload: Project[] }
  | { type: &amp;#39;SET_CURRENT_PROJECT&amp;#39;; payload: Project }
  | { type: &amp;#39;SET_FRAGMENTS&amp;#39;; payload: Fragment[] }
  | { type: &amp;#39;UPDATE_FRAGMENT&amp;#39;; payload: Fragment }
  | { type: &amp;#39;DELETE_FRAGMENT&amp;#39;; payload: string }
  | { type: &amp;#39;SET_RESOLVED&amp;#39;; payload: { resolved: Record&amp;lt;string, unknown&amp;gt;; specHash: string } }
  | { type: &amp;#39;SET_GAPS&amp;#39;; payload: GapSet }
  | { type: &amp;#39;SET_IR&amp;#39;; payload: { kind: string; data: IRResponse } }
  | { type: &amp;#39;SET_ACTIVE_FRAGMENT&amp;#39;; payload: string | null }
  | { type: &amp;#39;SET_LOADING&amp;#39;; payload: boolean }
  | { type: &amp;#39;SET_ERROR&amp;#39;; payload: string | null }
  | { type: &amp;#39;SET_EDITOR_CONTENT&amp;#39;; payload: { fragmentId: string; content: string } }
  | { type: &amp;#39;MARK_UNSAVED&amp;#39;; payload: string }
  | { type: &amp;#39;MARK_SAVED&amp;#39;; payload: string }
  | { type: &amp;#39;SET_CONNECTION_STATUS&amp;#39;; payload: boolean }
  | { type: &amp;#39;INCREMENT_RECONNECT_ATTEMPTS&amp;#39; }
  | { type: &amp;#39;RESET_RECONNECT_ATTEMPTS&amp;#39; }
  | { type: &amp;#39;SET_LAST_SYNC&amp;#39;; payload: string }
  | {
      type: &amp;#39;SET_VALIDATION_STATE&amp;#39;;
      payload: {
        errors: ValidationError[];
        warnings: ValidationWarning[];
        isValidating: boolean;
        lastValidation: string | null;
        specHash: string | null;
      };
    }
  | { type: &amp;#39;SET_SELECTED_CUE_FILE&amp;#39;; payload: string | null }
  | { type: &amp;#39;SET_AVAILABLE_CUE_FILES&amp;#39;; payload: string[] };

// Component props
export interface SplitPaneProps {
  children: [React.ReactNode, React.ReactNode];
  defaultSize?: number | string;
  minSize?: number | string;
  maxSize?: number | string;
  allowResize?: boolean;
  split?: &amp;#39;vertical&amp;#39; | &amp;#39;horizontal&amp;#39;;
  className?: string;
}

export interface TabsProps {
  activeTab: string;
  onTabChange: (tab: string) &#x3D;&amp;gt; void;
  tabs: TabItem[];
  className?: string;
}

export interface TabItem {
  id: string;
  label: string;
  content: React.ReactNode;
  disabled?: boolean;
  badge?: string | number;
}

// File tree types
export interface FileTreeItem {
  id: string;
  path: string;
  type: &amp;#39;file&amp;#39; | &amp;#39;directory&amp;#39;;
  children?: FileTreeItem[];
  hasUnsavedChanges?: boolean;
}

// Monaco editor types
export interface EditorProps {
  value: string;
  onChange: (value: string) &#x3D;&amp;gt; void;
  onSave?: () &#x3D;&amp;gt; void;
  language?: string;
  theme?: string;
  options?: any;
  className?: string;
}

// Diagram renderer types
export interface DiagramRendererProps {
  data: any;
  loading?: boolean;
  error?: string;
  className?: string;
}

export interface MermaidDiagramProps extends DiagramRendererProps {
  data: string; // Mermaid text
}

export interface GraphvizDiagramProps extends DiagramRendererProps {
  data: string; // DOT notation
}

export interface ExcalidrawDiagramProps extends DiagramRendererProps {
  data: any; // Excalidraw scene data
  onDataChange?: (data: any) &#x3D;&amp;gt; void;
}

// Toast notification types
export interface ToastNotification {
  id: string;
  type: &amp;#39;info&amp;#39; | &amp;#39;success&amp;#39; | &amp;#39;warning&amp;#39; | &amp;#39;error&amp;#39;;
  message: string;
  duration?: number;
  timestamp: string;
  user?: string;
}

// WebSocket connection types
export interface WebSocketState {
  isConnected: boolean;
  reconnectAttempts: number;
  lastPing: string | null;
  connectionId: string | null;
}

// Worker message types
export interface WorkerMessage {
  id: string;
  type: &amp;#39;render&amp;#39; | &amp;#39;response&amp;#39; | &amp;#39;error&amp;#39;;
  data: any;
}

export interface WorkerResponse extends WorkerMessage {
  type: &amp;#39;response&amp;#39;;
  success: boolean;
  result?: any;
  error?: string;
  duration?: number;
}

// Coverage meter types
export interface CoverageMeterProps {
  label: string;
  current: number;
  target: number;
  unit?: string;
  showPercentage?: boolean;
  className?: string;
}

// Interactive gaps types
export interface GapItemProps {
  type: &amp;#39;missing_capability&amp;#39; | &amp;#39;orphaned_token&amp;#39; | &amp;#39;coverage_gap&amp;#39; | &amp;#39;duplicate&amp;#39;;
  data: any;
  onResolve?: (id: string) &#x3D;&amp;gt; void;
  onNavigate?: (location: string) &#x3D;&amp;gt; void;
}

// Performance monitoring types
export interface PerformanceMetrics {
  initialLoadTime: number;
  wsEventProcessingTime: number;
  diagramRenderTime: Record&amp;lt;string, number&amp;gt;;
  editorResponseTime: number;
  lastMeasured: string;
}

// Cache types
export interface CacheEntry&amp;lt;T &#x3D; any&amp;gt; {
  data: T;
  timestamp: string;
  specHash: string;
  expiresAt?: string;
}

export interface CacheManager {
  get&amp;lt;T&amp;gt;(key: string): CacheEntry&amp;lt;T&amp;gt; | null;
  set&amp;lt;T&amp;gt;(key: string, data: T, specHash: string, ttl?: number): void;
  invalidate(specHash: string): void;
  clear(): void;
}

// Error boundary types
export interface ErrorInfo {
  componentStack: string;
  errorBoundary?: string;
}

export interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-138">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/Layout/SplitPane.tsx</div>
                <div class="file-content">
                    <pre>/**
 * Resizable split pane component
 */

import React, { useState, useRef, useEffect, useCallback } from &amp;#39;react&amp;#39;;
import { clsx } from &amp;#39;clsx&amp;#39;;
import type { SplitPaneProps } from &amp;#39;../../types/ui&amp;#39;;

export function SplitPane({
  children,
  defaultSize &#x3D; &amp;#39;50%&amp;#39;,
  minSize &#x3D; &amp;#39;200px&amp;#39;,
  maxSize &#x3D; &amp;#39;80%&amp;#39;,
  allowResize &#x3D; true,
  split &#x3D; &amp;#39;vertical&amp;#39;,
  className,
}: SplitPaneProps) {
  const [size, setSize] &#x3D; useState&amp;lt;string&amp;gt;(
    typeof defaultSize &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39; ? defaultSize : &#x60;${defaultSize}px&#x60;
  );
  const [isDragging, setIsDragging] &#x3D; useState(false);

  const containerRef &#x3D; useRef&amp;lt;HTMLDivElement&amp;gt;(null);
  const resizerRef &#x3D; useRef&amp;lt;HTMLDivElement&amp;gt;(null);

  // Convert size to pixels for calculations
  const getPixelSize &#x3D; useCallback((sizeStr: string, containerSize: number): number &#x3D;&amp;gt; {
    if (sizeStr.endsWith(&amp;#39;%&amp;#39;)) {
      return (parseFloat(sizeStr) / 100) * containerSize;
    }
    return parseFloat(sizeStr);
  }, []);

  // Handle mouse down on resizer
  const handleMouseDown &#x3D; useCallback(
    (e: React.MouseEvent) &#x3D;&amp;gt; {
      if (!allowResize) return;

      e.preventDefault();
      setIsDragging(true);
    },
    [allowResize]
  );

  // Handle mouse move during drag
  useEffect(() &#x3D;&amp;gt; {
    if (!isDragging || !containerRef.current) return;

    const handleMouseMove &#x3D; (e: MouseEvent) &#x3D;&amp;gt; {
      if (!containerRef.current) return;

      const containerRect &#x3D; containerRef.current.getBoundingClientRect();
      const containerSize &#x3D; split &#x3D;&#x3D;&#x3D; &amp;#39;vertical&amp;#39; ? containerRect.width : containerRect.height;
      const offset &#x3D;
        split &#x3D;&#x3D;&#x3D; &amp;#39;vertical&amp;#39; ? e.clientX - containerRect.left : e.clientY - containerRect.top;

      // Calculate percentage
      const percentage &#x3D; (offset / containerSize) * 100;

      // Apply constraints
      const minPixels &#x3D; getPixelSize(
        typeof minSize &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39; ? minSize : &#x60;${minSize}px&#x60;,
        containerSize
      );
      const maxPixels &#x3D; getPixelSize(
        typeof maxSize &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39; ? maxSize : &#x60;${maxSize}px&#x60;,
        containerSize
      );
      const minPercentage &#x3D; (minPixels / containerSize) * 100;
      const maxPercentage &#x3D; (maxPixels / containerSize) * 100;

      const clampedPercentage &#x3D; Math.max(minPercentage, Math.min(maxPercentage, percentage));
      setSize(&#x60;${clampedPercentage}%&#x60;);
    };

    const handleMouseUp &#x3D; () &#x3D;&amp;gt; {
      setIsDragging(false);
    };

    document.addEventListener(&amp;#39;mousemove&amp;#39;, handleMouseMove);
    document.addEventListener(&amp;#39;mouseup&amp;#39;, handleMouseUp);
    document.body.style.cursor &#x3D; split &#x3D;&#x3D;&#x3D; &amp;#39;vertical&amp;#39; ? &amp;#39;col-resize&amp;#39; : &amp;#39;row-resize&amp;#39;;
    document.body.style.userSelect &#x3D; &amp;#39;none&amp;#39;;

    return () &#x3D;&amp;gt; {
      document.removeEventListener(&amp;#39;mousemove&amp;#39;, handleMouseMove);
      document.removeEventListener(&amp;#39;mouseup&amp;#39;, handleMouseUp);
      document.body.style.cursor &#x3D; &amp;#39;&amp;#39;;
      document.body.style.userSelect &#x3D; &amp;#39;&amp;#39;;
    };
  }, [isDragging, split, getPixelSize, minSize, maxSize]);

  const isVertical &#x3D; split &#x3D;&#x3D;&#x3D; &amp;#39;vertical&amp;#39;;
  const [leftPane, rightPane] &#x3D; children;

  return (
    &amp;lt;div
      ref&#x3D;{containerRef}
      className&#x3D;{clsx(
        &amp;#39;flex h-full w-full overflow-hidden&amp;#39;,
        isVertical ? &amp;#39;flex-row&amp;#39; : &amp;#39;flex-col&amp;#39;,
        className
      )}
    &amp;gt;
      {/* First pane */}
      &amp;lt;div
        className&#x3D;&amp;quot;relative overflow-hidden&amp;quot;
        style&#x3D;{{
          [isVertical ? &amp;#39;width&amp;#39; : &amp;#39;height&amp;#39;]: size,
          [isVertical ? &amp;#39;height&amp;#39; : &amp;#39;width&amp;#39;]: &amp;#39;100%&amp;#39;,
        }}
      &amp;gt;
        {leftPane}
      &amp;lt;/div&amp;gt;

      {/* Resizer */}
      {allowResize &amp;amp;&amp;amp; (
        &amp;lt;div
          ref&#x3D;{resizerRef}
          className&#x3D;{clsx(
            &amp;#39;bg-gray-300 hover:bg-gray-400 transition-colors duration-150 flex-shrink-0&amp;#39;,
            isVertical ? &amp;#39;w-1 cursor-col-resize hover:w-2&amp;#39; : &amp;#39;h-1 cursor-row-resize hover:h-2&amp;#39;,
            isDragging &amp;amp;&amp;amp; (isVertical ? &amp;#39;w-2 bg-blue-500&amp;#39; : &amp;#39;h-2 bg-blue-500&amp;#39;)
          )}
          onMouseDown&#x3D;{handleMouseDown}
        /&amp;gt;
      )}

      {/* Second pane */}
      &amp;lt;div
        className&#x3D;&amp;quot;flex-1 overflow-hidden&amp;quot;
        style&#x3D;{{
          [isVertical ? &amp;#39;width&amp;#39; : &amp;#39;height&amp;#39;]: &#x60;calc(100% - ${size} - 4px)&#x60;,
        }}
      &amp;gt;
        {rightPane}
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}

export default SplitPane;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-139">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/diagrams/MermaidRenderer.tsx</div>
                <div class="file-content">
                    <pre>import React, { useEffect, useRef, useState } from &amp;#39;react&amp;#39;;
import mermaid from &amp;#39;mermaid&amp;#39;;
import { AlertCircle, RefreshCw } from &amp;#39;lucide-react&amp;#39;;

interface MermaidRendererProps {
  chart: string;
  className?: string;
  title?: string;
}

export const MermaidRenderer: React.FC&amp;lt;MermaidRendererProps&amp;gt; &#x3D; ({
  chart,
  className &#x3D; &amp;#39;&amp;#39;,
  title,
}) &#x3D;&amp;gt; {
  const containerRef &#x3D; useRef&amp;lt;HTMLDivElement&amp;gt;(null);
  const [error, setError] &#x3D; useState&amp;lt;string | null&amp;gt;(null);
  const [isLoading, setIsLoading] &#x3D; useState(true);

  useEffect(() &#x3D;&amp;gt; {
    // Initialize mermaid with modern configuration
    mermaid.initialize({
      startOnLoad: true,
      theme: &amp;#39;default&amp;#39;,
      securityLevel: &amp;#39;loose&amp;#39;,
      fontFamily: &amp;#39;Inter, system-ui, sans-serif&amp;#39;,
      flowchart: {
        useMaxWidth: true,
        htmlLabels: true,
        curve: &amp;#39;basis&amp;#39;,
        padding: 20,
      },
      sequence: {
        useMaxWidth: true,
        rightAngles: false,
        showSequenceNumbers: true,
      },
      gantt: {
        useMaxWidth: true,
        leftPadding: 75,
        gridLineStartPadding: 35,
        fontSize: 11,
      },
      state: {
        useMaxWidth: true,
      },
    });
  }, []);

  const renderChart &#x3D; async () &#x3D;&amp;gt; {
    if (!containerRef.current || !chart) return;

    try {
      setIsLoading(true);
      setError(null);

      // Clear previous content
      containerRef.current.innerHTML &#x3D; &amp;#39;&amp;#39;;

      // Generate unique ID for this diagram
      const diagramId &#x3D; &#x60;mermaid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}&#x60;;

      // Render the diagram
      const { svg } &#x3D; await mermaid.render(diagramId, chart);

      // Insert the SVG into the container
      containerRef.current.innerHTML &#x3D; svg;

      // Make sure the SVG is responsive
      const svgElement &#x3D; containerRef.current.querySelector(&amp;#39;svg&amp;#39;);
      if (svgElement) {
        svgElement.style.maxWidth &#x3D; &amp;#39;100%&amp;#39;;
        svgElement.style.height &#x3D; &amp;#39;auto&amp;#39;;
        svgElement.style.display &#x3D; &amp;#39;block&amp;#39;;
        svgElement.style.margin &#x3D; &amp;#39;0 auto&amp;#39;;
      }
    } catch (err) {
      console.error(&amp;#39;Failed to render mermaid diagram:&amp;#39;, err);
      setError(err instanceof Error ? err.message : &amp;#39;Failed to render diagram&amp;#39;);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() &#x3D;&amp;gt; {
    renderChart();
  }, [chart]);

  const handleRetry &#x3D; () &#x3D;&amp;gt; {
    renderChart();
  };

  if (isLoading) {
    return (
      &amp;lt;div className&#x3D;{&#x60;flex items-center justify-center min-h-[200px] ${className}&#x60;}&amp;gt;
        &amp;lt;div className&#x3D;&amp;quot;text-center&amp;quot;&amp;gt;
          &amp;lt;RefreshCw className&#x3D;&amp;quot;w-8 h-8 animate-spin text-blue-600 mx-auto mb-2&amp;quot; /&amp;gt;
          &amp;lt;p className&#x3D;&amp;quot;text-gray-600&amp;quot;&amp;gt;Rendering diagram...&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }

  if (error) {
    return (
      &amp;lt;div className&#x3D;{&#x60;flex items-center justify-center min-h-[200px] ${className}&#x60;}&amp;gt;
        &amp;lt;div className&#x3D;&amp;quot;text-center max-w-md&amp;quot;&amp;gt;
          &amp;lt;AlertCircle className&#x3D;&amp;quot;w-12 h-12 text-red-500 mx-auto mb-4&amp;quot; /&amp;gt;
          &amp;lt;h4 className&#x3D;&amp;quot;text-red-700 font-medium mb-2&amp;quot;&amp;gt;Diagram Render Error&amp;lt;/h4&amp;gt;
          &amp;lt;p className&#x3D;&amp;quot;text-red-600 text-sm mb-4&amp;quot;&amp;gt;{error}&amp;lt;/p&amp;gt;
          &amp;lt;button
            onClick&#x3D;{handleRetry}
            className&#x3D;&amp;quot;inline-flex items-center gap-2 px-4 py-2 bg-red-100 text-red-800 rounded-md hover:bg-red-200 transition-colors&amp;quot;
          &amp;gt;
            &amp;lt;RefreshCw className&#x3D;&amp;quot;w-4 h-4&amp;quot; /&amp;gt;
            Retry
          &amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }

  return (
    &amp;lt;div className&#x3D;{className}&amp;gt;
      {title &amp;amp;&amp;amp; &amp;lt;h4 className&#x3D;&amp;quot;text-sm font-semibold text-gray-700 mb-4 text-center&amp;quot;&amp;gt;{title}&amp;lt;/h4&amp;gt;}
      &amp;lt;div className&#x3D;&amp;quot;bg-white rounded-lg border border-gray-200 p-4&amp;quot;&amp;gt;
        &amp;lt;div
          ref&#x3D;{containerRef}
          className&#x3D;&amp;quot;mermaid-container flex items-center justify-center min-h-[200px]&amp;quot;
        /&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default MermaidRenderer;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-140">
                <div class="file-header">ğŸ“„ packages/cli/src/constraints/index.ts</div>
                <div class="file-content">
                    <pre>import { EventEmitter } from &amp;#39;node:events&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import type { CLIConfig } from &amp;#39;../types.js&amp;#39;;
import {
  ConstraintViolationError,
  type Constraints,
  DEFAULT_CONSTRAINTS,
  constrainedOperation,
  globalConstraintEnforcer,
} from &amp;#39;./core.js&amp;#39;;
import {
  type FileSystemOperation,
  bundleStandalone,
  copyStandalone,
  globalFileSystemConstraints,
  safeFileOperation,
} from &amp;#39;./filesystem.js&amp;#39;;
import {
  type IdempotentOperation,
  globalIdempotencyValidator,
  validateIdempotentEdits,
  withIdempotencyValidation,
} from &amp;#39;./idempotency.js&amp;#39;;
import {
  type SandboxValidator,
  type SandboxedOperation,
  createSandboxValidator,
  initializeSandboxConfig,
} from &amp;#39;./sandbox.js&amp;#39;;
import {
  LATEST_API_VERSION,
  ensureLatestSchema,
  globalSchemaValidator,
  validateReadData,
} from &amp;#39;./schema.js&amp;#39;;

/**
 * Comprehensive constraint violation summary
 */
export interface ConstraintViolationSummary {
  totalViolations: number;
  byConstraint: Record&amp;lt;string, number&amp;gt;;
  criticalViolations: string[];
  suggestions: string[];
  complianceRate: number;
}

/**
 * Constraint system status
 */
export interface ConstraintSystemStatus {
  isHealthy: boolean;
  constraints: Constraints;
  violations: ConstraintViolationSummary;
  sandbox: {
    activeOperations: number;
    complianceRate: number;
  };
  fileSystem: {
    symlinks: number;
    invalidPaths: number;
  };
  idempotency: {
    cacheSize: number;
    validations: number;
  };
  schema: {
    latestVersion: string;
    deprecatedWarnings: number;
  };
}

/**
 * Master constraint system that coordinates all constraint enforcement
 */
export class ConstraintSystem extends EventEmitter {
  private readonly config: CLIConfig;
  private readonly constraints: Constraints;
  private readonly sandboxValidator: SandboxValidator;
  private readonly violationCounts &#x3D; new Map&amp;lt;string, number&amp;gt;();

  constructor(config: CLIConfig, constraints: Partial&amp;lt;Constraints&amp;gt; &#x3D; {}) {
    super();

    this.config &#x3D; config;
    this.constraints &#x3D; { ...DEFAULT_CONSTRAINTS, ...constraints };
    this.sandboxValidator &#x3D; createSandboxValidator(config);

    // Initialize global configurations
    initializeSandboxConfig(config);

    // Set up event listeners for violation tracking
    this.setupViolationTracking();

    // Start background maintenance tasks
    this.startMaintenanceTasks();
  }

  /**
   * Execute any operation with comprehensive constraint enforcement
   */
  async executeWithConstraints&amp;lt;T&amp;gt;(
    operation: string,
    operationType: {
      sandbox?: SandboxedOperation;
      filesystem?: FileSystemOperation;
      idempotent?: IdempotentOperation;
    },
    executor: () &#x3D;&amp;gt; Promise&amp;lt;T&amp;gt;,
    metadata?: Record&amp;lt;string, unknown&amp;gt;
  ): Promise&amp;lt;T&amp;gt; {
    return constrainedOperation(
      operation,
      async () &#x3D;&amp;gt; {
        // Start sandbox tracking if applicable
        let sandboxOperationId: string | undefined;
        if (operationType.sandbox) {
          sandboxOperationId &#x3D; this.sandboxValidator.startOperation(operationType.sandbox);
        }

        try {
          let result: T;

          // Apply idempotency validation if needed
          if (operationType.idempotent) {
            result &#x3D; await withIdempotencyValidation(
              operationType.idempotent,
              { operation, metadata },
              executor
            );
          } else {
            result &#x3D; await executor();
          }

          // Validate result schema if it looks like API data
          if (this.isApiData(result)) {
            ensureLatestSchema(result);
          }

          return result;
        } finally {
          // End sandbox tracking
          if (operationType.sandbox &amp;amp;&amp;amp; sandboxOperationId) {
            this.sandboxValidator.endOperation(operationType.sandbox, sandboxOperationId);
          }
        }
      },
      metadata
    );
  }

  /**
   * Validate file operation with all relevant constraints
   */
  async validateFileOperation(
    operation: FileSystemOperation,
    filePaths: string[],
    operationId?: string
  ): Promise&amp;lt;void&amp;gt; {
    for (const filePath of filePaths) {
      await globalFileSystemConstraints.validatePath(filePath, operation, operationId);
    }
  }

  /**
   * Validate payload sizes for all files
   */
  private validateFilePayloads(files: Record&amp;lt;string, string&amp;gt;, operationId: string): void {
    for (const [_path, content] of Object.entries(files)) {
      globalConstraintEnforcer.validatePayloadSize(content, operationId);
    }
  }

  /**
   * Ensure schema compliance for JSON files
   */
  private ensureSchemaCompliance(files: Record&amp;lt;string, string&amp;gt;): void {
    for (const [_path, content] of Object.entries(files)) {
      try {
        const parsed &#x3D; JSON.parse(content);
        if (this.isApiData(parsed)) {
          ensureLatestSchema(parsed);
        }
      } catch {
        // Not JSON, skip schema validation
      }
    }
  }

  /**
   * Export files with constraint enforcement
   */
  async exportWithConstraints(
    files: Record&amp;lt;string, string&amp;gt;,
    outputDir: string,
    format?: string
  ): Promise&amp;lt;void&amp;gt; {
    const operationId &#x3D; this.startExportOperation(files, outputDir, format);

    try {
      await this.performConstrainedExport(files, outputDir, operationId);
    } finally {
      globalConstraintEnforcer.endOperation(operationId);
    }
  }

  /**
   * Start export operation with proper metadata tracking
   */
  private startExportOperation(
    files: Record&amp;lt;string, string&amp;gt;,
    outputDir: string,
    format?: string
  ): string {
    return globalConstraintEnforcer.startOperation(&amp;#39;constrained_export&amp;#39;, {
      fileCount: Object.keys(files).length,
      outputDir,
      format,
    });
  }

  /**
   * Perform the constrained export with all validation steps
   */
  private async performConstrainedExport(
    files: Record&amp;lt;string, string&amp;gt;,
    outputDir: string,
    operationId: string
  ): Promise&amp;lt;void&amp;gt; {
    this.validateFilePayloads(files, operationId);
    await this.executeFileSystemExport(files, outputDir, operationId);
    this.ensureSchemaCompliance(files);
  }

  /**
   * Execute the file system export operation
   */
  private async executeFileSystemExport(
    files: Record&amp;lt;string, string&amp;gt;,
    outputDir: string,
    operationId: string
  ): Promise&amp;lt;void&amp;gt; {
    await globalFileSystemConstraints.exportFiles(files, outputDir, operationId);
  }

  /**
   * Bundle files with constraint enforcement
   */
  async bundleWithConstraints(files: string[], outputDir: string): Promise&amp;lt;void&amp;gt; {
    const operationId &#x3D; globalConstraintEnforcer.startOperation(&amp;#39;constrained_bundle&amp;#39;, {
      fileCount: files.length,
      outputDir,
    });

    try {
      // Validate all file paths first
      await this.validateFileOperation(&amp;#39;bundle&amp;#39;, files, operationId);

      // Use standalone copy bundling (no symlinks)
      await bundleStandalone(files, outputDir, operationId);
    } finally {
      globalConstraintEnforcer.endOperation(operationId);
    }
  }

  /**
   * Validate API response with schema and payload constraints
   */
  validateApiResponse(data: unknown, operationId?: string): unknown {
    // Validate payload size
    globalConstraintEnforcer.validatePayloadSize(data, operationId);

    // Validate schema for read operations
    if (this.isApiData(data)) {
      return validateReadData(data, operationId);
    }

    return data;
  }

  /**
   * Get comprehensive constraint system status
   */
  getSystemStatus(): ConstraintSystemStatus {
    const _constraintStatus &#x3D; globalConstraintEnforcer.getConstraintStatus();
    const sandboxStatus &#x3D; this.sandboxValidator.getSandboxStatus();
    const fsStatus &#x3D; globalFileSystemConstraints.getConstraintStatus();
    const idempotencyStats &#x3D; globalIdempotencyValidator.getValidationStats();

    const totalViolations &#x3D; Array.from(this.violationCounts.values()).reduce((a, b) &#x3D;&amp;gt; a + b, 0);
    const complianceRate &#x3D; totalViolations &amp;gt; 0 ? Math.max(0, 100 - totalViolations * 10) : 100;

    return {
      isHealthy: totalViolations &#x3D;&#x3D;&#x3D; 0 &amp;amp;&amp;amp; complianceRate &amp;gt; 95,
      constraints: this.constraints,
      violations: {
        totalViolations,
        byConstraint: Object.fromEntries(this.violationCounts),
        criticalViolations: this.getCriticalViolations(),
        suggestions: this.getImprovementSuggestions(),
        complianceRate,
      },
      sandbox: {
        activeOperations: sandboxStatus.activeOperations.length,
        complianceRate: sandboxStatus.complianceRate,
      },
      fileSystem: {
        symlinks: fsStatus.violations.symlinks,
        invalidPaths: fsStatus.violations.invalidPaths,
      },
      idempotency: {
        cacheSize: idempotencyStats.cacheSize,
        validations: idempotencyStats.validations,
      },
      schema: {
        latestVersion: LATEST_API_VERSION,
        deprecatedWarnings: 0, // Would be tracked via events
      },
    };
  }

  /**
   * Generate constraint compliance report
   */
  generateComplianceReport(): string {
    const status &#x3D; this.getSystemStatus();
    const lines: string[] &#x3D; [];

    lines.push(chalk.bold(&amp;#39;ğŸ›¡ï¸  Constraint System Status&amp;#39;));
    lines.push(&amp;#39;&amp;#39;);

    // Overall health
    const healthColor &#x3D; status.isHealthy ? chalk.green : chalk.red;
    const healthStatus &#x3D; status.isHealthy ? &amp;#39;HEALTHY&amp;#39; : &amp;#39;VIOLATIONS DETECTED&amp;#39;;
    lines.push(&#x60;Overall Status: ${healthColor(healthStatus)}&#x60;);
    lines.push(&#x60;Compliance Rate: ${this.formatComplianceRate(status.violations.complianceRate)}&#x60;);
    lines.push(&amp;#39;&amp;#39;);

    // Constraint details
    lines.push(chalk.bold(&amp;#39;Constraint Limits:&amp;#39;));
    lines.push(&#x60;  Max Payload Size: ${this.formatBytes(status.constraints.maxPayloadSize)}&#x60;);
    lines.push(&#x60;  Max Operation Time: ${status.constraints.maxOperationTime}ms&#x60;);
    lines.push(
      &#x60;  Rate Limit: ${status.constraints.rateLimit.requests} req/${status.constraints.rateLimit.windowMs}ms&#x60;
    );
    lines.push(&#x60;  API Version: ${status.constraints.apiVersion}&#x60;);
    lines.push(&#x60;  Symlink Depth: ${status.constraints.maxSymlinkDepth} (symlinks forbidden)&#x60;);
    lines.push(&amp;#39;&amp;#39;);

    // Violations
    if (status.violations.totalViolations &amp;gt; 0) {
      lines.push(chalk.bold(chalk.red(&amp;#39;Violations:&amp;#39;)));
      for (const [constraint, count] of Object.entries(status.violations.byConstraint)) {
        if (count &amp;gt; 0) {
          lines.push(&#x60;  ${chalk.red(&amp;#39;âœ—&amp;#39;)} ${constraint}: ${count} violations&#x60;);
        }
      }

      if (status.violations.criticalViolations.length &amp;gt; 0) {
        lines.push(&amp;#39;&amp;#39;);
        lines.push(chalk.bold(chalk.red(&amp;#39;Critical Issues:&amp;#39;)));
        for (const critical of status.violations.criticalViolations) {
          lines.push(&#x60;  ${chalk.red(&amp;#39;âš &amp;#39;)} ${critical}&#x60;);
        }
      }

      lines.push(&amp;#39;&amp;#39;);
      lines.push(chalk.bold(&amp;#39;Suggestions:&amp;#39;));
      for (const suggestion of status.violations.suggestions) {
        lines.push(&#x60;  ${chalk.yellow(&amp;#39;ğŸ’¡&amp;#39;)} ${suggestion}&#x60;);
      }
    } else {
      lines.push(chalk.green(&amp;#39;âœ… No constraint violations detected&amp;#39;));
    }

    lines.push(&amp;#39;&amp;#39;);

    // Component status
    lines.push(chalk.bold(&amp;#39;Component Status:&amp;#39;));
    lines.push(
      &#x60;  Sandbox: ${status.sandbox.activeOperations} active ops, ${status.sandbox.complianceRate.toFixed(1)}% compliant&#x60;
    );
    lines.push(
      &#x60;  File System: ${status.fileSystem.symlinks} symlinks, ${status.fileSystem.invalidPaths} invalid paths&#x60;
    );
    lines.push(
      &#x60;  Idempotency: ${status.idempotency.cacheSize} cached, ${status.idempotency.validations} validated&#x60;
    );
    lines.push(
      &#x60;  Schema: version ${status.schema.latestVersion}, ${status.schema.deprecatedWarnings} warnings&#x60;
    );

    return lines.join(&amp;#39;\n&amp;#39;);
  }

  /**
   * Cleanup and shutdown constraint system
   */
  async shutdown(): Promise&amp;lt;void&amp;gt; {
    // Clear idempotency cache
    globalIdempotencyValidator.clearExpiredCache();

    // Remove all listeners
    this.removeAllListeners();
    globalConstraintEnforcer.removeAllListeners();

    this.emit(&amp;#39;constraint_system:shutdown&amp;#39;);
  }

  /**
   * Set up violation tracking across all constraint modules
   */
  private setupViolationTracking(): void {
    // Track violations from core enforcer
    globalConstraintEnforcer.on(&amp;#39;constraint:violation&amp;#39;, event &#x3D;&amp;gt; {
      this.incrementViolationCount(event.constraint);
      this.emit(&amp;#39;violation&amp;#39;, {
        constraint: event.constraint,
        violation: event.violation,
        timestamp: Date.now(),
      });
    });

    // Track performance violations
    globalConstraintEnforcer.on(&amp;#39;operation:end&amp;#39;, event &#x3D;&amp;gt; {
      if (event.duration &amp;gt; this.constraints.maxOperationTime) {
        this.incrementViolationCount(&amp;#39;maxOperationTime&amp;#39;);
      }
    });
  }

  /**
   * Start background maintenance tasks
   */
  private startMaintenanceTasks(): void {
    // Clean up expired idempotency cache every 5 minutes
    setInterval(
      () &#x3D;&amp;gt; {
        globalIdempotencyValidator.clearExpiredCache();
      },
      5 * 60 * 1000
    );

    // Reset violation counts daily
    setInterval(
      () &#x3D;&amp;gt; {
        this.violationCounts.clear();
        this.emit(&amp;#39;violation_counts:reset&amp;#39;);
      },
      24 * 60 * 60 * 1000
    );
  }

  /**
   * Check if data looks like API envelope data
   */
  private isApiData(data: unknown): data is Record&amp;lt;string, unknown&amp;gt; {
    return typeof data &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp; data !&#x3D;&#x3D; null &amp;amp;&amp;amp; &amp;#39;apiVersion&amp;#39; in data &amp;amp;&amp;amp; &amp;#39;kind&amp;#39; in data;
  }

  /**
   * Increment violation count for a constraint
   */
  private incrementViolationCount(constraint: string): void {
    const current &#x3D; this.violationCounts.get(constraint) || 0;
    this.violationCounts.set(constraint, current + 1);
  }

  /**
   * Get critical violations that need immediate attention
   */
  private getCriticalViolations(): string[] {
    const critical: string[] &#x3D; [];

    for (const [constraint, count] of this.violationCounts.entries()) {
      if (count &amp;gt; 0) {
        switch (constraint) {
          case &amp;#39;maxPayloadSize&amp;#39;:
            critical.push(&amp;#39;Payload size limits exceeded - requests/responses too large&amp;#39;);
            break;
          case &amp;#39;maxOperationTime&amp;#39;:
            critical.push(&amp;#39;Operations taking too long - performance issues detected&amp;#39;);
            break;
          case &amp;#39;sandboxCompliance&amp;#39;:
            critical.push(&amp;#39;Direct tool execution detected - must use server endpoints&amp;#39;);
            break;
          case &amp;#39;symlinkPrevention&amp;#39;:
            critical.push(&amp;#39;Symlinks detected - must use standalone file copies&amp;#39;);
            break;
          case &amp;#39;apiVersion&amp;#39;:
            critical.push(&amp;#39;Outdated API versions in use - must use latest schema&amp;#39;);
            break;
          case &amp;#39;idempotency&amp;#39;:
            critical.push(&amp;#39;Non-idempotent operations detected - results are inconsistent&amp;#39;);
            break;
        }
      }
    }

    return critical;
  }

  /**
   * Get improvement suggestions based on violations
   */
  private getImprovementSuggestions(): string[] {
    const suggestions: string[] &#x3D; [];

    for (const [constraint, count] of this.violationCounts.entries()) {
      if (count &amp;gt; 0) {
        switch (constraint) {
          case &amp;#39;maxPayloadSize&amp;#39;:
            suggestions.push(&amp;#39;Consider pagination or compression for large datasets&amp;#39;);
            break;
          case &amp;#39;maxOperationTime&amp;#39;:
            suggestions.push(&amp;#39;Optimize algorithms or implement caching for better performance&amp;#39;);
            break;
          case &amp;#39;rateLimit&amp;#39;:
            suggestions.push(&amp;#39;Implement request queuing or batch operations&amp;#39;);
            break;
          case &amp;#39;sandboxCompliance&amp;#39;:
            suggestions.push(
              &amp;#39;Ensure all analyze/validate operations use API client instead of direct tools&amp;#39;
            );
            break;
          case &amp;#39;symlinkPrevention&amp;#39;:
            suggestions.push(&amp;#39;Use file copying utilities that create standalone copies&amp;#39;);
            break;
          case &amp;#39;apiVersion&amp;#39;:
            suggestions.push(&#x60;Update all schemas to use API version ${LATEST_API_VERSION}&#x60;);
            break;
        }
      }
    }

    return suggestions;
  }

  /**
   * Format compliance rate with appropriate colors
   */
  private formatComplianceRate(rate: number): string {
    if (rate &amp;gt;&#x3D; 95) return chalk.green(&#x60;${rate.toFixed(1)}%&#x60;);
    if (rate &amp;gt;&#x3D; 80) return chalk.yellow(&#x60;${rate.toFixed(1)}%&#x60;);
    return chalk.red(&#x60;${rate.toFixed(1)}%&#x60;);
  }

  /**
   * Format bytes in human-readable format
   */
  private formatBytes(bytes: number): string {
    if (bytes &#x3D;&#x3D;&#x3D; 0) return &amp;#39;0 B&amp;#39;;

    const k &#x3D; 1024;
    const sizes &#x3D; [&amp;#39;B&amp;#39;, &amp;#39;KB&amp;#39;, &amp;#39;MB&amp;#39;, &amp;#39;GB&amp;#39;];
    const i &#x3D; Math.floor(Math.log(bytes) / Math.log(k));

    return &#x60;${Number.parseFloat((bytes / k ** i).toFixed(2))} ${sizes[i]}&#x60;;
  }
}

// Export all constraint components and utilities
export {
  // Core
  globalConstraintEnforcer,
  constrainedOperation,
  ConstraintViolationError,
  DEFAULT_CONSTRAINTS,
  type Constraints,
  // Sandbox
  createSandboxValidator,
  initializeSandboxConfig,
  type SandboxedOperation,
  type SandboxValidator,
  // Schema
  globalSchemaValidator,
  ensureLatestSchema,
  validateReadData,
  LATEST_API_VERSION,
  // File System
  globalFileSystemConstraints,
  copyStandalone,
  bundleStandalone,
  safeFileOperation,
  type FileSystemOperation,
  // Idempotency
  globalIdempotencyValidator,
  withIdempotencyValidation,
  validateIdempotentEdits,
  type IdempotentOperation,
};

/**
 * Create and initialize constraint system for CLI
 */
export function createConstraintSystem(
  config: CLIConfig,
  constraints?: Partial&amp;lt;Constraints&amp;gt;
): ConstraintSystem {
  return new ConstraintSystem(config, constraints);
}

/**
 * Global constraint system instance (initialized by CLI)
 */
let globalConstraintSystem: ConstraintSystem | null &#x3D; null;

/**
 * Initialize global constraint system
 */
export function initializeGlobalConstraintSystem(
  config: CLIConfig,
  constraints?: Partial&amp;lt;Constraints&amp;gt;
): ConstraintSystem {
  globalConstraintSystem &#x3D; new ConstraintSystem(config, constraints);
  return globalConstraintSystem;
}

/**
 * Get global constraint system (throws if not initialized)
 */
export function getGlobalConstraintSystem(): ConstraintSystem {
  if (!globalConstraintSystem) {
    throw new Error(
      &amp;#39;Constraint system not initialized. Call initializeGlobalConstraintSystem first.&amp;#39;
    );
  }
  return globalConstraintSystem;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-141">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/diagrams/NetworkDiagram.tsx</div>
                <div class="file-content">
                    <pre>import React, { useEffect, useRef } from &amp;#39;react&amp;#39;;
import { Network } from &amp;#39;vis-network&amp;#39;;
import { DataSet } from &amp;#39;vis-data&amp;#39;;

interface NetworkNode {
  id: string;
  label: string;
  group?: string;
  color?: string;
  shape?: string;
  size?: number;
}

interface NetworkEdge {
  id?: string;
  from: string;
  to: string;
  label?: string;
  arrows?: string;
  color?: string;
  dashes?: boolean;
}

interface NetworkDiagramProps {
  nodes: NetworkNode[];
  edges: NetworkEdge[];
  className?: string;
  title?: string;
  options?: any;
}

export const NetworkDiagram: React.FC&amp;lt;NetworkDiagramProps&amp;gt; &#x3D; ({
  nodes,
  edges,
  className &#x3D; &amp;#39;&amp;#39;,
  title,
  options &#x3D; {},
}) &#x3D;&amp;gt; {
  const containerRef &#x3D; useRef&amp;lt;HTMLDivElement&amp;gt;(null);
  const networkRef &#x3D; useRef&amp;lt;Network | null&amp;gt;(null);

  useEffect(() &#x3D;&amp;gt; {
    if (!containerRef.current) return;

    // Create DataSets
    const nodeDataSet &#x3D; new DataSet(nodes);
    const edgeDataSet &#x3D; new DataSet(edges);

    // Default options
    const defaultOptions &#x3D; {
      nodes: {
        borderWidth: 2,
        borderWidthSelected: 4,
        chosen: true,
        font: {
          size: 12,
          color: &amp;#39;#343a40&amp;#39;,
          face: &amp;#39;Inter, system-ui, sans-serif&amp;#39;,
        },
        scaling: {
          min: 10,
          max: 30,
        },
        shadow: {
          enabled: true,
          color: &amp;#39;rgba(0,0,0,0.1)&amp;#39;,
          size: 5,
          x: 2,
          y: 2,
        },
      },
      edges: {
        width: 2,
        color: {
          color: &amp;#39;#848484&amp;#39;,
          highlight: &amp;#39;#2563eb&amp;#39;,
          hover: &amp;#39;#3b82f6&amp;#39;,
        },
        smooth: {
          type: &amp;#39;cubicBezier&amp;#39;,
          forceDirection: &amp;#39;horizontal&amp;#39;,
          roundness: 0.4,
        },
        arrows: {
          to: {
            enabled: true,
            scaleFactor: 0.8,
          },
        },
        font: {
          size: 11,
          color: &amp;#39;#6b7280&amp;#39;,
          align: &amp;#39;middle&amp;#39;,
          background: &amp;#39;rgba(255,255,255,0.8)&amp;#39;,
          strokeWidth: 0,
        },
      },
      physics: {
        enabled: true,
        stabilization: {
          enabled: true,
          iterations: 100,
          updateInterval: 25,
        },
        barnesHut: {
          gravitationalConstant: -2000,
          centralGravity: 0.3,
          springLength: 150,
          springConstant: 0.04,
          damping: 0.09,
          avoidOverlap: 0.1,
        },
      },
      interaction: {
        hover: true,
        zoomView: true,
        dragView: true,
        selectConnectedEdges: false,
        tooltipDelay: 200,
      },
      layout: {
        improvedLayout: true,
        clusterThreshold: 150,
      },
      ...options,
    };

    // Create network
    const data &#x3D; {
      nodes: nodeDataSet,
      edges: edgeDataSet,
    };

    networkRef.current &#x3D; new Network(containerRef.current, data, defaultOptions);

    // Add event listeners
    networkRef.current.on(&amp;#39;click&amp;#39;, params &#x3D;&amp;gt; {
      if (params.nodes.length &amp;gt; 0) {
        console.log(&amp;#39;Node clicked:&amp;#39;, params.nodes[0]);
      }
    });

    networkRef.current.on(&amp;#39;hoverNode&amp;#39;, params &#x3D;&amp;gt; {
      document.body.style.cursor &#x3D; &amp;#39;pointer&amp;#39;;
    });

    networkRef.current.on(&amp;#39;blurNode&amp;#39;, () &#x3D;&amp;gt; {
      document.body.style.cursor &#x3D; &amp;#39;default&amp;#39;;
    });

    // Cleanup function
    return () &#x3D;&amp;gt; {
      if (networkRef.current) {
        networkRef.current.destroy();
        networkRef.current &#x3D; null;
      }
      document.body.style.cursor &#x3D; &amp;#39;default&amp;#39;;
    };
  }, [nodes, edges, options]);

  return (
    &amp;lt;div className&#x3D;{className}&amp;gt;
      {title &amp;amp;&amp;amp; &amp;lt;h4 className&#x3D;&amp;quot;text-sm font-semibold text-gray-700 mb-4 text-center&amp;quot;&amp;gt;{title}&amp;lt;/h4&amp;gt;}
      &amp;lt;div className&#x3D;&amp;quot;bg-white rounded-lg border border-gray-200 overflow-hidden&amp;quot;&amp;gt;
        &amp;lt;div ref&#x3D;{containerRef} className&#x3D;&amp;quot;w-full h-96&amp;quot; style&#x3D;{{ minHeight: &amp;#39;400px&amp;#39; }} /&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default NetworkDiagram;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-142">
                <div class="file-header">ğŸ“„ packages/cli/src/validation/__tests__/debug-spec.test.ts</div>
                <div class="file-content">
                    <pre>/**
 * Debug test to understand what warnings are being generated
 */

import { describe, expect, it } from &amp;#39;bun:test&amp;#39;;
import type { AppSpec } from &amp;#39;@arbiter/shared&amp;#39;;
import { validateSpecification } from &amp;#39;../warnings.js&amp;#39;;

describe(&amp;#39;Debug Spec Warnings&amp;#39;, () &#x3D;&amp;gt; {
  it(&amp;#39;should debug complete spec warnings&amp;#39;, () &#x3D;&amp;gt; {
    const completeValidSpec: any &#x3D; {
      product: {
        name: &amp;#39;Test Product&amp;#39;,
        goals: [&amp;#39;Achieve high performance&amp;#39;, &amp;#39;Ensure reliability&amp;#39;],
      },
      metadata: {
        name: &amp;#39;test-project&amp;#39;,
        version: &amp;#39;1.0.0&amp;#39;,
        description: &amp;#39;A comprehensive test project&amp;#39;,
      },
      services: {},
      ui: { routes: [] },
      tests: [
        {
          name: &amp;#39;Unit Tests&amp;#39;,
          type: &amp;#39;unit&amp;#39;,
          cases: [{ name: &amp;#39;test case&amp;#39;, assertion: &amp;#39;should work&amp;#39; }],
        },
        {
          name: &amp;#39;Integration Tests&amp;#39;,
          type: &amp;#39;integration&amp;#39;,
          cases: [{ name: &amp;#39;integration test&amp;#39;, assertion: &amp;#39;should integrate&amp;#39; }],
        },
        {
          name: &amp;#39;E2E Tests&amp;#39;,
          type: &amp;#39;e2e&amp;#39;,
          cases: [{ name: &amp;#39;e2e test&amp;#39;, assertion: &amp;#39;should work end-to-end&amp;#39; }],
        },
      ],
      security: {
        authentication: { type: &amp;#39;oauth2&amp;#39; },
        authorization: { rbac: true },
      },
      performance: {
        sla: { responseTime: &amp;#39;&amp;lt; 200ms&amp;#39;, availability: &amp;#39;99.9%&amp;#39; },
      },
      observability: {
        logging: { level: &amp;#39;info&amp;#39;, format: &amp;#39;json&amp;#39; },
        monitoring: { metrics: [&amp;#39;response_time&amp;#39;, &amp;#39;error_rate&amp;#39;] },
      },
      environments: {
        development: { name: &amp;#39;dev&amp;#39; },
        production: { name: &amp;#39;prod&amp;#39; },
      },
    };

    const result &#x3D; validateSpecification(completeValidSpec);

    console.log(&amp;#39;Complete spec validation result:&amp;#39;);
    console.log(&amp;#39;Has warnings:&amp;#39;, result.hasWarnings);
    console.log(&amp;#39;Has errors:&amp;#39;, result.hasErrors);
    console.log(&amp;#39;Warning count:&amp;#39;, result.warnings.length);
    console.log(
      &amp;#39;Warnings:&amp;#39;,
      result.warnings.map(w &#x3D;&amp;gt; &#x60;${w.category}: ${w.message}&#x60;)
    );

    expect(result).toBeDefined();
  });
});
</pre>
                </div>
            </div>
            <div class="file-section" id="file-143">
                <div class="file-header">ğŸ“„ packages/cli/example-script-template.sh</div>
                <div class="file-content">
                    <pre>#!/bin/bash

# Example script-based template for Arbiter
# This demonstrates how to create a simple template using shell scripts

echo &amp;quot;ğŸ”§ Setting up service: $TEMPLATE_SERVICENAME&amp;quot;
echo &amp;quot;ğŸ“ Target directory: $TEMPLATE_DESTINATION&amp;quot;
echo &amp;quot;ğŸ·ï¸  Project: $TEMPLATE_PROJECTNAME&amp;quot;

# Create directory structure
mkdir -p &amp;quot;$TEMPLATE_DESTINATION/src&amp;quot;
mkdir -p &amp;quot;$TEMPLATE_DESTINATION/tests&amp;quot;
mkdir -p &amp;quot;$TEMPLATE_DESTINATION/docs&amp;quot;

# Create main service file
cat &amp;gt; &amp;quot;$TEMPLATE_DESTINATION/src/index.ts&amp;quot; &amp;lt;&amp;lt; EOF
/**
 * ${TEMPLATE_SERVICENAME} Service
 * Generated by Arbiter Template System
 */

export class ${TEMPLATE_SERVICENAME^}Service {
  constructor() {
    console.log(&amp;#39;${TEMPLATE_SERVICENAME^} service initialized&amp;#39;);
  }

  async start(): Promise&amp;lt;void&amp;gt; {
    console.log(&amp;#39;Starting ${TEMPLATE_SERVICENAME} service...&amp;#39;);
    // Add your service logic here
  }

  async stop(): Promise&amp;lt;void&amp;gt; {
    console.log(&amp;#39;Stopping ${TEMPLATE_SERVICENAME} service...&amp;#39;);
    // Add cleanup logic here
  }
}

export default ${TEMPLATE_SERVICENAME^}Service;
EOF

# Create package.json
cat &amp;gt; &amp;quot;$TEMPLATE_DESTINATION/package.json&amp;quot; &amp;lt;&amp;lt; EOF
{
  &amp;quot;name&amp;quot;: &amp;quot;${TEMPLATE_PROJECTNAME,,}-${TEMPLATE_SERVICENAME}&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;${TEMPLATE_SERVICENAME^} service for ${TEMPLATE_PROJECTNAME}&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;src/index.ts&amp;quot;,
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;dev&amp;quot;: &amp;quot;tsx watch src/index.ts&amp;quot;,
    &amp;quot;build&amp;quot;: &amp;quot;tsc&amp;quot;,
    &amp;quot;start&amp;quot;: &amp;quot;node dist/index.js&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;jest&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;tsx&amp;quot;: &amp;quot;^4.0.0&amp;quot;
  },
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;typescript&amp;quot;: &amp;quot;^5.0.0&amp;quot;,
    &amp;quot;@types/node&amp;quot;: &amp;quot;^20.0.0&amp;quot;,
    &amp;quot;jest&amp;quot;: &amp;quot;^29.0.0&amp;quot;
  }
}
EOF

# Create TypeScript config
cat &amp;gt; &amp;quot;$TEMPLATE_DESTINATION/tsconfig.json&amp;quot; &amp;lt;&amp;lt; EOF
{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;ES2022&amp;quot;,
    &amp;quot;module&amp;quot;: &amp;quot;ESNext&amp;quot;,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;esModuleInterop&amp;quot;: true,
    &amp;quot;allowSyntheticDefaultImports&amp;quot;: true,
    &amp;quot;strict&amp;quot;: true,
    &amp;quot;skipLibCheck&amp;quot;: true,
    &amp;quot;forceConsistentCasingInFileNames&amp;quot;: true,
    &amp;quot;outDir&amp;quot;: &amp;quot;./dist&amp;quot;,
    &amp;quot;rootDir&amp;quot;: &amp;quot;./src&amp;quot;
  },
  &amp;quot;include&amp;quot;: [&amp;quot;src/**/*&amp;quot;],
  &amp;quot;exclude&amp;quot;: [&amp;quot;node_modules&amp;quot;, &amp;quot;dist&amp;quot;, &amp;quot;tests&amp;quot;]
}
EOF

# Create test file
cat &amp;gt; &amp;quot;$TEMPLATE_DESTINATION/tests/${TEMPLATE_SERVICENAME}.test.ts&amp;quot; &amp;lt;&amp;lt; EOF
import ${TEMPLATE_SERVICENAME^}Service from &amp;#39;../src/index&amp;#39;;

describe(&amp;#39;${TEMPLATE_SERVICENAME^}Service&amp;#39;, () &#x3D;&amp;gt; {
  let service: ${TEMPLATE_SERVICENAME^}Service;

  beforeEach(() &#x3D;&amp;gt; {
    service &#x3D; new ${TEMPLATE_SERVICENAME^}Service();
  });

  it(&amp;#39;should initialize correctly&amp;#39;, () &#x3D;&amp;gt; {
    expect(service).toBeInstanceOf(${TEMPLATE_SERVICENAME^}Service);
  });

  it(&amp;#39;should start without errors&amp;#39;, async () &#x3D;&amp;gt; {
    await expect(service.start()).resolves.not.toThrow();
  });

  it(&amp;#39;should stop without errors&amp;#39;, async () &#x3D;&amp;gt; {
    await expect(service.stop()).resolves.not.toThrow();
  });
});
EOF

# Create README
cat &amp;gt; &amp;quot;$TEMPLATE_DESTINATION/README.md&amp;quot; &amp;lt;&amp;lt; EOF
# ${TEMPLATE_SERVICENAME^} Service

Generated by Arbiter Template System for the **${TEMPLATE_PROJECTNAME}** project.

## Description

This is the ${TEMPLATE_SERVICENAME} service, part of the ${TEMPLATE_PROJECTNAME} application.

## Development

\&#x60;\&#x60;\&#x60;bash
# Install dependencies
npm install

# Start development server
npm run dev

# Run tests
npm test

# Build for production
npm run build

# Start production server
npm start
\&#x60;\&#x60;\&#x60;

## Configuration

The service can be configured through environment variables or configuration files.

## API

Document your API endpoints here.

## Testing

Run the test suite with:

\&#x60;\&#x60;\&#x60;bash
npm test
\&#x60;\&#x60;\&#x60;

## Deployment

This service is configured to be deployed via Arbiter&amp;#39;s deployment system.
EOF

echo &amp;quot;âœ… Template applied successfully to $TEMPLATE_DESTINATION&amp;quot;
echo &amp;quot;ğŸ“ Files created:&amp;quot;
echo &amp;quot;   - src/index.ts&amp;quot;
echo &amp;quot;   - package.json&amp;quot;
echo &amp;quot;   - tsconfig.json&amp;quot;
echo &amp;quot;   - tests/${TEMPLATE_SERVICENAME}.test.ts&amp;quot;
echo &amp;quot;   - README.md&amp;quot;

echo &amp;quot;&amp;quot;
echo &amp;quot;ğŸš€ Next steps:&amp;quot;
echo &amp;quot;   1. cd $TEMPLATE_DESTINATION&amp;quot;
echo &amp;quot;   2. npm install&amp;quot;
echo &amp;quot;   3. npm run dev&amp;quot;</pre>
                </div>
            </div>
            <div class="file-section" id="file-144">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/design-system/components/StatusBadge.tsx</div>
                <div class="file-content">
                    <pre>/**
 * StatusBadge Component - Design System
 * Professional status indicators with comprehensive variants and states
 * Designed for developer tools with sophisticated graphite theme
 */

import React, { type ReactNode } from &amp;#39;react&amp;#39;;
import { clsx } from &amp;#39;clsx&amp;#39;;
import { statusVariants, sizeVariants, cn } from &amp;#39;../variants&amp;#39;;

export interface StatusBadgeProps {
  /** Status variant determines the color scheme */
  variant?:
    | &amp;#39;success&amp;#39;
    | &amp;#39;warning&amp;#39;
    | &amp;#39;error&amp;#39;
    | &amp;#39;info&amp;#39;
    | &amp;#39;neutral&amp;#39;
    | &amp;#39;pending&amp;#39;
    | &amp;#39;active&amp;#39;
    | &amp;#39;inactive&amp;#39;;

  /** Badge style appearance */
  style?: &amp;#39;solid&amp;#39; | &amp;#39;outlined&amp;#39; | &amp;#39;subtle&amp;#39;;

  /** Badge size */
  size?: &amp;#39;xs&amp;#39; | &amp;#39;sm&amp;#39; | &amp;#39;md&amp;#39; | &amp;#39;lg&amp;#39;;

  /** Whether to show a dot indicator */
  showDot?: boolean;

  /** Whether the dot should pulse (for active states) */
  pulse?: boolean;

  /** Icon to display (overrides dot) */
  icon?: ReactNode;

  /** Whether the badge has a loading state */
  loading?: boolean;

  /** Badge content */
  children: ReactNode;

  /** Custom className for additional styling */
  className?: string;
}

const sizeClasses &#x3D; {
  xs: {
    badge: &amp;#39;px-2 py-0.5 text-xs&amp;#39;,
    icon: &amp;#39;h-3 w-3&amp;#39;,
    dot: &amp;#39;h-1.5 w-1.5&amp;#39;,
    gap: &amp;#39;gap-1&amp;#39;,
  },
  sm: {
    badge: &amp;#39;px-2.5 py-1 text-xs&amp;#39;,
    icon: &amp;#39;h-3.5 w-3.5&amp;#39;,
    dot: &amp;#39;h-2 w-2&amp;#39;,
    gap: &amp;#39;gap-1.5&amp;#39;,
  },
  md: {
    badge: &amp;#39;px-3 py-1.5 text-sm&amp;#39;,
    icon: &amp;#39;h-4 w-4&amp;#39;,
    dot: &amp;#39;h-2.5 w-2.5&amp;#39;,
    gap: &amp;#39;gap-2&amp;#39;,
  },
  lg: {
    badge: &amp;#39;px-4 py-2 text-base&amp;#39;,
    icon: &amp;#39;h-5 w-5&amp;#39;,
    dot: &amp;#39;h-3 w-3&amp;#39;,
    gap: &amp;#39;gap-2&amp;#39;,
  },
} as const;

// Extended status variants with additional semantic meanings
const extendedStatusVariants &#x3D; {
  ...statusVariants,
  pending: {
    bg: &amp;#39;bg-amber-50&amp;#39;,
    border: &amp;#39;border-amber-200&amp;#39;,
    text: &amp;#39;text-amber-700&amp;#39;,
    icon: &amp;#39;text-amber-500&amp;#39;,
    dot: &amp;#39;bg-amber-500&amp;#39;,
  },
  active: {
    bg: &amp;#39;bg-green-50&amp;#39;,
    border: &amp;#39;border-green-200&amp;#39;,
    text: &amp;#39;text-green-700&amp;#39;,
    icon: &amp;#39;text-green-500&amp;#39;,
    dot: &amp;#39;bg-green-500&amp;#39;,
  },
  inactive: {
    bg: &amp;#39;bg-graphite-50&amp;#39;,
    border: &amp;#39;border-graphite-200&amp;#39;,
    text: &amp;#39;text-graphite-600&amp;#39;,
    icon: &amp;#39;text-graphite-400&amp;#39;,
    dot: &amp;#39;bg-graphite-400&amp;#39;,
  },
};

export function StatusBadge({
  variant &#x3D; &amp;#39;neutral&amp;#39;,
  style &#x3D; &amp;#39;solid&amp;#39;,
  size &#x3D; &amp;#39;sm&amp;#39;,
  showDot &#x3D; false,
  pulse &#x3D; false,
  icon,
  loading &#x3D; false,
  children,
  className,
}: StatusBadgeProps) {
  const status &#x3D; extendedStatusVariants[variant];
  const sizeClass &#x3D; sizeClasses[size];

  // Style variants
  const getStyleClasses &#x3D; () &#x3D;&amp;gt; {
    switch (style) {
      case &amp;#39;solid&amp;#39;:
        return cn(status.bg, status.border, status.text);
      case &amp;#39;outlined&amp;#39;:
        return cn(&amp;#39;bg-transparent border-2&amp;#39;, status.border, status.text);
      case &amp;#39;subtle&amp;#39;:
        return cn(status.bg, &amp;#39;border-transparent&amp;#39;, status.text);
      default:
        return cn(status.bg, status.border, status.text);
    }
  };

  const badgeClasses &#x3D; cn(
    // Base styles
    &amp;#39;inline-flex items-center font-medium rounded-full border transition-all duration-150&amp;#39;,

    // Size styles
    sizeClass.badge,
    sizeClass.gap,

    // Style variant classes
    getStyleClasses(),

    // Loading state
    loading &amp;amp;&amp;amp; &amp;#39;opacity-75&amp;#39;,

    // Custom className
    className
  );

  const renderIndicator &#x3D; () &#x3D;&amp;gt; {
    if (loading) {
      return (
        &amp;lt;div
          className&#x3D;{cn(
            &amp;#39;flex-shrink-0 border-2 border-current border-t-transparent rounded-full animate-spin&amp;#39;,
            sizeClass.dot
          )}
        /&amp;gt;
      );
    }

    if (icon) {
      return &amp;lt;span className&#x3D;{cn(&amp;#39;flex-shrink-0&amp;#39;, status.icon, sizeClass.icon)}&amp;gt;{icon}&amp;lt;/span&amp;gt;;
    }

    if (showDot) {
      return (
        &amp;lt;span
          className&#x3D;{cn(
            &amp;#39;flex-shrink-0 rounded-full&amp;#39;,
            status.dot,
            sizeClass.dot,
            pulse &amp;amp;&amp;amp; &amp;#39;animate-pulse&amp;#39;
          )}
        /&amp;gt;
      );
    }

    return null;
  };

  return (
    &amp;lt;span className&#x3D;{badgeClasses}&amp;gt;
      {renderIndicator()}
      &amp;lt;span&amp;gt;{children}&amp;lt;/span&amp;gt;
    &amp;lt;/span&amp;gt;
  );
}

export default StatusBadge;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-145">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/export.ts</div>
                <div class="file-content">
                    <pre>import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import { ApiClient } from &amp;#39;../api-client.js&amp;#39;;
import type { CLIConfig, ExportFormat, ExportOptions } from &amp;#39;../types.js&amp;#39;;
import { withProgress } from &amp;#39;../utils/progress.js&amp;#39;;

/**
 * Export command implementation
 * Export CUE configurations to various formats
 */
export async function exportCommand(
  inputFiles: string[],
  options: ExportOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  try {
    if (inputFiles.length &#x3D;&#x3D;&#x3D; 0) {
      console.error(chalk.red(&amp;#39;No input files specified&amp;#39;));
      return 1;
    }

    // Resolve input files
    const resolvedFiles &#x3D; await resolveInputFiles(inputFiles, config.projectDir);

    if (resolvedFiles.length &#x3D;&#x3D;&#x3D; 0) {
      console.error(chalk.red(&amp;#39;No valid input files found&amp;#39;));
      return 1;
    }

    // Combine all input files
    const combinedContent &#x3D; await combineInputFiles(resolvedFiles);

    // Load schema and config if specified
    let fullContent &#x3D; combinedContent;

    if (options.schema) {
      try {
        const schemaContent &#x3D; await fs.readFile(options.schema, &amp;#39;utf-8&amp;#39;);
        fullContent &#x3D; &#x60;${schemaContent}\n\n${fullContent}&#x60;;
      } catch (_error) {
        console.error(chalk.red(&#x60;Cannot read schema file: ${options.schema}&#x60;));
        return 1;
      }
    }

    if (options.config) {
      try {
        const configContent &#x3D; await fs.readFile(options.config, &amp;#39;utf-8&amp;#39;);
        fullContent &#x3D; &#x60;${fullContent}\n\n${configContent}&#x60;;
      } catch (_error) {
        console.error(chalk.red(&#x60;Cannot read config file: ${options.config}&#x60;));
        return 1;
      }
    }

    // Export to requested formats
    for (const format of options.format) {
      await exportToFormat(fullContent, format, options, config);
    }

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;Export command failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 2;
  }
}

/**
 * Resolve and validate input file paths
 */
async function resolveInputFiles(files: string[], cwd: string): Promise&amp;lt;string[]&amp;gt; {
  const resolved: string[] &#x3D; [];

  for (const file of files) {
    const fullPath &#x3D; path.resolve(cwd, file);

    try {
      const stats &#x3D; await fs.stat(fullPath);
      if (stats.isFile()) {
        if (path.extname(fullPath) &#x3D;&#x3D;&#x3D; &amp;#39;.cue&amp;#39;) {
          resolved.push(fullPath);
        }
      } else if (stats.isDirectory()) {
        // Find all .cue files in directory recursively
        const dirFiles &#x3D; await findCueFilesRecursive(fullPath);
        resolved.push(...dirFiles);
      }
    } catch (_error) {
      console.warn(chalk.yellow(&#x60;Warning: Cannot access ${file}&#x60;));
    }
  }

  return resolved;
}

/**
 * Find CUE files recursively in a directory
 */
async function findCueFilesRecursive(dir: string): Promise&amp;lt;string[]&amp;gt; {
  const files: string[] &#x3D; [];
  const entries &#x3D; await fs.readdir(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath &#x3D; path.join(dir, entry.name);

    if (entry.isDirectory() &amp;amp;&amp;amp; !shouldSkipDirectory(entry.name)) {
      const subFiles &#x3D; await findCueFilesRecursive(fullPath);
      files.push(...subFiles);
    } else if (entry.isFile() &amp;amp;&amp;amp; entry.name.endsWith(&amp;#39;.cue&amp;#39;)) {
      files.push(fullPath);
    }
  }

  return files;
}

/**
 * Check if directory should be skipped
 */
function shouldSkipDirectory(name: string): boolean {
  const skipDirs &#x3D; [&amp;#39;node_modules&amp;#39;, &amp;#39;.git&amp;#39;, &amp;#39;dist&amp;#39;, &amp;#39;build&amp;#39;, &amp;#39;.vscode&amp;#39;, &amp;#39;.idea&amp;#39;];
  return skipDirs.includes(name) || name.startsWith(&amp;#39;.&amp;#39;);
}

/**
 * Combine multiple input files into one
 */
async function combineInputFiles(files: string[]): Promise&amp;lt;string&amp;gt; {
  const contents: string[] &#x3D; [];

  for (const file of files) {
    try {
      const content &#x3D; await fs.readFile(file, &amp;#39;utf-8&amp;#39;);
      contents.push(&#x60;// File: ${path.basename(file)}\n${content}&#x60;);
    } catch (_error) {
      console.warn(chalk.yellow(&#x60;Warning: Cannot read ${file}&#x60;));
    }
  }

  return contents.join(&amp;#39;\n\n&amp;#39;);
}

/**
 * Export content to a specific format using the new export API
 */
async function exportToFormat(
  content: string,
  format: ExportFormat,
  options: ExportOptions,
  config: CLIConfig
): Promise&amp;lt;void&amp;gt; {
  const apiClient &#x3D; new ApiClient(config);

  return withProgress({ text: &#x60;Exporting to ${format} format...&#x60;, color: &amp;#39;green&amp;#39; }, async () &#x3D;&amp;gt; {
    const exportResult &#x3D; await apiClient.export(content, format, {
      strict: options.strict,
      includeExamples: true,
      outputMode: &amp;#39;single&amp;#39;,
    });

    if (!exportResult.success || !exportResult.data) {
      throw new Error(&#x60;Export failed: ${exportResult.error}&#x60;);
    }

    const result &#x3D; exportResult.data;

    // Handle export errors
    if (!result.success) {
      if (result.warnings &amp;amp;&amp;amp; result.warnings.length &amp;gt; 0) {
        result.warnings.forEach(warning &#x3D;&amp;gt; {
          console.warn(chalk.yellow(&#x60;Warning: ${warning}&#x60;));
        });
      }
      throw new Error(result.error || &amp;#39;Export failed&amp;#39;);
    }

    // Handle warnings
    if (result.warnings &amp;amp;&amp;amp; result.warnings.length &amp;gt; 0) {
      result.warnings.forEach(warning &#x3D;&amp;gt; {
        console.warn(chalk.yellow(&#x60;Warning: ${warning}&#x60;));
      });
    }

    // Process export files
    if (result.files &amp;amp;&amp;amp; result.files.length &amp;gt; 0) {
      for (const file of result.files) {
        await outputFile(file, options, format);
      }

      // Show export metadata
      if (result.metadata &amp;amp;&amp;amp; options.verbose) {
        console.log(chalk.gray(&amp;#39;\nExport metadata:&amp;#39;));
        console.log(chalk.gray(&#x60;  Generated: ${result.metadata.generatedAt}&#x60;));
        console.log(chalk.gray(&#x60;  Detected tags: ${result.metadata.detectedTags.join(&amp;#39;, &amp;#39;)}&#x60;));
        console.log(
          chalk.gray(&#x60;  Exported schemas: ${result.metadata.exportedSchemas.join(&amp;#39;, &amp;#39;)}&#x60;)
        );
      }
    } else {
      // Fallback: single output
      const outputContent &#x3D; JSON.stringify(result, null, 2);
      await outputContent_(outputContent, format, options);
    }
  });
}

/**
 * Output a single file from export result
 */
async function outputFile(
  file: { name: string; content: string; format: ExportFormat },
  options: ExportOptions,
  requestedFormat: ExportFormat
): Promise&amp;lt;void&amp;gt; {
  const formattedContent &#x3D; applyContentFormatting(file.content, requestedFormat, options);

  if (options.output) {
    await writeToFileSystem(file, formattedContent, options.output);
  } else {
    outputToConsole(file.name, formattedContent);
  }
}

/**
 * Apply content formatting based on format and options
 */
function applyContentFormatting(
  content: string,
  requestedFormat: ExportFormat,
  options: ExportOptions
): string {
  if (requestedFormat &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39; &amp;amp;&amp;amp; options.minify) {
    return minifyJsonContent(content);
  }
  return content;
}

/**
 * Minify JSON content safely
 */
function minifyJsonContent(content: string): string {
  try {
    const parsed &#x3D; JSON.parse(content);
    return JSON.stringify(parsed);
  } catch {
    // Keep original if not valid JSON
    return content;
  }
}

/**
 * Write content to filesystem with path resolution
 */
async function writeToFileSystem(
  file: { name: string; format: ExportFormat },
  content: string,
  outputPath: string
): Promise&amp;lt;void&amp;gt; {
  const resolvedPath &#x3D; await resolveOutputPath(outputPath, file.name);
  await fs.writeFile(resolvedPath, content, &amp;#39;utf-8&amp;#39;);
  console.log(chalk.green(&#x60;âœ“ Exported ${file.format} to ${resolvedPath}&#x60;));
}

/**
 * Resolve output path (directory vs file)
 */
async function resolveOutputPath(outputPath: string, fileName: string): Promise&amp;lt;string&amp;gt; {
  try {
    const stats &#x3D; await fs.stat(outputPath);
    if (stats.isDirectory()) {
      return path.join(outputPath, fileName);
    }
  } catch {
    // Path doesn&amp;#39;t exist, treat as file
  }
  return outputPath;
}

/**
 * Output content to console
 */
function outputToConsole(fileName: string, content: string): void {
  console.log(chalk.blue(&#x60;--- ${fileName} ---&#x60;));
  console.log(content);
}

/**
 * Output content directly (fallback method)
 */
async function outputContent_(
  content: string,
  format: ExportFormat,
  options: ExportOptions
): Promise&amp;lt;void&amp;gt; {
  if (options.output) {
    let outputPath &#x3D; options.output;

    // If output is a directory, generate filename
    try {
      const stats &#x3D; await fs.stat(outputPath);
      if (stats.isDirectory()) {
        const extension &#x3D; getDefaultExtension(format);
        const filename &#x3D; &#x60;export.${extension}&#x60;;
        outputPath &#x3D; path.join(outputPath, filename);
      }
    } catch {
      // Path doesn&amp;#39;t exist, treat as file
    }

    await fs.writeFile(outputPath, content, &amp;#39;utf-8&amp;#39;);
    console.log(chalk.green(&#x60;âœ“ Exported ${format} to ${outputPath}&#x60;));
  } else {
    // Output to stdout
    console.log(content);
  }
}

/**
 * Get default file extension for format
 */
function getDefaultExtension(format: ExportFormat): string {
  switch (format) {
    case &amp;#39;openapi&amp;#39;:
      return &amp;#39;openapi.yaml&amp;#39;;
    case &amp;#39;types&amp;#39;:
      return &amp;#39;d.ts&amp;#39;;
    case &amp;#39;k8s&amp;#39;:
      return &amp;#39;k8s.yaml&amp;#39;;
    case &amp;#39;terraform&amp;#39;:
      return &amp;#39;tf&amp;#39;;
    case &amp;#39;json-schema&amp;#39;:
      return &amp;#39;schema.json&amp;#39;;
    default:
      return &amp;#39;txt&amp;#39;;
  }
}

/**
 * List available export formats from the API
 */
export async function listFormats(config: CLIConfig): Promise&amp;lt;void&amp;gt; {
  try {
    const apiClient &#x3D; new ApiClient(config);
    const result &#x3D; await apiClient.getSupportedFormats();

    if (!result.success || !result.data) {
      console.error(chalk.red(&amp;#39;Failed to get supported formats from API&amp;#39;));
      console.error(chalk.red(&#x60;Error: ${result.error}&#x60;));

      // Fallback to static list
      console.log(chalk.yellow(&amp;#39;\nFallback - Static format list:&amp;#39;));
      const fallbackFormats &#x3D; [
        {
          format: &amp;#39;openapi&amp;#39;,
          description: &amp;#39;OpenAPI 3.1 specification&amp;#39;,
          example: &amp;#39;// #OpenAPI api-v1&amp;#39;,
        },
        {
          format: &amp;#39;types&amp;#39;,
          description: &amp;#39;TypeScript type definitions&amp;#39;,
          example: &amp;#39;// #TypeScript models&amp;#39;,
        },
        { format: &amp;#39;k8s&amp;#39;, description: &amp;#39;Kubernetes YAML manifests&amp;#39;, example: &amp;#39;// #K8s deployment&amp;#39; },
        {
          format: &amp;#39;terraform&amp;#39;,
          description: &amp;#39;Terraform HCL configuration&amp;#39;,
          example: &amp;#39;// #Terraform infrastructure&amp;#39;,
        },
        {
          format: &amp;#39;json-schema&amp;#39;,
          description: &amp;#39;JSON Schema specification&amp;#39;,
          example: &amp;#39;// #JsonSchema validation&amp;#39;,
        },
      ];

      printFormats(fallbackFormats);
      return;
    }

    console.log(chalk.cyan(&amp;#39;Available export formats:&amp;#39;));
    console.log();

    printFormats(result.data);

    console.log();
    console.log(chalk.gray(&amp;#39;Note: Exports require explicit tagging in your CUE schema.&amp;#39;));
    console.log(
      chalk.gray(&amp;#39;Add comments like &amp;quot;// #OpenAPI api-v1&amp;quot; to enable export for that format.&amp;#39;)
    );
  } catch (error) {
    console.error(chalk.red(&amp;#39;Failed to list formats:&amp;#39;), error);
  }
}

/**
 * Print formats in a consistent format
 */
function printFormats(
  formats: Array&amp;lt;{ format: string; description: string; example: string }&amp;gt;
): void {
  formats.forEach(format &#x3D;&amp;gt; {
    console.log(&#x60;${chalk.green(format.format.padEnd(12))} ${format.description}&#x60;);
    console.log(&#x60;${&amp;#39; &amp;#39;.repeat(14)}${chalk.gray(format.example)}&#x60;);
    console.log();
  });
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-146">
                <div class="file-header">ğŸ“„ packages/cli/package.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;name&amp;quot;: &amp;quot;@arbiter/cli&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;Arbiter CLI for CUE validation and management&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;./dist/index.js&amp;quot;,
  &amp;quot;bin&amp;quot;: {
    &amp;quot;arbiter&amp;quot;: &amp;quot;./dist/cli.js&amp;quot;
  },
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;build&amp;quot;: &amp;quot;mkdir -p dist &amp;amp;&amp;amp; mkdir -p dist/commands &amp;amp;&amp;amp; bun build src/cli.ts --outdir dist --target&#x3D;node --format&#x3D;esm --external commander --external chalk --external fs-extra --external yaml --external zod --external glob --external chokidar --external diff --external uuid &amp;amp;&amp;amp; bun build src/index.ts --outdir dist --target&#x3D;node --format&#x3D;esm --external commander --external chalk --external fs-extra --external yaml --external zod --external glob --external chokidar --external diff --external uuid &amp;amp;&amp;amp; bun build src/config.ts --outdir dist --target&#x3D;node --format&#x3D;esm --external commander --external chalk --external fs-extra --external yaml --external zod --external glob --external chokidar --external diff --external uuid &amp;amp;&amp;amp; bun build src/api-client.ts --outdir dist --target&#x3D;node --format&#x3D;esm --external commander --external chalk --external fs-extra --external yaml --external zod --external glob --external chokidar --external diff --external uuid &amp;amp;&amp;amp; bun build src/commands/*.ts --outdir dist/commands --target&#x3D;node --format&#x3D;esm --external commander --external chalk --external fs-extra --external yaml --external zod --external glob --external chokidar --external diff --external uuid&amp;quot;,
    &amp;quot;dev&amp;quot;: &amp;quot;tsc --watch&amp;quot;,
    &amp;quot;typecheck&amp;quot;: &amp;quot;tsc --noEmit&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;bun test&amp;quot;,
    &amp;quot;test:golden&amp;quot;: &amp;quot;bun test --grep &amp;#39;golden&amp;#39;&amp;quot;,
    &amp;quot;test:performance&amp;quot;: &amp;quot;bun run src/performance-test.ts&amp;quot;,
    &amp;quot;test:watch&amp;quot;: &amp;quot;bun test --watch&amp;quot;,
    &amp;quot;clean&amp;quot;: &amp;quot;rm -rf dist tsconfig.tsbuildinfo&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;@arbiter/shared&amp;quot;: &amp;quot;workspace:*&amp;quot;,
    &amp;quot;@arbiter/cue-runner&amp;quot;: &amp;quot;workspace:*&amp;quot;,
    &amp;quot;commander&amp;quot;: &amp;quot;^12.0.0&amp;quot;,
    &amp;quot;chalk&amp;quot;: &amp;quot;^5.3.0&amp;quot;,
    &amp;quot;cli-table3&amp;quot;: &amp;quot;^0.6.3&amp;quot;,
    &amp;quot;ora&amp;quot;: &amp;quot;^8.0.1&amp;quot;,
    &amp;quot;fs-extra&amp;quot;: &amp;quot;^11.2.0&amp;quot;,
    &amp;quot;yaml&amp;quot;: &amp;quot;^2.3.4&amp;quot;,
    &amp;quot;zod&amp;quot;: &amp;quot;^3.22.4&amp;quot;,
    &amp;quot;glob&amp;quot;: &amp;quot;^10.3.10&amp;quot;,
    &amp;quot;chokidar&amp;quot;: &amp;quot;^3.6.0&amp;quot;,
    &amp;quot;diff&amp;quot;: &amp;quot;^5.1.0&amp;quot;,
    &amp;quot;uuid&amp;quot;: &amp;quot;^9.0.0&amp;quot;,
    &amp;quot;inquirer&amp;quot;: &amp;quot;^9.3.6&amp;quot;,
    &amp;quot;js-yaml&amp;quot;: &amp;quot;^4.1.0&amp;quot;,
    &amp;quot;nanoid&amp;quot;: &amp;quot;^5.0.7&amp;quot;
  },
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;@types/fs-extra&amp;quot;: &amp;quot;^11.0.4&amp;quot;,
    &amp;quot;@types/node&amp;quot;: &amp;quot;^20.11.0&amp;quot;,
    &amp;quot;@types/diff&amp;quot;: &amp;quot;^5.0.9&amp;quot;,
    &amp;quot;@types/uuid&amp;quot;: &amp;quot;^9.0.0&amp;quot;,
    &amp;quot;bun-types&amp;quot;: &amp;quot;^1.2.21&amp;quot;,
    &amp;quot;typescript&amp;quot;: &amp;quot;^5.3.3&amp;quot;
  },
  &amp;quot;engines&amp;quot;: {
    &amp;quot;bun&amp;quot;: &amp;quot;&amp;gt;&#x3D;1.0.0&amp;quot;
  },
  &amp;quot;keywords&amp;quot;: [
    &amp;quot;cli&amp;quot;,
    &amp;quot;cue&amp;quot;,
    &amp;quot;validation&amp;quot;,
    &amp;quot;arbiter&amp;quot;
  ],
  &amp;quot;author&amp;quot;: &amp;quot;Nathan Rice&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-147">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/index.css</div>
                <div class="file-content">
                    <pre>@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom scrollbar styles */
.scrollbar-transparent {
  scrollbar-width: thin;
  scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
}

.scrollbar-transparent::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

.scrollbar-transparent::-webkit-scrollbar-track {
  background: transparent;
}

.scrollbar-transparent::-webkit-scrollbar-thumb {
  background-color: rgba(156, 163, 175, 0.5);
  border-radius: 4px;
  border: none;
}

.scrollbar-transparent::-webkit-scrollbar-thumb:hover {
  background-color: rgba(156, 163, 175, 0.7);
}

/* Base styles */
* {
  box-sizing: border-box;
}

html,
body {
  height: 100%;
  margin: 0;
  padding: 0;
  font-family:
    -apple-system, BlinkMacSystemFont, &amp;#39;Segoe UI&amp;#39;, &amp;#39;Roboto&amp;#39;, &amp;#39;Oxygen&amp;#39;, &amp;#39;Ubuntu&amp;#39;, &amp;#39;Cantarell&amp;#39;,
    &amp;#39;Fira Sans&amp;#39;, &amp;#39;Droid Sans&amp;#39;, &amp;#39;Helvetica Neue&amp;#39;, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#root {
  height: 100%;
}

/* Custom utility classes */
.font-mono {
  font-family: source-code-pro, Menlo, Monaco, Consolas, &amp;#39;Courier New&amp;#39;, monospace;
}

/* Monaco editor styles */
.monaco-editor {
  font-family: &amp;#39;Fira Code&amp;#39;, &amp;#39;Consolas&amp;#39;, &amp;#39;Monaco&amp;#39;, &amp;#39;Courier New&amp;#39;, monospace !important;
  font-size: 14px !important;
  line-height: 1.5 !important;
}

.monaco-editor .current-line {
  border: none !important;
}

.monaco-editor .monaco-editor-background {
  background-color: #fafafa !important;
}

.monaco-editor .margin {
  background-color: #f5f5f5 !important;
}

/* File tree styles */
.file-tree-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 8px;
  font-size: 14px;
  cursor: pointer;
  border-radius: 4px;
}

.file-tree-item:hover {
  background: #f3f4f6;
}

.file-tree-item.active {
  background: #dbeafe;
  color: #1e40af;
}

.file-tree-item.unsaved::after {
  content: &amp;#39;â€¢&amp;#39;;
  color: #f59e0b;
  font-weight: bold;
  margin-left: 4px;
}

/* Tab styles */
.tab-content {
  height: 100%;
  overflow: hidden;
}

/* Diagram container styles */
.diagram-container {
  height: 100%;
  width: 100%;
  overflow: auto;
  background: white;
}

.diagram-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: #6b7280;
}

.diagram-error {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: #ef4444;
  padding: 16px;
}

/* Mermaid diagram styles */
.mermaid {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.mermaid svg {
  max-width: 100% !important;
  height: auto !important;
  font-family: -apple-system, BlinkMacSystemFont, &amp;#39;Segoe UI&amp;#39;, Roboto, sans-serif !important;
}

/* Graphviz diagram styles */
.graphviz-container {
  @apply w-full h-full flex items-center justify-center overflow-auto;
}

.graphviz-container svg {
  max-width: 100% !important;
  height: auto !important;
  shape-rendering: crispEdges;
}

/* Coverage meter styles */
.coverage-meter {
  @apply relative bg-gray-200 rounded-full h-2 overflow-hidden;
}

.coverage-meter-fill {
  @apply h-full bg-green-500 rounded-full transition-all duration-300;
}

.coverage-meter-fill.warning {
  @apply bg-yellow-500;
}

.coverage-meter-fill.danger {
  @apply bg-red-500;
}

/* Gap item styles */
.gap-item {
  @apply border border-gray-200 rounded-lg p-4 mb-3 hover:bg-gray-50 transition-colors;
}

.gap-item.resolved {
  @apply bg-green-50 border-green-200;
}

.gap-item.high-priority {
  @apply border-red-200 bg-red-50;
}

/* Toast notification styles */
.toast-container {
  font-size: 14px !important;
}

/* Loading spinner */
.spinner {
  @apply animate-spin rounded-full border-2 border-gray-300 border-t-blue-600;
}

/* Error boundary styles */
.error-boundary {
  @apply flex flex-col items-center justify-center h-full p-8 text-center;
}

.error-boundary h2 {
  @apply text-xl font-semibold text-red-600 mb-4;
}

.error-boundary pre {
  @apply bg-gray-100 p-4 rounded text-sm text-left max-w-full overflow-auto;
}

/* Accessibility improvements */
@media (prefers-reduced-motion: reduce) {
  .animate-spin,
  .transition-all,
  .transition-colors,
  .coverage-meter-fill {
    animation: none !important;
    transition: none !important;
  }
}

/* High contrast mode */
@media (prefers-contrast: high) {
  .border-gray-200 {
    @apply border-gray-900;
  }

  .text-gray-500 {
    @apply text-gray-900;
  }

  .bg-gray-100 {
    @apply bg-gray-200;
  }
}

/* Print styles */
@media print {
  .no-print {
    display: none !important;
  }

  .diagram-container {
    @apply overflow-visible;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-148">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/check-constrained.ts</div>
                <div class="file-content">
                    <pre>import path from &amp;#39;node:path&amp;#39;;
import { translateCueErrors } from &amp;#39;@arbiter/shared&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import { glob } from &amp;#39;glob&amp;#39;;
import { ApiClient } from &amp;#39;../api-client.js&amp;#39;;
import { ConstraintViolationError, getGlobalConstraintSystem } from &amp;#39;../constraints/index.js&amp;#39;;
import type { CLIConfig, CheckOptions, ValidationResult } from &amp;#39;../types.js&amp;#39;;
import {
  formatErrorDetails,
  formatFileSize,
  formatJson,
  formatSummary,
  formatValidationTable,
  formatWarningDetails,
} from &amp;#39;../utils/formatting.js&amp;#39;;
import { withProgress } from &amp;#39;../utils/progress.js&amp;#39;;

/**
 * Enhanced check command with comprehensive constraint enforcement
 * Implements all &amp;quot;Don&amp;#39;ts&amp;quot; from TODO.md section 13
 */
export async function checkCommandConstrained(
  patterns: string[],
  options: CheckOptions,
  config: CLIConfig
): Promise&amp;lt;number&amp;gt; {
  const constraintSystem &#x3D; getGlobalConstraintSystem();

  try {
    return await constraintSystem.executeWithConstraints(
      &amp;#39;check&amp;#39;,
      {
        sandbox: &amp;#39;check&amp;#39;,
        filesystem: &amp;#39;read&amp;#39;,
        idempotent: &amp;#39;validate&amp;#39;,
      },
      async () &#x3D;&amp;gt; {
        // Use default pattern if none provided
        if (patterns.length &#x3D;&#x3D;&#x3D; 0) {
          patterns &#x3D; [&amp;#39;**/*.cue&amp;#39;];
        }

        // Find all matching files with constraint validation
        const files &#x3D; await findCueFilesConstrained(patterns, {
          recursive: options.recursive ?? true,
          cwd: config.projectDir,
        });

        if (files.length &#x3D;&#x3D;&#x3D; 0) {
          console.log(chalk.yellow(&amp;#39;No CUE files found&amp;#39;));
          return 0;
        }

        console.log(chalk.dim(&#x60;Found ${files.length} CUE files&#x60;));

        // Validate files with full constraint enforcement
        const results &#x3D; await validateFilesConstrained(files, config, options);

        // Format and display results
        if (options.format &#x3D;&#x3D;&#x3D; &amp;#39;json&amp;#39;) {
          const output &#x3D; formatJson(results, config.color);
          // Validate JSON output payload size
          constraintSystem.validateApiResponse(output);
          console.log(output);
        } else {
          displayResultsConstrained(results, options, config);
        }

        // Generate constraint compliance report if verbose
        if (options.verbose) {
          console.log(&#x60;\n${constraintSystem.generateComplianceReport()}&#x60;);
        }

        // Determine exit code
        const hasErrors &#x3D; results.some(r &#x3D;&amp;gt; r.status &#x3D;&#x3D;&#x3D; &amp;#39;invalid&amp;#39; || r.status &#x3D;&#x3D;&#x3D; &amp;#39;error&amp;#39;);
        return hasErrors ? 1 : 0;
      },
      {
        patterns: patterns.length,
        recursive: options.recursive,
        format: options.format,
      }
    );
  } catch (error) {
    if (error instanceof ConstraintViolationError) {
      console.error(chalk.red(&amp;#39;Constraint violation:&amp;#39;), error.message);
      console.error(chalk.dim(&amp;#39;Details:&amp;#39;), JSON.stringify(error.details, null, 2));
      return 2; // Constraint violation exit code
    }

    console.error(
      chalk.red(&amp;#39;Check command failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 2;
  }
}

/**
 * Find CUE files with file system constraint validation
 */
async function findCueFilesConstrained(
  patterns: string[],
  options: {
    recursive: boolean;
    cwd: string;
  }
): Promise&amp;lt;string[]&amp;gt; {
  const constraintSystem &#x3D; getGlobalConstraintSystem();

  // Validate working directory path
  await constraintSystem.validateFileOperation(&amp;#39;read&amp;#39;, [options.cwd]);

  const allFiles: string[] &#x3D; [];

  for (const pattern of patterns) {
    const files &#x3D; await glob(pattern, {
      cwd: options.cwd,
      absolute: true,
      ignore: [&amp;#39;**/node_modules/**&amp;#39;, &amp;#39;**/.git/**&amp;#39;, &amp;#39;**/dist/**&amp;#39;, &amp;#39;**/build/**&amp;#39;],
    });

    // Validate each found file path
    await constraintSystem.validateFileOperation(&amp;#39;read&amp;#39;, files);

    allFiles.push(...files);
  }

  // Remove duplicates and sort
  return [...new Set(allFiles)].sort();
}

/**
 * Validate multiple files with comprehensive constraint enforcement
 */
async function validateFilesConstrained(
  files: string[],
  config: CLIConfig,
  options: CheckOptions
): Promise&amp;lt;ValidationResult[]&amp;gt; {
  const constraintSystem &#x3D; getGlobalConstraintSystem();
  const apiClient &#x3D; new ApiClient(config);
  const results: ValidationResult[] &#x3D; [];

  // Check server health first with sandbox compliance
  const healthCheck &#x3D; await apiClient.health();
  if (!healthCheck.success) {
    throw new Error(&#x60;Cannot connect to Arbiter server: ${healthCheck.error}&#x60;);
  }

  let _processedCount &#x3D; 0;
  const progressText &#x3D; &#x60;Validating ${files.length} files...&#x60;;

  return withProgress({ text: progressText, color: &amp;#39;blue&amp;#39; }, async () &#x3D;&amp;gt; {
    // Process files with constrained concurrency (respects rate limiting)
    const concurrency &#x3D; 1; // Enforce ~1 rps rate limit
    const chunks &#x3D; chunkArray(files, concurrency);

    for (const chunk of chunks) {
      const chunkResults: ValidationResult[] &#x3D; [];

      // Process chunk sequentially to respect rate limits
      for (const file of chunk) {
        try {
          const result &#x3D; await validateFileConstrained(file, apiClient, options, constraintSystem);
          chunkResults.push(result);
          _processedCount++;

          if (options.verbose) {
            const status &#x3D;
              result.status &#x3D;&#x3D;&#x3D; &amp;#39;valid&amp;#39;
                ? chalk.green(&amp;#39;âœ“&amp;#39;)
                : result.status &#x3D;&#x3D;&#x3D; &amp;#39;invalid&amp;#39;
                  ? chalk.red(&amp;#39;âœ—&amp;#39;)
                  : chalk.yellow(&amp;#39;!&amp;#39;);
            console.log(&#x60;${status} ${path.relative(config.projectDir, file)}&#x60;);
          }

          // Enforce rate limiting between requests
          await new Promise(resolve &#x3D;&amp;gt; setTimeout(resolve, 1100)); // Slightly over 1 second for ~1 rps
        } catch (error) {
          if (error instanceof ConstraintViolationError) {
            console.error(
              chalk.red(&#x60;Constraint violation in ${path.basename(file)}:&#x60;),
              error.message
            );

            // Create error result for constraint violations
            chunkResults.push({
              file: path.basename(file),
              status: &amp;#39;error&amp;#39;,
              errors: [
                {
                  line: 0,
                  column: 0,
                  message: &#x60;Constraint violation: ${error.constraint} - ${error.message}&#x60;,
                  severity: &amp;#39;error&amp;#39; as const,
                  category: &amp;#39;constraint&amp;#39;,
                },
              ],
              warnings: [],
              processingTime: 0,
            });
          } else {
            throw error;
          }
        }
      }

      results.push(...chunkResults);

      // Fail fast if requested and we have errors
      if (options.failFast &amp;amp;&amp;amp; chunkResults.some(r &#x3D;&amp;gt; r.status !&#x3D;&#x3D; &amp;#39;valid&amp;#39;)) {
        break;
      }
    }

    return results;
  });
}

/**
 * Validate a single file with comprehensive constraint enforcement
 */
async function validateFileConstrained(
  filePath: string,
  apiClient: ApiClient,
  _options: CheckOptions,
  constraintSystem: ReturnType&amp;lt;typeof getGlobalConstraintSystem&amp;gt;
): Promise&amp;lt;ValidationResult&amp;gt; {
  const startTime &#x3D; Date.now();

  try {
    // Validate file path constraints
    await constraintSystem.validateFileOperation(&amp;#39;read&amp;#39;, [filePath]);

    // Check if file exists and is readable
    const stats &#x3D; await fs.stat(filePath);
    if (!stats.isFile()) {
      return {
        file: path.basename(filePath),
        status: &amp;#39;error&amp;#39;,
        errors: [
          {
            line: 0,
            column: 0,
            message: &amp;#39;Not a file&amp;#39;,
            severity: &amp;#39;error&amp;#39; as const,
            category: &amp;#39;system&amp;#39;,
          },
        ],
        warnings: [],
        processingTime: Date.now() - startTime,
      };
    }

    // Enforce payload size limit (64 KB)
    const maxSize &#x3D; 64 * 1024; // 64 KB constraint
    if (stats.size &amp;gt; maxSize) {
      return {
        file: path.basename(filePath),
        status: &amp;#39;error&amp;#39;,
        errors: [
          {
            line: 0,
            column: 0,
            message: &#x60;File too large (${formatFileSize(stats.size)}), maximum allowed: ${formatFileSize(maxSize)}&#x60;,
            severity: &amp;#39;error&amp;#39; as const,
            category: &amp;#39;constraint&amp;#39;,
          },
        ],
        warnings: [],
        processingTime: Date.now() - startTime,
      };
    }

    // Read file content
    const content &#x3D; await fs.readFile(filePath, &amp;#39;utf-8&amp;#39;);

    // Validate content payload size
    constraintSystem.validateApiResponse(content);

    // Validate using API (sandbox compliant)
    const validationResult &#x3D; await apiClient.validate(content);

    // Validate API response constraints
    const _validatedResponse &#x3D; constraintSystem.validateApiResponse(validationResult);

    if (!validationResult.success || !validationResult.data) {
      return {
        file: path.basename(filePath),
        status: &amp;#39;error&amp;#39;,
        errors: [
          {
            line: 0,
            column: 0,
            message: validationResult.error || &amp;#39;Unknown validation error&amp;#39;,
            severity: &amp;#39;error&amp;#39; as const,
            category: &amp;#39;api&amp;#39;,
          },
        ],
        warnings: [],
        processingTime: Date.now() - startTime,
      };
    }

    const data &#x3D; validationResult.data;

    // Process errors with enhanced translation
    const errors &#x3D;
      data.errors?.map(error &#x3D;&amp;gt; {
        const translated &#x3D; translateCueErrors(error.message);
        return {
          line: error.line || 0,
          column: error.column || 0,
          message: translated[0]?.friendlyMessage || error.message,
          severity: &amp;#39;error&amp;#39; as const,
          category: translated[0]?.category || &amp;#39;validation&amp;#39;,
        };
      }) || [];

    // Process warnings
    const warnings &#x3D;
      data.warnings?.map(warning &#x3D;&amp;gt; ({
        line: warning.line || 0,
        column: warning.column || 0,
        message: warning.message,
        category: &amp;#39;validation&amp;#39;,
      })) || [];

    const status &#x3D; data.success ? &amp;#39;valid&amp;#39; : &amp;#39;invalid&amp;#39;;
    const processingTime &#x3D; Date.now() - startTime;

    // Enforce operation time constraint (â‰¤750 ms)
    if (processingTime &amp;gt; 750) {
      console.warn(
        chalk.yellow(
          &#x60;Warning: ${path.basename(filePath)} took ${processingTime}ms (&amp;gt;750ms constraint)&#x60;
        )
      );
    }

    return {
      file: path.basename(filePath),
      status,
      errors,
      warnings,
      processingTime,
    };
  } catch (error) {
    if (error instanceof ConstraintViolationError) {
      throw error; // Let constraint violations bubble up
    }

    return {
      file: path.basename(filePath),
      status: &amp;#39;error&amp;#39;,
      errors: [
        {
          line: 0,
          column: 0,
          message: error instanceof Error ? error.message : String(error),
          severity: &amp;#39;error&amp;#39; as const,
          category: &amp;#39;system&amp;#39;,
        },
      ],
      warnings: [],
      processingTime: Date.now() - startTime,
    };
  }
}

/**
 * Display validation results with constraint compliance information
 */
function displayResultsConstrained(
  results: ValidationResult[],
  options: CheckOptions,
  _config: CLIConfig
): void {
  // Show table
  console.log(&#x60;\n${formatValidationTable(results)}&#x60;);

  // Show constraint compliance summary
  const constraintSystem &#x3D; getGlobalConstraintSystem();
  const status &#x3D; constraintSystem.getSystemStatus();

  if (!status.isHealthy) {
    console.log(chalk.yellow(&amp;#39;\nâš ï¸  Constraint Violations Detected:&amp;#39;));
    for (const critical of status.violations.criticalViolations) {
      console.log(&#x60;   ${chalk.red(&amp;#39;â€¢&amp;#39;)} ${critical}&#x60;);
    }
  }

  // Show detailed errors if present
  if (options.verbose || results.some(r &#x3D;&amp;gt; r.errors.length &amp;gt; 0)) {
    const errorDetails &#x3D; formatErrorDetails(results);
    if (errorDetails) {
      console.log(errorDetails);
    }
  }

  // Show warnings if verbose or if there are warnings
  if (options.verbose || results.some(r &#x3D;&amp;gt; r.warnings.length &amp;gt; 0)) {
    const warningDetails &#x3D; formatWarningDetails(results);
    if (warningDetails) {
      console.log(warningDetails);
    }
  }

  // Show summary with constraint compliance
  console.log(formatSummary(results));

  // Show performance summary
  const totalTime &#x3D; results.reduce((sum, r) &#x3D;&amp;gt; sum + r.processingTime, 0);
  const avgTime &#x3D; totalTime / results.length;
  const maxTime &#x3D; Math.max(...results.map(r &#x3D;&amp;gt; r.processingTime));

  console.log(
    chalk.dim(
      &#x60;Performance: avg ${Math.round(avgTime)}ms, max ${Math.round(maxTime)}ms, total ${Math.round(totalTime)}ms&#x60;
    )
  );

  if (maxTime &amp;gt; 750) {
    console.log(chalk.yellow(&amp;#39;Warning: Some operations exceeded 750ms constraint&amp;#39;));
  }
}

/**
 * Utility to chunk array for batch processing
 */
function chunkArray&amp;lt;T&amp;gt;(array: T[], size: number): T[][] {
  const chunks: T[][] &#x3D; [];
  for (let i &#x3D; 0; i &amp;lt; array.length; i +&#x3D; size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-149">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/design-system/variants.ts</div>
                <div class="file-content">
                    <pre>/**
 * Component Variant Patterns
 * Consistent styling patterns for different component states and variants
 */

import { clsx } from &amp;#39;clsx&amp;#39;;

// Base component classes
export const baseClasses &#x3D; {
  // Focus ring for interactive elements
  focusRing: &amp;#39;focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2&amp;#39;,

  // Transitions
  transition: &amp;#39;transition-all duration-150 ease-in-out&amp;#39;,

  // Typography
  text: {
    xs: &amp;#39;text-xs&amp;#39;,
    sm: &amp;#39;text-sm&amp;#39;,
    base: &amp;#39;text-base&amp;#39;,
    lg: &amp;#39;text-lg&amp;#39;,
    xl: &amp;#39;text-xl&amp;#39;,
  },

  // Spacing
  spacing: {
    xs: &amp;#39;px-2 py-1&amp;#39;,
    sm: &amp;#39;px-3 py-1.5&amp;#39;,
    md: &amp;#39;px-4 py-2&amp;#39;,
    lg: &amp;#39;px-6 py-3&amp;#39;,
    xl: &amp;#39;px-8 py-4&amp;#39;,
  },

  // Border radius
  rounded: {
    none: &amp;#39;rounded-none&amp;#39;,
    sm: &amp;#39;rounded-sm&amp;#39;,
    md: &amp;#39;rounded&amp;#39;,
    lg: &amp;#39;rounded-lg&amp;#39;,
    xl: &amp;#39;rounded-xl&amp;#39;,
    full: &amp;#39;rounded-full&amp;#39;,
  },
} as const;

// Button variants
export const buttonVariants &#x3D; {
  // Primary button - main actions
  primary: clsx(
    &amp;#39;bg-blue-600 hover:bg-blue-700 active:bg-blue-800&amp;#39;,
    &amp;#39;text-white font-medium&amp;#39;,
    &amp;#39;border border-transparent&amp;#39;,
    &amp;#39;disabled:bg-gray-300 disabled:text-gray-500 disabled:cursor-not-allowed&amp;#39;,
    baseClasses.transition,
    baseClasses.focusRing
  ),

  // Secondary button - secondary actions
  secondary: clsx(
    &amp;#39;bg-graphite-100 hover:bg-graphite-200 active:bg-graphite-300&amp;#39;,
    &amp;#39;text-graphite-700 font-medium&amp;#39;,
    &amp;#39;border border-graphite-300&amp;#39;,
    &amp;#39;disabled:bg-gray-50 disabled:text-gray-400 disabled:cursor-not-allowed&amp;#39;,
    baseClasses.transition,
    baseClasses.focusRing
  ),

  // Ghost button - subtle actions
  ghost: clsx(
    &amp;#39;bg-transparent hover:bg-graphite-100 active:bg-graphite-200&amp;#39;,
    &amp;#39;text-graphite-600 hover:text-graphite-700&amp;#39;,
    &amp;#39;border border-transparent&amp;#39;,
    &amp;#39;disabled:text-gray-400 disabled:cursor-not-allowed&amp;#39;,
    baseClasses.transition,
    baseClasses.focusRing
  ),

  // Danger button - destructive actions
  danger: clsx(
    &amp;#39;bg-red-600 hover:bg-red-700 active:bg-red-800&amp;#39;,
    &amp;#39;text-white font-medium&amp;#39;,
    &amp;#39;border border-transparent&amp;#39;,
    &amp;#39;disabled:bg-gray-300 disabled:text-gray-500 disabled:cursor-not-allowed&amp;#39;,
    baseClasses.transition,
    baseClasses.focusRing
  ),
} as const;

// Input variants
export const inputVariants &#x3D; {
  // Default input
  default: clsx(
    &amp;#39;bg-white border border-graphite-300&amp;#39;,
    &amp;#39;text-graphite-900 placeholder:text-graphite-400&amp;#39;,
    &amp;#39;hover:border-graphite-400 focus:border-blue-500 focus:ring-1 focus:ring-blue-500&amp;#39;,
    &amp;#39;disabled:bg-graphite-50 disabled:text-graphite-500 disabled:cursor-not-allowed disabled:border-graphite-200&amp;#39;,
    &amp;#39;outline-none transition-all duration-150&amp;#39;
  ),

  // Error state
  error: clsx(
    &amp;#39;bg-white border border-red-300&amp;#39;,
    &amp;#39;text-graphite-900 placeholder:text-graphite-400&amp;#39;,
    &amp;#39;hover:border-red-400 focus:border-red-500 focus:ring-1 focus:ring-red-500&amp;#39;,
    &amp;#39;disabled:bg-red-50 disabled:text-red-300 disabled:cursor-not-allowed disabled:border-red-200&amp;#39;,
    &amp;#39;outline-none transition-all duration-150&amp;#39;
  ),

  // Warning state
  warning: clsx(
    &amp;#39;bg-white border border-amber-300&amp;#39;,
    &amp;#39;text-graphite-900 placeholder:text-graphite-400&amp;#39;,
    &amp;#39;hover:border-amber-400 focus:border-amber-500 focus:ring-1 focus:ring-amber-500&amp;#39;,
    &amp;#39;disabled:bg-amber-50 disabled:text-amber-300 disabled:cursor-not-allowed disabled:border-amber-200&amp;#39;,
    &amp;#39;outline-none transition-all duration-150&amp;#39;
  ),

  // Success state
  success: clsx(
    &amp;#39;bg-white border border-emerald-300&amp;#39;,
    &amp;#39;text-graphite-900 placeholder:text-graphite-400&amp;#39;,
    &amp;#39;hover:border-emerald-400 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500&amp;#39;,
    &amp;#39;disabled:bg-emerald-50 disabled:text-emerald-300 disabled:cursor-not-allowed disabled:border-emerald-200&amp;#39;,
    &amp;#39;outline-none transition-all duration-150&amp;#39;
  ),
} as const;

// Card variants
export const cardVariants &#x3D; {
  // Default card
  default: clsx(
    &amp;#39;bg-white border border-graphite-200&amp;#39;,
    &amp;#39;shadow-sm hover:shadow-md&amp;#39;,
    &amp;#39;transition-shadow duration-150&amp;#39;
  ),

  // Interactive card (clickable)
  interactive: clsx(
    &amp;#39;bg-white border border-graphite-200&amp;#39;,
    &amp;#39;shadow-sm hover:shadow-md hover:border-graphite-300&amp;#39;,
    &amp;#39;cursor-pointer transition-all duration-150&amp;#39;,
    baseClasses.focusRing
  ),

  // Elevated card
  elevated: clsx(
    &amp;#39;bg-white border border-graphite-200&amp;#39;,
    &amp;#39;shadow-md hover:shadow-lg&amp;#39;,
    &amp;#39;transition-shadow duration-150&amp;#39;
  ),

  // Outlined card
  outlined: clsx(
    &amp;#39;bg-transparent border-2 border-graphite-300&amp;#39;,
    &amp;#39;hover:border-graphite-400 hover:bg-graphite-50&amp;#39;,
    &amp;#39;transition-all duration-150&amp;#39;
  ),

  // Ghost card
  ghost: clsx(
    &amp;#39;bg-transparent border-0 shadow-none&amp;#39;,
    &amp;#39;hover:bg-graphite-50&amp;#39;,
    &amp;#39;transition-colors duration-150&amp;#39;
  ),
} as const;

// Status indicator variants
export const statusVariants &#x3D; {
  success: {
    bg: &amp;#39;bg-emerald-50&amp;#39;,
    border: &amp;#39;border-emerald-200&amp;#39;,
    text: &amp;#39;text-emerald-700&amp;#39;,
    icon: &amp;#39;text-emerald-500&amp;#39;,
    dot: &amp;#39;bg-emerald-500&amp;#39;,
  },
  warning: {
    bg: &amp;#39;bg-amber-50&amp;#39;,
    border: &amp;#39;border-amber-200&amp;#39;,
    text: &amp;#39;text-amber-700&amp;#39;,
    icon: &amp;#39;text-amber-500&amp;#39;,
    dot: &amp;#39;bg-amber-500&amp;#39;,
  },
  error: {
    bg: &amp;#39;bg-red-50&amp;#39;,
    border: &amp;#39;border-red-200&amp;#39;,
    text: &amp;#39;text-red-700&amp;#39;,
    icon: &amp;#39;text-red-500&amp;#39;,
    dot: &amp;#39;bg-red-500&amp;#39;,
  },
  info: {
    bg: &amp;#39;bg-blue-50&amp;#39;,
    border: &amp;#39;border-blue-200&amp;#39;,
    text: &amp;#39;text-blue-700&amp;#39;,
    icon: &amp;#39;text-blue-500&amp;#39;,
    dot: &amp;#39;bg-blue-500&amp;#39;,
  },
  neutral: {
    bg: &amp;#39;bg-graphite-50&amp;#39;,
    border: &amp;#39;border-graphite-200&amp;#39;,
    text: &amp;#39;text-graphite-700&amp;#39;,
    icon: &amp;#39;text-graphite-500&amp;#39;,
    dot: &amp;#39;bg-graphite-500&amp;#39;,
  },
} as const;

// Size variants
export const sizeVariants &#x3D; {
  button: {
    xs: clsx(baseClasses.spacing.xs, baseClasses.text.xs, baseClasses.rounded.sm),
    sm: clsx(baseClasses.spacing.sm, baseClasses.text.sm, baseClasses.rounded.md),
    md: clsx(baseClasses.spacing.md, baseClasses.text.base, baseClasses.rounded.md),
    lg: clsx(baseClasses.spacing.lg, baseClasses.text.lg, baseClasses.rounded.lg),
    xl: clsx(baseClasses.spacing.xl, baseClasses.text.xl, baseClasses.rounded.lg),
  },

  input: {
    sm: clsx(&amp;#39;px-3 py-1.5&amp;#39;, baseClasses.text.sm, baseClasses.rounded.md),
    md: clsx(&amp;#39;px-3 py-2&amp;#39;, baseClasses.text.base, baseClasses.rounded.md),
    lg: clsx(&amp;#39;px-4 py-3&amp;#39;, baseClasses.text.lg, baseClasses.rounded.lg),
  },

  icon: {
    xs: &amp;#39;h-3 w-3&amp;#39;,
    sm: &amp;#39;h-4 w-4&amp;#39;,
    md: &amp;#39;h-5 w-5&amp;#39;,
    lg: &amp;#39;h-6 w-6&amp;#39;,
    xl: &amp;#39;h-8 w-8&amp;#39;,
  },
} as const;

// Animation variants
export const animationVariants &#x3D; {
  fadeIn: &amp;#39;animate-in fade-in duration-200&amp;#39;,
  fadeOut: &amp;#39;animate-out fade-out duration-200&amp;#39;,
  slideInFromTop: &amp;#39;animate-in slide-in-from-top-2 duration-200&amp;#39;,
  slideInFromBottom: &amp;#39;animate-in slide-in-from-bottom-2 duration-200&amp;#39;,
  slideInFromLeft: &amp;#39;animate-in slide-in-from-left-2 duration-200&amp;#39;,
  slideInFromRight: &amp;#39;animate-in slide-in-from-right-2 duration-200&amp;#39;,
  scaleIn: &amp;#39;animate-in zoom-in-95 duration-200&amp;#39;,
  scaleOut: &amp;#39;animate-out zoom-out-95 duration-200&amp;#39;,
} as const;

// Utility function to create variant classes
export function createVariant(
  base: string,
  variants: Record&amp;lt;string, string&amp;gt;,
  defaultVariant &#x3D; &amp;#39;default&amp;#39;
) {
  return (variant?: string) &#x3D;&amp;gt; clsx(base, variants[variant || defaultVariant]);
}

// Utility function to merge classes with variants
export function cn(...classes: (string | undefined | null | false)[]): string {
  return clsx(...classes);
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-150">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/github-sync.ts</div>
                <div class="file-content">
                    <pre>import { Octokit } from &amp;#39;@octokit/rest&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import type { GitHubSyncConfig, IssueSpec } from &amp;#39;../types.js&amp;#39;;
import { FileBasedTemplateManager } from &amp;#39;./file-based-template-manager.js&amp;#39;;
import { ConfigurableTemplateManager } from &amp;#39;./github-template-config.js&amp;#39;;
import { GitHubTemplateManager, type GitHubTemplateOptions } from &amp;#39;./github-templates.js&amp;#39;;
import type { Epic, Task } from &amp;#39;./sharded-storage.js&amp;#39;;

export interface GitHubIssue {
  number: number;
  title: string;
  body?: string;
  state: &amp;#39;open&amp;#39; | &amp;#39;closed&amp;#39;;
  labels: string[];
  milestone?: {
    number: number;
    title: string;
  };
  assignee?: {
    login: string;
  };
}

/** Enhanced GitHub issue template based on exact issue schema */
export interface GitHubIssueTemplate extends IssueSpec {
  /** Additional GitHub-specific fields */
  assignees?: string[];
  milestone?: number;
  projects?: number[];
}

export interface GitHubMilestone {
  number: number;
  title: string;
  state: &amp;#39;open&amp;#39; | &amp;#39;closed&amp;#39;;
  description?: string;
}

export interface SyncResult {
  action: &amp;#39;created&amp;#39; | &amp;#39;updated&amp;#39; | &amp;#39;skipped&amp;#39; | &amp;#39;closed&amp;#39;;
  type: &amp;#39;epic&amp;#39; | &amp;#39;task&amp;#39; | &amp;#39;milestone&amp;#39;;
  itemId: string;
  githubNumber?: number;
  details?: string;
}

export interface SyncPreview {
  epics: {
    create: Epic[];
    update: Array&amp;lt;{ epic: Epic; existing: GitHubIssue }&amp;gt;;
    close: Array&amp;lt;{ epic: Epic; existing: GitHubIssue }&amp;gt;;
  };
  tasks: {
    create: Task[];
    update: Array&amp;lt;{ task: Task; existing: GitHubIssue }&amp;gt;;
    close: Array&amp;lt;{ task: Task; existing: GitHubIssue }&amp;gt;;
  };
  milestones: {
    create: Epic[];
    update: Array&amp;lt;{ epic: Epic; existing: GitHubMilestone }&amp;gt;;
    close: Array&amp;lt;{ epic: Epic; existing: GitHubMilestone }&amp;gt;;
  };
}

export class GitHubSyncClient {
  private octokit: Octokit;
  private config: GitHubSyncConfig;
  private templateManager: GitHubTemplateManager;
  private configurableTemplateManager: ConfigurableTemplateManager;
  private fileBasedTemplateManager: FileBasedTemplateManager;
  private issueCache: Map&amp;lt;string, GitHubIssue&amp;gt; &#x3D; new Map();
  private milestoneCache: Map&amp;lt;string, GitHubMilestone&amp;gt; &#x3D; new Map();

  constructor(config: GitHubSyncConfig) {
    this.config &#x3D; config;
    this.templateManager &#x3D; new GitHubTemplateManager();
    this.configurableTemplateManager &#x3D; new ConfigurableTemplateManager(config.templates);
    this.fileBasedTemplateManager &#x3D; new FileBasedTemplateManager(config.templates || {});

    // Get GitHub token from configured environment variable
    const tokenEnvName &#x3D; config.repository.tokenEnv || &amp;#39;GITHUB_TOKEN&amp;#39;;
    const token &#x3D;
      process.env[tokenEnvName] || process.env.GITHUB_TOKEN || process.env.ARBITER_GITHUB_TOKEN;

    if (!token) {
      const envVarMessage &#x3D;
        tokenEnvName !&#x3D;&#x3D; &amp;#39;GITHUB_TOKEN&amp;#39;
          ? &#x60;${tokenEnvName} (or GITHUB_TOKEN as fallback)&#x60;
          : &amp;#39;GITHUB_TOKEN&amp;#39;;

      throw new Error(
        &#x60;GitHub token not found. Set the ${envVarMessage} environment variable.\nTo create a token:\n1. Go to https://github.com/settings/tokens\n2. Generate a new token with &amp;#39;repo&amp;#39; scope\n3. Set ${tokenEnvName}&#x3D;your_token_here in your environment&#x60;
      );
    }

    this.octokit &#x3D; new Octokit({
      auth: token,
      baseUrl: config.repository.baseUrl || &amp;#39;https://api.github.com&amp;#39;,
    });
  }

  /**
   * Generate a preview of what would be synced without making changes
   */
  async generateSyncPreview(epics: Epic[]): Promise&amp;lt;SyncPreview&amp;gt; {
    await this.loadExistingData();

    const preview: SyncPreview &#x3D; {
      epics: { create: [], update: [], close: [] },
      tasks: { create: [], update: [], close: [] },
      milestones: { create: [], update: [], close: [] },
    };

    // Process epics
    for (const epic of epics) {
      const epicTitle &#x3D; await this.generateEpicTitle(epic);
      const existingIssue &#x3D; this.findExistingIssue(epicTitle, epic.id);

      if (!existingIssue) {
        preview.epics.create.push(epic);
      } else if (await this.shouldUpdateEpic(epic, existingIssue)) {
        preview.epics.update.push({ epic, existing: existingIssue });
      }

      if (epic.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39; || epic.status &#x3D;&#x3D;&#x3D; &amp;#39;cancelled&amp;#39;) {
        if (existingIssue &amp;amp;&amp;amp; existingIssue.state &#x3D;&#x3D;&#x3D; &amp;#39;open&amp;#39;) {
          preview.epics.close.push({ epic, existing: existingIssue });
        }
      }

      // Process milestone for epic
      if (this.config.behavior?.createMilestones) {
        const milestoneTitle &#x3D; this.generateMilestoneTitle(epic);
        const existingMilestone &#x3D; this.findExistingMilestone(milestoneTitle, epic.id);

        if (!existingMilestone) {
          preview.milestones.create.push(epic);
        } else if (this.shouldUpdateMilestone(epic, existingMilestone)) {
          preview.milestones.update.push({ epic, existing: existingMilestone });
        }

        if (epic.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39; || epic.status &#x3D;&#x3D;&#x3D; &amp;#39;cancelled&amp;#39;) {
          if (existingMilestone &amp;amp;&amp;amp; existingMilestone.state &#x3D;&#x3D;&#x3D; &amp;#39;open&amp;#39;) {
            preview.milestones.close.push({ epic, existing: existingMilestone });
          }
        }
      }

      // Process tasks for this epic
      for (const task of epic.tasks) {
        const taskTitle &#x3D; await this.generateTaskTitle(task, epic);
        const existingTaskIssue &#x3D; this.findExistingIssue(taskTitle, task.id);

        if (!existingTaskIssue) {
          preview.tasks.create.push(task);
        } else if (await this.shouldUpdateTask(task, existingTaskIssue, epic)) {
          preview.tasks.update.push({ task, existing: existingTaskIssue });
        }

        if (task.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39; || task.status &#x3D;&#x3D;&#x3D; &amp;#39;cancelled&amp;#39;) {
          if (existingTaskIssue &amp;amp;&amp;amp; existingTaskIssue.state &#x3D;&#x3D;&#x3D; &amp;#39;open&amp;#39;) {
            preview.tasks.close.push({ task, existing: existingTaskIssue });
          }
        }
      }
    }

    return preview;
  }

  /**
   * Sync epics and tasks to GitHub (idempotent operation)
   */
  async syncToGitHub(epics: Epic[], dryRun &#x3D; false): Promise&amp;lt;SyncResult[]&amp;gt; {
    const results: SyncResult[] &#x3D; [];

    if (dryRun) {
      const preview &#x3D; await this.generateSyncPreview(epics);
      return this.convertPreviewToResults(preview);
    }

    await this.loadExistingData();

    // Process epics
    for (const epic of epics) {
      const epicResults &#x3D; await this.syncEpic(epic);
      results.push(...epicResults);

      // Process tasks for this epic
      for (const task of epic.tasks) {
        const taskResults &#x3D; await this.syncTask(task, epic);
        results.push(...taskResults);
      }
    }

    return results;
  }

  /**
   * Load existing GitHub issues and milestones into cache
   */
  private async loadExistingData(): Promise&amp;lt;void&amp;gt; {
    const { owner, repo } &#x3D; this.config.repository;

    try {
      // Load issues
      const issues &#x3D; await this.octokit.paginate(this.octokit.rest.issues.listForRepo, {
        owner,
        repo,
        state: &amp;#39;all&amp;#39;,
        per_page: 100,
      });

      for (const issue of issues) {
        if (!issue.pull_request) {
          // Exclude PRs
          const githubIssue: GitHubIssue &#x3D; {
            number: issue.number,
            title: issue.title,
            body: issue.body || undefined,
            state: issue.state as &amp;#39;open&amp;#39; | &amp;#39;closed&amp;#39;,
            labels: issue.labels.map(label &#x3D;&amp;gt;
              typeof label &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39; ? label : label.name || &amp;#39;&amp;#39;
            ),
            milestone: issue.milestone
              ? {
                  number: issue.milestone.number,
                  title: issue.milestone.title,
                }
              : undefined,
            assignee: issue.assignee
              ? {
                  login: issue.assignee.login,
                }
              : undefined,
          };

          this.issueCache.set(issue.title, githubIssue);

          // Also cache by arbiter ID if present in body
          const arbiterIdMatch &#x3D; issue.body?.match(/&amp;lt;!-- arbiter-id: ([^\\s]+) --&amp;gt;/);
          if (arbiterIdMatch) {
            this.issueCache.set(&#x60;arbiter:${arbiterIdMatch[1]}&#x60;, githubIssue);
          }
        }
      }

      // Load milestones if needed
      if (this.config.behavior?.createMilestones) {
        const milestones &#x3D; await this.octokit.paginate(this.octokit.rest.issues.listMilestones, {
          owner,
          repo,
          state: &amp;#39;all&amp;#39;,
          per_page: 100,
        });

        for (const milestone of milestones) {
          const githubMilestone: GitHubMilestone &#x3D; {
            number: milestone.number,
            title: milestone.title,
            state: milestone.state as &amp;#39;open&amp;#39; | &amp;#39;closed&amp;#39;,
            description: milestone.description || undefined,
          };

          this.milestoneCache.set(milestone.title, githubMilestone);

          // Also cache by arbiter ID if present in description
          const arbiterIdMatch &#x3D; milestone.description?.match(/&amp;lt;!-- arbiter-id: ([^\\s]+) --&amp;gt;/);
          if (arbiterIdMatch) {
            this.milestoneCache.set(&#x60;arbiter:${arbiterIdMatch[1]}&#x60;, githubMilestone);
          }
        }
      }
    } catch (error) {
      throw new Error(
        &#x60;Failed to load existing GitHub data: ${error instanceof Error ? error.message : String(error)}&#x60;
      );
    }
  }

  /**
   * Sync a single epic to GitHub
   */
  private async syncEpic(epic: Epic): Promise&amp;lt;SyncResult[]&amp;gt; {
    const results: SyncResult[] &#x3D; [];
    const { owner, repo } &#x3D; this.config.repository;

    try {
      const epicTitle &#x3D; await this.generateEpicTitle(epic);
      const existingIssue &#x3D; this.findExistingIssue(epicTitle, epic.id);

      if (!existingIssue) {
        // Create new epic issue using file-based template system (fallback to configurable)
        let template;
        try {
          template &#x3D; await this.fileBasedTemplateManager.generateEpicTemplate(epic, {
            includeMetadata: true,
            includeArbiterIds: true,
            includeAcceptanceCriteria: true,
            includeDependencies: true,
            includeEstimations: true,
          });
        } catch (error) {
          // Fallback to configurable template manager
          template &#x3D; this.configurableTemplateManager.generateEpicTemplate(epic, {
            includeMetadata: true,
            includeArbiterIds: true,
            includeAcceptanceCriteria: true,
            includeDependencies: true,
            includeEstimations: true,
          });
        }

        // Map semantic labels to GitHub labels
        const mappedLabels &#x3D; this.mapSemanticLabels(template.labels, &amp;#39;epic&amp;#39;, epic);

        const newIssue &#x3D; await this.octokit.rest.issues.create({
          owner,
          repo,
          title: template.title,
          body: template.body,
          labels: mappedLabels,
          assignees:
            this.config.behavior?.syncAssignees &amp;amp;&amp;amp; template.assignees
              ? template.assignees
              : undefined,
        });

        this.issueCache.set(epicTitle, {
          number: newIssue.data.number,
          title: newIssue.data.title,
          body: newIssue.data.body || undefined,
          state: newIssue.data.state as &amp;#39;open&amp;#39; | &amp;#39;closed&amp;#39;,
          labels: newIssue.data.labels.map(l &#x3D;&amp;gt; (typeof l &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39; ? l : l.name || &amp;#39;&amp;#39;)),
        });

        results.push({
          action: &amp;#39;created&amp;#39;,
          type: &amp;#39;epic&amp;#39;,
          itemId: epic.id,
          githubNumber: newIssue.data.number,
          details: &#x60;Created GitHub issue #${newIssue.data.number}&#x60;,
        });
      } else if (await this.shouldUpdateEpic(epic, existingIssue)) {
        // Update existing epic issue using file-based template system (fallback to configurable)
        let template;
        try {
          template &#x3D; await this.fileBasedTemplateManager.generateEpicTemplate(epic, {
            includeMetadata: true,
            includeArbiterIds: true,
            includeAcceptanceCriteria: true,
            includeDependencies: true,
            includeEstimations: true,
          });
        } catch (error) {
          // Fallback to configurable template manager
          template &#x3D; this.configurableTemplateManager.generateEpicTemplate(epic, {
            includeMetadata: true,
            includeArbiterIds: true,
            includeAcceptanceCriteria: true,
            includeDependencies: true,
            includeEstimations: true,
          });
        }

        // Map semantic labels to GitHub labels
        const mappedLabels &#x3D; this.mapSemanticLabels(template.labels, &amp;#39;epic&amp;#39;, epic);

        await this.octokit.rest.issues.update({
          owner,
          repo,
          issue_number: existingIssue.number,
          title: template.title,
          body: template.body,
          labels: mappedLabels,
          assignees:
            this.config.behavior?.syncAssignees &amp;amp;&amp;amp; template.assignees
              ? template.assignees
              : undefined,
        });

        results.push({
          action: &amp;#39;updated&amp;#39;,
          type: &amp;#39;epic&amp;#39;,
          itemId: epic.id,
          githubNumber: existingIssue.number,
          details: &#x60;Updated GitHub issue #${existingIssue.number}&#x60;,
        });
      } else {
        results.push({
          action: &amp;#39;skipped&amp;#39;,
          type: &amp;#39;epic&amp;#39;,
          itemId: epic.id,
          githubNumber: existingIssue.number,
          details: &#x60;No changes needed for GitHub issue #${existingIssue.number}&#x60;,
        });
      }

      // Handle epic completion/cancellation
      if (
        (epic.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39; || epic.status &#x3D;&#x3D;&#x3D; &amp;#39;cancelled&amp;#39;) &amp;amp;&amp;amp;
        existingIssue &amp;amp;&amp;amp;
        existingIssue.state &#x3D;&#x3D;&#x3D; &amp;#39;open&amp;#39; &amp;amp;&amp;amp;
        this.config.behavior?.autoClose
      ) {
        await this.octokit.rest.issues.update({
          owner,
          repo,
          issue_number: existingIssue.number,
          state: &amp;#39;closed&amp;#39;,
        });

        results.push({
          action: &amp;#39;closed&amp;#39;,
          type: &amp;#39;epic&amp;#39;,
          itemId: epic.id,
          githubNumber: existingIssue.number,
          details: &#x60;Closed GitHub issue #${existingIssue.number}&#x60;,
        });
      }

      // Handle milestone creation/update
      if (this.config.behavior?.createMilestones) {
        const milestoneResults &#x3D; await this.syncEpicMilestone(epic);
        results.push(...milestoneResults);
      }
    } catch (error) {
      results.push({
        action: &amp;#39;skipped&amp;#39;,
        type: &amp;#39;epic&amp;#39;,
        itemId: epic.id,
        details: &#x60;Failed to sync epic: ${error instanceof Error ? error.message : String(error)}&#x60;,
      });
    }

    return results;
  }

  /**
   * Sync a single task to GitHub
   */
  private async syncTask(task: Task, epic: Epic): Promise&amp;lt;SyncResult[]&amp;gt; {
    const results: SyncResult[] &#x3D; [];
    const { owner, repo } &#x3D; this.config.repository;

    try {
      const taskTitle &#x3D; await this.generateTaskTitle(task, epic);
      const existingIssue &#x3D; this.findExistingIssue(taskTitle, task.id);

      if (!existingIssue) {
        // Create new task issue using file-based template system (fallback to configurable)
        let template;
        try {
          template &#x3D; await this.fileBasedTemplateManager.generateTaskTemplate(task, epic, {
            includeMetadata: true,
            includeArbiterIds: true,
            includeAcceptanceCriteria: true,
            includeDependencies: true,
            includeEstimations: true,
          });
        } catch (error) {
          // Fallback to configurable template manager
          template &#x3D; this.configurableTemplateManager.generateTaskTemplate(task, epic, {
            includeMetadata: true,
            includeArbiterIds: true,
            includeAcceptanceCriteria: true,
            includeDependencies: true,
            includeEstimations: true,
          });
        }
        const milestone &#x3D; this.findMilestoneForEpic(epic);

        // Map semantic labels to GitHub labels
        const mappedLabels &#x3D; this.mapSemanticLabels(template.labels, &amp;#39;task&amp;#39;, task);

        const newIssue &#x3D; await this.octokit.rest.issues.create({
          owner,
          repo,
          title: template.title,
          body: template.body,
          labels: mappedLabels,
          assignees:
            this.config.behavior?.syncAssignees &amp;amp;&amp;amp; template.assignees
              ? template.assignees
              : undefined,
          milestone: milestone?.number,
        });

        results.push({
          action: &amp;#39;created&amp;#39;,
          type: &amp;#39;task&amp;#39;,
          itemId: task.id,
          githubNumber: newIssue.data.number,
          details: &#x60;Created GitHub issue #${newIssue.data.number}&#x60;,
        });
      } else if (await this.shouldUpdateTask(task, existingIssue, epic)) {
        // Update existing task issue using file-based template system (fallback to configurable)
        let template;
        try {
          template &#x3D; await this.fileBasedTemplateManager.generateTaskTemplate(task, epic, {
            includeMetadata: true,
            includeArbiterIds: true,
            includeAcceptanceCriteria: true,
            includeDependencies: true,
            includeEstimations: true,
          });
        } catch (error) {
          // Fallback to configurable template manager
          template &#x3D; this.configurableTemplateManager.generateTaskTemplate(task, epic, {
            includeMetadata: true,
            includeArbiterIds: true,
            includeAcceptanceCriteria: true,
            includeDependencies: true,
            includeEstimations: true,
          });
        }
        const milestone &#x3D; this.findMilestoneForEpic(epic);

        // Map semantic labels to GitHub labels
        const mappedLabels &#x3D; this.mapSemanticLabels(template.labels, &amp;#39;task&amp;#39;, task);

        await this.octokit.rest.issues.update({
          owner,
          repo,
          issue_number: existingIssue.number,
          title: template.title,
          body: template.body,
          labels: mappedLabels,
          assignees:
            this.config.behavior?.syncAssignees &amp;amp;&amp;amp; template.assignees
              ? template.assignees
              : undefined,
          milestone: milestone?.number,
        });

        results.push({
          action: &amp;#39;updated&amp;#39;,
          type: &amp;#39;task&amp;#39;,
          itemId: task.id,
          githubNumber: existingIssue.number,
          details: &#x60;Updated GitHub issue #${existingIssue.number}&#x60;,
        });
      } else {
        results.push({
          action: &amp;#39;skipped&amp;#39;,
          type: &amp;#39;task&amp;#39;,
          itemId: task.id,
          githubNumber: existingIssue.number,
          details: &#x60;No changes needed for GitHub issue #${existingIssue.number}&#x60;,
        });
      }

      // Handle task completion/cancellation
      if (
        (task.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39; || task.status &#x3D;&#x3D;&#x3D; &amp;#39;cancelled&amp;#39;) &amp;amp;&amp;amp;
        existingIssue &amp;amp;&amp;amp;
        existingIssue.state &#x3D;&#x3D;&#x3D; &amp;#39;open&amp;#39; &amp;amp;&amp;amp;
        this.config.behavior?.autoClose
      ) {
        await this.octokit.rest.issues.update({
          owner,
          repo,
          issue_number: existingIssue.number,
          state: &amp;#39;closed&amp;#39;,
        });

        results.push({
          action: &amp;#39;closed&amp;#39;,
          type: &amp;#39;task&amp;#39;,
          itemId: task.id,
          githubNumber: existingIssue.number,
          details: &#x60;Closed GitHub issue #${existingIssue.number}&#x60;,
        });
      }
    } catch (error) {
      results.push({
        action: &amp;#39;skipped&amp;#39;,
        type: &amp;#39;task&amp;#39;,
        itemId: task.id,
        details: &#x60;Failed to sync task: ${error instanceof Error ? error.message : String(error)}&#x60;,
      });
    }

    return results;
  }

  /**
   * Sync milestone for an epic
   */
  private async syncEpicMilestone(epic: Epic): Promise&amp;lt;SyncResult[]&amp;gt; {
    const results: SyncResult[] &#x3D; [];
    const { owner, repo } &#x3D; this.config.repository;

    try {
      const milestoneTitle &#x3D; this.generateMilestoneTitle(epic);
      const existingMilestone &#x3D; this.findExistingMilestone(milestoneTitle, epic.id);

      if (!existingMilestone) {
        // Create new milestone
        const description &#x3D; this.generateMilestoneDescription(epic);
        const dueDate &#x3D; epic.dueDate ? new Date(epic.dueDate).toISOString() : undefined;

        const newMilestone &#x3D; await this.octokit.rest.issues.createMilestone({
          owner,
          repo,
          title: milestoneTitle,
          description,
          due_on: dueDate,
        });

        this.milestoneCache.set(milestoneTitle, {
          number: newMilestone.data.number,
          title: newMilestone.data.title,
          state: newMilestone.data.state as &amp;#39;open&amp;#39; | &amp;#39;closed&amp;#39;,
          description: newMilestone.data.description || undefined,
        });

        results.push({
          action: &amp;#39;created&amp;#39;,
          type: &amp;#39;milestone&amp;#39;,
          itemId: epic.id,
          githubNumber: newMilestone.data.number,
          details: &#x60;Created GitHub milestone #${newMilestone.data.number}&#x60;,
        });
      } else if (this.shouldUpdateMilestone(epic, existingMilestone)) {
        // Update existing milestone
        const description &#x3D; this.generateMilestoneDescription(epic);
        const dueDate &#x3D; epic.dueDate ? new Date(epic.dueDate).toISOString() : undefined;

        await this.octokit.rest.issues.updateMilestone({
          owner,
          repo,
          milestone_number: existingMilestone.number,
          title: milestoneTitle,
          description,
          due_on: dueDate,
        });

        results.push({
          action: &amp;#39;updated&amp;#39;,
          type: &amp;#39;milestone&amp;#39;,
          itemId: epic.id,
          githubNumber: existingMilestone.number,
          details: &#x60;Updated GitHub milestone #${existingMilestone.number}&#x60;,
        });
      }

      // Handle milestone completion
      if (
        (epic.status &#x3D;&#x3D;&#x3D; &amp;#39;completed&amp;#39; || epic.status &#x3D;&#x3D;&#x3D; &amp;#39;cancelled&amp;#39;) &amp;amp;&amp;amp;
        existingMilestone &amp;amp;&amp;amp;
        existingMilestone.state &#x3D;&#x3D;&#x3D; &amp;#39;open&amp;#39;
      ) {
        await this.octokit.rest.issues.updateMilestone({
          owner,
          repo,
          milestone_number: existingMilestone.number,
          state: &amp;#39;closed&amp;#39;,
        });

        results.push({
          action: &amp;#39;closed&amp;#39;,
          type: &amp;#39;milestone&amp;#39;,
          itemId: epic.id,
          githubNumber: existingMilestone.number,
          details: &#x60;Closed GitHub milestone #${existingMilestone.number}&#x60;,
        });
      }
    } catch (error) {
      results.push({
        action: &amp;#39;skipped&amp;#39;,
        type: &amp;#39;milestone&amp;#39;,
        itemId: epic.id,
        details: &#x60;Failed to sync milestone: ${error instanceof Error ? error.message : String(error)}&#x60;,
      });
    }

    return results;
  }

  // Helper methods for generating GitHub content (kept for milestone support)

  private async generateEpicTitle(epic: Epic): Promise&amp;lt;string&amp;gt; {
    // Use file-based template manager for consistency (fallback to configurable)
    try {
      const template &#x3D; await this.fileBasedTemplateManager.generateEpicTemplate(epic);
      return template.title;
    } catch {
      // Fallback to configurable template manager
      const template &#x3D; this.configurableTemplateManager.generateEpicTemplate(epic);
      return template.title;
    }
  }

  private async generateTaskTitle(task: Task, epic: Epic): Promise&amp;lt;string&amp;gt; {
    // Use file-based template manager for consistency (fallback to configurable)
    try {
      const template &#x3D; await this.fileBasedTemplateManager.generateTaskTemplate(task, epic);
      return template.title;
    } catch {
      // Fallback to configurable template manager
      const template &#x3D; this.configurableTemplateManager.generateTaskTemplate(task, epic);
      return template.title;
    }
  }

  private generateMilestoneTitle(epic: Epic): string {
    return &#x60;Epic: ${epic.name}&#x60;;
  }

  private generateMilestoneDescription(epic: Epic): string {
    let description &#x3D; &#x60;&amp;lt;!-- arbiter-id: ${epic.id} --&amp;gt;\n\n&#x60;;

    if (epic.description) {
      description +&#x3D; &#x60;${epic.description}\n\n&#x60;;
    }

    description +&#x3D; &#x60;Arbiter Epic: ${epic.name}\n&#x60;;
    description +&#x3D; &#x60;Tasks: ${epic.tasks.length}\n&#x60;;

    if (epic.estimatedHours) {
      const totalEstimated &#x3D; epic.tasks.reduce((sum, task) &#x3D;&amp;gt; sum + (task.estimatedHours || 0), 0);
      description +&#x3D; &#x60;Estimated Hours: ${totalEstimated}\n&#x60;;
    }

    return description;
  }

  // Helper methods for finding existing items

  private findExistingIssue(title: string, arbiterId: string): GitHubIssue | undefined {
    // First try to find by arbiter ID
    const byId &#x3D; this.issueCache.get(&#x60;arbiter:${arbiterId}&#x60;);
    if (byId) return byId;

    // Then try by title
    return this.issueCache.get(title);
  }

  private findExistingMilestone(title: string, arbiterId: string): GitHubMilestone | undefined {
    // First try to find by arbiter ID
    const byId &#x3D; this.milestoneCache.get(&#x60;arbiter:${arbiterId}&#x60;);
    if (byId) return byId;

    // Then try by title
    return this.milestoneCache.get(title);
  }

  private findMilestoneForEpic(epic: Epic): GitHubMilestone | undefined {
    if (!this.config.behavior?.createMilestones) return undefined;

    const milestoneTitle &#x3D; this.generateMilestoneTitle(epic);
    return this.findExistingMilestone(milestoneTitle, epic.id);
  }

  // Helper methods for determining if updates are needed

  private async shouldUpdateEpic(epic: Epic, existingIssue: GitHubIssue): Promise&amp;lt;boolean&amp;gt; {
    let template;
    try {
      template &#x3D; await this.fileBasedTemplateManager.generateEpicTemplate(epic, {
        includeMetadata: true,
        includeArbiterIds: true,
        includeAcceptanceCriteria: true,
        includeDependencies: true,
        includeEstimations: true,
      });
    } catch (error) {
      // Fallback to configurable template manager
      template &#x3D; this.configurableTemplateManager.generateEpicTemplate(epic, {
        includeMetadata: true,
        includeArbiterIds: true,
        includeAcceptanceCriteria: true,
        includeDependencies: true,
        includeEstimations: true,
      });
    }

    return existingIssue.title !&#x3D;&#x3D; template.title || existingIssue.body !&#x3D;&#x3D; template.body;
  }

  private async shouldUpdateTask(
    task: Task,
    existingIssue: GitHubIssue,
    epic: Epic
  ): Promise&amp;lt;boolean&amp;gt; {
    let template;
    try {
      template &#x3D; await this.fileBasedTemplateManager.generateTaskTemplate(task, epic, {
        includeMetadata: true,
        includeArbiterIds: true,
        includeAcceptanceCriteria: true,
        includeDependencies: true,
        includeEstimations: true,
      });
    } catch (error) {
      // Fallback to configurable template manager
      template &#x3D; this.configurableTemplateManager.generateTaskTemplate(task, epic, {
        includeMetadata: true,
        includeArbiterIds: true,
        includeAcceptanceCriteria: true,
        includeDependencies: true,
        includeEstimations: true,
      });
    }

    return existingIssue.title !&#x3D;&#x3D; template.title || existingIssue.body !&#x3D;&#x3D; template.body;
  }

  private shouldUpdateMilestone(epic: Epic, existingMilestone: GitHubMilestone): boolean {
    const expectedTitle &#x3D; this.generateMilestoneTitle(epic);
    const expectedDescription &#x3D; this.generateMilestoneDescription(epic);

    return (
      existingMilestone.title !&#x3D;&#x3D; expectedTitle ||
      existingMilestone.description !&#x3D;&#x3D; expectedDescription
    );
  }

  /**
   * Map semantic labels to GitHub/GitLab platform labels
   */
  private mapSemanticLabels(
    labels: string[],
    itemType: &amp;#39;epic&amp;#39; | &amp;#39;task&amp;#39;,
    item: Epic | Task
  ): string[] {
    const mappedLabels: string[] &#x3D; [];

    // Add default labels from configuration
    if (this.config.mapping.defaultLabels) {
      mappedLabels.push(...this.config.mapping.defaultLabels);
    }

    // Map semantic labels using configuration
    for (const label of labels) {
      // Check type-specific mappings first
      const typeSpecificLabels &#x3D;
        itemType &#x3D;&#x3D;&#x3D; &amp;#39;epic&amp;#39;
          ? this.config.mapping.epicLabels?.[label]
          : this.config.mapping.taskLabels?.[label];

      if (typeSpecificLabels) {
        mappedLabels.push(...typeSpecificLabels);
      } else {
        // Use label as-is if no mapping found
        mappedLabels.push(label);
      }
    }

    // Add contextual labels based on item properties
    if (itemType &#x3D;&#x3D;&#x3D; &amp;#39;epic&amp;#39;) {
      const epic &#x3D; item as Epic;
      mappedLabels.push(&#x60;priority:${epic.priority}&#x60;);
      mappedLabels.push(&#x60;status:${epic.status}&#x60;);
      mappedLabels.push(&amp;#39;type:epic&amp;#39;);
    } else {
      const task &#x3D; item as Task;
      mappedLabels.push(&#x60;priority:${task.priority}&#x60;);
      mappedLabels.push(&#x60;status:${task.status}&#x60;);
      mappedLabels.push(&#x60;type:${task.type}&#x60;);
    }

    // Add prefix labels if configured
    const prefix &#x3D;
      itemType &#x3D;&#x3D;&#x3D; &amp;#39;epic&amp;#39; ? this.config.mapping.epicPrefix : this.config.mapping.taskPrefix;
    if (prefix) {
      mappedLabels.unshift(prefix);
    }

    // Remove duplicates and return
    return Array.from(new Set(mappedLabels)).filter(label &#x3D;&amp;gt; label.trim() !&#x3D;&#x3D; &amp;#39;&amp;#39;);
  }

  // Helper method to convert preview to results format
  private convertPreviewToResults(preview: SyncPreview): SyncResult[] {
    const results: SyncResult[] &#x3D; [];

    // Process epics
    preview.epics.create.forEach(epic &#x3D;&amp;gt; {
      results.push({
        action: &amp;#39;created&amp;#39;,
        type: &amp;#39;epic&amp;#39;,
        itemId: epic.id,
        details: &#x60;Would create epic: ${epic.name}&#x60;,
      });
    });

    preview.epics.update.forEach(({ epic }) &#x3D;&amp;gt; {
      results.push({
        action: &amp;#39;updated&amp;#39;,
        type: &amp;#39;epic&amp;#39;,
        itemId: epic.id,
        details: &#x60;Would update epic: ${epic.name}&#x60;,
      });
    });

    preview.epics.close.forEach(({ epic }) &#x3D;&amp;gt; {
      results.push({
        action: &amp;#39;closed&amp;#39;,
        type: &amp;#39;epic&amp;#39;,
        itemId: epic.id,
        details: &#x60;Would close epic: ${epic.name}&#x60;,
      });
    });

    // Process tasks
    preview.tasks.create.forEach(task &#x3D;&amp;gt; {
      results.push({
        action: &amp;#39;created&amp;#39;,
        type: &amp;#39;task&amp;#39;,
        itemId: task.id,
        details: &#x60;Would create task: ${task.name}&#x60;,
      });
    });

    preview.tasks.update.forEach(({ task }) &#x3D;&amp;gt; {
      results.push({
        action: &amp;#39;updated&amp;#39;,
        type: &amp;#39;task&amp;#39;,
        itemId: task.id,
        details: &#x60;Would update task: ${task.name}&#x60;,
      });
    });

    preview.tasks.close.forEach(({ task }) &#x3D;&amp;gt; {
      results.push({
        action: &amp;#39;closed&amp;#39;,
        type: &amp;#39;task&amp;#39;,
        itemId: task.id,
        details: &#x60;Would close task: ${task.name}&#x60;,
      });
    });

    // Process milestones
    preview.milestones.create.forEach(epic &#x3D;&amp;gt; {
      results.push({
        action: &amp;#39;created&amp;#39;,
        type: &amp;#39;milestone&amp;#39;,
        itemId: epic.id,
        details: &#x60;Would create milestone: ${epic.name}&#x60;,
      });
    });

    preview.milestones.update.forEach(({ epic }) &#x3D;&amp;gt; {
      results.push({
        action: &amp;#39;updated&amp;#39;,
        type: &amp;#39;milestone&amp;#39;,
        itemId: epic.id,
        details: &#x60;Would update milestone: ${epic.name}&#x60;,
      });
    });

    preview.milestones.close.forEach(({ epic }) &#x3D;&amp;gt; {
      results.push({
        action: &amp;#39;closed&amp;#39;,
        type: &amp;#39;milestone&amp;#39;,
        itemId: epic.id,
        details: &#x60;Would close milestone: ${epic.name}&#x60;,
      });
    });

    return results;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-151">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/design-system/components/Sidebar.tsx</div>
                <div class="file-content">
                    <pre>/**
 * Sidebar Component - Design System
 * Professional sidebar navigation with collapsible sections and elegant hierarchy
 * Designed for developer tools with sophisticated graphite theme
 */

import React, { useState, type ReactNode } from &amp;#39;react&amp;#39;;
import { clsx } from &amp;#39;clsx&amp;#39;;
import {
  ChevronRight,
  ChevronDown,
  Folder,
  FolderOpen,
  File,
  Settings,
  Users,
  Home,
  Search,
} from &amp;#39;lucide-react&amp;#39;;
import { cn } from &amp;#39;../variants&amp;#39;;

export interface SidebarNavItem {
  id: string;
  label: string;
  icon?: ReactNode;
  href?: string;
  active?: boolean;
  badge?: string | number;
  children?: SidebarNavItem[];
  collapsible?: boolean;
  collapsed?: boolean;
  onClick?: () &#x3D;&amp;gt; void;
}

export interface SidebarProps {
  /** Navigation items */
  items: SidebarNavItem[];

  /** Whether the sidebar is collapsed */
  collapsed?: boolean;

  /** Sidebar width when expanded */
  width?: &amp;#39;sm&amp;#39; | &amp;#39;md&amp;#39; | &amp;#39;lg&amp;#39;;

  /** Callback when an item is clicked */
  onItemClick?: (item: SidebarNavItem) &#x3D;&amp;gt; void;

  /** Callback when a collapsible section is toggled */
  onToggle?: (itemId: string, collapsed: boolean) &#x3D;&amp;gt; void;

  /** Header content */
  header?: ReactNode;

  /** Footer content */
  footer?: ReactNode;

  /** Custom className */
  className?: string;

  /** Whether to show tooltips when collapsed */
  showTooltips?: boolean;
}

const widthClasses &#x3D; {
  sm: &amp;#39;w-48&amp;#39;,
  md: &amp;#39;w-64&amp;#39;,
  lg: &amp;#39;w-80&amp;#39;,
} as const;

const collapsedWidth &#x3D; &amp;#39;w-14&amp;#39;;

function NavItemComponent({
  item,
  level &#x3D; 0,
  collapsed &#x3D; false,
  onItemClick,
  onToggle,
}: {
  item: SidebarNavItem;
  level?: number;
  collapsed?: boolean;
  onItemClick?: (item: SidebarNavItem) &#x3D;&amp;gt; void;
  onToggle?: (itemId: string, collapsed: boolean) &#x3D;&amp;gt; void;
}) {
  const [isCollapsed, setIsCollapsed] &#x3D; useState(item.collapsed || false);
  const hasChildren &#x3D; item.children &amp;amp;&amp;amp; item.children.length &amp;gt; 0;
  const isActive &#x3D; item.active;

  const handleClick &#x3D; () &#x3D;&amp;gt; {
    if (item.collapsible &amp;amp;&amp;amp; hasChildren) {
      const newCollapsed &#x3D; !isCollapsed;
      setIsCollapsed(newCollapsed);
      onToggle?.(item.id, newCollapsed);
    }

    if (item.onClick) {
      item.onClick();
    }

    onItemClick?.(item);
  };

  const itemContent &#x3D; (
    &amp;lt;div
      className&#x3D;{cn(
        &amp;#39;group flex items-center gap-2 px-3 py-2 rounded-md cursor-pointer transition-all duration-150&amp;#39;,
        &amp;#39;text-sm font-medium&amp;#39;,

        // Indentation for nested items
        level &amp;gt; 0 &amp;amp;&amp;amp; !collapsed &amp;amp;&amp;amp; &#x60;ml-${level * 4}&#x60;,

        // Active state
        isActive &amp;amp;&amp;amp; &amp;#39;bg-blue-50 text-blue-700 border-r-2 border-blue-500&amp;#39;,

        // Hover state
        !isActive &amp;amp;&amp;amp; &amp;#39;text-graphite-700 hover:bg-graphite-100 hover:text-graphite-900&amp;#39;,

        // Collapsed state
        collapsed &amp;amp;&amp;amp; &amp;#39;justify-center px-2&amp;#39;
      )}
      onClick&#x3D;{handleClick}
      role&#x3D;&amp;quot;button&amp;quot;
      tabIndex&#x3D;{0}
      onKeyDown&#x3D;{e &#x3D;&amp;gt; {
        if (e.key &#x3D;&#x3D;&#x3D; &amp;#39;Enter&amp;#39; || e.key &#x3D;&#x3D;&#x3D; &amp;#39; &amp;#39;) {
          e.preventDefault();
          handleClick();
        }
      }}
    &amp;gt;
      {/* Collapse/expand icon */}
      {hasChildren &amp;amp;&amp;amp; item.collapsible &amp;amp;&amp;amp; !collapsed &amp;amp;&amp;amp; (
        &amp;lt;span className&#x3D;&amp;quot;flex-shrink-0 text-graphite-400&amp;quot;&amp;gt;
          {isCollapsed ? &amp;lt;ChevronRight className&#x3D;&amp;quot;h-4 w-4&amp;quot; /&amp;gt; : &amp;lt;ChevronDown className&#x3D;&amp;quot;h-4 w-4&amp;quot; /&amp;gt;}
        &amp;lt;/span&amp;gt;
      )}

      {/* Item icon */}
      {item.icon &amp;amp;&amp;amp; (
        &amp;lt;span
          className&#x3D;{cn(
            &amp;#39;flex-shrink-0&amp;#39;,
            isActive ? &amp;#39;text-blue-600&amp;#39; : &amp;#39;text-graphite-500 group-hover:text-graphite-700&amp;#39;,
            hasChildren &amp;amp;&amp;amp; item.collapsible &amp;amp;&amp;amp; !collapsed &amp;amp;&amp;amp; &amp;#39;ml-0&amp;#39;
          )}
        &amp;gt;
          {item.icon}
        &amp;lt;/span&amp;gt;
      )}

      {/* Item label */}
      {!collapsed &amp;amp;&amp;amp; (
        &amp;lt;&amp;gt;
          &amp;lt;span className&#x3D;&amp;quot;flex-1 truncate&amp;quot;&amp;gt;{item.label}&amp;lt;/span&amp;gt;

          {/* Badge */}
          {item.badge &amp;amp;&amp;amp; (
            &amp;lt;span
              className&#x3D;{cn(
                &amp;#39;inline-flex items-center justify-center px-2 py-0.5 rounded-full text-xs font-medium&amp;#39;,
                isActive
                  ? &amp;#39;bg-blue-100 text-blue-700&amp;#39;
                  : &amp;#39;bg-graphite-100 text-graphite-600 group-hover:bg-graphite-200&amp;#39;
              )}
            &amp;gt;
              {item.badge}
            &amp;lt;/span&amp;gt;
          )}
        &amp;lt;/&amp;gt;
      )}
    &amp;lt;/div&amp;gt;
  );

  return (
    &amp;lt;li className&#x3D;&amp;quot;relative&amp;quot;&amp;gt;
      {collapsed &amp;amp;&amp;amp; item.label ? (
        &amp;lt;div title&#x3D;{item.label} className&#x3D;&amp;quot;relative&amp;quot;&amp;gt;
          {itemContent}
        &amp;lt;/div&amp;gt;
      ) : (
        itemContent
      )}

      {/* Children */}
      {hasChildren &amp;amp;&amp;amp; !isCollapsed &amp;amp;&amp;amp; !collapsed &amp;amp;&amp;amp; (
        &amp;lt;ul className&#x3D;&amp;quot;mt-1 space-y-1&amp;quot;&amp;gt;
          {item.children!.map(child &#x3D;&amp;gt; (
            &amp;lt;NavItemComponent
              key&#x3D;{child.id}
              item&#x3D;{child}
              level&#x3D;{level + 1}
              collapsed&#x3D;{collapsed}
              onItemClick&#x3D;{onItemClick}
              onToggle&#x3D;{onToggle}
            /&amp;gt;
          ))}
        &amp;lt;/ul&amp;gt;
      )}
    &amp;lt;/li&amp;gt;
  );
}

export function Sidebar({
  items,
  collapsed &#x3D; false,
  width &#x3D; &amp;#39;md&amp;#39;,
  onItemClick,
  onToggle,
  header,
  footer,
  className,
  showTooltips &#x3D; true,
}: SidebarProps) {
  return (
    &amp;lt;aside
      className&#x3D;{cn(
        &amp;#39;flex flex-col h-full bg-white border-r border-graphite-200 transition-all duration-200&amp;#39;,
        collapsed ? collapsedWidth : widthClasses[width],
        className
      )}
    &amp;gt;
      {/* Header */}
      {header &amp;amp;&amp;amp; (
        &amp;lt;div className&#x3D;{cn(&amp;#39;flex-shrink-0 p-4 border-b border-graphite-200&amp;#39;, collapsed &amp;amp;&amp;amp; &amp;#39;px-2&amp;#39;)}&amp;gt;
          {header}
        &amp;lt;/div&amp;gt;
      )}

      {/* Navigation */}
      &amp;lt;nav className&#x3D;&amp;quot;flex-1 overflow-y-auto py-4&amp;quot;&amp;gt;
        &amp;lt;ul className&#x3D;&amp;quot;space-y-1 px-2&amp;quot;&amp;gt;
          {items.map(item &#x3D;&amp;gt; (
            &amp;lt;NavItemComponent
              key&#x3D;{item.id}
              item&#x3D;{item}
              collapsed&#x3D;{collapsed}
              onItemClick&#x3D;{onItemClick}
              onToggle&#x3D;{onToggle}
            /&amp;gt;
          ))}
        &amp;lt;/ul&amp;gt;
      &amp;lt;/nav&amp;gt;

      {/* Footer */}
      {footer &amp;amp;&amp;amp; (
        &amp;lt;div className&#x3D;{cn(&amp;#39;flex-shrink-0 p-4 border-t border-graphite-200&amp;#39;, collapsed &amp;amp;&amp;amp; &amp;#39;px-2&amp;#39;)}&amp;gt;
          {footer}
        &amp;lt;/div&amp;gt;
      )}
    &amp;lt;/aside&amp;gt;
  );
}

// Convenience components for common navigation items
export const sidebarIcons &#x3D; {
  Home,
  Folder,
  FolderOpen,
  File,
  Settings,
  Users,
  Search,
} as const;

export default Sidebar;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-152">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/services/websocket.ts</div>
                <div class="file-content">
                    <pre>/**
 * WebSocket service for real-time communication
 */

import type { WebSocketMessage, WsEvent } from &amp;#39;../types/api&amp;#39;;
import { createLogger } from &amp;#39;../utils/logger&amp;#39;;

const log &#x3D; createLogger(&amp;#39;WebSocket&amp;#39;);

export type WebSocketEventHandler &#x3D; (event: WsEvent) &#x3D;&amp;gt; void;

export interface TimerService {
  setTimeout(callback: () &#x3D;&amp;gt; void, delay: number): number;
  setInterval(callback: () &#x3D;&amp;gt; void, delay: number): number;
  clearTimeout(timerId: number): void;
  clearInterval(timerId: number): void;
}

export interface LocationService {
  protocol: string;
  host: string;
}

export interface WebSocketFactory {
  create(url: string): WebSocket;
}

export interface WebSocketDependencies {
  timerService?: TimerService;
  locationService?: LocationService;
  webSocketFactory?: WebSocketFactory;
}

export interface WebSocketOptions extends WebSocketDependencies {
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
  pingInterval?: number;
  onConnect?: () &#x3D;&amp;gt; void;
  onDisconnect?: () &#x3D;&amp;gt; void;
  onReconnect?: (attempt: number) &#x3D;&amp;gt; void;
  onError?: (error: Event) &#x3D;&amp;gt; void;
}

// Default implementations for production use
const defaultTimerService: TimerService &#x3D; {
  setTimeout: (callback: () &#x3D;&amp;gt; void, delay: number) &#x3D;&amp;gt; window.setTimeout(callback, delay),
  setInterval: (callback: () &#x3D;&amp;gt; void, delay: number) &#x3D;&amp;gt; window.setInterval(callback, delay),
  clearTimeout: (timerId: number) &#x3D;&amp;gt; window.clearTimeout(timerId),
  clearInterval: (timerId: number) &#x3D;&amp;gt; window.clearInterval(timerId),
};

const defaultLocationService: LocationService &#x3D; {
  get protocol() {
    return window.location.protocol;
  },
  get host() {
    return window.location.host;
  },
};

const defaultWebSocketFactory: WebSocketFactory &#x3D; {
  create: (url: string) &#x3D;&amp;gt; new WebSocket(url),
};

class WebSocketService {
  private ws: WebSocket | null &#x3D; null;
  private reconnectTimer: number | null &#x3D; null;
  private pingTimer: number | null &#x3D; null;
  private reconnectAttempts &#x3D; 0;
  private isManuallyDisconnected &#x3D; false;
  private eventHandlers &#x3D; new Set&amp;lt;WebSocketEventHandler&amp;gt;();
  private messageQueue: WebSocketMessage[] &#x3D; [];
  private wsUrl: string | null &#x3D; null;

  private readonly timerService: TimerService;
  private readonly locationService: LocationService;
  private readonly webSocketFactory: WebSocketFactory;

  private readonly options: Required&amp;lt;Omit&amp;lt;WebSocketOptions, keyof WebSocketDependencies&amp;gt;&amp;gt; &#x3D; {
    reconnectInterval: 5000, // 5 seconds
    maxReconnectAttempts: 10,
    pingInterval: 30000, // 30 seconds
    onConnect: () &#x3D;&amp;gt; {},
    onDisconnect: () &#x3D;&amp;gt; {},
    onReconnect: () &#x3D;&amp;gt; {},
    onError: () &#x3D;&amp;gt; {},
  };

  constructor(options: WebSocketOptions &#x3D; {}) {
    // Extract dependencies from options
    const { timerService, locationService, webSocketFactory, ...wsOptions } &#x3D; options;

    // Set up dependencies with defaults
    this.timerService &#x3D; timerService || defaultTimerService;
    this.locationService &#x3D; locationService || defaultLocationService;
    this.webSocketFactory &#x3D; webSocketFactory || defaultWebSocketFactory;

    // Merge websocket options
    this.options &#x3D; { ...this.options, ...wsOptions };
  }

  connect(projectId: string): void {
    if (this.ws?.readyState &#x3D;&#x3D;&#x3D; WebSocket.OPEN) {
      return; // Already connected
    }

    this.isManuallyDisconnected &#x3D; false;
    const protocol &#x3D; this.locationService.protocol &#x3D;&#x3D;&#x3D; &amp;#39;https:&amp;#39; ? &amp;#39;wss:&amp;#39; : &amp;#39;ws:&amp;#39;;
    // Use API server port (5050) instead of frontend port for WebSocket connection
    this.wsUrl &#x3D; &#x60;${protocol}//localhost:5050/ws?project_id&#x3D;${projectId}&#x60;;

    try {
      this.ws &#x3D; this.webSocketFactory.create(this.wsUrl);
      this.setupEventListeners();
    } catch (error) {
      log.error(&amp;#39;Failed to create WebSocket connection:&amp;#39;, error);
      this.scheduleReconnect();
    }
  }

  disconnect(): void {
    this.isManuallyDisconnected &#x3D; true;
    this.clearTimers();

    if (this.ws) {
      this.ws.close(1000, &amp;#39;Manual disconnect&amp;#39;);
      this.ws &#x3D; null;
    }

    this.reconnectAttempts &#x3D; 0;
  }

  send(message: WebSocketMessage): void {
    if (this.ws?.readyState &#x3D;&#x3D;&#x3D; WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    } else {
      // Queue message for when connection is restored
      this.messageQueue.push(message);
      log.debug(&amp;#39;WebSocket not connected, queuing message:&amp;#39;, message);
    }
  }

  subscribe(handler: WebSocketEventHandler): () &#x3D;&amp;gt; void {
    this.eventHandlers.add(handler);

    // Return unsubscribe function
    return () &#x3D;&amp;gt; {
      this.eventHandlers.delete(handler);
    };
  }

  isConnected(): boolean {
    return this.ws?.readyState &#x3D;&#x3D;&#x3D; WebSocket.OPEN;
  }

  getReconnectAttempts(): number {
    return this.reconnectAttempts;
  }

  private setupEventListeners(): void {
    if (!this.ws) return;

    this.ws.addEventListener(&amp;#39;open&amp;#39;, this.handleOpen.bind(this));
    this.ws.addEventListener(&amp;#39;message&amp;#39;, this.handleMessage.bind(this));
    this.ws.addEventListener(&amp;#39;close&amp;#39;, this.handleClose.bind(this));
    this.ws.addEventListener(&amp;#39;error&amp;#39;, this.handleError.bind(this));
  }

  private handleOpen(): void {
    log.info(&amp;#39;WebSocket connected&amp;#39;);
    this.reconnectAttempts &#x3D; 0;
    this.options.onConnect();

    // Send queued messages
    while (this.messageQueue.length &amp;gt; 0) {
      const message &#x3D; this.messageQueue.shift();
      if (message) {
        this.send(message);
      }
    }

    // Start ping interval
    this.startPingInterval();
  }

  private handleMessage(event: MessageEvent): void {
    try {
      const message: WebSocketMessage &#x3D; JSON.parse(event.data);

      switch (message.type) {
        case &amp;#39;event&amp;#39;:
          this.handleEventMessage(message);
          break;

        case &amp;#39;error&amp;#39;:
          log.error(&amp;#39;WebSocket server error:&amp;#39;, message.data);
          break;

        case &amp;#39;pong&amp;#39;:
          // Server responded to ping
          log.trace(&amp;#39;Received pong from server&amp;#39;);
          break;

        case &amp;#39;ping&amp;#39;:
          // Server sent ping, respond with pong
          log.trace(&amp;#39;Received ping from server, responding with pong&amp;#39;);
          this.send({ type: &amp;#39;pong&amp;#39;, data: {} });
          break;

        default:
          log.warn(&amp;#39;Unknown WebSocket message type:&amp;#39;, message);
      }
    } catch (error) {
      log.error(&amp;#39;Failed to parse WebSocket message:&amp;#39;, error);
    }
  }

  private handleEventMessage(message: WebSocketMessage): void {
    try {
      const rawEvent &#x3D; message.data as any;

      // Handle different event formats from server
      const wsEvent: WsEvent &#x3D; {
        type: rawEvent.type || rawEvent.event_type,
        project_id: rawEvent.project_id,
        timestamp: rawEvent.timestamp,
        data: rawEvent.data,
      };

      // Validate event structure - connection_established events don&amp;#39;t need project_id
      if (!wsEvent.type || !wsEvent.timestamp) {
        log.warn(&amp;#39;Invalid WebSocket event structure:&amp;#39;, rawEvent);
        return;
      }

      // Skip project-specific events if we don&amp;#39;t have a project_id (except connection_established)
      if (!wsEvent.project_id &amp;amp;&amp;amp; wsEvent.type !&#x3D;&#x3D; &amp;#39;connection_established&amp;#39;) {
        log.debug(&amp;#39;Skipping non-project event:&amp;#39;, wsEvent.type);
        return;
      }

      log.debug(&amp;#39;Processing WebSocket event:&amp;#39;, {
        type: wsEvent.type,
        project_id: wsEvent.project_id,
      });

      // Notify all subscribers
      this.eventHandlers.forEach(handler &#x3D;&amp;gt; {
        try {
          handler(wsEvent);
        } catch (error) {
          log.error(&amp;#39;Error in WebSocket event handler:&amp;#39;, error);
        }
      });
    } catch (error) {
      log.error(&amp;#39;Failed to handle WebSocket event:&amp;#39;, error);
    }
  }

  private handleClose(event: CloseEvent): void {
    log.info(&amp;#39;WebSocket disconnected:&amp;#39;, { code: event.code, reason: event.reason });
    this.clearTimers();
    this.options.onDisconnect();

    if (!this.isManuallyDisconnected &amp;amp;&amp;amp; event.code !&#x3D;&#x3D; 1000) {
      this.scheduleReconnect();
    }
  }

  private handleError(event: Event): void {
    log.error(&amp;#39;WebSocket error:&amp;#39;, event);
    this.options.onError(event);
  }

  private scheduleReconnect(): void {
    if (
      this.isManuallyDisconnected ||
      this.reconnectAttempts &amp;gt;&#x3D; this.options.maxReconnectAttempts
    ) {
      log.warn(&amp;#39;Max reconnect attempts reached or manually disconnected&amp;#39;);
      return;
    }

    if (this.reconnectTimer) {
      this.timerService.clearTimeout(this.reconnectTimer);
    }

    this.reconnectAttempts++;
    log.info(
      &#x60;Scheduling WebSocket reconnect attempt ${this.reconnectAttempts}/${this.options.maxReconnectAttempts} in ${this.options.reconnectInterval}ms&#x60;
    );

    this.reconnectTimer &#x3D; this.timerService.setTimeout(() &#x3D;&amp;gt; {
      this.options.onReconnect(this.reconnectAttempts);
      this.reconnect();
    }, this.options.reconnectInterval);
  }

  private reconnect(): void {
    if (this.isManuallyDisconnected) {
      return;
    }

    // Use stored URL instead of relying on WebSocket instance
    if (!this.wsUrl) {
      log.error(&amp;#39;Cannot reconnect: no previous URL available&amp;#39;);
      return;
    }

    const urlParams &#x3D; new URLSearchParams(this.wsUrl.split(&amp;#39;?&amp;#39;)[1]);
    const projectId &#x3D; urlParams.get(&amp;#39;project_id&amp;#39;);

    if (!projectId) {
      log.error(&amp;#39;Cannot reconnect: no project ID available&amp;#39;);
      return;
    }

    this.connect(projectId);
  }

  private startPingInterval(): void {
    this.clearPingTimer();

    this.pingTimer &#x3D; this.timerService.setInterval(() &#x3D;&amp;gt; {
      if (this.ws?.readyState &#x3D;&#x3D;&#x3D; WebSocket.OPEN) {
        this.send({
          type: &amp;#39;ping&amp;#39;,
          data: { timestamp: new Date().toISOString() },
        });
        log.trace(&amp;#39;Ping sent to server&amp;#39;);
      }
    }, this.options.pingInterval);
  }

  private clearTimers(): void {
    this.clearReconnectTimer();
    this.clearPingTimer();
  }

  private clearReconnectTimer(): void {
    if (this.reconnectTimer) {
      this.timerService.clearTimeout(this.reconnectTimer);
      this.reconnectTimer &#x3D; null;
    }
  }

  private clearPingTimer(): void {
    if (this.pingTimer) {
      this.timerService.clearInterval(this.pingTimer);
      this.pingTimer &#x3D; null;
    }
  }
}

// Export factory function to create WebSocket service instances
export function createWebSocketService(options: WebSocketOptions &#x3D; {}): WebSocketService {
  return new WebSocketService(options);
}

// Export singleton instance for global use
export const wsService &#x3D; createWebSocketService();
</pre>
                </div>
            </div>
            <div class="file-section" id="file-153">
                <div class="file-header">ğŸ“„ apps/api/package.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;name&amp;quot;: &amp;quot;@arbiter/api&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;Arbiter API server&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;./src/server.ts&amp;quot;,
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;dev&amp;quot;: &amp;quot;bun --hot src/server.ts&amp;quot;,
    &amp;quot;start&amp;quot;: &amp;quot;bun src/server.ts&amp;quot;,
    &amp;quot;build&amp;quot;: &amp;quot;bun build src/server.ts --outdir&#x3D;dist --target&#x3D;bun&amp;quot;,
    &amp;quot;build:worker&amp;quot;: &amp;quot;wrangler deploy --dry-run&amp;quot;,
    &amp;quot;typecheck&amp;quot;: &amp;quot;tsc --noEmit&amp;quot;,
    &amp;quot;migrate&amp;quot;: &amp;quot;bun src/migrations/run.ts&amp;quot;,
    &amp;quot;db:generate&amp;quot;: &amp;quot;bunx drizzle-kit generate&amp;quot;,
    &amp;quot;db:migrate&amp;quot;: &amp;quot;bunx drizzle-kit migrate&amp;quot;,
    &amp;quot;db:push&amp;quot;: &amp;quot;bunx drizzle-kit push&amp;quot;,
    &amp;quot;db:studio&amp;quot;: &amp;quot;bunx drizzle-kit studio&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;bun test&amp;quot;,
    &amp;quot;test:coverage&amp;quot;: &amp;quot;bun test --coverage&amp;quot;,
    &amp;quot;test:stress&amp;quot;: &amp;quot;echo &amp;#39;Stress tests are currently skipped. To run them, temporarily unskip tests marked with [STRESS TEST] in src/tests/concurrency/raceConditions.test.ts&amp;#39;&amp;quot;,
    &amp;quot;test:local&amp;quot;: &amp;quot;miniflare --modules --script&#x3D;src/worker.ts --d1&#x3D;DB&#x3D;local-db.sqlite3&amp;quot;,
    &amp;quot;test:miniflare&amp;quot;: &amp;quot;bun test src/__tests__/miniflare.test.ts&amp;quot;,
    &amp;quot;cf:dev&amp;quot;: &amp;quot;wrangler dev&amp;quot;,
    &amp;quot;cf:deploy&amp;quot;: &amp;quot;wrangler deploy&amp;quot;,
    &amp;quot;cf:d1:create&amp;quot;: &amp;quot;wrangler d1 create arbiter-db&amp;quot;,
    &amp;quot;cf:d1:migrate&amp;quot;: &amp;quot;wrangler d1 migrations apply arbiter-db&amp;quot;,
    &amp;quot;cf:d1:local&amp;quot;: &amp;quot;wrangler d1 execute arbiter-db --local --file&#x3D;./migrations/schema.sql&amp;quot;,
    &amp;quot;lint&amp;quot;: &amp;quot;bunx @biomejs/biome lint src/&amp;quot;,
    &amp;quot;format&amp;quot;: &amp;quot;bunx @biomejs/biome format src/ --write&amp;quot;,
    &amp;quot;format:check&amp;quot;: &amp;quot;bunx @biomejs/biome format src/&amp;quot;,
    &amp;quot;lint:fix&amp;quot;: &amp;quot;bunx @biomejs/biome check src/ --write&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;@arbiter/shared&amp;quot;: &amp;quot;workspace:*&amp;quot;,
    &amp;quot;@arbiter/cue-runner&amp;quot;: &amp;quot;workspace:*&amp;quot;,
    &amp;quot;@arbiter/api-types&amp;quot;: &amp;quot;workspace:*&amp;quot;,
    &amp;quot;better-sqlite3&amp;quot;: &amp;quot;^12.2.0&amp;quot;,
    &amp;quot;drizzle-kit&amp;quot;: &amp;quot;^0.31.4&amp;quot;,
    &amp;quot;drizzle-orm&amp;quot;: &amp;quot;^0.44.5&amp;quot;,
    &amp;quot;hono&amp;quot;: &amp;quot;^4.9.8&amp;quot;,
    &amp;quot;jose&amp;quot;: &amp;quot;^5.9.6&amp;quot;,
    &amp;quot;nats&amp;quot;: &amp;quot;^2.28.2&amp;quot;,
    &amp;quot;nodemailer&amp;quot;: &amp;quot;^6.9.9&amp;quot;,
    &amp;quot;oauth4webapi&amp;quot;: &amp;quot;^2.16.0&amp;quot;,
    &amp;quot;ws&amp;quot;: &amp;quot;^8.16.0&amp;quot;,
    &amp;quot;zod&amp;quot;: &amp;quot;^3.22.4&amp;quot;
  },
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;@types/better-sqlite3&amp;quot;: &amp;quot;^7.6.13&amp;quot;,
    &amp;quot;@types/node&amp;quot;: &amp;quot;^20.11.0&amp;quot;,
    &amp;quot;@types/ws&amp;quot;: &amp;quot;^8.5.10&amp;quot;,
    &amp;quot;bun-types&amp;quot;: &amp;quot;^1.2.21&amp;quot;,
    &amp;quot;typescript&amp;quot;: &amp;quot;^5.3.3&amp;quot;,
    &amp;quot;wrangler&amp;quot;: &amp;quot;^3.78.12&amp;quot;,
    &amp;quot;miniflare&amp;quot;: &amp;quot;^3.20241022.0&amp;quot;,
    &amp;quot;@cloudflare/workers-types&amp;quot;: &amp;quot;^4.20241022.0&amp;quot;
  },
  &amp;quot;engines&amp;quot;: {
    &amp;quot;bun&amp;quot;: &amp;quot;&amp;gt;&#x3D;1.0.0&amp;quot;
  },
  &amp;quot;keywords&amp;quot;: [
    &amp;quot;arbiter&amp;quot;,
    &amp;quot;api&amp;quot;,
    &amp;quot;server&amp;quot;,
    &amp;quot;websocket&amp;quot;
  ],
  &amp;quot;author&amp;quot;: &amp;quot;Nathan Rice&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-154">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/minimal.css</div>
                <div class="file-content">
                    <pre>/* Minimal CSS for Spec Workbench */

/* Base reset and styles */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html,
body,
#root {
  height: 100%;
  font-family: -apple-system, BlinkMacSystemFont, &amp;#39;Segoe UI&amp;#39;, &amp;#39;Roboto&amp;#39;, sans-serif;
  background: #ffffff;
  color: #333;
  line-height: 1.5;
}

/* Layout styles */
.app {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.top-bar {
  height: 60px;
  background: #f8f9fa;
  border-bottom: 1px solid #e9ecef;
  display: flex;
  align-items: center;
  padding: 0 20px;
  gap: 10px;
}

.main-content {
  flex: 1;
  display: flex;
  min-height: 0;
}

.left-pane,
.right-pane {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
}

.left-pane {
  border-right: 1px solid #e9ecef;
}

/* Editor styles */
.editor-container {
  flex: 1;
  min-height: 0;
  position: relative;
}

.file-tree {
  padding: 12px;
  background: #f8f9fa;
  border-bottom: 1px solid #e9ecef;
  min-height: 60px;
}

.file-tree-item {
  padding: 6px 12px;
  cursor: pointer;
  border-radius: 4px;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.file-tree-item:hover {
  background: #e9ecef;
}

.file-tree-item.active {
  background: #007bff;
  color: white;
}

/* Tab styles */
.tabs {
  display: flex;
  background: #f8f9fa;
  border-bottom: 1px solid #e9ecef;
}

.tab {
  padding: 12px 20px;
  border: none;
  background: transparent;
  cursor: pointer;
  border-bottom: 2px solid transparent;
  font-size: 14px;
}

.tab:hover {
  background: #e9ecef;
}

.tab.active {
  background: white;
  border-bottom-color: #007bff;
  color: #007bff;
}

.tab-content {
  flex: 1;
  padding: 20px;
  overflow-y: auto;
  min-height: 0;
}

/* Button styles */
.btn {
  padding: 8px 16px;
  border: 1px solid #007bff;
  background: #007bff;
  color: white;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

.btn:hover {
  background: #0056b3;
  border-color: #0056b3;
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.btn-secondary {
  background: white;
  color: #007bff;
}

.btn-secondary:hover {
  background: #f8f9fa;
}

/* Status indicators */
.status {
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 4px;
  font-weight: 500;
}

.status.connected {
  background: #d4edda;
  color: #155724;
}

.status.disconnected {
  background: #f8d7da;
  color: #721c24;
}

.status.connecting {
  background: #fff3cd;
  color: #856404;
}

/* Monaco editor container */
.monaco-editor-container {
  height: 100%;
  width: 100%;
}

/* Loading states */
.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  flex: 1;
  font-size: 16px;
  color: #6c757d;
}

.spinner {
  width: 20px;
  height: 20px;
  border: 2px solid #f3f3f3;
  border-top: 2px solid #007bff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* Error states */
.error {
  color: #dc3545;
  background: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 4px;
  padding: 12px;
  margin: 10px 0;
}

/* Diagram containers */
.diagram-container {
  height: 100%;
  width: 100%;
  overflow: auto;
  background: white;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Responsive design */
@media (max-width: 768px) {
  .main-content {
    flex-direction: column;
  }

  .left-pane {
    border-right: none;
    border-bottom: 1px solid #e9ecef;
  }
}

/* Accessibility */
@media (prefers-reduced-motion: reduce) {
  .spinner {
    animation: none;
  }
}

/* Focus styles for accessibility */
.tab:focus,
.btn:focus,
.file-tree-item:focus {
  outline: 2px solid #007bff;
  outline-offset: 2px;
}

/* Print styles */
@media print {
  .top-bar,
  .tabs {
    display: none;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-155">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/App.tsx</div>
                <div class="file-content">
                    <pre>import React, { useEffect } from &amp;#39;react&amp;#39;;
import { ToastContainer } from &amp;#39;react-toastify&amp;#39;;
import &amp;#39;react-toastify/dist/ReactToastify.css&amp;#39;;

// Providers
import { QueryProvider } from &amp;#39;./providers/QueryProvider&amp;#39;;
import {
  ProjectProvider,
  useCurrentProject,
  useSetCurrentProject,
} from &amp;#39;./contexts/ProjectContext&amp;#39;;

// Stores
import { useUiStore, useTabs } from &amp;#39;./stores/ui-store&amp;#39;;

// Hooks
import { useProjects } from &amp;#39;./hooks/api-hooks&amp;#39;;
import { useWebSocket } from &amp;#39;./hooks/useWebSocket&amp;#39;;

// Components
import TopBar from &amp;#39;./components/Layout/TopBar&amp;#39;;
import SplitPane from &amp;#39;./components/Layout/SplitPane&amp;#39;;
import Tabs from &amp;#39;./components/Layout/Tabs&amp;#39;;
import {
  FlowDiagram,
  FriendlyDiagram,
  SourceDiagram,
  FsmDiagram,
  ViewDiagram,
  SiteDiagram,
  GapsChecklist,
  ResolvedViewer,
  ArchitectureDiagram,
} from &amp;#39;./components/diagrams&amp;#39;;
import { Handlers } from &amp;#39;./components/Handlers&amp;#39;;

import type { DiagramTab, LeftTab, RightTab } from &amp;#39;./types/ui&amp;#39;;

// Main app content with modern state management
function AppContent() {
  // Store state
  const { leftTab, rightTab, setLeftTab, setRightTab } &#x3D; useTabs();
  const currentProject &#x3D; useCurrentProject();
  const setCurrentProject &#x3D; useSetCurrentProject();

  // Server state
  const { data: projects } &#x3D; useProjects();

  // Initialize WebSocket connection
  useWebSocket(currentProject?.id || null, {
    autoReconnect: true,
    showToastNotifications: true,
  });

  // Initialize first project if available
  useEffect(() &#x3D;&amp;gt; {
    if (!currentProject &amp;amp;&amp;amp; projects &amp;amp;&amp;amp; projects.length &amp;gt; 0) {
      setCurrentProject(projects[0]);
      console.log(&amp;#39;Set initial project:&amp;#39;, projects[0]);
    }
  }, [currentProject, projects, setCurrentProject]);

  const diagramTabs &#x3D; [
    {
      id: &amp;#39;flow&amp;#39;,
      label: &amp;#39;Flow&amp;#39;,
      content: currentProject ? (
        &amp;lt;FlowDiagram projectId&#x3D;{currentProject.id} /&amp;gt;
      ) : (
        &amp;lt;DiagramPlaceholder type&#x3D;&amp;quot;Flow Diagram&amp;quot; /&amp;gt;
      ),
    },
    {
      id: &amp;#39;site&amp;#39;,
      label: &amp;#39;Site&amp;#39;,
      content: currentProject ? (
        &amp;lt;SiteDiagram projectId&#x3D;{currentProject.id} /&amp;gt;
      ) : (
        &amp;lt;DiagramPlaceholder type&#x3D;&amp;quot;Site DAG&amp;quot; /&amp;gt;
      ),
    },
    {
      id: &amp;#39;fsm&amp;#39;,
      label: &amp;#39;FSM&amp;#39;,
      content: currentProject ? (
        &amp;lt;FsmDiagram projectId&#x3D;{currentProject.id} /&amp;gt;
      ) : (
        &amp;lt;DiagramPlaceholder type&#x3D;&amp;quot;FSM Diagram&amp;quot; /&amp;gt;
      ),
    },
    {
      id: &amp;#39;view&amp;#39;,
      label: &amp;#39;View&amp;#39;,
      content: currentProject ? (
        &amp;lt;ViewDiagram projectId&#x3D;{currentProject.id} /&amp;gt;
      ) : (
        &amp;lt;DiagramPlaceholder type&#x3D;&amp;quot;View Wireframes&amp;quot; /&amp;gt;
      ),
    },
    {
      id: &amp;#39;gaps&amp;#39;,
      label: &amp;#39;Gaps&amp;#39;,
      content: currentProject ? (
        &amp;lt;GapsChecklist projectId&#x3D;{currentProject.id} /&amp;gt;
      ) : (
        &amp;lt;DiagramPlaceholder type&#x3D;&amp;quot;Gaps Checklist&amp;quot; /&amp;gt;
      ),
    },
    {
      id: &amp;#39;resolved&amp;#39;,
      label: &amp;#39;Resolved&amp;#39;,
      content: currentProject ? (
        &amp;lt;ResolvedViewer projectId&#x3D;{currentProject.id} /&amp;gt;
      ) : (
        &amp;lt;DiagramPlaceholder type&#x3D;&amp;quot;Resolved JSON&amp;quot; /&amp;gt;
      ),
    },
    {
      id: &amp;#39;architecture&amp;#39;,
      label: &amp;#39;Architecture&amp;#39;,
      content: currentProject ? (
        &amp;lt;ArchitectureDiagram projectId&#x3D;{currentProject.id} /&amp;gt;
      ) : (
        &amp;lt;DiagramPlaceholder type&#x3D;&amp;quot;System Architecture&amp;quot; /&amp;gt;
      ),
    },
    {
      id: &amp;#39;handlers&amp;#39;,
      label: &amp;#39;Handlers&amp;#39;,
      content: &amp;lt;Handlers /&amp;gt;,
    },
  ];

  const editorTabs &#x3D; [
    {
      id: &amp;#39;source&amp;#39;,
      label: &amp;#39;Source&amp;#39;,
      content: currentProject ? (
        &amp;lt;SourceDiagram projectId&#x3D;{currentProject.id} /&amp;gt;
      ) : (
        &amp;lt;DiagramPlaceholder type&#x3D;&amp;quot;Source Code&amp;quot; /&amp;gt;
      ),
    },
    {
      id: &amp;#39;friendly&amp;#39;,
      label: &amp;#39;Friendly&amp;#39;,
      content: currentProject ? (
        &amp;lt;FriendlyDiagram projectId&#x3D;{currentProject.id} /&amp;gt;
      ) : (
        &amp;lt;DiagramPlaceholder type&#x3D;&amp;quot;Friendly Diagram&amp;quot; /&amp;gt;
      ),
    },
  ];

  return (
    &amp;lt;div className&#x3D;&amp;quot;h-full flex flex-col bg-gray-50&amp;quot;&amp;gt;
      {/* Top navigation bar */}
      &amp;lt;TopBar className&#x3D;&amp;quot;flex-shrink-0&amp;quot; /&amp;gt;

      {/* Main content area */}
      &amp;lt;div className&#x3D;&amp;quot;flex-1 overflow-hidden&amp;quot;&amp;gt;
        &amp;lt;SplitPane defaultSize&#x3D;&amp;quot;40%&amp;quot; minSize&#x3D;&amp;quot;300px&amp;quot; maxSize&#x3D;&amp;quot;70%&amp;quot; split&#x3D;&amp;quot;vertical&amp;quot;&amp;gt;
          {/* Left pane - Editor with tabs (Source &amp;amp; Friendly) */}
          &amp;lt;div className&#x3D;&amp;quot;h-full bg-white border-r border-gray-200&amp;quot;&amp;gt;
            &amp;lt;Tabs
              activeTab&#x3D;{leftTab}
              onTabChange&#x3D;{tab &#x3D;&amp;gt; setLeftTab(tab as LeftTab)}
              tabs&#x3D;{editorTabs}
              className&#x3D;&amp;quot;h-full&amp;quot;
            /&amp;gt;
          &amp;lt;/div&amp;gt;

          {/* Right pane - Diagrams */}
          &amp;lt;div className&#x3D;&amp;quot;h-full bg-white&amp;quot;&amp;gt;
            &amp;lt;Tabs
              activeTab&#x3D;{rightTab}
              onTabChange&#x3D;{tab &#x3D;&amp;gt; setRightTab(tab as RightTab)}
              tabs&#x3D;{diagramTabs}
              className&#x3D;&amp;quot;h-full&amp;quot;
            /&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/SplitPane&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}

// Placeholder component for diagrams
function DiagramPlaceholder({ type }: { type: string }) {
  return (
    &amp;lt;div className&#x3D;&amp;quot;diagram-container&amp;quot;&amp;gt;
      &amp;lt;div className&#x3D;&amp;quot;diagram-loading&amp;quot;&amp;gt;
        &amp;lt;div className&#x3D;&amp;quot;text-center&amp;quot;&amp;gt;
          &amp;lt;div className&#x3D;&amp;quot;spinner h-8 w-8 mb-4 mx-auto&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
          &amp;lt;p&amp;gt;{type} coming soon...&amp;lt;/p&amp;gt;
          &amp;lt;p className&#x3D;&amp;quot;text-sm text-gray-400 mt-2&amp;quot;&amp;gt;
            This will render interactive diagrams from the backend IR
          &amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}

// Error boundary component
class ErrorBoundary extends React.Component&amp;lt;
  { children: React.ReactNode },
  { hasError: boolean; error: Error | null }
&amp;gt; {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state &#x3D; { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error(&amp;#39;Error boundary caught an error:&amp;#39;, error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        &amp;lt;div className&#x3D;&amp;quot;error-boundary&amp;quot;&amp;gt;
          &amp;lt;h2&amp;gt;Something went wrong&amp;lt;/h2&amp;gt;
          &amp;lt;p className&#x3D;&amp;quot;text-gray-600 mb-4&amp;quot;&amp;gt;The application encountered an unexpected error.&amp;lt;/p&amp;gt;
          &amp;lt;details className&#x3D;&amp;quot;text-left&amp;quot;&amp;gt;
            &amp;lt;summary className&#x3D;&amp;quot;cursor-pointer text-blue-600 hover:text-blue-700&amp;quot;&amp;gt;
              Error Details
            &amp;lt;/summary&amp;gt;
            &amp;lt;pre className&#x3D;&amp;quot;mt-2&amp;quot;&amp;gt;{this.state.error?.stack}&amp;lt;/pre&amp;gt;
          &amp;lt;/details&amp;gt;
          &amp;lt;button
            className&#x3D;&amp;quot;mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700&amp;quot;
            onClick&#x3D;{() &#x3D;&amp;gt; window.location.reload()}
          &amp;gt;
            Reload Page
          &amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
      );
    }

    return this.props.children;
  }
}

// Main App component with all providers
function App() {
  return (
    &amp;lt;ErrorBoundary&amp;gt;
      &amp;lt;QueryProvider&amp;gt;
        &amp;lt;ProjectProvider&amp;gt;
          &amp;lt;AppContent /&amp;gt;
          &amp;lt;ToastContainer
            position&#x3D;&amp;quot;top-right&amp;quot;
            autoClose&#x3D;{3000}
            hideProgressBar&#x3D;{false}
            newestOnTop
            closeOnClick
            rtl&#x3D;{false}
            pauseOnFocusLoss
            draggable
            pauseOnHover
            theme&#x3D;&amp;quot;light&amp;quot;
          /&amp;gt;
        &amp;lt;/ProjectProvider&amp;gt;
      &amp;lt;/QueryProvider&amp;gt;
    &amp;lt;/ErrorBoundary&amp;gt;
  );
}

export default App;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-156">
                <div class="file-header">ğŸ“„ apps/api/src/tests/integration/nats.test.ts</div>
                <div class="file-content">
                    <pre>/**
 * NATS integration tests
 */
import { type NatsConnection, connect } from &amp;#39;nats&amp;#39;;
import { NatsService } from &amp;#39;../../nats.ts&amp;#39;;
import type { Event, NatsConfig } from &amp;#39;../../types.ts&amp;#39;;

describe(&amp;#39;NATS Integration&amp;#39;, () &#x3D;&amp;gt; {
  let natsService: NatsService;
  let testConnection: NatsConnection | null &#x3D; null;
  let natsAvailable &#x3D; false;
  const TEST_NATS_URL &#x3D; &amp;#39;nats://localhost:4222&amp;#39;;

  beforeAll(async () &#x3D;&amp;gt; {
    // Skip tests if no NATS server available
    try {
      testConnection &#x3D; await connect({
        servers: [TEST_NATS_URL],
        timeout: 2000,
      });
      natsAvailable &#x3D; true;
    } catch (_error) {
      console.warn(&amp;#39;NATS server not available, skipping NATS tests&amp;#39;);
      return;
    }
  });

  afterAll(async () &#x3D;&amp;gt; {
    if (testConnection) {
      await testConnection.close();
    }
    if (natsService) {
      await natsService.cleanup();
    }
  });

  describe(&amp;#39;NatsService&amp;#39;, () &#x3D;&amp;gt; {
    it(&amp;#39;should initialize with NATS disabled by default&amp;#39;, () &#x3D;&amp;gt; {
      const service &#x3D; new NatsService();
      const stats &#x3D; service.getStats();

      expect(stats.enabled).toBe(false);
      expect(stats.connected).toBe(false);
    });

    it(&amp;#39;should enable NATS when URL is provided&amp;#39;, () &#x3D;&amp;gt; {
      if (!natsAvailable) return;

      const config: NatsConfig &#x3D; {
        url: TEST_NATS_URL,
        enabled: true,
        reconnectTimeWait: 1000,
        maxReconnectAttempts: 3,
        topicPrefix: &amp;#39;test-spec&amp;#39;,
      };

      natsService &#x3D; new NatsService(config);
      const stats &#x3D; natsService.getStats();

      expect(stats.enabled).toBe(true);
      expect(stats.config.topicPrefix).toBe(&amp;#39;test-spec&amp;#39;);
    });

    it(&amp;#39;should publish events to NATS topics&amp;#39;, async () &#x3D;&amp;gt; {
      if (!natsAvailable || !testConnection) return;

      const config: NatsConfig &#x3D; {
        url: TEST_NATS_URL,
        enabled: true,
        reconnectTimeWait: 1000,
        maxReconnectAttempts: 3,
        topicPrefix: &amp;#39;test-spec&amp;#39;,
      };

      natsService &#x3D; new NatsService(config);

      // Give service time to connect
      await new Promise(resolve &#x3D;&amp;gt; setTimeout(resolve, 1000));

      // Subscribe to test topic
      const subscription &#x3D; testConnection.subscribe(&amp;#39;test-spec.project123.fragment.updated&amp;#39;);
      const messagePromise &#x3D; new Promise(resolve &#x3D;&amp;gt; {
        subscription.then(async sub &#x3D;&amp;gt; {
          for await (const message of sub) {
            const event &#x3D; JSON.parse(message.data.toString());
            resolve(event);
            break;
          }
        });
      });

      // Publish test event
      const testEvent: Omit&amp;lt;Event, &amp;#39;id&amp;#39; | &amp;#39;created_at&amp;#39;&amp;gt; &#x3D; {
        project_id: &amp;#39;project123&amp;#39;,
        event_type: &amp;#39;fragment_updated&amp;#39;,
        data: {
          path: &amp;#39;test.cue&amp;#39;,
          content: &amp;#39;package test\n\nvalue: 42&amp;#39;,
        },
      };

      await natsService.publishEvent(&amp;#39;project123&amp;#39;, testEvent, &amp;#39;testhash123&amp;#39;);

      // Wait for message
      const receivedEvent &#x3D; (await Promise.race([
        messagePromise,
        new Promise((_, reject) &#x3D;&amp;gt; setTimeout(() &#x3D;&amp;gt; reject(new Error(&amp;#39;Timeout&amp;#39;)), 3000)),
      ])) as any;

      expect(receivedEvent.topic).toBe(&amp;#39;test-spec.project123.fragment.updated&amp;#39;);
      expect(receivedEvent.projectId).toBe(&amp;#39;project123&amp;#39;);
      expect(receivedEvent.event.event_type).toBe(&amp;#39;fragment_updated&amp;#39;);
      expect(receivedEvent.event.project_id).toBe(&amp;#39;project123&amp;#39;);
      expect(receivedEvent.metadata.specHash).toBe(&amp;#39;testhash123&amp;#39;);
      expect(receivedEvent.metadata.sequence).toBeGreaterThan(0);
    });

    it(&amp;#39;should handle NATS unavailability gracefully&amp;#39;, async () &#x3D;&amp;gt; {
      const config: NatsConfig &#x3D; {
        url: &amp;#39;nats://nonexistent:4222&amp;#39;,
        enabled: true,
        reconnectTimeWait: 100,
        maxReconnectAttempts: 1,
        topicPrefix: &amp;#39;test-spec&amp;#39;,
      };

      const service &#x3D; new NatsService(config);

      // Publishing should not throw even if NATS is unavailable
      const testEvent: Omit&amp;lt;Event, &amp;#39;id&amp;#39; | &amp;#39;created_at&amp;#39;&amp;gt; &#x3D; {
        project_id: &amp;#39;project123&amp;#39;,
        event_type: &amp;#39;fragment_updated&amp;#39;,
        data: { test: true },
      };

      await expect(service.publishEvent(&amp;#39;project123&amp;#39;, testEvent)).resolves.toBeUndefined();

      const stats &#x3D; service.getStats();
      expect(stats.enabled).toBe(true);
      expect(stats.connected).toBe(false);

      await service.cleanup();
    });
  });

  describe(&amp;#39;Event Topic Mapping&amp;#39;, () &#x3D;&amp;gt; {
    it(&amp;#39;should map fragment events correctly&amp;#39;, () &#x3D;&amp;gt; {
      if (!natsAvailable) return;

      const config: NatsConfig &#x3D; {
        url: TEST_NATS_URL,
        enabled: true,
        reconnectTimeWait: 1000,
        maxReconnectAttempts: 3,
        topicPrefix: &amp;#39;spec&amp;#39;,
      };

      const service &#x3D; new NatsService(config);

      // Test topic mapping via reflection (accessing private method for testing)
      const getTopicSuffix &#x3D; (service as any).getTopicSuffix.bind(service);

      expect(getTopicSuffix(&amp;#39;fragment_created&amp;#39;)).toBe(&amp;#39;fragment&amp;#39;);
      expect(getTopicSuffix(&amp;#39;fragment_updated&amp;#39;)).toBe(&amp;#39;fragment&amp;#39;);
      expect(getTopicSuffix(&amp;#39;fragment_deleted&amp;#39;)).toBe(&amp;#39;fragment&amp;#39;);
      expect(getTopicSuffix(&amp;#39;validation_started&amp;#39;)).toBe(&amp;#39;validation&amp;#39;);
      expect(getTopicSuffix(&amp;#39;validation_completed&amp;#39;)).toBe(&amp;#39;validation&amp;#39;);
      expect(getTopicSuffix(&amp;#39;validation_failed&amp;#39;)).toBe(&amp;#39;validation&amp;#39;);
      expect(getTopicSuffix(&amp;#39;version_frozen&amp;#39;)).toBe(&amp;#39;version&amp;#39;);
      expect(getTopicSuffix(&amp;#39;unknown_event&amp;#39;)).toBe(&amp;#39;general&amp;#39;);
    });
  });
});
</pre>
                </div>
            </div>
            <div class="file-section" id="file-157">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/design-system/components/NavItem.tsx</div>
                <div class="file-content">
                    <pre>/**
 * NavItem Component - Design System
 * Flexible navigation item for various navigation contexts
 * Designed for developer tools with sophisticated graphite theme
 */

import React, { forwardRef, type ReactNode } from &amp;#39;react&amp;#39;;
import { clsx } from &amp;#39;clsx&amp;#39;;
import { ExternalLink, ChevronRight } from &amp;#39;lucide-react&amp;#39;;
import { cn } from &amp;#39;../variants&amp;#39;;

export interface NavItemProps {
  /** Item content/label */
  children: ReactNode;

  /** Item href */
  href?: string;

  /** Whether the item is currently active */
  active?: boolean;

  /** Whether the item is disabled */
  disabled?: boolean;

  /** Icon to display before the label */
  icon?: ReactNode;

  /** Icon to display after the label */
  endIcon?: ReactNode;

  /** Badge or secondary content */
  badge?: string | number | ReactNode;

  /** Visual variant */
  variant?: &amp;#39;default&amp;#39; | &amp;#39;subtle&amp;#39; | &amp;#39;ghost&amp;#39;;

  /** Size variant */
  size?: &amp;#39;sm&amp;#39; | &amp;#39;md&amp;#39; | &amp;#39;lg&amp;#39;;

  /** Whether this is an external link */
  external?: boolean;

  /** Custom className */
  className?: string;

  /** Click handler */
  onClick?: (event: React.MouseEvent&amp;lt;HTMLButtonElement | HTMLAnchorElement&amp;gt;) &#x3D;&amp;gt; void;

  /** Whether to show hover effects */
  interactive?: boolean;

  /** Keyboard shortcut hint */
  shortcut?: string;
}

const variantClasses &#x3D; {
  default: {
    base: &amp;#39;text-graphite-700 hover:text-graphite-900 hover:bg-graphite-100&amp;#39;,
    active: &amp;#39;bg-blue-50 text-blue-700 border-r-2 border-blue-500&amp;#39;,
    disabled: &amp;#39;text-graphite-400 cursor-not-allowed&amp;#39;,
  },
  subtle: {
    base: &amp;#39;text-graphite-600 hover:text-graphite-800 hover:bg-graphite-50&amp;#39;,
    active: &amp;#39;bg-graphite-100 text-graphite-900 font-medium&amp;#39;,
    disabled: &amp;#39;text-graphite-400 cursor-not-allowed&amp;#39;,
  },
  ghost: {
    base: &amp;#39;text-graphite-600 hover:text-graphite-900&amp;#39;,
    active: &amp;#39;text-blue-600 font-medium&amp;#39;,
    disabled: &amp;#39;text-graphite-400 cursor-not-allowed&amp;#39;,
  },
} as const;

const sizeClasses &#x3D; {
  sm: {
    container: &amp;#39;px-2 py-1.5 text-sm&amp;#39;,
    icon: &amp;#39;h-3.5 w-3.5&amp;#39;,
    badge: &amp;#39;px-1.5 py-0.5 text-xs&amp;#39;,
    shortcut: &amp;#39;text-xs&amp;#39;,
  },
  md: {
    container: &amp;#39;px-3 py-2 text-sm&amp;#39;,
    icon: &amp;#39;h-4 w-4&amp;#39;,
    badge: &amp;#39;px-2 py-1 text-xs&amp;#39;,
    shortcut: &amp;#39;text-xs&amp;#39;,
  },
  lg: {
    container: &amp;#39;px-4 py-3 text-base&amp;#39;,
    icon: &amp;#39;h-5 w-5&amp;#39;,
    badge: &amp;#39;px-2.5 py-1 text-sm&amp;#39;,
    shortcut: &amp;#39;text-sm&amp;#39;,
  },
} as const;

export const NavItem &#x3D; forwardRef&amp;lt;HTMLButtonElement | HTMLAnchorElement, NavItemProps&amp;gt;(
  (
    {
      children,
      href,
      active &#x3D; false,
      disabled &#x3D; false,
      icon,
      endIcon,
      badge,
      variant &#x3D; &amp;#39;default&amp;#39;,
      size &#x3D; &amp;#39;md&amp;#39;,
      external &#x3D; false,
      className,
      onClick,
      interactive &#x3D; true,
      shortcut,
      ...props
    },
    ref
  ) &#x3D;&amp;gt; {
    const variants &#x3D; variantClasses[variant];
    const sizes &#x3D; sizeClasses[size];

    const baseClasses &#x3D; cn(
      &amp;#39;flex items-center justify-between w-full rounded-md font-medium transition-all duration-150&amp;#39;,
      &amp;#39;focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1&amp;#39;,
      sizes.container,

      // State styling
      disabled ? variants.disabled : active ? variants.active : interactive &amp;amp;&amp;amp; variants.base,

      className
    );

    const content &#x3D; (
      &amp;lt;&amp;gt;
        {/* Left content */}
        &amp;lt;div className&#x3D;&amp;quot;flex items-center gap-2 min-w-0 flex-1&amp;quot;&amp;gt;
          {/* Icon */}
          {icon &amp;amp;&amp;amp; (
            &amp;lt;span
              className&#x3D;{cn(
                &amp;#39;flex-shrink-0&amp;#39;,
                sizes.icon,
                active ? &amp;#39;text-blue-600&amp;#39; : &amp;#39;text-graphite-500&amp;#39;
              )}
            &amp;gt;
              {icon}
            &amp;lt;/span&amp;gt;
          )}

          {/* Label */}
          &amp;lt;span className&#x3D;&amp;quot;truncate&amp;quot;&amp;gt;{children}&amp;lt;/span&amp;gt;

          {/* External link indicator */}
          {external &amp;amp;&amp;amp; href &amp;amp;&amp;amp; (
            &amp;lt;ExternalLink className&#x3D;{cn(&amp;#39;flex-shrink-0&amp;#39;, sizes.icon, &amp;#39;text-graphite-400&amp;#39;)} /&amp;gt;
          )}
        &amp;lt;/div&amp;gt;

        {/* Right content */}
        &amp;lt;div className&#x3D;&amp;quot;flex items-center gap-2 flex-shrink-0&amp;quot;&amp;gt;
          {/* Badge */}
          {badge &amp;amp;&amp;amp; (
            &amp;lt;span
              className&#x3D;{cn(
                &amp;#39;inline-flex items-center justify-center font-medium rounded-full&amp;#39;,
                sizes.badge,
                active ? &amp;#39;bg-blue-100 text-blue-700&amp;#39; : &amp;#39;bg-graphite-100 text-graphite-600&amp;#39;
              )}
            &amp;gt;
              {badge}
            &amp;lt;/span&amp;gt;
          )}

          {/* Keyboard shortcut */}
          {shortcut &amp;amp;&amp;amp; (
            &amp;lt;kbd
              className&#x3D;{cn(
                &amp;#39;inline-flex items-center font-mono font-medium rounded border bg-graphite-50 px-1.5 py-0.5&amp;#39;,
                sizes.shortcut,
                &amp;#39;text-graphite-500 border-graphite-200&amp;#39;
              )}
            &amp;gt;
              {shortcut}
            &amp;lt;/kbd&amp;gt;
          )}

          {/* End icon */}
          {endIcon &amp;amp;&amp;amp; (
            &amp;lt;span className&#x3D;{cn(&amp;#39;flex-shrink-0&amp;#39;, sizes.icon, &amp;#39;text-graphite-400&amp;#39;)}&amp;gt;{endIcon}&amp;lt;/span&amp;gt;
          )}
        &amp;lt;/div&amp;gt;
      &amp;lt;/&amp;gt;
    );

    // Render as link if href is provided
    if (href &amp;amp;&amp;amp; !disabled) {
      return (
        &amp;lt;a
          ref&#x3D;{ref as React.Ref&amp;lt;HTMLAnchorElement&amp;gt;}
          href&#x3D;{href}
          className&#x3D;{baseClasses}
          onClick&#x3D;{onClick as React.MouseEventHandler&amp;lt;HTMLAnchorElement&amp;gt;}
          target&#x3D;{external ? &amp;#39;_blank&amp;#39; : undefined}
          rel&#x3D;{external ? &amp;#39;noopener noreferrer&amp;#39; : undefined}
          {...(props as React.AnchorHTMLAttributes&amp;lt;HTMLAnchorElement&amp;gt;)}
        &amp;gt;
          {content}
        &amp;lt;/a&amp;gt;
      );
    }

    // Render as button otherwise
    return (
      &amp;lt;button
        ref&#x3D;{ref as React.Ref&amp;lt;HTMLButtonElement&amp;gt;}
        type&#x3D;&amp;quot;button&amp;quot;
        className&#x3D;{baseClasses}
        onClick&#x3D;{onClick as React.MouseEventHandler&amp;lt;HTMLButtonElement&amp;gt;}
        disabled&#x3D;{disabled}
        {...(props as React.ButtonHTMLAttributes&amp;lt;HTMLButtonElement&amp;gt;)}
      &amp;gt;
        {content}
      &amp;lt;/button&amp;gt;
    );
  }
);

NavItem.displayName &#x3D; &amp;#39;NavItem&amp;#39;;

// Group component for organizing navigation items
export interface NavGroupProps {
  /** Group title */
  title?: string;

  /** Group items */
  children: ReactNode;

  /** Whether the group is collapsible */
  collapsible?: boolean;

  /** Whether the group is initially collapsed */
  defaultCollapsed?: boolean;

  /** Custom className */
  className?: string;
}

export function NavGroup({
  title,
  children,
  collapsible &#x3D; false,
  defaultCollapsed &#x3D; false,
  className,
}: NavGroupProps) {
  const [collapsed, setCollapsed] &#x3D; React.useState(defaultCollapsed);

  return (
    &amp;lt;div className&#x3D;{cn(&amp;#39;space-y-1&amp;#39;, className)}&amp;gt;
      {title &amp;amp;&amp;amp; (
        &amp;lt;div className&#x3D;&amp;quot;flex items-center justify-between&amp;quot;&amp;gt;
          {collapsible ? (
            &amp;lt;button
              type&#x3D;&amp;quot;button&amp;quot;
              className&#x3D;&amp;quot;flex items-center gap-2 px-3 py-2 text-xs font-semibold text-graphite-500 uppercase tracking-wide hover:text-graphite-700 transition-colors&amp;quot;
              onClick&#x3D;{() &#x3D;&amp;gt; setCollapsed(!collapsed)}
            &amp;gt;
              &amp;lt;ChevronRight
                className&#x3D;{cn(&amp;#39;h-3 w-3 transition-transform&amp;#39;, !collapsed &amp;amp;&amp;amp; &amp;#39;rotate-90&amp;#39;)}
              /&amp;gt;
              {title}
            &amp;lt;/button&amp;gt;
          ) : (
            &amp;lt;h3 className&#x3D;&amp;quot;px-3 py-2 text-xs font-semibold text-graphite-500 uppercase tracking-wide&amp;quot;&amp;gt;
              {title}
            &amp;lt;/h3&amp;gt;
          )}
        &amp;lt;/div&amp;gt;
      )}

      {(!collapsible || !collapsed) &amp;amp;&amp;amp; &amp;lt;div className&#x3D;&amp;quot;space-y-1&amp;quot;&amp;gt;{children}&amp;lt;/div&amp;gt;}
    &amp;lt;/div&amp;gt;
  );
}

export default NavItem;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-158">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/design-system/components/Breadcrumbs.tsx</div>
                <div class="file-content">
                    <pre>/**
 * Breadcrumbs Component - Design System
 * Professional breadcrumb navigation with elegant separators and hover states
 * Designed for developer tools with sophisticated graphite theme
 */

import React, { type ReactNode } from &amp;#39;react&amp;#39;;
import { clsx } from &amp;#39;clsx&amp;#39;;
import { ChevronRight, Home, Folder, File, MoreHorizontal } from &amp;#39;lucide-react&amp;#39;;
import { cn } from &amp;#39;../variants&amp;#39;;

export interface BreadcrumbItem {
  id: string;
  label: string;
  href?: string;
  icon?: ReactNode;
  current?: boolean;
  onClick?: () &#x3D;&amp;gt; void;
}

export interface BreadcrumbsProps {
  /** Breadcrumb items */
  items: BreadcrumbItem[];

  /** Separator between items */
  separator?: &amp;#39;chevron&amp;#39; | &amp;#39;slash&amp;#39; | &amp;#39;dot&amp;#39; | ReactNode;

  /** Maximum number of items to show before collapsing */
  maxItems?: number;

  /** Size variant */
  size?: &amp;#39;sm&amp;#39; | &amp;#39;md&amp;#39; | &amp;#39;lg&amp;#39;;

  /** Whether to show home icon for first item */
  showHomeIcon?: boolean;

  /** Custom className */
  className?: string;

  /** Callback when an item is clicked */
  onItemClick?: (item: BreadcrumbItem) &#x3D;&amp;gt; void;
}

const separators &#x3D; {
  chevron: &amp;lt;ChevronRight className&#x3D;&amp;quot;h-4 w-4 text-graphite-400&amp;quot; /&amp;gt;,
  slash: &amp;lt;span className&#x3D;&amp;quot;text-graphite-400 font-normal&amp;quot;&amp;gt;/&amp;lt;/span&amp;gt;,
  dot: &amp;lt;span className&#x3D;&amp;quot;text-graphite-400&amp;quot;&amp;gt;â€¢&amp;lt;/span&amp;gt;,
} as const;

const sizeClasses &#x3D; {
  sm: {
    container: &amp;#39;text-xs&amp;#39;,
    item: &amp;#39;px-2 py-1&amp;#39;,
    icon: &amp;#39;h-3 w-3&amp;#39;,
  },
  md: {
    container: &amp;#39;text-sm&amp;#39;,
    item: &amp;#39;px-2.5 py-1.5&amp;#39;,
    icon: &amp;#39;h-4 w-4&amp;#39;,
  },
  lg: {
    container: &amp;#39;text-base&amp;#39;,
    item: &amp;#39;px-3 py-2&amp;#39;,
    icon: &amp;#39;h-5 w-5&amp;#39;,
  },
} as const;

function BreadcrumbItem({
  item,
  size &#x3D; &amp;#39;md&amp;#39;,
  onItemClick,
  showIcon &#x3D; false,
}: {
  item: BreadcrumbItem;
  size?: &amp;#39;sm&amp;#39; | &amp;#39;md&amp;#39; | &amp;#39;lg&amp;#39;;
  onItemClick?: (item: BreadcrumbItem) &#x3D;&amp;gt; void;
  showIcon?: boolean;
}) {
  const sizes &#x3D; sizeClasses[size];
  const isClickable &#x3D; item.href || item.onClick || onItemClick;
  const isCurrent &#x3D; item.current;

  const handleClick &#x3D; () &#x3D;&amp;gt; {
    if (item.onClick) {
      item.onClick();
    }
    onItemClick?.(item);
  };

  const content &#x3D; (
    &amp;lt;span
      className&#x3D;{cn(
        &amp;#39;inline-flex items-center gap-1.5 rounded-md transition-colors duration-150&amp;#39;,
        sizes.item,

        // Current item styling
        isCurrent &amp;amp;&amp;amp; &amp;#39;text-graphite-900 font-semibold&amp;#39;,

        // Clickable item styling
        isClickable &amp;amp;&amp;amp;
          !isCurrent &amp;amp;&amp;amp; [
            &amp;#39;text-graphite-600 hover:text-graphite-900 hover:bg-graphite-50 cursor-pointer&amp;#39;,
            &amp;#39;focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1&amp;#39;,
          ],

        // Non-clickable item styling
        !isClickable &amp;amp;&amp;amp; !isCurrent &amp;amp;&amp;amp; &amp;#39;text-graphite-600&amp;#39;
      )}
    &amp;gt;
      {/* Icon */}
      {(showIcon || item.icon) &amp;amp;&amp;amp; (
        &amp;lt;span
          className&#x3D;{cn(
            &amp;#39;flex-shrink-0&amp;#39;,
            sizes.icon,
            isCurrent ? &amp;#39;text-graphite-700&amp;#39; : &amp;#39;text-graphite-500&amp;#39;
          )}
        &amp;gt;
          {item.icon || &amp;lt;Folder className&#x3D;{sizes.icon} /&amp;gt;}
        &amp;lt;/span&amp;gt;
      )}

      &amp;lt;span className&#x3D;&amp;quot;truncate&amp;quot;&amp;gt;{item.label}&amp;lt;/span&amp;gt;
    &amp;lt;/span&amp;gt;
  );

  if (isClickable) {
    return (
      &amp;lt;button
        type&#x3D;&amp;quot;button&amp;quot;
        onClick&#x3D;{handleClick}
        className&#x3D;&amp;quot;inline-flex items-center&amp;quot;
        aria-current&#x3D;{isCurrent ? &amp;#39;page&amp;#39; : undefined}
      &amp;gt;
        {content}
      &amp;lt;/button&amp;gt;
    );
  }

  return (
    &amp;lt;span className&#x3D;&amp;quot;inline-flex items-center&amp;quot; aria-current&#x3D;{isCurrent ? &amp;#39;page&amp;#39; : undefined}&amp;gt;
      {content}
    &amp;lt;/span&amp;gt;
  );
}

function CollapsedItems({
  items,
  size &#x3D; &amp;#39;md&amp;#39;,
  onItemClick,
}: {
  items: BreadcrumbItem[];
  size?: &amp;#39;sm&amp;#39; | &amp;#39;md&amp;#39; | &amp;#39;lg&amp;#39;;
  onItemClick?: (item: BreadcrumbItem) &#x3D;&amp;gt; void;
}) {
  const [expanded, setExpanded] &#x3D; React.useState(false);
  const sizes &#x3D; sizeClasses[size];

  if (expanded) {
    return (
      &amp;lt;&amp;gt;
        {items.map((item, index) &#x3D;&amp;gt; (
          &amp;lt;React.Fragment key&#x3D;{item.id}&amp;gt;
            &amp;lt;BreadcrumbItem item&#x3D;{item} size&#x3D;{size} onItemClick&#x3D;{onItemClick} /&amp;gt;
            {index &amp;lt; items.length - 1 &amp;amp;&amp;amp; (
              &amp;lt;span className&#x3D;&amp;quot;flex-shrink-0 mx-1&amp;quot;&amp;gt;{separators.chevron}&amp;lt;/span&amp;gt;
            )}
          &amp;lt;/React.Fragment&amp;gt;
        ))}
      &amp;lt;/&amp;gt;
    );
  }

  return (
    &amp;lt;button
      type&#x3D;&amp;quot;button&amp;quot;
      onClick&#x3D;{() &#x3D;&amp;gt; setExpanded(true)}
      className&#x3D;{cn(
        &amp;#39;inline-flex items-center gap-1 rounded-md transition-colors duration-150&amp;#39;,
        sizes.item,
        &amp;#39;text-graphite-600 hover:text-graphite-900 hover:bg-graphite-50&amp;#39;,
        &amp;#39;focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1&amp;#39;
      )}
      aria-label&#x3D;{&#x60;Show ${items.length} hidden items&#x60;}
    &amp;gt;
      &amp;lt;MoreHorizontal className&#x3D;{sizes.icon} /&amp;gt;
    &amp;lt;/button&amp;gt;
  );
}

export function Breadcrumbs({
  items,
  separator &#x3D; &amp;#39;chevron&amp;#39;,
  maxItems,
  size &#x3D; &amp;#39;md&amp;#39;,
  showHomeIcon &#x3D; false,
  className,
  onItemClick,
}: BreadcrumbsProps) {
  const sizes &#x3D; sizeClasses[size];

  // Handle collapsing items if maxItems is set
  let displayItems &#x3D; items;
  let collapsedItems: BreadcrumbItem[] &#x3D; [];

  if (maxItems &amp;amp;&amp;amp; items.length &amp;gt; maxItems) {
    // Always show first item, collapsed indicator, and last few items
    const keepFromEnd &#x3D; Math.max(1, maxItems - 2);
    const firstItem &#x3D; items[0];
    const lastItems &#x3D; items.slice(-keepFromEnd);
    collapsedItems &#x3D; items.slice(1, items.length - keepFromEnd);

    displayItems &#x3D; [firstItem, ...lastItems];
  }

  const getSeparator &#x3D; () &#x3D;&amp;gt; {
    if (typeof separator &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39;) {
      return separators[separator];
    }
    return separator;
  };

  return (
    &amp;lt;nav aria-label&#x3D;&amp;quot;Breadcrumb&amp;quot; className&#x3D;{cn(&amp;#39;flex items-center&amp;#39;, sizes.container, className)}&amp;gt;
      &amp;lt;ol className&#x3D;&amp;quot;flex items-center space-x-1&amp;quot;&amp;gt;
        {displayItems.map((item, index) &#x3D;&amp;gt; {
          const isFirst &#x3D; index &#x3D;&#x3D;&#x3D; 0;
          const isLast &#x3D; index &#x3D;&#x3D;&#x3D; displayItems.length - 1;
          const showIcon &#x3D; isFirst &amp;amp;&amp;amp; showHomeIcon;

          return (
            &amp;lt;li key&#x3D;{item.id} className&#x3D;&amp;quot;flex items-center&amp;quot;&amp;gt;
              {/* Show collapsed items indicator */}
              {isFirst &amp;amp;&amp;amp; collapsedItems.length &amp;gt; 0 &amp;amp;&amp;amp; (
                &amp;lt;&amp;gt;
                  &amp;lt;BreadcrumbItem
                    item&#x3D;{item}
                    size&#x3D;{size}
                    onItemClick&#x3D;{onItemClick}
                    showIcon&#x3D;{showIcon}
                  /&amp;gt;
                  &amp;lt;span className&#x3D;&amp;quot;flex-shrink-0 mx-1&amp;quot;&amp;gt;{getSeparator()}&amp;lt;/span&amp;gt;
                  &amp;lt;CollapsedItems items&#x3D;{collapsedItems} size&#x3D;{size} onItemClick&#x3D;{onItemClick} /&amp;gt;
                  {!isLast &amp;amp;&amp;amp; &amp;lt;span className&#x3D;&amp;quot;flex-shrink-0 mx-1&amp;quot;&amp;gt;{getSeparator()}&amp;lt;/span&amp;gt;}
                &amp;lt;/&amp;gt;
              )}

              {/* Regular item */}
              {(isFirst &amp;amp;&amp;amp; collapsedItems.length &#x3D;&#x3D;&#x3D; 0) || !isFirst ? (
                &amp;lt;&amp;gt;
                  &amp;lt;BreadcrumbItem
                    item&#x3D;{item}
                    size&#x3D;{size}
                    onItemClick&#x3D;{onItemClick}
                    showIcon&#x3D;{showIcon}
                  /&amp;gt;
                  {!isLast &amp;amp;&amp;amp; &amp;lt;span className&#x3D;&amp;quot;flex-shrink-0 mx-1&amp;quot;&amp;gt;{getSeparator()}&amp;lt;/span&amp;gt;}
                &amp;lt;/&amp;gt;
              ) : null}
            &amp;lt;/li&amp;gt;
          );
        })}
      &amp;lt;/ol&amp;gt;
    &amp;lt;/nav&amp;gt;
  );
}

// Convenience icons for breadcrumb items
export const breadcrumbIcons &#x3D; {
  Home,
  Folder,
  File,
} as const;

export default Breadcrumbs;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-159">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/diagrams/FlowDiagram.tsx</div>
                <div class="file-content">
                    <pre>import React, { useEffect, useRef, useState } from &amp;#39;react&amp;#39;;
import mermaid from &amp;#39;mermaid&amp;#39;;
import { apiService } from &amp;#39;../../services/api&amp;#39;;
import type { IRResponse } from &amp;#39;../../types/api&amp;#39;;

interface FlowDiagramProps {
  projectId: string;
  className?: string;
}

interface FlowIRData {
  specHash: string;
  flows: {
    id: string;
    nodes: {
      id: string;
      kind: &amp;#39;visit&amp;#39; | &amp;#39;click&amp;#39; | &amp;#39;fill&amp;#39; | &amp;#39;expect&amp;#39; | &amp;#39;expect_api&amp;#39;;
      label: string;
    }[];
    edges: {
      from: string;
      to: string;
      label?: string;
    }[];
  }[];
}

const FlowDiagram: React.FC&amp;lt;FlowDiagramProps&amp;gt; &#x3D; ({ projectId, className &#x3D; &amp;#39;&amp;#39; }) &#x3D;&amp;gt; {
  const containerRef &#x3D; useRef&amp;lt;HTMLDivElement&amp;gt;(null);
  const [flowData, setFlowData] &#x3D; useState&amp;lt;FlowIRData | null&amp;gt;(null);
  const [loading, setLoading] &#x3D; useState(true);
  const [error, setError] &#x3D; useState&amp;lt;string | null&amp;gt;(null);

  useEffect(() &#x3D;&amp;gt; {
    // Initialize mermaid with configuration
    mermaid.initialize({
      startOnLoad: true,
      theme: &amp;#39;default&amp;#39;,
      securityLevel: &amp;#39;loose&amp;#39;,
      flowchart: {
        useMaxWidth: true,
        htmlLabels: true,
        curve: &amp;#39;basis&amp;#39;,
      },
      fontFamily: &amp;#39;Inter, system-ui, sans-serif&amp;#39;,
    });
  }, []);

  useEffect(() &#x3D;&amp;gt; {
    if (!projectId) return;

    const loadFlowData &#x3D; async () &#x3D;&amp;gt; {
      try {
        setLoading(true);
        setError(null);

        const response: IRResponse &#x3D; await apiService.getIR(projectId, &amp;#39;flow&amp;#39;);
        setFlowData(response.data as FlowIRData);
      } catch (err) {
        console.error(&amp;#39;Failed to load flow data:&amp;#39;, err);
        setError(err instanceof Error ? err.message : &amp;#39;Failed to load flow diagram&amp;#39;);
      } finally {
        setLoading(false);
      }
    };

    loadFlowData();
  }, [projectId]);

  const convertFlowToMermaid &#x3D; (flows: FlowIRData[&amp;#39;flows&amp;#39;]): string &#x3D;&amp;gt; {
    if (!flows || flows.length &#x3D;&#x3D;&#x3D; 0) {
      return &#x60;graph TD
        A[No flows defined]
        style A fill:#f9f9f9,stroke:#ccc,stroke-dasharray: 5 5&#x60;;
    }

    let mermaidCode &#x3D; &amp;#39;graph TD\n&amp;#39;;

    // Process each flow
    flows.forEach((flow, flowIndex) &#x3D;&amp;gt; {
      // Add flow title as a comment
      mermaidCode +&#x3D; &#x60;    %% Flow: ${flow.id}\n&#x60;;

      // Add nodes with appropriate styling based on their kind
      flow.nodes.forEach(node &#x3D;&amp;gt; {
        const nodeId &#x3D; &#x60;${flowIndex}_${node.id}&#x60;;
        const label &#x3D; node.label || node.id;

        switch (node.kind) {
          case &amp;#39;visit&amp;#39;:
            mermaidCode +&#x3D; &#x60;    ${nodeId}[${label}]\n&#x60;;
            mermaidCode +&#x3D; &#x60;    style ${nodeId} fill:#e1f5fe,stroke:#01579b\n&#x60;;
            break;
          case &amp;#39;click&amp;#39;:
            mermaidCode +&#x3D; &#x60;    ${nodeId}{${label}}\n&#x60;;
            mermaidCode +&#x3D; &#x60;    style ${nodeId} fill:#f3e5f5,stroke:#4a148c\n&#x60;;
            break;
          case &amp;#39;fill&amp;#39;:
            mermaidCode +&#x3D; &#x60;    ${nodeId}[/${label}/]\n&#x60;;
            mermaidCode +&#x3D; &#x60;    style ${nodeId} fill:#e8f5e8,stroke:#1b5e20\n&#x60;;
            break;
          case &amp;#39;expect&amp;#39;:
            mermaidCode +&#x3D; &#x60;    ${nodeId}((${label}))\n&#x60;;
            mermaidCode +&#x3D; &#x60;    style ${nodeId} fill:#fff3e0,stroke:#e65100\n&#x60;;
            break;
          case &amp;#39;expect_api&amp;#39;:
            mermaidCode +&#x3D; &#x60;    ${nodeId}{{${label}}}\n&#x60;;
            mermaidCode +&#x3D; &#x60;    style ${nodeId} fill:#fce4ec,stroke:#880e4f\n&#x60;;
            break;
          default:
            mermaidCode +&#x3D; &#x60;    ${nodeId}[${label}]\n&#x60;;
        }
      });

      // Add edges
      flow.edges.forEach(edge &#x3D;&amp;gt; {
        const fromId &#x3D; &#x60;${flowIndex}_${edge.from}&#x60;;
        const toId &#x3D; &#x60;${flowIndex}_${edge.to}&#x60;;
        const label &#x3D; edge.label ? &#x60;|${edge.label}|&#x60; : &amp;#39;&amp;#39;;
        mermaidCode +&#x3D; &#x60;    ${fromId} --&amp;gt;${label} ${toId}\n&#x60;;
      });

      // Add spacing between flows
      if (flowIndex &amp;lt; flows.length - 1) {
        mermaidCode +&#x3D; &amp;#39;\n&amp;#39;;
      }
    });

    return mermaidCode;
  };

  const renderMermaidDiagram &#x3D; async (mermaidCode: string) &#x3D;&amp;gt; {
    if (!containerRef.current) return;

    try {
      // Clear previous content
      containerRef.current.innerHTML &#x3D; &amp;#39;&amp;#39;;

      // Generate unique ID for this diagram
      const diagramId &#x3D; &#x60;mermaid-${Date.now()}&#x60;;

      // Render the diagram
      const { svg } &#x3D; await mermaid.render(diagramId, mermaidCode);

      // Insert the SVG into the container
      containerRef.current.innerHTML &#x3D; svg;

      // Make sure the SVG is responsive
      const svgElement &#x3D; containerRef.current.querySelector(&amp;#39;svg&amp;#39;);
      if (svgElement) {
        svgElement.style.maxWidth &#x3D; &amp;#39;100%&amp;#39;;
        svgElement.style.height &#x3D; &amp;#39;auto&amp;#39;;
      }
    } catch (err) {
      console.error(&amp;#39;Failed to render mermaid diagram:&amp;#39;, err);
      setError(&amp;#39;Failed to render flow diagram&amp;#39;);
    }
  };

  useEffect(() &#x3D;&amp;gt; {
    if (flowData &amp;amp;&amp;amp; !loading &amp;amp;&amp;amp; !error) {
      const mermaidCode &#x3D; convertFlowToMermaid(flowData.flows);
      renderMermaidDiagram(mermaidCode);
    }
  }, [flowData, loading, error]);

  if (loading) {
    return (
      &amp;lt;div className&#x3D;{&#x60;flex items-center justify-center h-full ${className}&#x60;}&amp;gt;
        &amp;lt;div className&#x3D;&amp;quot;text-center&amp;quot;&amp;gt;
          &amp;lt;div className&#x3D;&amp;quot;animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
          &amp;lt;p className&#x3D;&amp;quot;text-gray-600&amp;quot;&amp;gt;Loading flow diagrams...&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }

  if (error) {
    return (
      &amp;lt;div className&#x3D;{&#x60;flex items-center justify-center h-full ${className}&#x60;}&amp;gt;
        &amp;lt;div className&#x3D;&amp;quot;text-center&amp;quot;&amp;gt;
          &amp;lt;div className&#x3D;&amp;quot;text-red-500 mb-4&amp;quot;&amp;gt;
            &amp;lt;svg
              className&#x3D;&amp;quot;w-12 h-12 mx-auto&amp;quot;
              fill&#x3D;&amp;quot;none&amp;quot;
              stroke&#x3D;&amp;quot;currentColor&amp;quot;
              viewBox&#x3D;&amp;quot;0 0 24 24&amp;quot;
            &amp;gt;
              &amp;lt;path
                strokeLinecap&#x3D;&amp;quot;round&amp;quot;
                strokeLinejoin&#x3D;&amp;quot;round&amp;quot;
                strokeWidth&#x3D;{2}
                d&#x3D;&amp;quot;M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z&amp;quot;
              /&amp;gt;
            &amp;lt;/svg&amp;gt;
          &amp;lt;/div&amp;gt;
          &amp;lt;p className&#x3D;&amp;quot;text-red-700 font-medium&amp;quot;&amp;gt;Error loading flow diagram&amp;lt;/p&amp;gt;
          &amp;lt;p className&#x3D;&amp;quot;text-red-600 text-sm mt-1&amp;quot;&amp;gt;{error}&amp;lt;/p&amp;gt;
          &amp;lt;button
            onClick&#x3D;{() &#x3D;&amp;gt; window.location.reload()}
            className&#x3D;&amp;quot;mt-3 px-4 py-2 bg-red-100 text-red-800 rounded-md hover:bg-red-200 transition-colors&amp;quot;
          &amp;gt;
            Retry
          &amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }

  return (
    &amp;lt;div className&#x3D;{&#x60;h-full overflow-auto ${className}&#x60;}&amp;gt;
      &amp;lt;div className&#x3D;&amp;quot;p-4&amp;quot;&amp;gt;
        {flowData?.flows &amp;amp;&amp;amp; flowData.flows.length &amp;gt; 0 &amp;amp;&amp;amp; (
          &amp;lt;div className&#x3D;&amp;quot;mb-4&amp;quot;&amp;gt;
            &amp;lt;h3 className&#x3D;&amp;quot;text-lg font-medium text-gray-900&amp;quot;&amp;gt;Flow Diagrams&amp;lt;/h3&amp;gt;
            &amp;lt;p className&#x3D;&amp;quot;text-sm text-gray-600&amp;quot;&amp;gt;
              Showing {flowData.flows.length} flow{flowData.flows.length !&#x3D;&#x3D; 1 ? &amp;#39;s&amp;#39; : &amp;#39;&amp;#39;}
            &amp;lt;/p&amp;gt;
          &amp;lt;/div&amp;gt;
        )}
        &amp;lt;div
          ref&#x3D;{containerRef}
          className&#x3D;&amp;quot;mermaid-container bg-white border border-gray-200 rounded-lg p-4 min-h-[400px] flex items-center justify-center&amp;quot;
        /&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default FlowDiagram;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-160">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/preview.ts</div>
                <div class="file-content">
                    <pre>/**
 * Preview command - Generate deterministic plans showing what would be created
 *
 * This command analyzes the assembly.cue file and shows what would be generated
 * without actually creating files. Critical for deterministic output testing.
 */

import fs from &amp;#39;node:fs&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import type { Config } from &amp;#39;../config.js&amp;#39;;

export interface PreviewOptions {
  format?: &amp;#39;json&amp;#39; | &amp;#39;yaml&amp;#39; | &amp;#39;text&amp;#39;;
  output?: string;
  outputDir?: string;
  verbose?: boolean;
  includeContent?: boolean;
}

interface PreviewPlan {
  timestamp: string;
  assembly: {
    language: string;
    kind: string;
    name: string;
    version: string;
    buildTool?: string;
  };
  plannedFiles: Array&amp;lt;{
    path: string;
    type: &amp;#39;file&amp;#39; | &amp;#39;directory&amp;#39;;
    size?: number;
    checksum?: string;
    content?: string;
  }&amp;gt;;
  operations: Array&amp;lt;{
    type: &amp;#39;create&amp;#39; | &amp;#39;update&amp;#39; | &amp;#39;delete&amp;#39;;
    target: string;
    reason: string;
  }&amp;gt;;
  metadata: {
    totalFiles: number;
    totalDirectories: number;
    estimatedSize: number;
  };
}

/**
 * Main preview command implementation
 */
export async function previewCommand(options: PreviewOptions, _config: Config): Promise&amp;lt;number&amp;gt; {
  try {
    if (options.verbose) {
      console.log(chalk.blue(&amp;#39;ğŸ” Generating deterministic preview plan...&amp;#39;));
    }

    // Read assembly file
    const assemblyPath &#x3D; resolveAssemblyPath();
    if (!assemblyPath) {
      console.error(chalk.red(&amp;#39;âŒ No assembly specification found&amp;#39;));
      console.log(chalk.dim(&amp;#39;Initialize a project with: arbiter init&amp;#39;));
      return 1;
    }

    const assemblyContent &#x3D; fs.readFileSync(assemblyPath, &amp;#39;utf-8&amp;#39;);
    const assemblyConfig &#x3D; parseAssemblyFile(assemblyContent);

    // Generate deterministic plan
    const plan &#x3D; await generatePreviewPlan(assemblyConfig, options);

    // Output plan in requested format
    let output: string;
    switch (options.format) {
      case &amp;#39;json&amp;#39;:
        output &#x3D; JSON.stringify(plan, null, 2);
        break;
      case &amp;#39;yaml&amp;#39;:
        output &#x3D; convertToYAML(plan);
        break;
      default:
        output &#x3D; formatAsText(plan, options.verbose);
        break;
    }

    // Write to file or stdout
    if (options.output) {
      const outputDir &#x3D; options.outputDir || &amp;#39;.&amp;#39;;
      const outputPath &#x3D; path.isAbsolute(options.output)
        ? options.output
        : path.join(outputDir, options.output);

      // Ensure output directory exists
      fs.mkdirSync(path.dirname(outputPath), { recursive: true });

      fs.writeFileSync(outputPath, output);
      if (options.verbose) {
        console.log(chalk.green(&#x60;âœ… Preview plan written to ${outputPath}&#x60;));
      }
    } else {
      console.log(output);
    }

    return 0;
  } catch (error) {
    console.error(
      chalk.red(&amp;#39;âŒ Preview failed:&amp;#39;),
      error instanceof Error ? error.message : String(error)
    );
    return 1;
  }
}

function resolveAssemblyPath(): string | null {
  const primary &#x3D; path.resolve(&amp;#39;.arbiter&amp;#39;, &amp;#39;assembly.cue&amp;#39;);
  if (fs.existsSync(primary)) {
    return primary;
  }

  const arbiterDir &#x3D; path.resolve(&amp;#39;.arbiter&amp;#39;);
  if (fs.existsSync(arbiterDir)) {
    const entries &#x3D; fs.readdirSync(arbiterDir, { withFileTypes: true });
    for (const entry of entries) {
      if (!entry.isDirectory()) continue;
      const candidate &#x3D; path.join(arbiterDir, entry.name, &amp;#39;assembly.cue&amp;#39;);
      if (fs.existsSync(candidate)) {
        return candidate;
      }
    }
  }

  return null;
}

/**
 * Parse assembly.cue file and extract configuration
 */
function parseAssemblyFile(content: string): any {
  // Basic CUE parsing - extract key information
  const config: any &#x3D; {
    kind: &amp;#39;library&amp;#39;,
    language: &amp;#39;typescript&amp;#39;,
    name: &amp;#39;unknown&amp;#39;,
    version: &amp;#39;1.0.0&amp;#39;,
  };

  // Extract language
  const langMatch &#x3D; content.match(/language:\s*&amp;quot;([^&amp;quot;]+)&amp;quot;/);
  if (langMatch) {
    config.language &#x3D; langMatch[1];
  }

  // Extract kind
  const kindMatch &#x3D; content.match(/kind:\s*&amp;quot;([^&amp;quot;]+)&amp;quot;/);
  if (kindMatch) {
    config.kind &#x3D; kindMatch[1];
  }

  // Extract name from metadata
  const nameMatch &#x3D; content.match(/name:\s*&amp;quot;([^&amp;quot;]+)&amp;quot;/);
  if (nameMatch) {
    config.name &#x3D; nameMatch[1];
  }

  // Extract version
  const versionMatch &#x3D; content.match(/version:\s*&amp;quot;([^&amp;quot;]+)&amp;quot;/);
  if (versionMatch) {
    config.version &#x3D; versionMatch[1];
  }

  // Extract build tool
  const toolMatch &#x3D; content.match(/tool:\s*&amp;quot;([^&amp;quot;]+)&amp;quot;/);
  if (toolMatch) {
    config.buildTool &#x3D; toolMatch[1];
  }

  return config;
}

/**
 * Generate a deterministic preview plan
 */
async function generatePreviewPlan(
  assemblyConfig: any,
  options: PreviewOptions
): Promise&amp;lt;PreviewPlan&amp;gt; {
  const plan: PreviewPlan &#x3D; {
    // Use fixed timestamp for deterministic output
    timestamp: &amp;#39;2024-01-01T00:00:00.000Z&amp;#39;,
    assembly: assemblyConfig,
    plannedFiles: [],
    operations: [],
    metadata: {
      totalFiles: 0,
      totalDirectories: 0,
      estimatedSize: 0,
    },
  };

  // Plan language-specific files
  const languageFiles &#x3D; planLanguageFiles(assemblyConfig);
  plan.plannedFiles.push(...languageFiles);

  // Plan project structure files
  const structureFiles &#x3D; planProjectStructure(assemblyConfig);
  plan.plannedFiles.push(...structureFiles);

  // Plan CI files if applicable
  if (assemblyConfig.ci !&#x3D;&#x3D; false) {
    const ciFiles &#x3D; planCIFiles(assemblyConfig);
    plan.plannedFiles.push(...ciFiles);
  }

  // Generate operations
  plan.operations &#x3D; plan.plannedFiles.map(file &#x3D;&amp;gt; ({
    type: &amp;#39;create&amp;#39; as const,
    target: file.path,
    reason: &#x60;Generate ${file.type} for ${assemblyConfig.language} ${assemblyConfig.kind}&#x60;,
  }));

  // Calculate metadata
  plan.metadata.totalFiles &#x3D; plan.plannedFiles.filter(f &#x3D;&amp;gt; f.type &#x3D;&#x3D;&#x3D; &amp;#39;file&amp;#39;).length;
  plan.metadata.totalDirectories &#x3D; plan.plannedFiles.filter(f &#x3D;&amp;gt; f.type &#x3D;&#x3D;&#x3D; &amp;#39;directory&amp;#39;).length;
  plan.metadata.estimatedSize &#x3D; plan.plannedFiles.reduce((sum, f) &#x3D;&amp;gt; sum + (f.size || 0), 0);

  // Add content if requested (for deterministic comparison)
  if (options.includeContent) {
    plan.plannedFiles.forEach(file &#x3D;&amp;gt; {
      if (file.type &#x3D;&#x3D;&#x3D; &amp;#39;file&amp;#39;) {
        file.content &#x3D; generateFileContent(file.path, assemblyConfig);
        file.checksum &#x3D; generateChecksum(file.content);
        file.size &#x3D; file.content.length;
      }
    });
  }

  return plan;
}

/**
 * Plan language-specific files
 */
function planLanguageFiles(
  config: any
): Array&amp;lt;{ path: string; type: &amp;#39;file&amp;#39; | &amp;#39;directory&amp;#39;; size?: number }&amp;gt; {
  const files: Array&amp;lt;{ path: string; type: &amp;#39;file&amp;#39; | &amp;#39;directory&amp;#39;; size?: number }&amp;gt; &#x3D; [];

  switch (config.language) {
    case &amp;#39;typescript&amp;#39;:
      files.push(
        { path: &amp;#39;package.json&amp;#39;, type: &amp;#39;file&amp;#39;, size: 500 },
        { path: &amp;#39;tsconfig.json&amp;#39;, type: &amp;#39;file&amp;#39;, size: 300 },
        { path: &amp;#39;src/&amp;#39;, type: &amp;#39;directory&amp;#39; },
        { path: &amp;#39;src/index.ts&amp;#39;, type: &amp;#39;file&amp;#39;, size: 200 },
        { path: &amp;#39;tests/&amp;#39;, type: &amp;#39;directory&amp;#39; }
      );
      break;
    case &amp;#39;python&amp;#39;:
      files.push(
        { path: &amp;#39;pyproject.toml&amp;#39;, type: &amp;#39;file&amp;#39;, size: 400 },
        { path: &amp;#39;requirements.txt&amp;#39;, type: &amp;#39;file&amp;#39;, size: 100 },
        { path: &#x60;src/${config.name}/&#x60;, type: &amp;#39;directory&amp;#39; },
        { path: &#x60;src/${config.name}/__init__.py&#x60;, type: &amp;#39;file&amp;#39;, size: 150 },
        { path: &#x60;src/${config.name}/main.py&#x60;, type: &amp;#39;file&amp;#39;, size: 200 },
        { path: &amp;#39;tests/&amp;#39;, type: &amp;#39;directory&amp;#39; }
      );
      break;
    case &amp;#39;rust&amp;#39;:
      files.push(
        { path: &amp;#39;Cargo.toml&amp;#39;, type: &amp;#39;file&amp;#39;, size: 200 },
        { path: &amp;#39;src/&amp;#39;, type: &amp;#39;directory&amp;#39; },
        { path: &amp;#39;src/lib.rs&amp;#39;, type: &amp;#39;file&amp;#39;, size: 300 },
        { path: &amp;#39;tests/&amp;#39;, type: &amp;#39;directory&amp;#39; }
      );
      break;
    case &amp;#39;go&amp;#39;:
      files.push(
        { path: &amp;#39;go.mod&amp;#39;, type: &amp;#39;file&amp;#39;, size: 100 },
        { path: &amp;#39;main.go&amp;#39;, type: &amp;#39;file&amp;#39;, size: 250 },
        { path: &amp;#39;test/&amp;#39;, type: &amp;#39;directory&amp;#39; }
      );
      break;
    case &amp;#39;shell&amp;#39;:
    case &amp;#39;bash&amp;#39;:
      files.push(
        { path: &amp;#39;Makefile&amp;#39;, type: &amp;#39;file&amp;#39;, size: 300 },
        { path: &amp;#39;src/&amp;#39;, type: &amp;#39;directory&amp;#39; },
        { path: &#x60;src/${config.name}&#x60;, type: &amp;#39;file&amp;#39;, size: 400 },
        { path: &amp;#39;tests/&amp;#39;, type: &amp;#39;directory&amp;#39; }
      );
      break;
  }

  return files;
}

/**
 * Plan project structure files
 */
function planProjectStructure(
  _config: any
): Array&amp;lt;{ path: string; type: &amp;#39;file&amp;#39; | &amp;#39;directory&amp;#39;; size?: number }&amp;gt; {
  return [
    { path: &amp;#39;README.md&amp;#39;, type: &amp;#39;file&amp;#39;, size: 800 },
    { path: &amp;#39;.gitignore&amp;#39;, type: &amp;#39;file&amp;#39;, size: 200 },
  ];
}

/**
 * Plan CI/CD files
 */
function planCIFiles(
  _config: any
): Array&amp;lt;{ path: string; type: &amp;#39;file&amp;#39; | &amp;#39;directory&amp;#39;; size?: number }&amp;gt; {
  return [
    { path: &amp;#39;.github/&amp;#39;, type: &amp;#39;directory&amp;#39; },
    { path: &amp;#39;.github/workflows/&amp;#39;, type: &amp;#39;directory&amp;#39; },
    { path: &amp;#39;.github/workflows/ci.yml&amp;#39;, type: &amp;#39;file&amp;#39;, size: 600 },
  ];
}

/**
 * Generate deterministic file content for checksums
 */
function generateFileContent(filePath: string, config: any): string {
  // Return predictable content based on file path and config
  // This ensures identical runs produce identical output

  if (filePath &#x3D;&#x3D;&#x3D; &amp;#39;README.md&amp;#39;) {
    return &#x60;# ${config.name}\n\nGenerated by Arbiter - Version ${config.version}\n&#x60;;
  }

  if (filePath &#x3D;&#x3D;&#x3D; &amp;#39;package.json&amp;#39;) {
    return JSON.stringify(
      {
        name: config.name,
        version: config.version,
        type: &amp;#39;module&amp;#39;,
      },
      null,
      2
    );
  }

  if (filePath.endsWith(&amp;#39;.ts&amp;#39;)) {
    return &#x60;// ${config.name} - Generated by Arbiter\nexport function main() {\n  console.log(&amp;#39;Hello!&amp;#39;);\n}\n&#x60;;
  }

  if (filePath.endsWith(&amp;#39;.py&amp;#39;)) {
    return &#x60;# ${config.name} - Generated by Arbiter\ndef main():\n    print(&amp;#39;Hello!&amp;#39;)\n&#x60;;
  }

  if (filePath.endsWith(&amp;#39;.rs&amp;#39;)) {
    return &#x60;// ${config.name} - Generated by Arbiter\npub fn main() {\n    println!(&amp;quot;Hello!&amp;quot;);\n}\n&#x60;;
  }

  if (filePath.endsWith(&amp;#39;.go&amp;#39;)) {
    return &#x60;// ${config.name} - Generated by Arbiter\npackage main\n\nimport &amp;quot;fmt&amp;quot;\n\nfunc main() {\n    fmt.Println(&amp;quot;Hello!&amp;quot;)\n}\n&#x60;;
  }

  if (filePath.endsWith(&amp;#39;.yml&amp;#39;) || filePath.endsWith(&amp;#39;.yaml&amp;#39;)) {
    return &#x60;# ${config.name} CI - Generated by Arbiter\nname: CI\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n&#x60;;
  }

  // Default content
  return &#x60;# Generated by Arbiter for ${config.name}\n&#x60;;
}

/**
 * Generate a simple checksum for content
 */
function generateChecksum(content: string): string {
  // Simple hash for deterministic checksums
  let hash &#x3D; 0;
  for (let i &#x3D; 0; i &amp;lt; content.length; i++) {
    const char &#x3D; content.charCodeAt(i);
    hash &#x3D; (hash &amp;lt;&amp;lt; 5) - hash + char;
    hash &#x3D; hash &amp;amp; hash; // Convert to 32bit integer
  }
  return Math.abs(hash).toString(16);
}

/**
 * Convert plan to YAML format
 */
function convertToYAML(plan: PreviewPlan): string {
  // Simple YAML conversion
  return &#x60;timestamp: &amp;quot;${plan.timestamp}&amp;quot;
assembly:
  language: &amp;quot;${plan.assembly.language}&amp;quot;
  kind: &amp;quot;${plan.assembly.kind}&amp;quot;
  name: &amp;quot;${plan.assembly.name}&amp;quot;
  version: &amp;quot;${plan.assembly.version}&amp;quot;
plannedFiles:
${plan.plannedFiles.map(f &#x3D;&amp;gt; &#x60;  - path: &amp;quot;${f.path}&amp;quot;\n    type: &amp;quot;${f.type}&amp;quot;&#x60;).join(&amp;#39;\n&amp;#39;)}
operations:
${plan.operations.map(op &#x3D;&amp;gt; &#x60;  - type: &amp;quot;${op.type}&amp;quot;\n    target: &amp;quot;${op.target}&amp;quot;\n    reason: &amp;quot;${op.reason}&amp;quot;&#x60;).join(&amp;#39;\n&amp;#39;)}
metadata:
  totalFiles: ${plan.metadata.totalFiles}
  totalDirectories: ${plan.metadata.totalDirectories}
  estimatedSize: ${plan.metadata.estimatedSize}
&#x60;;
}

/**
 * Format plan as human-readable text
 */
function formatAsText(plan: PreviewPlan, verbose &#x3D; false): string {
  let output &#x3D; &amp;#39;&amp;#39;;

  if (verbose) {
    output +&#x3D; chalk.blue(&amp;#39;ğŸ“‹ Preview Plan\n&amp;#39;);
    output +&#x3D; chalk.dim(&#x60;Generated: ${plan.timestamp}\n\n&#x60;);
  }

  output +&#x3D; chalk.cyan(&amp;#39;Assembly Configuration:\n&amp;#39;);
  output +&#x3D; &#x60;  Language: ${plan.assembly.language}\n&#x60;;
  output +&#x3D; &#x60;  Kind: ${plan.assembly.kind}\n&#x60;;
  output +&#x3D; &#x60;  Name: ${plan.assembly.name}\n&#x60;;
  output +&#x3D; &#x60;  Version: ${plan.assembly.version}\n&#x60;;
  if (plan.assembly.buildTool) {
    output +&#x3D; &#x60;  Build Tool: ${plan.assembly.buildTool}\n&#x60;;
  }
  output +&#x3D; &amp;#39;\n&amp;#39;;

  output +&#x3D; chalk.cyan(&amp;#39;Planned Files:\n&amp;#39;);
  const files &#x3D; plan.plannedFiles.filter(f &#x3D;&amp;gt; f.type &#x3D;&#x3D;&#x3D; &amp;#39;file&amp;#39;);
  const dirs &#x3D; plan.plannedFiles.filter(f &#x3D;&amp;gt; f.type &#x3D;&#x3D;&#x3D; &amp;#39;directory&amp;#39;);

  dirs.forEach(dir &#x3D;&amp;gt; {
    output +&#x3D; chalk.yellow(&#x60;  ğŸ“ ${dir.path}\n&#x60;);
  });

  files.forEach(file &#x3D;&amp;gt; {
    output +&#x3D; chalk.green(&#x60;  ğŸ“„ ${file.path}&#x60;);
    if (file.size) {
      output +&#x3D; chalk.dim(&#x60; (${file.size} bytes)&#x60;);
    }
    if (file.checksum &amp;amp;&amp;amp; verbose) {
      output +&#x3D; chalk.dim(&#x60; [${file.checksum}]&#x60;);
    }
    output +&#x3D; &amp;#39;\n&amp;#39;;
  });

  output +&#x3D; &amp;#39;\n&amp;#39;;
  output +&#x3D; chalk.cyan(&amp;#39;Summary:\n&amp;#39;);
  output +&#x3D; &#x60;  Files: ${plan.metadata.totalFiles}\n&#x60;;
  output +&#x3D; &#x60;  Directories: ${plan.metadata.totalDirectories}\n&#x60;;
  output +&#x3D; &#x60;  Estimated Size: ${plan.metadata.estimatedSize} bytes\n&#x60;;

  if (verbose) {
    output +&#x3D; &amp;#39;\n&amp;#39;;
    output +&#x3D; chalk.cyan(&amp;#39;Operations:\n&amp;#39;);
    plan.operations.forEach(op &#x3D;&amp;gt; {
      output +&#x3D; &#x60;  ${op.type.toUpperCase()} ${op.target} - ${op.reason}\n&#x60;;
    });
  }

  return output;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-161">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/design-system/components/Input.tsx</div>
                <div class="file-content">
                    <pre>/**
 * Input Component - Design System
 * Professional input with comprehensive variants, states, and accessibility
 * Designed for developer tools with sophisticated graphite theme
 */

import React, { forwardRef, type InputHTMLAttributes, type ReactNode } from &amp;#39;react&amp;#39;;
import { clsx } from &amp;#39;clsx&amp;#39;;
import { AlertCircle, CheckCircle, AlertTriangle, Loader2 } from &amp;#39;lucide-react&amp;#39;;
import { inputVariants, sizeVariants, cn } from &amp;#39;../variants&amp;#39;;

export interface InputProps extends Omit&amp;lt;InputHTMLAttributes&amp;lt;HTMLInputElement&amp;gt;, &amp;#39;size&amp;#39;&amp;gt; {
  /** Input variant determines the visual style */
  variant?: &amp;#39;default&amp;#39; | &amp;#39;error&amp;#39; | &amp;#39;success&amp;#39; | &amp;#39;warning&amp;#39;;

  /** Input size affects padding and font size */
  size?: &amp;#39;sm&amp;#39; | &amp;#39;md&amp;#39; | &amp;#39;lg&amp;#39;;

  /** Whether the input should take full width of container */
  fullWidth?: boolean;

  /** Icon to display before the input */
  leftIcon?: ReactNode;

  /** Icon to display after the input */
  rightIcon?: ReactNode;

  /** Label for the input */
  label?: string;

  /** Helper text below the input */
  helperText?: string;

  /** Error message (sets variant to error automatically) */
  error?: string;

  /** Warning message (sets variant to warning automatically) */
  warning?: string;

  /** Success message (sets variant to success automatically) */
  success?: string;

  /** Whether the input is in a loading state */
  loading?: boolean;

  /** Whether to show validation icons automatically */
  showValidationIcon?: boolean;

  /** Whether to show the label */
  hideLabel?: boolean;

  /** Whether the label should be inside the input (floating) */
  floatingLabel?: boolean;

  /** Additional description text */
  description?: string;

  /** Custom className for additional styling */
  className?: string;

  /** Custom className for the wrapper */
  wrapperClassName?: string;

  /** Custom className for the input wrapper */
  inputWrapperClassName?: string;
}

export const Input &#x3D; forwardRef&amp;lt;HTMLInputElement, InputProps&amp;gt;(
  (
    {
      variant &#x3D; &amp;#39;default&amp;#39;,
      size &#x3D; &amp;#39;md&amp;#39;,
      fullWidth &#x3D; true,
      leftIcon,
      rightIcon,
      label,
      helperText,
      error,
      warning,
      success,
      loading &#x3D; false,
      showValidationIcon &#x3D; true,
      hideLabel &#x3D; false,
      floatingLabel &#x3D; false,
      description,
      className,
      wrapperClassName,
      inputWrapperClassName,
      disabled,
      id,
      ...props
    },
    ref
  ) &#x3D;&amp;gt; {
    // Determine actual variant based on state props
    const actualVariant &#x3D; error ? &amp;#39;error&amp;#39; : warning ? &amp;#39;warning&amp;#39; : success ? &amp;#39;success&amp;#39; : variant;
    const actualHelperText &#x3D; error || warning || success || helperText;
    const inputId &#x3D; id || &#x60;input-${Math.random().toString(36).substr(2, 9)}&#x60;;

    // Validation icon logic
    const getValidationIcon &#x3D; () &#x3D;&amp;gt; {
      if (!showValidationIcon || loading) return null;

      if (error) return &amp;lt;AlertCircle className&#x3D;{cn(sizeVariants.icon[size], &amp;#39;text-red-500&amp;#39;)} /&amp;gt;;
      if (warning)
        return &amp;lt;AlertTriangle className&#x3D;{cn(sizeVariants.icon[size], &amp;#39;text-amber-500&amp;#39;)} /&amp;gt;;
      if (success) return &amp;lt;CheckCircle className&#x3D;{cn(sizeVariants.icon[size], &amp;#39;text-green-500&amp;#39;)} /&amp;gt;;

      return null;
    };

    const validationIcon &#x3D; getValidationIcon();
    const hasRightElement &#x3D; rightIcon || validationIcon || loading;

    const inputClasses &#x3D; cn(
      // Base styles
      &amp;#39;block w-full font-sans&amp;#39;,
      &amp;#39;transition-all duration-150 ease-in-out&amp;#39;,
      &amp;#39;placeholder:text-graphite-400&amp;#39;,
      &amp;#39;focus:outline-none focus:ring-2 focus:ring-offset-0&amp;#39;,

      // Variant styles
      inputVariants[actualVariant],

      // Size styles
      sizeVariants.input[size],

      // Icon padding adjustments
      leftIcon &amp;amp;&amp;amp; (size &#x3D;&#x3D;&#x3D; &amp;#39;lg&amp;#39; ? &amp;#39;pl-12&amp;#39; : size &#x3D;&#x3D;&#x3D; &amp;#39;sm&amp;#39; ? &amp;#39;pl-8&amp;#39; : &amp;#39;pl-10&amp;#39;),
      hasRightElement &amp;amp;&amp;amp; (size &#x3D;&#x3D;&#x3D; &amp;#39;lg&amp;#39; ? &amp;#39;pr-12&amp;#39; : size &#x3D;&#x3D;&#x3D; &amp;#39;sm&amp;#39; ? &amp;#39;pr-8&amp;#39; : &amp;#39;pr-10&amp;#39;),

      // Loading state
      loading &amp;amp;&amp;amp; &amp;#39;cursor-wait&amp;#39;,

      // Floating label adjustments
      floatingLabel &amp;amp;&amp;amp; &amp;#39;pt-6 pb-2&amp;#39;,

      // Custom className
      className
    );

    const wrapperClasses &#x3D; cn(
      &amp;#39;space-y-1&amp;#39;,
      !fullWidth &amp;amp;&amp;amp; &amp;#39;inline-block&amp;#39;,
      disabled &amp;amp;&amp;amp; &amp;#39;opacity-60 cursor-not-allowed&amp;#39;,
      wrapperClassName
    );

    const inputWrapperClasses &#x3D; cn(&amp;#39;relative&amp;#39;, inputWrapperClassName);

    return (
      &amp;lt;div className&#x3D;{wrapperClasses}&amp;gt;
        {/* Label */}
        {label &amp;amp;&amp;amp; !hideLabel &amp;amp;&amp;amp; !floatingLabel &amp;amp;&amp;amp; (
          &amp;lt;label htmlFor&#x3D;{inputId} className&#x3D;&amp;quot;block text-sm font-medium text-graphite-700&amp;quot;&amp;gt;
            {label}
            {props.required &amp;amp;&amp;amp; &amp;lt;span className&#x3D;&amp;quot;text-red-500 ml-1&amp;quot;&amp;gt;*&amp;lt;/span&amp;gt;}
          &amp;lt;/label&amp;gt;
        )}

        {/* Description */}
        {description &amp;amp;&amp;amp; !floatingLabel &amp;amp;&amp;amp; (
          &amp;lt;p className&#x3D;&amp;quot;text-sm text-graphite-600&amp;quot;&amp;gt;{description}&amp;lt;/p&amp;gt;
        )}

        {/* Input wrapper */}
        &amp;lt;div className&#x3D;{inputWrapperClasses}&amp;gt;
          {/* Floating label */}
          {label &amp;amp;&amp;amp; !hideLabel &amp;amp;&amp;amp; floatingLabel &amp;amp;&amp;amp; (
            &amp;lt;label
              htmlFor&#x3D;{inputId}
              className&#x3D;{cn(
                &amp;#39;absolute left-3 transition-all duration-150 pointer-events-none&amp;#39;,
                &amp;#39;text-sm font-medium&amp;#39;,
                props.value || props.defaultValue
                  ? &amp;#39;top-2 text-xs text-graphite-600&amp;#39;
                  : &amp;#39;top-1/2 -translate-y-1/2 text-graphite-500&amp;#39;,
                actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;error&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-red-600&amp;#39;,
                actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;warning&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-amber-600&amp;#39;,
                actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;success&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-green-600&amp;#39;
              )}
            &amp;gt;
              {label}
              {props.required &amp;amp;&amp;amp; &amp;lt;span className&#x3D;&amp;quot;text-red-500 ml-1&amp;quot;&amp;gt;*&amp;lt;/span&amp;gt;}
            &amp;lt;/label&amp;gt;
          )}

          {/* Left icon */}
          {leftIcon &amp;amp;&amp;amp; (
            &amp;lt;div
              className&#x3D;{cn(
                &amp;#39;absolute top-1/2 -translate-y-1/2 text-graphite-400&amp;#39;,
                size &#x3D;&#x3D;&#x3D; &amp;#39;lg&amp;#39; ? &amp;#39;left-4&amp;#39; : size &#x3D;&#x3D;&#x3D; &amp;#39;sm&amp;#39; ? &amp;#39;left-2&amp;#39; : &amp;#39;left-3&amp;#39;
              )}
            &amp;gt;
              &amp;lt;div className&#x3D;{sizeVariants.icon[size]}&amp;gt;{leftIcon}&amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
          )}

          {/* Input field */}
          &amp;lt;input
            ref&#x3D;{ref}
            id&#x3D;{inputId}
            disabled&#x3D;{disabled || loading}
            className&#x3D;{inputClasses}
            aria-describedby&#x3D;{cn(
              actualHelperText &amp;amp;&amp;amp; &#x60;${inputId}-description&#x60;,
              description &amp;amp;&amp;amp; &#x60;${inputId}-desc&#x60;
            )}
            aria-invalid&#x3D;{!!error}
            {...props}
          /&amp;gt;

          {/* Right side elements */}
          &amp;lt;div
            className&#x3D;{cn(
              &amp;#39;absolute top-1/2 -translate-y-1/2 flex items-center gap-1&amp;#39;,
              size &#x3D;&#x3D;&#x3D; &amp;#39;lg&amp;#39; ? &amp;#39;right-4&amp;#39; : size &#x3D;&#x3D;&#x3D; &amp;#39;sm&amp;#39; ? &amp;#39;right-2&amp;#39; : &amp;#39;right-3&amp;#39;
            )}
          &amp;gt;
            {/* Loading spinner */}
            {loading &amp;amp;&amp;amp; (
              &amp;lt;Loader2 className&#x3D;{cn(sizeVariants.icon[size], &amp;#39;animate-spin text-graphite-400&amp;#39;)} /&amp;gt;
            )}

            {/* Validation icon */}
            {validationIcon}

            {/* Right icon */}
            {rightIcon &amp;amp;&amp;amp; (
              &amp;lt;div className&#x3D;&amp;quot;text-graphite-400&amp;quot;&amp;gt;
                &amp;lt;div className&#x3D;{sizeVariants.icon[size]}&amp;gt;{rightIcon}&amp;lt;/div&amp;gt;
              &amp;lt;/div&amp;gt;
            )}
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        {/* Description for floating label variant */}
        {description &amp;amp;&amp;amp; floatingLabel &amp;amp;&amp;amp; (
          &amp;lt;p id&#x3D;{&#x60;${inputId}-desc&#x60;} className&#x3D;&amp;quot;text-sm text-graphite-600&amp;quot;&amp;gt;
            {description}
          &amp;lt;/p&amp;gt;
        )}

        {/* Helper text / Validation messages */}
        {actualHelperText &amp;amp;&amp;amp; (
          &amp;lt;p
            id&#x3D;{&#x60;${inputId}-description&#x60;}
            className&#x3D;{cn(
              &amp;#39;text-sm flex items-start gap-1&amp;#39;,
              actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;error&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-red-600&amp;#39;,
              actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;warning&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-amber-600&amp;#39;,
              actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;success&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-green-600&amp;#39;,
              actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;default&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-graphite-600&amp;#39;
            )}
          &amp;gt;
            {actualHelperText}
          &amp;lt;/p&amp;gt;
        )}
      &amp;lt;/div&amp;gt;
    );
  }
);

Input.displayName &#x3D; &amp;#39;Input&amp;#39;;

export default Input;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-162">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/components/diagrams/PlotsDiagram.tsx</div>
                <div class="file-content">
                    <pre>import React, { useState, useEffect } from &amp;#39;react&amp;#39;;
import { CuePlotViewer } from &amp;#39;../charts/CuePlotViewer&amp;#39;;
import { apiService } from &amp;#39;../../services/api&amp;#39;;
import { Loader2, AlertCircle, BarChart3 } from &amp;#39;lucide-react&amp;#39;;

interface PlotsDiagramProps {
  projectId: string;
}

const PlotsDiagram: React.FC&amp;lt;PlotsDiagramProps&amp;gt; &#x3D; ({ projectId }) &#x3D;&amp;gt; {
  const [plotData, setPlotData] &#x3D; useState&amp;lt;Record&amp;lt;string, any&amp;gt;&amp;gt;({});
  const [loading, setLoading] &#x3D; useState(true);
  const [error, setError] &#x3D; useState&amp;lt;string | null&amp;gt;(null);

  useEffect(() &#x3D;&amp;gt; {
    let mounted &#x3D; true;

    const loadPlotData &#x3D; async () &#x3D;&amp;gt; {
      try {
        setLoading(true);
        setError(null);

        // For now, use sample data while we fix the API integration
        const samplePlots &#x3D; {
          plots: {
            lineChart: {
              title: &amp;#39;Server Response Time&amp;#39;,
              type: &amp;#39;line&amp;#39;,
              data: {
                labels: [&amp;#39;00:00&amp;#39;, &amp;#39;01:00&amp;#39;, &amp;#39;02:00&amp;#39;, &amp;#39;03:00&amp;#39;, &amp;#39;04:00&amp;#39;, &amp;#39;05:00&amp;#39;, &amp;#39;06:00&amp;#39;],
                datasets: [
                  {
                    label: &amp;#39;Response Time (ms)&amp;#39;,
                    data: [120, 150, 180, 160, 140, 130, 125],
                    backgroundColor: &amp;#39;#dbeafe&amp;#39;,
                    borderColor: &amp;#39;#3b82f6&amp;#39;,
                    fill: false,
                  },
                ],
              },
              options: {
                responsive: true,
                scales: {
                  y: {
                    beginAtZero: true,
                    title: {
                      display: true,
                      text: &amp;#39;Response Time (ms)&amp;#39;,
                    },
                  },
                  x: {
                    title: {
                      display: true,
                      text: &amp;#39;Time&amp;#39;,
                    },
                  },
                },
              },
            },
            barChart: {
              title: &amp;#39;Service Usage by Hour&amp;#39;,
              type: &amp;#39;bar&amp;#39;,
              data: {
                labels: [&amp;#39;API&amp;#39;, &amp;#39;Database&amp;#39;, &amp;#39;Cache&amp;#39;, &amp;#39;Queue&amp;#39;, &amp;#39;Storage&amp;#39;],
                datasets: [
                  {
                    label: &amp;#39;Requests per Second&amp;#39;,
                    data: [65, 59, 80, 81, 56],
                    backgroundColor: [&amp;#39;#ef4444&amp;#39;, &amp;#39;#f59e0b&amp;#39;, &amp;#39;#10b981&amp;#39;, &amp;#39;#3b82f6&amp;#39;, &amp;#39;#8b5cf6&amp;#39;],
                    borderColor: [&amp;#39;#dc2626&amp;#39;, &amp;#39;#d97706&amp;#39;, &amp;#39;#059669&amp;#39;, &amp;#39;#2563eb&amp;#39;, &amp;#39;#7c3aed&amp;#39;],
                    borderWidth: 1,
                  },
                ],
              },
              options: {
                responsive: true,
                scales: {
                  y: {
                    beginAtZero: true,
                    title: {
                      display: true,
                      text: &amp;#39;Requests/sec&amp;#39;,
                    },
                  },
                },
              },
            },
            timeSeriesChart: {
              title: &amp;#39;System Metrics Over Time&amp;#39;,
              type: &amp;#39;line&amp;#39;,
              data: {
                labels: [
                  &amp;#39;2024-01-01T00:00:00Z&amp;#39;,
                  &amp;#39;2024-01-01T01:00:00Z&amp;#39;,
                  &amp;#39;2024-01-01T02:00:00Z&amp;#39;,
                  &amp;#39;2024-01-01T03:00:00Z&amp;#39;,
                  &amp;#39;2024-01-01T04:00:00Z&amp;#39;,
                  &amp;#39;2024-01-01T05:00:00Z&amp;#39;,
                ],
                datasets: [
                  {
                    label: &amp;#39;CPU Usage (%)&amp;#39;,
                    data: [45, 52, 48, 61, 55, 47],
                    borderColor: &amp;#39;#3b82f6&amp;#39;,
                    backgroundColor: &amp;#39;#dbeafe&amp;#39;,
                    fill: false,
                  },
                  {
                    label: &amp;#39;Memory Usage (%)&amp;#39;,
                    data: [62, 68, 71, 75, 73, 69],
                    borderColor: &amp;#39;#10b981&amp;#39;,
                    backgroundColor: &amp;#39;#d1fae5&amp;#39;,
                    fill: false,
                  },
                ],
              },
              options: {
                responsive: true,
                interaction: {
                  mode: &amp;#39;index&amp;#39;,
                  intersect: false,
                },
                scales: {
                  x: {
                    display: true,
                    title: {
                      display: true,
                      text: &amp;#39;Time&amp;#39;,
                    },
                  },
                  y: {
                    display: true,
                    title: {
                      display: true,
                      text: &amp;#39;Usage (%)&amp;#39;,
                    },
                    min: 0,
                    max: 100,
                  },
                },
                plugins: {
                  legend: {
                    position: &amp;#39;top&amp;#39;,
                  },
                  title: {
                    display: true,
                    text: &amp;#39;System Resource Usage&amp;#39;,
                  },
                },
              },
            },
          },
        };

        setPlotData(samplePlots);

        // TODO: Uncomment when API integration is working
        // const resolved &#x3D; await apiService.getResolvedSpec(projectId);
        // if (resolved &amp;amp;&amp;amp; resolved.resolved &amp;amp;&amp;amp; resolved.resolved.plots) {
        //   setPlotData(resolved.resolved);
        // }
      } catch (err) {
        if (!mounted) return;
        console.error(&amp;#39;Failed to load plot data:&amp;#39;, err);
        setError(err instanceof Error ? err.message : &amp;#39;Failed to load plot data&amp;#39;);
      } finally {
        if (mounted) {
          setLoading(false);
        }
      }
    };

    loadPlotData();

    return () &#x3D;&amp;gt; {
      mounted &#x3D; false;
    };
  }, [projectId]);

  if (loading) {
    return (
      &amp;lt;div className&#x3D;&amp;quot;diagram-container&amp;quot;&amp;gt;
        &amp;lt;div className&#x3D;&amp;quot;diagram-loading&amp;quot;&amp;gt;
          &amp;lt;div className&#x3D;&amp;quot;text-center&amp;quot;&amp;gt;
            &amp;lt;Loader2 className&#x3D;&amp;quot;h-8 w-8 mb-4 mx-auto animate-spin text-blue-500&amp;quot; /&amp;gt;
            &amp;lt;p className&#x3D;&amp;quot;text-gray-600&amp;quot;&amp;gt;Loading plot data...&amp;lt;/p&amp;gt;
            &amp;lt;p className&#x3D;&amp;quot;text-sm text-gray-400 mt-2&amp;quot;&amp;gt;
              Parsing CUE specifications for visualization data
            &amp;lt;/p&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }

  if (error) {
    return (
      &amp;lt;div className&#x3D;&amp;quot;diagram-container&amp;quot;&amp;gt;
        &amp;lt;div className&#x3D;&amp;quot;diagram-error&amp;quot;&amp;gt;
          &amp;lt;div className&#x3D;&amp;quot;bg-red-50 border border-red-200 rounded-lg p-6 text-center&amp;quot;&amp;gt;
            &amp;lt;AlertCircle className&#x3D;&amp;quot;h-12 w-12 text-red-400 mx-auto mb-4&amp;quot; /&amp;gt;
            &amp;lt;h3 className&#x3D;&amp;quot;text-lg font-semibold text-red-800 mb-2&amp;quot;&amp;gt;Failed to Load Plot Data&amp;lt;/h3&amp;gt;
            &amp;lt;p className&#x3D;&amp;quot;text-red-600 mb-4&amp;quot;&amp;gt;{error}&amp;lt;/p&amp;gt;
            &amp;lt;button
              onClick&#x3D;{() &#x3D;&amp;gt; window.location.reload()}
              className&#x3D;&amp;quot;px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors&amp;quot;
            &amp;gt;
              Retry
            &amp;lt;/button&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }

  if (!plotData || Object.keys(plotData).length &#x3D;&#x3D;&#x3D; 0) {
    return (
      &amp;lt;div className&#x3D;&amp;quot;diagram-container&amp;quot;&amp;gt;
        &amp;lt;div className&#x3D;&amp;quot;bg-gray-50 border border-gray-200 rounded-lg p-8 text-center&amp;quot;&amp;gt;
          &amp;lt;BarChart3 className&#x3D;&amp;quot;h-12 w-12 text-gray-400 mx-auto mb-4&amp;quot; /&amp;gt;
          &amp;lt;h3 className&#x3D;&amp;quot;text-lg font-semibold text-gray-700 mb-2&amp;quot;&amp;gt;No Plot Data Available&amp;lt;/h3&amp;gt;
          &amp;lt;p className&#x3D;&amp;quot;text-gray-600 mb-4&amp;quot;&amp;gt;
            No visualization data found in the CUE specification.
          &amp;lt;/p&amp;gt;
          &amp;lt;div className&#x3D;&amp;quot;text-left bg-white border border-gray-200 rounded-lg p-4 max-w-md mx-auto&amp;quot;&amp;gt;
            &amp;lt;h4 className&#x3D;&amp;quot;font-medium text-gray-900 mb-2&amp;quot;&amp;gt;
              To add plots, define them in your CUE files then export as JSON:
            &amp;lt;/h4&amp;gt;
            &amp;lt;pre className&#x3D;&amp;quot;text-xs font-mono text-gray-600 whitespace-pre-wrap&amp;quot;&amp;gt;
              {&#x60;// In your CUE file:
myChart: {
  title: &amp;quot;Sample Chart&amp;quot;
  type: &amp;quot;line&amp;quot;
  data: {
    labels: [&amp;quot;Jan&amp;quot;, &amp;quot;Feb&amp;quot;, &amp;quot;Mar&amp;quot;]
    datasets: [{
      label: &amp;quot;Sales&amp;quot;
      data: [100, 150, 200]
      backgroundColor: &amp;quot;#3b82f6&amp;quot;
    }]
  }
}

// Export with: cue export -o plots.json&#x60;}
            &amp;lt;/pre&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }

  return (
    &amp;lt;div className&#x3D;&amp;quot;diagram-container h-full overflow-auto&amp;quot;&amp;gt;
      &amp;lt;div className&#x3D;&amp;quot;p-6&amp;quot;&amp;gt;
        &amp;lt;CuePlotViewer plotData&#x3D;{plotData} projectId&#x3D;{projectId} mode&#x3D;&amp;quot;plots&amp;quot; className&#x3D;&amp;quot;h-full&amp;quot; /&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default PlotsDiagram;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-163">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/design-system/components/Card.tsx</div>
                <div class="file-content">
                    <pre>/**
 * Card Component - Design System
 * Professional card container with comprehensive variants and states
 * Designed for developer tools with sophisticated graphite theme
 */

import React, { forwardRef, type HTMLAttributes, type ReactNode } from &amp;#39;react&amp;#39;;
import { clsx } from &amp;#39;clsx&amp;#39;;
import { cn } from &amp;#39;../variants&amp;#39;;

export interface CardProps extends HTMLAttributes&amp;lt;HTMLDivElement&amp;gt; {
  /** Card variant determines the visual style and interaction behavior */
  variant?: &amp;#39;default&amp;#39; | &amp;#39;interactive&amp;#39; | &amp;#39;elevated&amp;#39; | &amp;#39;outlined&amp;#39; | &amp;#39;ghost&amp;#39;;

  /** Card size affects padding and border radius */
  size?: &amp;#39;sm&amp;#39; | &amp;#39;md&amp;#39; | &amp;#39;lg&amp;#39; | &amp;#39;xl&amp;#39;;

  /** Card header content */
  header?: ReactNode;

  /** Card title */
  title?: string;

  /** Card subtitle or description */
  subtitle?: string;

  /** Card footer content */
  footer?: ReactNode;

  /** Whether to show a divider between header and content */
  headerDivider?: boolean;

  /** Whether to show a divider between content and footer */
  footerDivider?: boolean;

  /** Whether the card has a loading state */
  loading?: boolean;

  /** Whether the card is disabled */
  disabled?: boolean;

  /** Whether the card is selected */
  selected?: boolean;

  /** Whether the card has hover effects */
  hoverable?: boolean;

  /** Custom className for additional styling */
  className?: string;

  /** Custom className for the header */
  headerClassName?: string;

  /** Custom className for the body */
  bodyClassName?: string;

  /** Custom className for the footer */
  footerClassName?: string;

  /** Card content */
  children?: ReactNode;
}

export const Card &#x3D; forwardRef&amp;lt;HTMLDivElement, CardProps&amp;gt;(
  (
    {
      variant &#x3D; &amp;#39;default&amp;#39;,
      size &#x3D; &amp;#39;md&amp;#39;,
      header,
      title,
      subtitle,
      footer,
      headerDivider &#x3D; false,
      footerDivider &#x3D; false,
      loading &#x3D; false,
      disabled &#x3D; false,
      selected &#x3D; false,
      hoverable &#x3D; false,
      className,
      headerClassName,
      bodyClassName,
      footerClassName,
      children,
      onClick,
      ...props
    },
    ref
  ) &#x3D;&amp;gt; {
    // Card size classes
    const sizeClasses &#x3D; {
      sm: {
        card: &amp;#39;rounded-lg&amp;#39;,
        padding: &amp;#39;p-3&amp;#39;,
        headerPadding: &amp;#39;px-3 pt-3&amp;#39;,
        bodyPadding: &amp;#39;px-3&amp;#39;,
        footerPadding: &amp;#39;px-3 pb-3&amp;#39;,
        gap: &amp;#39;space-y-2&amp;#39;,
      },
      md: {
        card: &amp;#39;rounded-lg&amp;#39;,
        padding: &amp;#39;p-4&amp;#39;,
        headerPadding: &amp;#39;px-4 pt-4&amp;#39;,
        bodyPadding: &amp;#39;px-4&amp;#39;,
        footerPadding: &amp;#39;px-4 pb-4&amp;#39;,
        gap: &amp;#39;space-y-3&amp;#39;,
      },
      lg: {
        card: &amp;#39;rounded-xl&amp;#39;,
        padding: &amp;#39;p-6&amp;#39;,
        headerPadding: &amp;#39;px-6 pt-6&amp;#39;,
        bodyPadding: &amp;#39;px-6&amp;#39;,
        footerPadding: &amp;#39;px-6 pb-6&amp;#39;,
        gap: &amp;#39;space-y-4&amp;#39;,
      },
      xl: {
        card: &amp;#39;rounded-xl&amp;#39;,
        padding: &amp;#39;p-8&amp;#39;,
        headerPadding: &amp;#39;px-8 pt-8&amp;#39;,
        bodyPadding: &amp;#39;px-8&amp;#39;,
        footerPadding: &amp;#39;px-8 pb-8&amp;#39;,
        gap: &amp;#39;space-y-6&amp;#39;,
      },
    };

    const sizeClass &#x3D; sizeClasses[size];

    // Card variant classes
    const variantClasses &#x3D; {
      default: cn(
        &amp;#39;bg-white border border-graphite-200 shadow-sm&amp;#39;,
        hoverable &amp;amp;&amp;amp; &amp;#39;hover:border-graphite-300 hover:shadow-md&amp;#39;,
        selected &amp;amp;&amp;amp; &amp;#39;border-blue-500 ring-1 ring-blue-500 ring-opacity-20&amp;#39;
      ),
      interactive: cn(
        &amp;#39;bg-white border border-graphite-200 shadow-sm&amp;#39;,
        &amp;#39;hover:border-graphite-300 hover:shadow-md hover:shadow-graphite-900/5&amp;#39;,
        &amp;#39;active:scale-[0.998] active:shadow-sm&amp;#39;,
        &amp;#39;transition-all duration-150 ease-out cursor-pointer&amp;#39;,
        selected &amp;amp;&amp;amp; &amp;#39;border-blue-500 ring-1 ring-blue-500 ring-opacity-20&amp;#39;,
        disabled &amp;amp;&amp;amp;
          &amp;#39;cursor-not-allowed opacity-60 hover:border-graphite-200 hover:shadow-sm active:scale-100&amp;#39;
      ),
      elevated: cn(
        &amp;#39;bg-white border-0 shadow-lg shadow-graphite-900/10&amp;#39;,
        hoverable &amp;amp;&amp;amp; &amp;#39;hover:shadow-xl hover:shadow-graphite-900/15&amp;#39;,
        selected &amp;amp;&amp;amp; &amp;#39;ring-1 ring-blue-500 ring-opacity-30&amp;#39;
      ),
      outlined: cn(
        &amp;#39;bg-transparent border-2 border-graphite-300&amp;#39;,
        hoverable &amp;amp;&amp;amp; &amp;#39;hover:border-graphite-400 hover:bg-graphite-50&amp;#39;,
        selected &amp;amp;&amp;amp; &amp;#39;border-blue-500 bg-blue-50&amp;#39;
      ),
      ghost: cn(
        &amp;#39;bg-transparent border-0 shadow-none&amp;#39;,
        hoverable &amp;amp;&amp;amp; &amp;#39;hover:bg-graphite-50&amp;#39;,
        selected &amp;amp;&amp;amp; &amp;#39;bg-blue-50&amp;#39;
      ),
    };

    const cardClasses &#x3D; cn(
      // Base styles
      &amp;#39;relative transition-all duration-150 ease-out overflow-hidden&amp;#39;,

      // Size
      sizeClass.card,

      // Variant styles
      variantClasses[variant],

      // Loading state
      loading &amp;amp;&amp;amp; &amp;#39;pointer-events-none&amp;#39;,

      // Disabled state
      disabled &amp;amp;&amp;amp; &amp;#39;opacity-60 cursor-not-allowed&amp;#39;,

      className
    );

    const hasHeader &#x3D; header || title || subtitle;
    const hasFooter &#x3D; footer;
    const isClickable &#x3D; onClick &amp;amp;&amp;amp; !disabled &amp;amp;&amp;amp; !loading;

    return (
      &amp;lt;div
        ref&#x3D;{ref}
        className&#x3D;{cardClasses}
        onClick&#x3D;{isClickable ? onClick : undefined}
        role&#x3D;{isClickable ? &amp;#39;button&amp;#39; : undefined}
        tabIndex&#x3D;{isClickable ? 0 : undefined}
        onKeyDown&#x3D;{
          isClickable
            ? e &#x3D;&amp;gt; {
                if (e.key &#x3D;&#x3D;&#x3D; &amp;#39;Enter&amp;#39; || e.key &#x3D;&#x3D;&#x3D; &amp;#39; &amp;#39;) {
                  e.preventDefault();
                  onClick?.(e as any);
                }
              }
            : undefined
        }
        aria-selected&#x3D;{selected}
        aria-disabled&#x3D;{disabled}
        {...props}
      &amp;gt;
        {/* Loading overlay */}
        {loading &amp;amp;&amp;amp; (
          &amp;lt;div className&#x3D;&amp;quot;absolute inset-0 bg-white bg-opacity-80 rounded-inherit flex items-center justify-center z-10&amp;quot;&amp;gt;
            &amp;lt;div className&#x3D;&amp;quot;flex items-center gap-2 text-graphite-600&amp;quot;&amp;gt;
              &amp;lt;div className&#x3D;&amp;quot;w-4 h-4 border-2 border-graphite-300 border-t-blue-600 rounded-full animate-spin&amp;quot; /&amp;gt;
              &amp;lt;span className&#x3D;&amp;quot;text-sm&amp;quot;&amp;gt;Loading...&amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/div&amp;gt;
        )}

        &amp;lt;div className&#x3D;{sizeClass.gap}&amp;gt;
          {/* Header */}
          {hasHeader &amp;amp;&amp;amp; (
            &amp;lt;div
              className&#x3D;{cn(
                hasFooter || children ? sizeClass.headerPadding : sizeClass.padding,
                headerDivider &amp;amp;&amp;amp; &amp;#39;border-b border-graphite-200&amp;#39;,
                headerClassName
              )}
            &amp;gt;
              {header || (
                &amp;lt;div className&#x3D;&amp;quot;space-y-1&amp;quot;&amp;gt;
                  {title &amp;amp;&amp;amp; (
                    &amp;lt;h3
                      className&#x3D;{cn(
                        &amp;#39;font-semibold text-graphite-900&amp;#39;,
                        size &#x3D;&#x3D;&#x3D; &amp;#39;sm&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-sm&amp;#39;,
                        size &#x3D;&#x3D;&#x3D; &amp;#39;md&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-base&amp;#39;,
                        size &#x3D;&#x3D;&#x3D; &amp;#39;lg&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-lg&amp;#39;,
                        size &#x3D;&#x3D;&#x3D; &amp;#39;xl&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-xl&amp;#39;
                      )}
                    &amp;gt;
                      {title}
                    &amp;lt;/h3&amp;gt;
                  )}
                  {subtitle &amp;amp;&amp;amp; (
                    &amp;lt;p
                      className&#x3D;{cn(
                        &amp;#39;text-graphite-600&amp;#39;,
                        size &#x3D;&#x3D;&#x3D; &amp;#39;sm&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-xs&amp;#39;,
                        size &#x3D;&#x3D;&#x3D; &amp;#39;md&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-sm&amp;#39;,
                        size &#x3D;&#x3D;&#x3D; &amp;#39;lg&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-sm&amp;#39;,
                        size &#x3D;&#x3D;&#x3D; &amp;#39;xl&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-base&amp;#39;
                      )}
                    &amp;gt;
                      {subtitle}
                    &amp;lt;/p&amp;gt;
                  )}
                &amp;lt;/div&amp;gt;
              )}
            &amp;lt;/div&amp;gt;
          )}

          {/* Body */}
          {children &amp;amp;&amp;amp; (
            &amp;lt;div
              className&#x3D;{cn(
                hasHeader &amp;amp;&amp;amp; hasFooter
                  ? sizeClass.bodyPadding
                  : hasHeader
                    ? sizeClass.footerPadding
                    : hasFooter
                      ? sizeClass.headerPadding
                      : sizeClass.padding,
                bodyClassName
              )}
            &amp;gt;
              {children}
            &amp;lt;/div&amp;gt;
          )}

          {/* Footer */}
          {hasFooter &amp;amp;&amp;amp; (
            &amp;lt;div
              className&#x3D;{cn(
                hasHeader || children ? sizeClass.footerPadding : sizeClass.padding,
                footerDivider &amp;amp;&amp;amp; &amp;#39;border-t border-graphite-200&amp;#39;,
                footerClassName
              )}
            &amp;gt;
              {footer}
            &amp;lt;/div&amp;gt;
          )}
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
);

Card.displayName &#x3D; &amp;#39;Card&amp;#39;;

export default Card;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-164">
                <div class="file-header">ğŸ“„ packages/cli/src/utils/__tests__/git-detection.test.ts</div>
                <div class="file-content">
                    <pre>import { beforeEach, describe, expect, it, mock } from &amp;#39;bun:test&amp;#39;;
import type { GitHubRepo } from &amp;#39;../../types.js&amp;#39;;
import {
  createRepositoryConfig,
  detectRepositoryConflicts,
  getSmartRepositoryConfig,
  parseGitHubUrl,
  validateRepositoryConfig,
} from &amp;#39;../git-detection.js&amp;#39;;

describe(&amp;#39;git-detection&amp;#39;, () &#x3D;&amp;gt; {
  describe(&amp;#39;parseGitHubUrl&amp;#39;, () &#x3D;&amp;gt; {
    it(&amp;#39;should parse HTTPS GitHub URLs&amp;#39;, () &#x3D;&amp;gt; {
      const result &#x3D; parseGitHubUrl(&amp;#39;https://github.com/owner/repo.git&amp;#39;);
      expect(result).toEqual({
        owner: &amp;#39;owner&amp;#39;,
        repo: &amp;#39;repo&amp;#39;,
        url: &amp;#39;https://github.com/owner/repo.git&amp;#39;,
        type: &amp;#39;https&amp;#39;,
      });
    });

    it(&amp;#39;should parse HTTPS GitHub URLs without .git extension&amp;#39;, () &#x3D;&amp;gt; {
      const result &#x3D; parseGitHubUrl(&amp;#39;https://github.com/owner/repo&amp;#39;);
      expect(result).toEqual({
        owner: &amp;#39;owner&amp;#39;,
        repo: &amp;#39;repo&amp;#39;,
        url: &amp;#39;https://github.com/owner/repo&amp;#39;,
        type: &amp;#39;https&amp;#39;,
      });
    });

    it(&amp;#39;should parse SSH GitHub URLs&amp;#39;, () &#x3D;&amp;gt; {
      const result &#x3D; parseGitHubUrl(&amp;#39;git@github.com:owner/repo.git&amp;#39;);
      expect(result).toEqual({
        owner: &amp;#39;owner&amp;#39;,
        repo: &amp;#39;repo&amp;#39;,
        url: &amp;#39;git@github.com:owner/repo.git&amp;#39;,
        type: &amp;#39;ssh&amp;#39;,
      });
    });

    it(&amp;#39;should parse SSH GitHub URLs without .git extension&amp;#39;, () &#x3D;&amp;gt; {
      const result &#x3D; parseGitHubUrl(&amp;#39;git@github.com:owner/repo&amp;#39;);
      expect(result).toEqual({
        owner: &amp;#39;owner&amp;#39;,
        repo: &amp;#39;repo&amp;#39;,
        url: &amp;#39;git@github.com:owner/repo&amp;#39;,
        type: &amp;#39;ssh&amp;#39;,
      });
    });

    it(&amp;#39;should return null for non-GitHub URLs&amp;#39;, () &#x3D;&amp;gt; {
      expect(parseGitHubUrl(&amp;#39;https://gitlab.com/owner/repo.git&amp;#39;)).toBeNull();
      expect(parseGitHubUrl(&amp;#39;https://bitbucket.org/owner/repo.git&amp;#39;)).toBeNull();
      expect(parseGitHubUrl(&amp;#39;not-a-url&amp;#39;)).toBeNull();
    });
  });

  describe(&amp;#39;detectRepositoryConflicts&amp;#39;, () &#x3D;&amp;gt; {
    it(&amp;#39;should return null when there are no conflicts&amp;#39;, () &#x3D;&amp;gt; {
      const configRepo: GitHubRepo &#x3D; { owner: &amp;#39;owner&amp;#39;, repo: &amp;#39;repo&amp;#39; };
      const detectedRepo &#x3D; {
        owner: &amp;#39;owner&amp;#39;,
        repo: &amp;#39;repo&amp;#39;,
        url: &amp;#39;https://github.com/owner/repo.git&amp;#39;,
        type: &amp;#39;https&amp;#39; as const,
      };

      const conflict &#x3D; detectRepositoryConflicts(configRepo, detectedRepo);
      expect(conflict).toBeNull();
    });

    it(&amp;#39;should detect owner conflicts&amp;#39;, () &#x3D;&amp;gt; {
      const configRepo: GitHubRepo &#x3D; { owner: &amp;#39;config-owner&amp;#39;, repo: &amp;#39;repo&amp;#39; };
      const detectedRepo &#x3D; {
        owner: &amp;#39;detected-owner&amp;#39;,
        repo: &amp;#39;repo&amp;#39;,
        url: &amp;#39;https://github.com/detected-owner/repo.git&amp;#39;,
        type: &amp;#39;https&amp;#39; as const,
      };

      const conflict &#x3D; detectRepositoryConflicts(configRepo, detectedRepo);
      expect(conflict).toEqual({
        configRepo,
        detectedRepo,
        conflictType: &amp;#39;owner&amp;#39;,
      });
    });

    it(&amp;#39;should detect repo conflicts&amp;#39;, () &#x3D;&amp;gt; {
      const configRepo: GitHubRepo &#x3D; { owner: &amp;#39;owner&amp;#39;, repo: &amp;#39;config-repo&amp;#39; };
      const detectedRepo &#x3D; {
        owner: &amp;#39;owner&amp;#39;,
        repo: &amp;#39;detected-repo&amp;#39;,
        url: &amp;#39;https://github.com/owner/detected-repo.git&amp;#39;,
        type: &amp;#39;https&amp;#39; as const,
      };

      const conflict &#x3D; detectRepositoryConflicts(configRepo, detectedRepo);
      expect(conflict).toEqual({
        configRepo,
        detectedRepo,
        conflictType: &amp;#39;repo&amp;#39;,
      });
    });

    it(&amp;#39;should detect both owner and repo conflicts&amp;#39;, () &#x3D;&amp;gt; {
      const configRepo: GitHubRepo &#x3D; { owner: &amp;#39;config-owner&amp;#39;, repo: &amp;#39;config-repo&amp;#39; };
      const detectedRepo &#x3D; {
        owner: &amp;#39;detected-owner&amp;#39;,
        repo: &amp;#39;detected-repo&amp;#39;,
        url: &amp;#39;https://github.com/detected-owner/detected-repo.git&amp;#39;,
        type: &amp;#39;https&amp;#39; as const,
      };

      const conflict &#x3D; detectRepositoryConflicts(configRepo, detectedRepo);
      expect(conflict).toEqual({
        configRepo,
        detectedRepo,
        conflictType: &amp;#39;both&amp;#39;,
      });
    });
  });

  describe(&amp;#39;validateRepositoryConfig&amp;#39;, () &#x3D;&amp;gt; {
    it(&amp;#39;should validate valid repository config&amp;#39;, () &#x3D;&amp;gt; {
      const config: GitHubRepo &#x3D; {
        owner: &amp;#39;owner&amp;#39;,
        repo: &amp;#39;repo&amp;#39;,
        baseUrl: &amp;#39;https://api.github.com&amp;#39;,
        tokenEnv: &amp;#39;GITHUB_TOKEN&amp;#39;,
      };

      const result &#x3D; validateRepositoryConfig(config);
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
      expect(result.suggestions).toHaveLength(0);
    });

    it(&amp;#39;should require owner and repo&amp;#39;, () &#x3D;&amp;gt; {
      const config: GitHubRepo &#x3D; {};

      const result &#x3D; validateRepositoryConfig(config);
      expect(result.valid).toBe(false);
      expect(result.errors).toContain(&amp;#39;Repository owner is required&amp;#39;);
      expect(result.errors).toContain(&amp;#39;Repository name is required&amp;#39;);
    });

    it(&amp;#39;should validate base URL format&amp;#39;, () &#x3D;&amp;gt; {
      const config: GitHubRepo &#x3D; {
        owner: &amp;#39;owner&amp;#39;,
        repo: &amp;#39;repo&amp;#39;,
        baseUrl: &amp;#39;invalid-url&amp;#39;,
      };

      const result &#x3D; validateRepositoryConfig(config);
      expect(result.valid).toBe(false);
      expect(result.errors).toContain(&amp;#39;Base URL must start with https://&amp;#39;);
    });

    it(&amp;#39;should provide suggestions for common mistakes&amp;#39;, () &#x3D;&amp;gt; {
      const config: GitHubRepo &#x3D; {
        owner: &amp;#39;owner/repo&amp;#39;,
        repo: &amp;#39;repo.git&amp;#39;,
      };

      const result &#x3D; validateRepositoryConfig(config);
      expect(result.valid).toBe(false);
      expect(result.suggestions).toContain(&#x60;Did you mean owner: &amp;quot;owner&amp;quot;, repo: &amp;quot;repo&amp;quot;?&#x60;);
      expect(result.suggestions).toContain(
        &#x60;Repository name should not include .git extension: &amp;quot;repo&amp;quot;&#x60;
      );
    });
  });

  describe(&amp;#39;createRepositoryConfig&amp;#39;, () &#x3D;&amp;gt; {
    it(&amp;#39;should create repository config with defaults&amp;#39;, () &#x3D;&amp;gt; {
      const result &#x3D; createRepositoryConfig(&amp;#39;owner&amp;#39;, &amp;#39;repo&amp;#39;);
      expect(result).toEqual({
        owner: &amp;#39;owner&amp;#39;,
        repo: &amp;#39;repo&amp;#39;,
        tokenEnv: &amp;#39;GITHUB_TOKEN&amp;#39;,
      });
    });

    it(&amp;#39;should merge with base config&amp;#39;, () &#x3D;&amp;gt; {
      const baseConfig &#x3D; {
        baseUrl: &amp;#39;https://github.enterprise.com/api/v3&amp;#39;,
        tokenEnv: &amp;#39;ENTERPRISE_TOKEN&amp;#39;,
      };

      const result &#x3D; createRepositoryConfig(&amp;#39;owner&amp;#39;, &amp;#39;repo&amp;#39;, baseConfig);
      expect(result).toEqual({
        owner: &amp;#39;owner&amp;#39;,
        repo: &amp;#39;repo&amp;#39;,
        baseUrl: &amp;#39;https://github.enterprise.com/api/v3&amp;#39;,
        tokenEnv: &amp;#39;ENTERPRISE_TOKEN&amp;#39;,
      });
    });
  });

  describe(&amp;#39;getSmartRepositoryConfig&amp;#39;, () &#x3D;&amp;gt; {
    beforeEach(() &#x3D;&amp;gt; {
      // Clear any previous mocks
    });

    it(&amp;#39;should use config when no Git detection&amp;#39;, () &#x3D;&amp;gt; {
      // Mock execSync to throw (no Git remote)
      const mockExecSync &#x3D; mock(() &#x3D;&amp;gt; {
        throw new Error(&amp;#39;Not a git repository&amp;#39;);
      });

      // We&amp;#39;ll test this without mocking for now since Bun mocking is different
      const configRepo: GitHubRepo &#x3D; { owner: &amp;#39;config-owner&amp;#39;, repo: &amp;#39;config-repo&amp;#39; };
      const result &#x3D; getSmartRepositoryConfig(configRepo, { verbose: false });

      expect(result).toEqual({
        repo: configRepo,
        source: &amp;#39;config&amp;#39;,
      });
    });

    it(&amp;#39;should use config when provided regardless of Git detection&amp;#39;, () &#x3D;&amp;gt; {
      const configRepo: GitHubRepo &#x3D; { owner: &amp;#39;config-owner&amp;#39;, repo: &amp;#39;config-repo&amp;#39; };
      const result &#x3D; getSmartRepositoryConfig(configRepo, { verbose: false });

      expect(result).toEqual({
        repo: configRepo,
        source: &amp;#39;config&amp;#39;,
      });
    });

    // Note: Removed tests that require complex mocking of child_process
    // These would need to be integration tests or use a different approach
  });
});
</pre>
                </div>
            </div>
            <div class="file-section" id="file-165">
                <div class="file-header">ğŸ“„ packages/cli/src/templates/index.ts</div>
                <div class="file-content">
                    <pre>/**
 * Pluggable Template System
 *
 * This module provides a pluggable template system with clean alias configuration
 * that keeps implementation details separate from CUE specifications.
 */

import { spawn } from &amp;#39;node:child_process&amp;#39;;
import os from &amp;#39;node:os&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import { promisify } from &amp;#39;node:util&amp;#39;;
import chalk from &amp;#39;chalk&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;

/**
 * Helper function to replace execa with spawn
 */
async function execCommand(
  command: string,
  args: string[],
  options: { env?: Record&amp;lt;string, string&amp;gt;; cwd?: string } &#x3D; {}
): Promise&amp;lt;void&amp;gt; {
  return new Promise((resolve, reject) &#x3D;&amp;gt; {
    const child &#x3D; spawn(command, args, {
      stdio: &amp;#39;inherit&amp;#39;,
      env: { ...process.env, ...options.env },
      cwd: options.cwd || process.cwd(),
    });

    child.on(&amp;#39;close&amp;#39;, code &#x3D;&amp;gt; {
      if (code &#x3D;&#x3D;&#x3D; 0) {
        resolve();
      } else {
        reject(new Error(&#x60;Command failed with exit code ${code}: ${command} ${args.join(&amp;#39; &amp;#39;)}&#x60;));
      }
    });

    child.on(&amp;#39;error&amp;#39;, error &#x3D;&amp;gt; {
      reject(error);
    });
  });
}

/**
 * Template engine interface
 */
export interface TemplateEngine {
  name: string;
  command: string;
  defaultArgs: string[];
  validate?(source: string): Promise&amp;lt;boolean&amp;gt;;
  execute(source: string, destination: string, variables: Record&amp;lt;string, any&amp;gt;): Promise&amp;lt;void&amp;gt;;
}

/**
 * Template alias configuration
 */
export interface TemplateAlias {
  engine: string;
  source: string;
  description: string;
  variables?: Record&amp;lt;string, any&amp;gt;;
  prerequisites?: string[];
}

/**
 * Template configuration file structure
 */
export interface TemplateConfig {
  engines: Record&amp;lt;string, TemplateEngineConfig&amp;gt;;
  aliases: Record&amp;lt;string, TemplateAlias&amp;gt;;
  settings?: {
    defaultEngine?: string;
    cacheDir?: string;
    timeout?: number;
  };
}

/**
 * Engine configuration in the template config
 */
export interface TemplateEngineConfig {
  command: string;
  defaultArgs: string[];
  timeout?: number;
}

/**
 * Variable extraction context from CUE specs
 */
export interface VariableContext {
  projectName: string;
  serviceName?: string;
  serviceType?: string;
  language?: string;
  ports?: number[];
  environment?: Record&amp;lt;string, string&amp;gt;;
  database?: {
    type: string;
    name: string;
    port?: number;
  };
  [key: string]: any;
}

/**
 * Template manager for handling aliases and execution
 */
export class TemplateManager {
  private config: TemplateConfig | null &#x3D; null;
  private engines: Map&amp;lt;string, TemplateEngine&amp;gt; &#x3D; new Map();

  constructor() {
    this.loadDefaultEngines();
  }

  /**
   * Load default template engines
   */
  private loadDefaultEngines(): void {
    // Cookiecutter engine
    this.engines.set(&amp;#39;cookiecutter&amp;#39;, new CookiecutterEngine());

    // Yeoman engine (future implementation)
    // this.engines.set(&amp;#39;yeoman&amp;#39;, new YeomanEngine());

    // Custom script engine for simple templates
    this.engines.set(&amp;#39;script&amp;#39;, new ScriptEngine());
  }

  /**
   * Load template configuration from file system
   */
  async loadConfig(configPath?: string): Promise&amp;lt;void&amp;gt; {
    const defaultPath &#x3D; await this.getDefaultConfigPath();
    const targetPath &#x3D; configPath || defaultPath;

    try {
      if (await fs.pathExists(targetPath)) {
        const content &#x3D; await fs.readJson(targetPath);
        this.config &#x3D; content;
      } else {
        // Create default config
        this.config &#x3D; this.getDefaultConfig();
        await this.saveConfig(targetPath);
      }
    } catch (error) {
      console.warn(chalk.yellow(&#x60;Warning: Failed to load template config: ${error}&#x60;));
      this.config &#x3D; this.getDefaultConfig();
    }
  }

  /**
   * Get default configuration path
   */
  private async getDefaultConfigPath(): Promise&amp;lt;string&amp;gt; {
    // Look for .arbiter/templates.json first
    const projectPath &#x3D; path.join(process.cwd(), &amp;#39;.arbiter&amp;#39;, &amp;#39;templates.json&amp;#39;);
    if (await fs.pathExists(projectPath)) {
      return projectPath;
    }

    // Fall back to global config
    return path.join(os.homedir(), &amp;#39;.arbiter&amp;#39;, &amp;#39;templates.json&amp;#39;);
  }

  /**
   * Get default template configuration
   */
  private getDefaultConfig(): TemplateConfig {
    return {
      engines: {
        cookiecutter: {
          command: &amp;#39;cookiecutter&amp;#39;,
          defaultArgs: [&amp;#39;--no-input&amp;#39;],
          timeout: 300000, // 5 minutes
        },
        script: {
          command: &amp;#39;sh&amp;#39;,
          defaultArgs: [],
          timeout: 60000, // 1 minute
        },
      },
      aliases: {
        &amp;#39;bun-hono&amp;#39;: {
          engine: &amp;#39;cookiecutter&amp;#39;,
          source: &amp;#39;https://github.com/arbiter-templates/bun-hono.git&amp;#39;,
          description: &amp;#39;Bun + Hono API service with Drizzle ORM&amp;#39;,
        },
        &amp;#39;rust-axum&amp;#39;: {
          engine: &amp;#39;cookiecutter&amp;#39;,
          source: &amp;#39;gh:arbiter-templates/rust-axum&amp;#39;,
          description: &amp;#39;Rust + Axum service with SQLx&amp;#39;,
        },
        &amp;#39;react-vite&amp;#39;: {
          engine: &amp;#39;cookiecutter&amp;#39;,
          source: &amp;#39;/local/path/to/react-template&amp;#39;,
          description: &amp;#39;React + Vite frontend with Tailwind&amp;#39;,
        },
        &amp;#39;python-fastapi&amp;#39;: {
          engine: &amp;#39;cookiecutter&amp;#39;,
          source: &amp;#39;https://github.com/fastapi-users/fastapi-users-cookiecutter.git&amp;#39;,
          description: &amp;#39;FastAPI service with async SQLAlchemy&amp;#39;,
        },
      },
      settings: {
        defaultEngine: &amp;#39;cookiecutter&amp;#39;,
        cacheDir: path.join(os.homedir(), &amp;#39;.arbiter&amp;#39;, &amp;#39;template-cache&amp;#39;),
        timeout: 300000,
      },
    };
  }

  /**
   * Save configuration to file
   */
  async saveConfig(configPath?: string): Promise&amp;lt;void&amp;gt; {
    if (!this.config) {
      throw new Error(&amp;#39;No configuration to save&amp;#39;);
    }

    const targetPath &#x3D; configPath || (await this.getDefaultConfigPath());
    await fs.ensureDir(path.dirname(targetPath));
    await fs.writeJson(targetPath, this.config, { spaces: 2 });
  }

  /**
   * Get all available template aliases
   */
  getAliases(): Record&amp;lt;string, TemplateAlias&amp;gt; {
    if (!this.config) {
      throw new Error(&amp;#39;Configuration not loaded. Call loadConfig() first.&amp;#39;);
    }
    return this.config.aliases;
  }

  /**
   * Get specific template alias
   */
  getAlias(name: string): TemplateAlias | undefined {
    if (!this.config) {
      throw new Error(&amp;#39;Configuration not loaded. Call loadConfig() first.&amp;#39;);
    }
    return this.config.aliases[name];
  }

  /**
   * Add or update template alias
   */
  async addAlias(name: string, alias: TemplateAlias): Promise&amp;lt;void&amp;gt; {
    if (!this.config) {
      throw new Error(&amp;#39;Configuration not loaded. Call loadConfig() first.&amp;#39;);
    }

    // Validate engine exists
    if (!this.engines.has(alias.engine)) {
      throw new Error(&#x60;Unknown engine: ${alias.engine}&#x60;);
    }

    this.config.aliases[name] &#x3D; alias;
    await this.saveConfig();
  }

  /**
   * Remove template alias
   */
  async removeAlias(name: string): Promise&amp;lt;void&amp;gt; {
    if (!this.config) {
      throw new Error(&amp;#39;Configuration not loaded. Call loadConfig() first.&amp;#39;);
    }

    delete this.config.aliases[name];
    await this.saveConfig();
  }

  /**
   * Execute template with variables
   */
  async executeTemplate(
    aliasName: string,
    destination: string,
    variables: VariableContext
  ): Promise&amp;lt;void&amp;gt; {
    const alias &#x3D; this.getAlias(aliasName);
    if (!alias) {
      throw new Error(&#x60;Template alias &amp;#39;${aliasName}&amp;#39; not found&#x60;);
    }

    const engine &#x3D; this.engines.get(alias.engine);
    if (!engine) {
      throw new Error(&#x60;Engine &amp;#39;${alias.engine}&amp;#39; not found&#x60;);
    }

    // Merge variables with alias defaults
    const finalVariables &#x3D; {
      ...alias.variables,
      ...variables,
    };

    // Validate prerequisites if any
    if (alias.prerequisites) {
      await this.validatePrerequisites(alias.prerequisites);
    }

    // Execute template
    await engine.execute(alias.source, destination, finalVariables);
  }

  /**
   * Validate template prerequisites
   */
  private async validatePrerequisites(prerequisites: string[]): Promise&amp;lt;void&amp;gt; {
    for (const prereq of prerequisites) {
      // Simple command existence check
      try {
        await execCommand(&amp;#39;which&amp;#39;, [prereq]);
      } catch {
        throw new Error(&#x60;Prerequisite not found: ${prereq}&#x60;);
      }
    }
  }

  /**
   * List available engines
   */
  getEngines(): string[] {
    return Array.from(this.engines.keys());
  }

  /**
   * Add custom engine
   */
  addEngine(engine: TemplateEngine): void {
    this.engines.set(engine.name, engine);
  }
}

/**
 * Cookiecutter template engine implementation
 */
export class CookiecutterEngine implements TemplateEngine {
  name &#x3D; &amp;#39;cookiecutter&amp;#39;;
  command &#x3D; &amp;#39;cookiecutter&amp;#39;;
  defaultArgs &#x3D; [&amp;#39;--no-input&amp;#39;];

  async validate(source: string): Promise&amp;lt;boolean&amp;gt; {
    try {
      await execCommand(&amp;#39;which&amp;#39;, [&amp;#39;cookiecutter&amp;#39;]);
      return true;
    } catch {
      return false;
    }
  }

  async execute(
    source: string,
    destination: string,
    variables: Record&amp;lt;string, any&amp;gt;
  ): Promise&amp;lt;void&amp;gt; {
    try {
      // Build cookiecutter command
      const args &#x3D; [...this.defaultArgs];

      // Add variables as command line arguments
      for (const [key, value] of Object.entries(variables)) {
        args.push(&amp;#39;--extra-context&amp;#39;);
        args.push(&#x60;${key}&#x3D;${value}&#x60;);
      }

      // Add output directory
      args.push(&amp;#39;--output-dir&amp;#39;, destination);

      // Add template source
      args.push(source);

      await execCommand(&amp;#39;cookiecutter&amp;#39;, args);
    } catch (error) {
      throw new Error(&#x60;Cookiecutter execution failed: ${error}&#x60;);
    }
  }
}

/**
 * Simple script-based template engine
 */
export class ScriptEngine implements TemplateEngine {
  name &#x3D; &amp;#39;script&amp;#39;;
  command &#x3D; &amp;#39;sh&amp;#39;;
  defaultArgs &#x3D; [];

  async validate(source: string): Promise&amp;lt;boolean&amp;gt; {
    return fs.pathExists(source);
  }

  async execute(
    source: string,
    destination: string,
    variables: Record&amp;lt;string, any&amp;gt;
  ): Promise&amp;lt;void&amp;gt; {
    try {
      // Set variables as environment variables
      const env &#x3D; {
        ...process.env,
        TEMPLATE_DESTINATION: destination,
        ...Object.fromEntries(
          Object.entries(variables).map(([k, v]) &#x3D;&amp;gt; [&#x60;TEMPLATE_${k.toUpperCase()}&#x60;, String(v)])
        ),
      };

      await execCommand(&amp;#39;sh&amp;#39;, [source], { env });
    } catch (error) {
      throw new Error(&#x60;Script execution failed: ${error}&#x60;);
    }
  }
}

/**
 * Extract variables from CUE specification content
 */
export function extractVariablesFromCue(content: string, serviceName?: string): VariableContext {
  const variables &#x3D; initializeBaseVariables(serviceName);

  extractProjectName(content, variables);

  if (serviceName) {
    extractServiceInformation(content, serviceName, variables);
  }

  return variables;
}

/**
 * Initialize base variable context
 */
function initializeBaseVariables(serviceName?: string): VariableContext {
  return {
    projectName: path.basename(process.cwd()).replace(/[^a-zA-Z0-9]/g, &amp;#39;&amp;#39;),
    serviceName: serviceName || &amp;#39;api&amp;#39;,
  };
}

/**
 * Extract project name from package declaration
 */
function extractProjectName(content: string, variables: VariableContext): void {
  const packageMatch &#x3D; content.match(/package\s+(\w+)/);
  if (packageMatch) {
    variables.projectName &#x3D; packageMatch[1];
  }
}

/**
 * Extract service-specific information from CUE content
 */
function extractServiceInformation(
  content: string,
  serviceName: string,
  variables: VariableContext
): void {
  const serviceContent &#x3D; extractServiceContent(content, serviceName);
  if (!serviceContent) return;

  extractServiceLanguage(serviceContent, variables);
  extractServiceType(serviceContent, variables);
  extractServicePorts(serviceContent, variables);
}

/**
 * Extract service content block from CUE
 */
function extractServiceContent(content: string, serviceName: string): string | null {
  const serviceRegex &#x3D; new RegExp(&#x60;${serviceName}:\\s*{([^}]+)}&#x60;, &amp;#39;s&amp;#39;);
  const serviceMatch &#x3D; content.match(serviceRegex);
  return serviceMatch ? serviceMatch[1] : null;
}

/**
 * Extract language from service content
 */
function extractServiceLanguage(serviceContent: string, variables: VariableContext): void {
  const langMatch &#x3D; serviceContent.match(/language:\s*&amp;quot;([^&amp;quot;]+)&amp;quot;/);
  if (langMatch) {
    variables.language &#x3D; langMatch[1];
  }
}

/**
 * Extract service type from service content
 */
function extractServiceType(serviceContent: string, variables: VariableContext): void {
  const typeMatch &#x3D; serviceContent.match(/serviceType:\s*&amp;quot;([^&amp;quot;]+)&amp;quot;/);
  if (typeMatch) {
    variables.serviceType &#x3D; typeMatch[1];
  }
}

/**
 * Extract ports from service content
 */
function extractServicePorts(serviceContent: string, variables: VariableContext): void {
  const portsMatch &#x3D; serviceContent.match(/ports:\s*\[([^\]]+)\]/s);
  if (portsMatch) {
    const portsContent &#x3D; portsMatch[1];
    const portMatches &#x3D; portsContent.matchAll(/port:\s*(\d+)/g);
    variables.ports &#x3D; Array.from(portMatches).map(m &#x3D;&amp;gt; Number.parseInt(m[1], 10));
  }
}

/**
 * Default template manager instance
 */
export const templateManager &#x3D; new TemplateManager();
</pre>
                </div>
            </div>
            <div class="file-section" id="file-166">
                <div class="file-header">ğŸ“„ packages/cli/src/commands/compat.ts</div>
                <div class="file-content">
                    <pre>/**
 * @fileoverview Compatibility Check Command Implementation v1.0 RC
 * Provides CLI interface for version compatibility validation and migration
 */

import {
  CURRENT_VERSIONS,
  type CompatibilityResult,
  type VersionSet,
  checkCompatibility,
  estimateMigrationDuration,
  executeMigration,
  getAvailableMigrationPaths,
  getRuntimeVersionInfo,
  hasMigrationPath,
  validateVersionSet,
} from &amp;#39;@arbiter/shared&amp;#39;;
import { z } from &amp;#39;zod&amp;#39;;

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// COMMAND SCHEMAS
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Compatibility check command options
 */
export const CompatCheckOptionsSchema &#x3D; z
  .object({
    input: z.string().optional().describe(&amp;#39;Path to version file or JSON&amp;#39;),
    format: z.enum([&amp;#39;json&amp;#39;, &amp;#39;text&amp;#39;, &amp;#39;table&amp;#39;]).default(&amp;#39;text&amp;#39;).describe(&amp;#39;Output format&amp;#39;),
    allowCompat: z.boolean().default(false).describe(&amp;#39;Allow compatibility warnings&amp;#39;),
    showMigrations: z.boolean().default(true).describe(&amp;#39;Show available migration paths&amp;#39;),
    verbose: z.boolean().default(false).describe(&amp;#39;Verbose output&amp;#39;),
  })
  .strict();

export type CompatCheckOptions &#x3D; z.infer&amp;lt;typeof CompatCheckOptionsSchema&amp;gt;;

/**
 * Migration command options
 */
export const MigrationOptionsSchema &#x3D; z
  .object({
    from: z.string().describe(&amp;#39;Source version&amp;#39;),
    to: z.string().describe(&amp;#39;Target version&amp;#39;),
    component: z
      .enum([&amp;#39;api_version&amp;#39;, &amp;#39;schema_version&amp;#39;, &amp;#39;contract_version&amp;#39;, &amp;#39;ticket_format&amp;#39;])
      .describe(&amp;#39;Component to migrate&amp;#39;),
    dryRun: z.boolean().default(false).describe(&amp;#39;Show migration plan without executing&amp;#39;),
    force: z.boolean().default(false).describe(&amp;#39;Force migration even if risky&amp;#39;),
    backup: z.boolean().default(true).describe(&amp;#39;Create backup before migration&amp;#39;),
  })
  .strict();

export type MigrationOptions &#x3D; z.infer&amp;lt;typeof MigrationOptionsSchema&amp;gt;;

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// COMPATIBILITY CHECK COMMAND
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Execute compatibility check command
 */
export async function runCompatCheck(options: CompatCheckOptions): Promise&amp;lt;void&amp;gt; {
  try {
    console.log(&amp;#39;ğŸ” Arbiter Compatibility Check v1.0 RC\n&amp;#39;);

    // Get runtime version information
    const runtimeInfo &#x3D; getRuntimeVersionInfo();

    if (options.verbose) {
      console.log(&amp;#39;ğŸ“‹ Current Runtime Versions:&amp;#39;);
      console.table(runtimeInfo.versions);
      console.log();
    }

    // Load versions to check against
    const versionsToCheck &#x3D; await loadVersionsToCheck(options.input);

    if (options.verbose) {
      console.log(&amp;#39;ğŸ“¥ Versions to Check:&amp;#39;);
      console.table(versionsToCheck);
      console.log();
    }

    // Perform compatibility check
    const result &#x3D; await checkCompatibility(versionsToCheck, options.allowCompat);

    // Output results
    await outputCompatibilityResult(result, options);

    // Show migration paths if requested
    if (options.showMigrations &amp;amp;&amp;amp; result.version_mismatches.length &amp;gt; 0) {
      await showMigrationPaths(versionsToCheck, options);
    }

    // Exit with appropriate code
    process.exit(result.compatible ? 0 : 1);
  } catch (error) {
    console.error(&amp;#39;âŒ Compatibility check failed:&amp;#39;, error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

/**
 * Load versions to check from input source
 */
async function loadVersionsToCheck(input?: string): Promise&amp;lt;Partial&amp;lt;VersionSet&amp;gt;&amp;gt; {
  if (!input) {
    // Use current versions as baseline
    return CURRENT_VERSIONS;
  }

  try {
    // Try to read as file
    const fs &#x3D; await import(&amp;#39;node:fs/promises&amp;#39;);
    const content &#x3D; await fs.readFile(input, &amp;#39;utf-8&amp;#39;);
    const data &#x3D; JSON.parse(content);

    // Validate structure
    if (data.versions) {
      validateVersionSet(data.versions);
      return data.versions;
    }
    validateVersionSet(data);
    return data;
  } catch (_error) {
    // Try to parse as direct JSON
    try {
      const data &#x3D; JSON.parse(input);
      validateVersionSet(data);
      return data;
    } catch {
      throw new Error(&#x60;Cannot load versions from: ${input}&#x60;);
    }
  }
}

/**
 * Output compatibility check result in specified format
 */
async function outputCompatibilityResult(
  result: CompatibilityResult,
  options: CompatCheckOptions
): Promise&amp;lt;void&amp;gt; {
  switch (options.format) {
    case &amp;#39;json&amp;#39;:
      console.log(JSON.stringify(result, null, 2));
      break;

    case &amp;#39;table&amp;#39;:
      outputCompatibilityTable(result);
      break;
    default:
      outputCompatibilityText(result, options.verbose);
      break;
  }
}

/**
 * Output compatibility result as formatted text
 */
function outputCompatibilityText(result: CompatibilityResult, verbose: boolean): void {
  if (result.compatible) {
    console.log(&amp;#39;âœ… All versions are compatible!\n&amp;#39;);
  } else {
    console.log(&amp;#39;âŒ Version compatibility issues detected:\n&amp;#39;);
  }

  if (result.version_mismatches.length &amp;gt; 0) {
    console.log(&amp;#39;ğŸ” Version Mismatches:&amp;#39;);
    for (const mismatch of result.version_mismatches) {
      const icon &#x3D; mismatch.severity &#x3D;&#x3D;&#x3D; &amp;#39;error&amp;#39; ? &amp;#39;âŒ&amp;#39; : &amp;#39;âš ï¸&amp;#39;;
      console.log(
        &#x60;  ${icon} ${mismatch.component}: expected ${mismatch.expected}, got ${mismatch.actual}&#x60;
      );
    }
    console.log();
  }

  if (result.migration_required &amp;amp;&amp;amp; result.migration_path) {
    console.log(&amp;#39;ğŸ”„ Migration Available:&amp;#39;);
    console.log(&#x60;  Command: ${result.migration_path}&#x60;);
    console.log();
  }

  if (verbose) {
    console.log(&#x60;â° Checked at: ${result.timestamp}&#x60;);
  }
}

/**
 * Output compatibility result as table
 */
function outputCompatibilityTable(result: CompatibilityResult): void {
  if (result.version_mismatches.length &#x3D;&#x3D;&#x3D; 0) {
    console.log(&amp;#39;âœ… All versions compatible - no issues to display&amp;#39;);
    return;
  }

  console.table(
    result.version_mismatches.map(mismatch &#x3D;&amp;gt; ({
      Component: mismatch.component,
      Expected: mismatch.expected,
      Actual: mismatch.actual,
      Severity: mismatch.severity,
      Status: mismatch.severity &#x3D;&#x3D;&#x3D; &amp;#39;error&amp;#39; ? &amp;#39;âŒ Error&amp;#39; : &amp;#39;âš ï¸ Warning&amp;#39;,
    }))
  );
}

/**
 * Show available migration paths for incompatible versions
 */
async function showMigrationPaths(
  versionsToCheck: Partial&amp;lt;VersionSet&amp;gt;,
  _options: CompatCheckOptions
): Promise&amp;lt;void&amp;gt; {
  console.log(&amp;#39;ğŸš€ Available Migration Paths:\n&amp;#39;);

  for (const [component, sourceVersion] of Object.entries(versionsToCheck)) {
    const key &#x3D; component as keyof VersionSet;
    const componentName &#x3D; String(key);
    const targetVersion &#x3D; CURRENT_VERSIONS[key];

    if (sourceVersion &amp;amp;&amp;amp; sourceVersion !&#x3D;&#x3D; targetVersion) {
      const paths &#x3D; getAvailableMigrationPaths(componentName);
      const directPath &#x3D; hasMigrationPath(componentName, sourceVersion, targetVersion);
      const duration &#x3D; estimateMigrationDuration(componentName, sourceVersion, targetVersion);

      console.log(&#x60;ğŸ“¦ ${component}:&#x60;);
      console.log(&#x60;  Current: ${sourceVersion} â†’ Target: ${targetVersion}&#x60;);

      if (directPath) {
        console.log(&amp;#39;  âœ… Direct migration available&amp;#39;);
        console.log(&#x60;  â±ï¸  Estimated duration: ${duration}ms&#x60;);
        console.log(
          &#x60;  ğŸ”§ Command: arbiter migrate --component ${componentName} --from ${sourceVersion} --to ${targetVersion}&#x60;
        );
      } else {
        console.log(&amp;#39;  âŒ No direct migration path available&amp;#39;);
        if (paths.length &amp;gt; 0) {
          console.log(&#x60;  ğŸ›¤ï¸  Available paths: ${paths.join(&amp;#39;, &amp;#39;)}&#x60;);
        }
      }
      console.log();
    }
  }
}

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// MIGRATION COMMAND
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Execute migration command
 */
export async function runMigration(options: MigrationOptions): Promise&amp;lt;void&amp;gt; {
  const migrationRunner &#x3D; new MigrationRunner(options);
  await migrationRunner.execute();
}

/**
 * Migration execution orchestrator using Command pattern
 */
class MigrationRunner {
  private readonly component: keyof VersionSet;
  private readonly componentName: string;

  constructor(private readonly options: MigrationOptions) {
    this.component &#x3D; options.component as keyof VersionSet;
    this.componentName &#x3D; String(this.component);
  }

  async execute(): Promise&amp;lt;void&amp;gt; {
    try {
      this.displayHeader();
      await this.validateMigrationPath();
      this.displayEstimatedDuration();

      if (this.options.dryRun) {
        this.executeDryRun();
        return;
      }

      this.requestConfirmationIfNeeded();
      await this.performMigration();
    } catch (error) {
      this.handleFatalError(error);
    }
  }

  private displayHeader(): void {
    console.log(&amp;#39;ğŸ”„ Arbiter Migration Tool v1.0 RC\n&amp;#39;);
    console.log(&#x60;ğŸ“¦ Component: ${this.componentName}&#x60;);
    console.log(&#x60;ğŸ“¥ From: ${this.options.from}&#x60;);
    console.log(&#x60;ğŸ“¤ To: ${this.options.to}&#x60;);
    console.log();
  }

  private async validateMigrationPath(): Promise&amp;lt;void&amp;gt; {
    if (!hasMigrationPath(this.componentName, this.options.from, this.options.to)) {
      this.displayMigrationPathError();
      process.exit(1);
    }
  }

  private displayMigrationPathError(): void {
    console.error(
      &#x60;âŒ No migration path available: ${this.componentName} ${this.options.from} -&amp;gt; ${this.options.to}&#x60;
    );

    const availablePaths &#x3D; getAvailableMigrationPaths(this.componentName);
    if (availablePaths.length &amp;gt; 0) {
      console.log(&amp;#39;\nğŸ›¤ï¸  Available migration paths:&amp;#39;);
      availablePaths.forEach(path &#x3D;&amp;gt; console.log(&#x60;  â€¢ ${path}&#x60;));
    }
  }

  private displayEstimatedDuration(): void {
    const estimatedDuration &#x3D; estimateMigrationDuration(
      this.componentName,
      this.options.from,
      this.options.to
    );
    console.log(&#x60;â±ï¸  Estimated duration: ${estimatedDuration}ms&#x60;);
  }

  private executeDryRun(): void {
    console.log(&amp;#39;\nğŸ§ª DRY RUN MODE - No changes will be made\n&amp;#39;);
    this.displayMigrationPlan();
    console.log(&amp;#39;\nâœ… Dry run completed - use --dry-run&#x3D;false to execute&amp;#39;);
    process.exit(0);
  }

  private displayMigrationPlan(): void {
    console.log(&amp;#39;Migration plan:&amp;#39;);
    console.log(&#x60;  1. Validate preconditions for ${this.componentName} migration&#x60;);
    console.log(&#x60;  2. ${this.options.backup ? &amp;#39;Create backup&amp;#39; : &amp;#39;Skip backup (disabled)&amp;#39;}&#x60;);
    console.log(&amp;#39;  3. Execute migration transformations&amp;#39;);
    console.log(&amp;#39;  4. Validate post-migration state&amp;#39;);
    console.log(&amp;#39;  5. Update version metadata&amp;#39;);
  }

  private requestConfirmationIfNeeded(): void {
    if (!this.options.force) {
      console.log(&amp;#39;âš ï¸  This will modify your system. Continue? (y/N)&amp;#39;);
      // In a real CLI, we&amp;#39;d wait for user input here
      // For now, assume confirmation
    }
  }

  private async performMigration(): Promise&amp;lt;void&amp;gt; {
    console.log(&amp;#39;\nğŸš€ Starting migration...\n&amp;#39;);

    const result &#x3D; await executeMigration(this.componentName, this.options.from, this.options.to);

    if (result.success) {
      this.displaySuccessResult(result);
    } else {
      this.displayFailureResult(result);
      process.exit(1);
    }
  }

  private displaySuccessResult(result: MigrationResult): void {
    console.log(&amp;#39;âœ… Migration completed successfully!\n&amp;#39;);

    this.displayOperations(&amp;#39;ğŸ“‹ Operations performed:&amp;#39;, result.operations_performed);
    this.displayWarningsIfAny(result.warnings);

    console.log(&#x60;\nâ° Completed at: ${result.timestamp}&#x60;);
  }

  private displayFailureResult(result: MigrationResult): void {
    console.error(&amp;#39;âŒ Migration failed!\n&amp;#39;);

    this.displayOperations(&amp;#39;ğŸ“‹ Operations attempted:&amp;#39;, result.operations_performed);

    if (result.warnings.length &amp;gt; 0) {
      console.log(&amp;#39;\nâš ï¸  Issues encountered:&amp;#39;);
      result.warnings.forEach(warning &#x3D;&amp;gt; console.log(&#x60;  â€¢ ${warning}&#x60;));
    }
  }

  private displayOperations(header: string, operations: string[]): void {
    console.log(header);
    operations.forEach(op &#x3D;&amp;gt; console.log(&#x60;  â€¢ ${op}&#x60;));
  }

  private displayWarningsIfAny(warnings: string[]): void {
    if (warnings.length &amp;gt; 0) {
      console.log(&amp;#39;\nâš ï¸  Warnings:&amp;#39;);
      warnings.forEach(warning &#x3D;&amp;gt; console.log(&#x60;  â€¢ ${warning}&#x60;));
    }
  }

  private handleFatalError(error: unknown): never {
    console.error(&amp;#39;âŒ Migration failed:&amp;#39;, error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

/**
 * Migration result interface
 */
interface MigrationResult {
  success: boolean;
  operations_performed: string[];
  warnings: string[];
  timestamp: string;
}

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// VERSION INFO COMMAND
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Show current version information
 */
export async function showVersionInfo(): Promise&amp;lt;void&amp;gt; {
  const runtimeInfo &#x3D; getRuntimeVersionInfo();

  console.log(&amp;#39;ğŸ“‹ Arbiter Version Information v1.0 RC\n&amp;#39;);

  console.log(&amp;#39;ğŸ”¢ Current Versions:&amp;#39;);
  console.table(runtimeInfo.versions);

  console.log(&amp;#39;\nğŸ—ï¸  Build Information:&amp;#39;);
  console.log(&#x60;  Timestamp: ${runtimeInfo.build_info.timestamp}&#x60;);
  console.log(&#x60;  Commit: ${runtimeInfo.build_info.commit_hash || &amp;#39;unknown&amp;#39;}&#x60;);
  console.log(&#x60;  Deterministic: ${runtimeInfo.build_info.deterministic ? &amp;#39;âœ…&amp;#39; : &amp;#39;âŒ&amp;#39;}&#x60;);
  console.log(&#x60;  Reproducible: ${runtimeInfo.build_info.reproducible ? &amp;#39;âœ…&amp;#39; : &amp;#39;âŒ&amp;#39;}&#x60;);

  console.log(&amp;#39;\nâš™ï¸  Compatibility Settings:&amp;#39;);
  console.log(&#x60;  Strict Mode: ${runtimeInfo.compatibility.strict_mode ? &amp;#39;âœ…&amp;#39; : &amp;#39;âŒ&amp;#39;}&#x60;);
  console.log(&#x60;  Allow Compat Flag: ${runtimeInfo.compatibility.allow_compat_flag ? &amp;#39;âœ…&amp;#39; : &amp;#39;âŒ&amp;#39;}&#x60;);
  console.log(&#x60;  Migration Support: ${runtimeInfo.compatibility.migration_support ? &amp;#39;âœ…&amp;#39; : &amp;#39;âŒ&amp;#39;}&#x60;);
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-167">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/design-system/components/Checkbox.tsx</div>
                <div class="file-content">
                    <pre>/**
 * Checkbox Component - Design System
 * Professional checkbox with comprehensive states and accessibility
 * Designed for developer tools with sophisticated graphite theme
 */

import React, { forwardRef, type InputHTMLAttributes, type ReactNode } from &amp;#39;react&amp;#39;;
import { clsx } from &amp;#39;clsx&amp;#39;;
import { Check, Minus, AlertCircle, CheckCircle, AlertTriangle, Loader2 } from &amp;#39;lucide-react&amp;#39;;
import { cn } from &amp;#39;../variants&amp;#39;;

export interface CheckboxProps extends Omit&amp;lt;InputHTMLAttributes&amp;lt;HTMLInputElement&amp;gt;, &amp;#39;size&amp;#39;&amp;gt; {
  /** Checkbox variant determines the visual style */
  variant?: &amp;#39;default&amp;#39; | &amp;#39;error&amp;#39; | &amp;#39;success&amp;#39; | &amp;#39;warning&amp;#39;;

  /** Checkbox size affects the checkbox and font size */
  size?: &amp;#39;sm&amp;#39; | &amp;#39;md&amp;#39; | &amp;#39;lg&amp;#39;;

  /** Label text for the checkbox */
  label?: string;

  /** Additional description text */
  description?: string;

  /** Helper text below the checkbox */
  helperText?: string;

  /** Error message (sets variant to error automatically) */
  error?: string;

  /** Warning message (sets variant to warning automatically) */
  warning?: string;

  /** Success message (sets variant to success automatically) */
  success?: string;

  /** Whether the checkbox is in an indeterminate state */
  indeterminate?: boolean;

  /** Whether the checkbox is in a loading state */
  loading?: boolean;

  /** Whether to show validation icons automatically */
  showValidationIcon?: boolean;

  /** Custom className for additional styling */
  className?: string;

  /** Custom className for the wrapper */
  wrapperClassName?: string;

  /** Custom className for the label */
  labelClassName?: string;

  /** Children to render as custom label content */
  children?: ReactNode;
}

export const Checkbox &#x3D; forwardRef&amp;lt;HTMLInputElement, CheckboxProps&amp;gt;(
  (
    {
      variant &#x3D; &amp;#39;default&amp;#39;,
      size &#x3D; &amp;#39;md&amp;#39;,
      label,
      description,
      helperText,
      error,
      warning,
      success,
      indeterminate &#x3D; false,
      loading &#x3D; false,
      showValidationIcon &#x3D; true,
      disabled,
      checked,
      className,
      wrapperClassName,
      labelClassName,
      children,
      id,
      ...props
    },
    ref
  ) &#x3D;&amp;gt; {
    // Determine actual variant based on state props
    const actualVariant &#x3D; error ? &amp;#39;error&amp;#39; : warning ? &amp;#39;warning&amp;#39; : success ? &amp;#39;success&amp;#39; : variant;
    const actualHelperText &#x3D; error || warning || success || helperText;

    // Generate unique ID
    const checkboxId &#x3D; id || &#x60;checkbox-${Math.random().toString(36).substr(2, 9)}&#x60;;

    // Get validation icon
    const getValidationIcon &#x3D; () &#x3D;&amp;gt; {
      if (!showValidationIcon || loading) return null;

      if (error) return &amp;lt;AlertCircle className&#x3D;&amp;quot;h-4 w-4 text-red-500&amp;quot; /&amp;gt;;
      if (warning) return &amp;lt;AlertTriangle className&#x3D;&amp;quot;h-4 w-4 text-amber-500&amp;quot; /&amp;gt;;
      if (success) return &amp;lt;CheckCircle className&#x3D;&amp;quot;h-4 w-4 text-green-500&amp;quot; /&amp;gt;;

      return null;
    };

    const validationIcon &#x3D; getValidationIcon();

    // Checkbox size classes
    const sizeClasses &#x3D; {
      sm: {
        checkbox: &amp;#39;h-4 w-4&amp;#39;,
        text: &amp;#39;text-sm&amp;#39;,
        icon: &amp;#39;h-2.5 w-2.5&amp;#39;,
        gap: &amp;#39;gap-2&amp;#39;,
      },
      md: {
        checkbox: &amp;#39;h-5 w-5&amp;#39;,
        text: &amp;#39;text-base&amp;#39;,
        icon: &amp;#39;h-3 w-3&amp;#39;,
        gap: &amp;#39;gap-3&amp;#39;,
      },
      lg: {
        checkbox: &amp;#39;h-6 w-6&amp;#39;,
        text: &amp;#39;text-lg&amp;#39;,
        icon: &amp;#39;h-4 w-4&amp;#39;,
        gap: &amp;#39;gap-3&amp;#39;,
      },
    };

    const sizeClass &#x3D; sizeClasses[size];

    // Checkbox variant classes
    const variantClasses &#x3D; {
      default: cn(
        &amp;#39;border-graphite-300 text-blue-600 focus:ring-blue-500&amp;#39;,
        &amp;#39;checked:bg-blue-600 checked:border-blue-600&amp;#39;,
        &amp;#39;hover:border-graphite-400&amp;#39;,
        &amp;#39;disabled:bg-graphite-50 disabled:border-graphite-200 disabled:text-graphite-400&amp;#39;
      ),
      error: cn(
        &amp;#39;border-red-300 text-red-600 focus:ring-red-500&amp;#39;,
        &amp;#39;checked:bg-red-600 checked:border-red-600&amp;#39;,
        &amp;#39;hover:border-red-400&amp;#39;,
        &amp;#39;disabled:bg-red-50 disabled:border-red-200 disabled:text-red-300&amp;#39;
      ),
      warning: cn(
        &amp;#39;border-amber-300 text-amber-600 focus:ring-amber-500&amp;#39;,
        &amp;#39;checked:bg-amber-600 checked:border-amber-600&amp;#39;,
        &amp;#39;hover:border-amber-400&amp;#39;,
        &amp;#39;disabled:bg-amber-50 disabled:border-amber-200 disabled:text-amber-300&amp;#39;
      ),
      success: cn(
        &amp;#39;border-emerald-300 text-emerald-600 focus:ring-emerald-500&amp;#39;,
        &amp;#39;checked:bg-emerald-600 checked:border-emerald-600&amp;#39;,
        &amp;#39;hover:border-emerald-400&amp;#39;,
        &amp;#39;disabled:bg-emerald-50 disabled:border-emerald-200 disabled:text-emerald-300&amp;#39;
      ),
    };

    const checkboxClasses &#x3D; cn(
      // Base styles
      &amp;#39;relative rounded border-2 transition-all duration-150 ease-in-out&amp;#39;,
      &amp;#39;focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-opacity-50&amp;#39;,
      &amp;#39;disabled:cursor-not-allowed&amp;#39;,

      // Size
      sizeClass.checkbox,

      // Variant styles
      variantClasses[actualVariant],

      // Loading state
      loading &amp;amp;&amp;amp; &amp;#39;cursor-wait&amp;#39;,

      className
    );

    const wrapperClasses &#x3D; cn(
      &amp;#39;flex items-start&amp;#39;,
      sizeClass.gap,
      disabled &amp;amp;&amp;amp; &amp;#39;opacity-60 cursor-not-allowed&amp;#39;,
      wrapperClassName
    );

    const labelClasses &#x3D; cn(
      &amp;#39;flex-1&amp;#39;,
      sizeClass.text,
      &amp;#39;text-graphite-900 font-medium cursor-pointer select-none&amp;#39;,
      actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;error&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-red-900&amp;#39;,
      actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;warning&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-amber-900&amp;#39;,
      actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;success&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-emerald-900&amp;#39;,
      disabled &amp;amp;&amp;amp; &amp;#39;cursor-not-allowed text-graphite-500&amp;#39;,
      labelClassName
    );

    return (
      &amp;lt;div className&#x3D;&amp;quot;space-y-1&amp;quot;&amp;gt;
        &amp;lt;div className&#x3D;{wrapperClasses}&amp;gt;
          {/* Hidden input */}
          &amp;lt;input
            ref&#x3D;{ref}
            type&#x3D;&amp;quot;checkbox&amp;quot;
            id&#x3D;{checkboxId}
            checked&#x3D;{checked}
            disabled&#x3D;{disabled || loading}
            className&#x3D;&amp;quot;sr-only&amp;quot;
            aria-describedby&#x3D;{cn(
              actualHelperText &amp;amp;&amp;amp; &#x60;${checkboxId}-description&#x60;,
              description &amp;amp;&amp;amp; &#x60;${checkboxId}-desc&#x60;
            )}
            {...props}
          /&amp;gt;

          {/* Custom checkbox */}
          &amp;lt;div className&#x3D;&amp;quot;relative flex-shrink-0&amp;quot;&amp;gt;
            &amp;lt;div className&#x3D;{checkboxClasses}&amp;gt;
              {/* Loading spinner */}
              {loading &amp;amp;&amp;amp; (
                &amp;lt;div className&#x3D;&amp;quot;absolute inset-0 flex items-center justify-center&amp;quot;&amp;gt;
                  &amp;lt;Loader2 className&#x3D;{cn(sizeClass.icon, &amp;#39;animate-spin text-graphite-400&amp;#39;)} /&amp;gt;
                &amp;lt;/div&amp;gt;
              )}

              {/* Check/indeterminate icon */}
              {!loading &amp;amp;&amp;amp; (checked || indeterminate) &amp;amp;&amp;amp; (
                &amp;lt;div className&#x3D;&amp;quot;absolute inset-0 flex items-center justify-center text-white&amp;quot;&amp;gt;
                  {indeterminate ? (
                    &amp;lt;Minus className&#x3D;{sizeClass.icon} strokeWidth&#x3D;{3} /&amp;gt;
                  ) : (
                    &amp;lt;Check className&#x3D;{sizeClass.icon} strokeWidth&#x3D;{3} /&amp;gt;
                  )}
                &amp;lt;/div&amp;gt;
              )}
            &amp;lt;/div&amp;gt;
          &amp;lt;/div&amp;gt;

          {/* Label and content */}
          {(label || children) &amp;amp;&amp;amp; (
            &amp;lt;div className&#x3D;&amp;quot;flex-1 space-y-1&amp;quot;&amp;gt;
              &amp;lt;label htmlFor&#x3D;{checkboxId} className&#x3D;{labelClasses}&amp;gt;
                &amp;lt;div className&#x3D;&amp;quot;flex items-start justify-between gap-2&amp;quot;&amp;gt;
                  &amp;lt;span&amp;gt;{children || label}&amp;lt;/span&amp;gt;

                  {/* Validation icon */}
                  {validationIcon &amp;amp;&amp;amp; &amp;lt;div className&#x3D;&amp;quot;flex-shrink-0&amp;quot;&amp;gt;{validationIcon}&amp;lt;/div&amp;gt;}
                &amp;lt;/div&amp;gt;
              &amp;lt;/label&amp;gt;

              {/* Description */}
              {description &amp;amp;&amp;amp; (
                &amp;lt;p
                  id&#x3D;{&#x60;${checkboxId}-desc&#x60;}
                  className&#x3D;{cn(&amp;#39;text-sm text-graphite-600&amp;#39;, disabled &amp;amp;&amp;amp; &amp;#39;text-graphite-400&amp;#39;)}
                &amp;gt;
                  {description}
                &amp;lt;/p&amp;gt;
              )}
            &amp;lt;/div&amp;gt;
          )}
        &amp;lt;/div&amp;gt;

        {/* Helper text / Validation messages */}
        {actualHelperText &amp;amp;&amp;amp; (
          &amp;lt;p
            id&#x3D;{&#x60;${checkboxId}-description&#x60;}
            className&#x3D;{cn(
              &amp;#39;text-sm ml-7 flex items-start gap-1&amp;#39;,
              actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;error&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-red-600&amp;#39;,
              actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;warning&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-amber-600&amp;#39;,
              actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;success&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-green-600&amp;#39;,
              actualVariant &#x3D;&#x3D;&#x3D; &amp;#39;default&amp;#39; &amp;amp;&amp;amp; &amp;#39;text-graphite-600&amp;#39;
            )}
          &amp;gt;
            {actualHelperText}
          &amp;lt;/p&amp;gt;
        )}
      &amp;lt;/div&amp;gt;
    );
  }
);

Checkbox.displayName &#x3D; &amp;#39;Checkbox&amp;#39;;

export default Checkbox;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-168">
                <div class="file-header">ğŸ“„ packages/shared/src/__tests__/issue-schema.test.ts</div>
                <div class="file-content">
                    <pre>/**
 * Tests for the issue schema specification and validation
 */
import { describe, expect, test } from &amp;#39;bun:test&amp;#39;;
import {
  DEFAULT_ISSUE_VALIDATION,
  type IssueSpec,
  createChecklistItem,
  createIssue,
  validateIssue,
} from &amp;#39;../types.js&amp;#39;;

describe(&amp;#39;Issue Schema Validation&amp;#39;, () &#x3D;&amp;gt; {
  test(&amp;#39;validates valid issue with required fields only&amp;#39;, () &#x3D;&amp;gt; {
    const issue: IssueSpec &#x3D; {
      title: &amp;#39;Test Issue&amp;#39;,
      body: &amp;#39;This is a test issue description&amp;#39;,
    };

    const result &#x3D; validateIssue(issue);
    expect(result.valid).toBe(true);
    expect(result.errors).toHaveLength(0);
  });

  test(&amp;#39;validates issue with all fields&amp;#39;, () &#x3D;&amp;gt; {
    const issue: IssueSpec &#x3D; {
      title: &amp;#39;Complete Test Issue&amp;#39;,
      body: &amp;#39;This is a comprehensive test issue with all fields&amp;#39;,
      labels: [&amp;#39;bug&amp;#39;, &amp;#39;priority:high&amp;#39;],
      acceptance_criteria: [&amp;#39;Should fix the bug&amp;#39;, &amp;#39;Should include tests&amp;#39;],
      checklist: [
        { id: &amp;#39;item-1&amp;#39;, text: &amp;#39;Fix the code&amp;#39;, done: false },
        { id: &amp;#39;item-2&amp;#39;, text: &amp;#39;Write tests&amp;#39;, done: true },
      ],
      links: [&amp;#39;https://github.com/example/repo/issues/123&amp;#39;],
    };

    const result &#x3D; validateIssue(issue);
    expect(result.valid).toBe(true);
    expect(result.errors).toHaveLength(0);
  });

  test(&amp;#39;rejects issue with missing title&amp;#39;, () &#x3D;&amp;gt; {
    const issue &#x3D; {
      body: &amp;#39;This has no title&amp;#39;,
    } as Partial&amp;lt;IssueSpec&amp;gt;;

    const result &#x3D; validateIssue(issue);
    expect(result.valid).toBe(false);
    expect(result.errors).toContain(&amp;quot;Field &amp;#39;title&amp;#39; is required&amp;quot;);
  });

  test(&amp;#39;rejects issue with missing body&amp;#39;, () &#x3D;&amp;gt; {
    const issue &#x3D; {
      title: &amp;#39;Title Only&amp;#39;,
    } as Partial&amp;lt;IssueSpec&amp;gt;;

    const result &#x3D; validateIssue(issue);
    expect(result.valid).toBe(false);
    expect(result.errors).toContain(&amp;quot;Field &amp;#39;body&amp;#39; is required&amp;quot;);
  });

  test(&amp;#39;rejects issue with empty title&amp;#39;, () &#x3D;&amp;gt; {
    const issue &#x3D; {
      title: &amp;#39;   &amp;#39;,
      body: &amp;#39;This has empty title&amp;#39;,
    } as Partial&amp;lt;IssueSpec&amp;gt;;

    const result &#x3D; validateIssue(issue);
    expect(result.valid).toBe(false);
    expect(result.errors).toContain(&amp;quot;Field &amp;#39;title&amp;#39; is required&amp;quot;);
  });

  test(&amp;#39;rejects title longer than 255 characters&amp;#39;, () &#x3D;&amp;gt; {
    const longTitle &#x3D; &amp;#39;a&amp;#39;.repeat(256);
    const issue: IssueSpec &#x3D; {
      title: longTitle,
      body: &amp;#39;This title is too long&amp;#39;,
    };

    const result &#x3D; validateIssue(issue);
    expect(result.valid).toBe(false);
    expect(result.errors).toContain(&amp;#39;Title exceeds maximum length of 255 characters&amp;#39;);
  });

  test(&amp;#39;validates checklist items structure&amp;#39;, () &#x3D;&amp;gt; {
    const issue: IssueSpec &#x3D; {
      title: &amp;#39;Test Checklist&amp;#39;,
      body: &amp;#39;Testing checklist validation&amp;#39;,
      checklist: [
        { id: &amp;#39;valid-item&amp;#39;, text: &amp;#39;Valid item&amp;#39;, done: false },
        { id: &amp;#39;&amp;#39;, text: &amp;#39;Invalid item - no id&amp;#39;, done: false },
        { id: &amp;#39;no-text&amp;#39;, text: &amp;#39;&amp;#39;, done: false },
      ],
    };

    const result &#x3D; validateIssue(issue);
    expect(result.valid).toBe(false);
    expect(result.errors).toContain(&amp;quot;Checklist item 1 missing required &amp;#39;id&amp;#39; field&amp;quot;);
    expect(result.errors).toContain(&amp;quot;Checklist item 2 missing required &amp;#39;text&amp;#39; field&amp;quot;);
  });
});

describe(&amp;#39;Issue Creation Helpers&amp;#39;, () &#x3D;&amp;gt; {
  test(&amp;#39;createIssue creates valid issue with defaults&amp;#39;, () &#x3D;&amp;gt; {
    const issue &#x3D; createIssue({
      title: &amp;#39;New Issue&amp;#39;,
      body: &amp;#39;New issue description&amp;#39;,
    });

    expect(issue.title).toBe(&amp;#39;New Issue&amp;#39;);
    expect(issue.body).toBe(&amp;#39;New issue description&amp;#39;);
    expect(issue.labels).toEqual([]);
    expect(issue.acceptance_criteria).toEqual([]);
    expect(issue.checklist).toEqual([]);
    expect(issue.links).toEqual([]);

    const validation &#x3D; validateIssue(issue);
    expect(validation.valid).toBe(true);
  });

  test(&amp;#39;createIssue merges provided optional fields&amp;#39;, () &#x3D;&amp;gt; {
    const issue &#x3D; createIssue({
      title: &amp;#39;New Issue&amp;#39;,
      body: &amp;#39;New issue description&amp;#39;,
      labels: [&amp;#39;feature&amp;#39;],
      acceptance_criteria: [&amp;#39;Must work&amp;#39;],
      links: [&amp;#39;https://example.com&amp;#39;],
    });

    expect(issue.labels).toEqual([&amp;#39;feature&amp;#39;]);
    expect(issue.acceptance_criteria).toEqual([&amp;#39;Must work&amp;#39;]);
    expect(issue.links).toEqual([&amp;#39;https://example.com&amp;#39;]);
  });

  test(&amp;#39;createChecklistItem generates proper structure&amp;#39;, () &#x3D;&amp;gt; {
    const item &#x3D; createChecklistItem(&amp;#39;Test item&amp;#39;, true);

    expect(item.text).toBe(&amp;#39;Test item&amp;#39;);
    expect(item.done).toBe(true);
    expect(item.id).toMatch(/^item-\d+-[a-z0-9]+$/);
  });

  test(&amp;#39;createChecklistItem defaults done to false&amp;#39;, () &#x3D;&amp;gt; {
    const item &#x3D; createChecklistItem(&amp;#39;Test item&amp;#39;);

    expect(item.done).toBe(false);
  });
});

describe(&amp;#39;Issue Validation Configuration&amp;#39;, () &#x3D;&amp;gt; {
  test(&amp;#39;uses custom validation config&amp;#39;, () &#x3D;&amp;gt; {
    const customConfig &#x3D; {
      maxTitleLength: 50,
      requiredFields: [&amp;#39;title&amp;#39;] as (keyof IssueSpec)[],
    };

    const issue: IssueSpec &#x3D; {
      title: &amp;#39;a&amp;#39;.repeat(51), // Exceeds custom limit
      body: &amp;#39;Body is not required in custom config&amp;#39;,
    };

    const result &#x3D; validateIssue(issue, customConfig);
    expect(result.valid).toBe(false);
    expect(result.errors).toContain(&amp;#39;Title exceeds maximum length of 50 characters&amp;#39;);
    // Should not complain about missing body since it&amp;#39;s not in requiredFields
    expect(result.errors.some(e &#x3D;&amp;gt; e.includes(&amp;#39;body&amp;#39;))).toBe(false);
  });

  test(&amp;#39;default configuration values&amp;#39;, () &#x3D;&amp;gt; {
    expect(DEFAULT_ISSUE_VALIDATION.maxTitleLength).toBe(255);
    expect(DEFAULT_ISSUE_VALIDATION.requiredFields).toEqual([&amp;#39;title&amp;#39;, &amp;#39;body&amp;#39;]);
  });
});
</pre>
                </div>
            </div>
            <div class="file-section" id="file-169">
                <div class="file-header">ğŸ“„ apps/api/src/handlers/examples/spec-validator.ts</div>
                <div class="file-content">
                    <pre>/**
 * Example: Spec validation handler
 * Automatically validates CUE specifications when changes are detected
 */

import type { HandlerModule, WebhookHandler } from &amp;#39;../types.js&amp;#39;;

const handleSpecValidation: WebhookHandler &#x3D; async (payload, context) &#x3D;&amp;gt; {
  const { logger, services, projectId } &#x3D; context;
  const { parsed } &#x3D; payload;

  logger.info(&amp;#39;Processing spec validation handler&amp;#39;, {
    event: parsed.eventType,
    repository: parsed.repository.fullName,
    commitCount: parsed.commits?.length || 0,
  });

  try {
    // Check if any CUE files were modified
    const specFiles &#x3D;
      parsed.commits?.flatMap(commit &#x3D;&amp;gt; [
        ...commit.added.filter(file &#x3D;&amp;gt; file.endsWith(&amp;#39;.cue&amp;#39;)),
        ...commit.modified.filter(file &#x3D;&amp;gt; file.endsWith(&amp;#39;.cue&amp;#39;)),
      ]) || [];

    if (specFiles.length &#x3D;&#x3D;&#x3D; 0) {
      logger.debug(&amp;#39;No CUE files changed, skipping validation&amp;#39;);
      return {
        success: true,
        message: &amp;#39;No CUE files changed&amp;#39;,
        actions: [],
      };
    }

    logger.info(&amp;#39;CUE files detected for validation&amp;#39;, {
      files: specFiles,
      count: specFiles.length,
    });

    const actions: string[] &#x3D; [];

    // Trigger spec validation event
    await services.events.broadcastToProject(projectId, {
      project_id: projectId,
      event_type: &amp;#39;validation_started&amp;#39;,
      data: {
        trigger: &amp;#39;spec_validation_handler&amp;#39;,
        repository: parsed.repository.fullName,
        ref: payload.ref,
        specFiles,
        commits:
          parsed.commits?.map(c &#x3D;&amp;gt; ({
            sha: c.sha,
            message: c.message,
            author: c.author,
          })) || [],
      },
    });

    actions.push(&#x60;Triggered validation for ${specFiles.length} CUE files&#x60;);

    // For each spec file, log what changed
    for (const file of specFiles) {
      const commit &#x3D; parsed.commits?.find(c &#x3D;&amp;gt; c.added.includes(file) || c.modified.includes(file));

      if (commit) {
        const action &#x3D; commit.added.includes(file) ? &amp;#39;added&amp;#39; : &amp;#39;modified&amp;#39;;
        logger.info(&#x60;Spec file ${action}&#x60;, {
          file,
          commit: commit.sha,
          message: commit.message,
        });

        actions.push(&#x60;Detected ${action} spec file: ${file}&#x60;);
      }
    }

    // Check for breaking changes based on commit messages
    const breakingChanges &#x3D;
      parsed.commits?.filter(
        commit &#x3D;&amp;gt;
          commit.message.toLowerCase().includes(&amp;#39;breaking&amp;#39;) ||
          commit.message.toLowerCase().includes(&amp;#39;breaking change&amp;#39;) ||
          commit.message.includes(&amp;#39;BREAKING CHANGE:&amp;#39;)
      ) || [];

    if (breakingChanges.length &amp;gt; 0) {
      logger.warn(&amp;#39;Breaking changes detected in spec files&amp;#39;, {
        commits: breakingChanges.map(c &#x3D;&amp;gt; ({ sha: c.sha, message: c.message })),
      });

      // Broadcast breaking change warning
      await services.events.broadcastToProject(projectId, {
        project_id: projectId,
        event_type: &amp;#39;validation_started&amp;#39;,
        data: {
          trigger: &amp;#39;breaking_change_detection&amp;#39;,
          repository: parsed.repository.fullName,
          breakingChanges: breakingChanges.map(c &#x3D;&amp;gt; ({
            sha: c.sha,
            message: c.message,
            author: c.author,
          })),
          warning: &amp;#39;Breaking changes detected in specification files&amp;#39;,
        },
      });

      actions.push(&#x60;âš ï¸ Detected ${breakingChanges.length} commits with breaking changes&#x60;);
    }

    // Check for assembly files specifically
    const assemblyFiles &#x3D; specFiles.filter(
      file &#x3D;&amp;gt; file.includes(&amp;#39;assembly&amp;#39;) || file.includes(&amp;#39;.assembly.cue&amp;#39;)
    );

    if (assemblyFiles.length &amp;gt; 0) {
      logger.info(&amp;#39;Assembly files detected, triggering comprehensive validation&amp;#39;, {
        assemblyFiles,
      });

      await services.events.broadcastToProject(projectId, {
        project_id: projectId,
        event_type: &amp;#39;validation_started&amp;#39;,
        data: {
          trigger: &amp;#39;assembly_validation&amp;#39;,
          repository: parsed.repository.fullName,
          assemblyFiles,
          validationType: &amp;#39;comprehensive&amp;#39;,
        },
      });

      actions.push(
        &#x60;ğŸ—ï¸ Triggered comprehensive validation for ${assemblyFiles.length} assembly files&#x60;
      );
    }

    // Estimate validation complexity
    const totalLines &#x3D;
      parsed.commits?.reduce((sum, commit) &#x3D;&amp;gt; {
        return sum + (commit.added.length + commit.modified.length);
      }, 0) || 0;

    let complexity &#x3D; &amp;#39;low&amp;#39;;
    if (totalLines &amp;gt; 50 || breakingChanges.length &amp;gt; 0) {
      complexity &#x3D; &amp;#39;high&amp;#39;;
    } else if (totalLines &amp;gt; 20 || assemblyFiles.length &amp;gt; 0) {
      complexity &#x3D; &amp;#39;medium&amp;#39;;
    }

    logger.info(&amp;#39;Validation complexity estimated&amp;#39;, {
      complexity,
      totalLines,
      specFiles: specFiles.length,
      assemblyFiles: assemblyFiles.length,
      breakingChanges: breakingChanges.length,
    });

    return {
      success: true,
      message: &#x60;Validation triggered for ${specFiles.length} CUE files&#x60;,
      actions,
      data: {
        specFilesChanged: specFiles.length,
        assemblyFilesChanged: assemblyFiles.length,
        breakingChangesDetected: breakingChanges.length,
        validationComplexity: complexity,
        repository: parsed.repository.fullName,
        ref: payload.ref,
      },
    };
  } catch (error) {
    logger.error(&amp;#39;Spec validation handler failed&amp;#39;, error as Error);

    return {
      success: false,
      message: &amp;#39;Spec validation handler execution failed&amp;#39;,
      errors: [
        {
          code: &amp;#39;VALIDATION_HANDLER_ERROR&amp;#39;,
          message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
          stack: error instanceof Error ? error.stack : undefined,
        },
      ],
    };
  }
};

const handlerModule: HandlerModule &#x3D; {
  handler: handleSpecValidation,
  config: {
    enabled: true,
    timeout: 20000,
    retries: 1,
    environment: {
      VALIDATION_MODE: &amp;#39;strict&amp;#39;,
    },
    secrets: {},
  },
  metadata: {
    name: &amp;#39;Spec Validation Handler&amp;#39;,
    description: &amp;#39;Automatically validates CUE specifications when changes are detected in commits&amp;#39;,
    version: &amp;#39;1.0.0&amp;#39;,
    author: &amp;#39;Arbiter Team&amp;#39;,
    supportedEvents: [&amp;#39;push&amp;#39;, &amp;#39;Push Hook&amp;#39;],
    requiredPermissions: [&amp;#39;events:publish&amp;#39;, &amp;#39;validation:trigger&amp;#39;],
  },
};

export default handlerModule;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-170">
                <div class="file-header">ğŸ“„ README.md</div>
                <div class="file-content">
                    <pre># test-project

This is a CUE project created with Arbiter CLI.

## Getting Started

âš ï¸ **IMPORTANT**: This project has been initialized with basic structure only.
To add functionality, use the Arbiter CLI commands to build your specification:

### 1. Add components to your specification:

&#x60;&#x60;&#x60;bash
# Add API endpoints, data models, configurations, etc.
arbiter add &amp;lt;component-type&amp;gt; &amp;lt;name&amp;gt;
&#x60;&#x60;&#x60;

### 2. Generate project files from your specification:

&#x60;&#x60;&#x60;bash
arbiter generate
&#x60;&#x60;&#x60;

### 3. Validate your configuration:

&#x60;&#x60;&#x60;bash
arbiter check
&#x60;&#x60;&#x60;

## Project Structure

- &#x60;cue.mod/&#x60; - CUE module configuration
- &#x60;.arbiter/config.json&#x60; - Arbiter CLI configuration
- Generated CUE files will appear after running &#x60;arbiter generate&#x60;

## Learn More

- [CUE Documentation](https://cuelang.org/docs/)
- [Arbiter CLI](https://github.com/arbiter/cli)
</pre>
                </div>
            </div>
            <div class="file-section" id="file-171">
                <div class="file-header">ğŸ“„ docs/CLEANUP_BASELINE.md</div>
                <div class="file-content">
                    <pre># BASELINE METRICS - Tue Sep 2 18:01:44 EDT 2025

## File Count Analysis
</pre>
                </div>
            </div>
            <div class="file-section" id="file-172">
                <div class="file-header">ğŸ“„ demo-project/index.html</div>
                <div class="file-content">
                    <pre>&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang&#x3D;&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset&#x3D;&amp;quot;UTF-8&amp;quot; /&amp;gt;
    &amp;lt;link rel&#x3D;&amp;quot;icon&amp;quot; type&#x3D;&amp;quot;image/svg+xml&amp;quot; href&#x3D;&amp;quot;/vite.svg&amp;quot; /&amp;gt;
    &amp;lt;meta name&#x3D;&amp;quot;viewport&amp;quot; content&#x3D;&amp;quot;width&#x3D;device-width, initial-scale&#x3D;1.0&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;demo-project&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id&#x3D;&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script type&#x3D;&amp;quot;module&amp;quot; src&#x3D;&amp;quot;/src/main.tsx&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-173">
                <div class="file-header">ğŸ“„ apps/web/frontend/src/App.test.tsx</div>
                <div class="file-content">
                    <pre>/**
 * Temporary test app to verify Monaco Editor CUE syntax highlighting
 */

import React from &amp;#39;react&amp;#39;;
import MonacoTest from &amp;#39;./MonacoTest&amp;#39;;

function TestApp() {
  return &amp;lt;MonacoTest /&amp;gt;;
}

export default TestApp;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-174">
                <div class="file-header">ğŸ“„ tests/e2e-docker-compose/app/package.json</div>
                <div class="file-content">
                    <pre>{
  &amp;quot;name&amp;quot;: &amp;quot;e2e-test-app&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;start&amp;quot;: &amp;quot;node index.js&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;express&amp;quot;: &amp;quot;^4.18.2&amp;quot;
  }
}
</pre>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Load self-contained bundle (includes React, ReactDOM, React Arborist, and Lucide React) -->
    <script src="assets/scribe-tree-bundle.js"></script>
    
    <script>
        // File data from Handlebars template
        const fileData = [
            {
                path: "DIRECTORY_MAP.txt",
                icon: "file-text",
                index: 0,
                size: "47.84 KB",
                tokens: "16,408",
                score: "1.00"
            },
            {
                path: "packages/cli/src/validation/warnings.ts",
                icon: "file-code",
                index: 1,
                size: "18.86 KB",
                tokens: "3,783",
                score: "0.85"
            },
            {
                path: "apps/api/src/ir.ts",
                icon: "file-code",
                index: 2,
                size: "14.62 KB",
                tokens: "3,035",
                score: "0.85"
            },
            {
                path: "packages/cli/src/constraints/core.ts",
                icon: "file-code",
                index: 3,
                size: "12.57 KB",
                tokens: "2,602",
                score: "0.85"
            },
            {
                path: "apps/api/src/db.ts",
                icon: "file-code",
                index: 4,
                size: "16.22 KB",
                tokens: "3,489",
                score: "0.85"
            },
            {
                path: "packages/cli/src/config.ts",
                icon: "file-code",
                index: 5,
                size: "9.80 KB",
                tokens: "2,142",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/sharded-storage.ts",
                icon: "file-code",
                index: 6,
                size: "19.21 KB",
                tokens: "4,465",
                score: "0.85"
            },
            {
                path: "apps/api/src/events.ts",
                icon: "file-code",
                index: 7,
                size: "14.14 KB",
                tokens: "2,849",
                score: "0.85"
            },
            {
                path: "apps/api/src/nats.ts",
                icon: "file-code",
                index: 8,
                size: "6.97 KB",
                tokens: "1,453",
                score: "0.85"
            },
            {
                path: "packages/cli/src/api-client.ts",
                icon: "file-code",
                index: 9,
                size: "15.07 KB",
                tokens: "3,184",
                score: "0.85"
            },
            {
                path: "apps/api/src/handlers/services.ts",
                icon: "file-code",
                index: 10,
                size: "17.12 KB",
                tokens: "3,730",
                score: "0.85"
            },
            {
                path: "packages/cli/src/language-plugins/python.ts",
                icon: "file-code",
                index: 11,
                size: "37.27 KB",
                tokens: "8,346",
                score: "0.85"
            },
            {
                path: "packages/cli/src/language-plugins/typescript.ts",
                icon: "file-code",
                index: 12,
                size: "15.26 KB",
                tokens: "3,445",
                score: "0.85"
            },
            {
                path: "apps/api/src/handlers/discovery.ts",
                icon: "file-code",
                index: 13,
                size: "11.29 KB",
                tokens: "2,274",
                score: "0.85"
            },
            {
                path: "packages/cli/src/language-plugins/go.ts",
                icon: "file-code",
                index: 14,
                size: "37.99 KB",
                tokens: "9,242",
                score: "0.85"
            },
            {
                path: "packages/cli/src/constraints/sandbox.ts",
                icon: "file-code",
                index: 15,
                size: "10.66 KB",
                tokens: "2,176",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/github-template-config.ts",
                icon: "file-code",
                index: 16,
                size: "25.06 KB",
                tokens: "5,647",
                score: "0.85"
            },
            {
                path: "packages/cli/src/language-plugins/rust.ts",
                icon: "file-code",
                index: 17,
                size: "47.03 KB",
                tokens: "10,663",
                score: "0.85"
            },
            {
                path: "packages/shared/src/utils.ts",
                icon: "file-code",
                index: 18,
                size: "2.54 KB",
                tokens: "538",
                score: "0.72"
            },
            {
                path: "packages/cli/src/constraints/filesystem.ts",
                icon: "file-code",
                index: 19,
                size: "13.71 KB",
                tokens: "2,736",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/surface.ts",
                icon: "file-code",
                index: 20,
                size: "8.21 KB",
                tokens: "1,628",
                score: "0.85"
            },
            {
                path: "packages/cli/src/connection-validator.ts",
                icon: "file-code",
                index: 21,
                size: "5.21 KB",
                tokens: "1,045",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/diff.ts",
                icon: "file-code",
                index: 22,
                size: "16.96 KB",
                tokens: "3,800",
                score: "0.85"
            },
            {
                path: "packages/cli/src/constraints/idempotency.ts",
                icon: "file-code",
                index: 23,
                size: "19.95 KB",
                tokens: "4,326",
                score: "0.85"
            },
            {
                path: "apps/api/src/auth.ts",
                icon: "file-code",
                index: 24,
                size: "7.25 KB",
                tokens: "1,461",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/sync.ts",
                icon: "file-code",
                index: 25,
                size: "26.66 KB",
                tokens: "5,979",
                score: "0.85"
            },
            {
                path: "apps/api/src/handlers/executor.ts",
                icon: "file-code",
                index: 26,
                size: "17.50 KB",
                tokens: "3,477",
                score: "0.85"
            },
            {
                path: "apps/api/src/handlers/manager.ts",
                icon: "file-code",
                index: 27,
                size: "16.35 KB",
                tokens: "3,366",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/github-templates.ts",
                icon: "file-code",
                index: 28,
                size: "15.74 KB",
                tokens: "3,678",
                score: "0.85"
            },
            {
                path: "packages/cli/src/constraints/monitoring.ts",
                icon: "file-code",
                index: 29,
                size: "19.37 KB",
                tokens: "4,172",
                score: "0.85"
            },
            {
                path: "packages/cli/src/constraints/schema.ts",
                icon: "file-code",
                index: 30,
                size: "14.62 KB",
                tokens: "2,921",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/git-detection.ts",
                icon: "file-code",
                index: 31,
                size: "8.91 KB",
                tokens: "1,943",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/file-based-template-manager.ts",
                icon: "file-code",
                index: 32,
                size: "21.88 KB",
                tokens: "4,541",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/smart-naming.ts",
                icon: "file-code",
                index: 33,
                size: "12.93 KB",
                tokens: "2,805",
                score: "0.85"
            },
            {
                path: "packages/shared/src/types.ts",
                icon: "file-code",
                index: 34,
                size: "43.00 B",
                tokens: "10",
                score: "0.60"
            },
            {
                path: "apps/api/src/server.ts",
                icon: "file-code",
                index: 35,
                size: "11.48 KB",
                tokens: "2,450",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/template.ts",
                icon: "file-code",
                index: 36,
                size: "9.26 KB",
                tokens: "1,939",
                score: "0.85"
            },
            {
                path: "apps/api/src/handlers/api.ts",
                icon: "file-code",
                index: 37,
                size: "10.47 KB",
                tokens: "2,168",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/import.ts",
                icon: "file-code",
                index: 38,
                size: "16.43 KB",
                tokens: "3,466",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/types/architecture.ts",
                icon: "file-code",
                index: 39,
                size: "5.52 KB",
                tokens: "1,289",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/design-system/tokens.ts",
                icon: "file-code",
                index: 40,
                size: "7.32 KB",
                tokens: "2,732",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/generate.ts",
                icon: "file-code",
                index: 41,
                size: "116.29 KB",
                tokens: "26,032",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/check.ts",
                icon: "file-code",
                index: 42,
                size: "9.63 KB",
                tokens: "2,065",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/create.ts",
                icon: "file-code",
                index: 43,
                size: "17.73 KB",
                tokens: "3,863",
                score: "0.85"
            },
            {
                path: "apps/api/src/utils.ts",
                icon: "file-code",
                index: 44,
                size: "8.85 KB",
                tokens: "1,987",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/services/api.ts",
                icon: "file-code",
                index: 45,
                size: "9.21 KB",
                tokens: "2,035",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/ux-polish.ts",
                icon: "file-code",
                index: 46,
                size: "12.54 KB",
                tokens: "2,712",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/docs.ts",
                icon: "file-code",
                index: 47,
                size: "23.71 KB",
                tokens: "6,055",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/init.ts",
                icon: "file-code",
                index: 48,
                size: "8.00 KB",
                tokens: "1,873",
                score: "0.85"
            },
            {
                path: "apps/api/src/handlers/examples/slack-notification.ts",
                icon: "file-code",
                index: 49,
                size: "8.53 KB",
                tokens: "1,701",
                score: "0.85"
            },
            {
                path: "apps/api/src/webhooks.ts",
                icon: "file-code",
                index: 50,
                size: "13.22 KB",
                tokens: "2,629",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/progress.ts",
                icon: "file-code",
                index: 51,
                size: "13.85 KB",
                tokens: "3,039",
                score: "0.85"
            },
            {
                path: "packages/cli/src/cue/index.ts",
                icon: "file-code",
                index: 52,
                size: "19.15 KB",
                tokens: "4,353",
                score: "0.85"
            },
            {
                path: "examples/external-agent.ts",
                icon: "file-code",
                index: 53,
                size: "7.35 KB",
                tokens: "1,555",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/templates.ts",
                icon: "file-code",
                index: 54,
                size: "10.65 KB",
                tokens: "2,219",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/github-template.ts",
                icon: "file-code",
                index: 55,
                size: "20.29 KB",
                tokens: "4,133",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/performance.ts",
                icon: "file-code",
                index: 56,
                size: "7.62 KB",
                tokens: "1,747",
                score: "0.85"
            },
            {
                path: "apps/api/src/types.ts",
                icon: "file-code",
                index: 57,
                size: "6.93 KB",
                tokens: "1,602",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/github-templates.ts",
                icon: "file-code",
                index: 58,
                size: "21.60 KB",
                tokens: "4,555",
                score: "0.85"
            },
            {
                path: "packages/cli/src/types.ts",
                icon: "file-code",
                index: 59,
                size: "17.26 KB",
                tokens: "3,614",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/.storybook/preview.ts",
                icon: "file-code",
                index: 60,
                size: "6.89 KB",
                tokens: "1,583",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/epic.ts",
                icon: "file-code",
                index: 61,
                size: "33.22 KB",
                tokens: "7,735",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/utils/diagramLayout.ts",
                icon: "file-code",
                index: 62,
                size: "11.60 KB",
                tokens: "2,470",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/execute.ts",
                icon: "file-code",
                index: 63,
                size: "33.55 KB",
                tokens: "7,273",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/types/api.ts",
                icon: "file-code",
                index: 64,
                size: "6.87 KB",
                tokens: "1,620",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/webhook.ts",
                icon: "file-code",
                index: 65,
                size: "13.09 KB",
                tokens: "2,822",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/platform-detection.ts",
                icon: "file-code",
                index: 66,
                size: "8.63 KB",
                tokens: "1,895",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/utils/logger.ts",
                icon: "file-code",
                index: 67,
                size: "5.72 KB",
                tokens: "1,381",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/validate.ts",
                icon: "file-code",
                index: 68,
                size: "8.92 KB",
                tokens: "1,881",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/file-watcher.ts",
                icon: "file-code",
                index: 69,
                size: "6.29 KB",
                tokens: "1,349",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/formatting.ts",
                icon: "file-code",
                index: 70,
                size: "6.52 KB",
                tokens: "1,583",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/add.ts",
                icon: "file-code",
                index: 71,
                size: "39.56 KB",
                tokens: "8,434",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/watch.ts",
                icon: "file-code",
                index: 72,
                size: "10.79 KB",
                tokens: "2,416",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/ide.ts",
                icon: "file-code",
                index: 73,
                size: "22.15 KB",
                tokens: "5,100",
                score: "0.85"
            },
            {
                path: "apps/api/src/migrations/run.ts",
                icon: "file-code",
                index: 74,
                size: "8.41 KB",
                tokens: "1,751",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/debounce.ts",
                icon: "file-code",
                index: 75,
                size: "1.31 KB",
                tokens: "301",
                score: "0.66"
            },
            {
                path: "apps/web/frontend/.storybook/main.ts",
                icon: "file-code",
                index: 76,
                size: "478.00 B",
                tokens: "124",
                score: "0.62"
            },
            {
                path: "apps/web/frontend/src/vite-env.d.ts",
                icon: "file-code",
                index: 77,
                size: "38.00 B",
                tokens: "10",
                score: "0.60"
            },
            {
                path: "apps/api/src/specEngine.ts",
                icon: "file-code",
                index: 78,
                size: "26.89 KB",
                tokens: "5,388",
                score: "0.17"
            },
            {
                path: "tests/e2e-docker-compose/src/index.ts",
                icon: "file-code",
                index: 79,
                size: "246.00 B",
                tokens: "63",
                score: "0.17"
            },
            {
                path: "packages/cli/src/commands/check-connection.ts",
                icon: "file-code",
                index: 80,
                size: "4.57 KB",
                tokens: "861",
                score: "0.82"
            },
            {
                path: "packages/cli/src/language-plugins/index.ts",
                icon: "file-code",
                index: 81,
                size: "5.10 KB",
                tokens: "1,026",
                score: "0.85"
            },
            {
                path: "apps/api/src/handlers/examples/push-handler.ts",
                icon: "file-code",
                index: 82,
                size: "3.94 KB",
                tokens: "808",
                score: "0.79"
            },
            {
                path: "scripts/update-version.js",
                icon: "file-code",
                index: 83,
                size: "2.75 KB",
                tokens: "668",
                score: "0.73"
            },
            {
                path: "packages/shared/src/version.ts",
                icon: "file-code",
                index: 84,
                size: "2.44 KB",
                tokens: "553",
                score: "0.72"
            },
            {
                path: "scripts/sync-versions.ts",
                icon: "file-code",
                index: 85,
                size: "4.12 KB",
                tokens: "909",
                score: "0.80"
            },
            {
                path: "apps/web/frontend/src/design-system/index.ts",
                icon: "file-code",
                index: 86,
                size: "2.11 KB",
                tokens: "426",
                score: "0.70"
            },
            {
                path: "apps/web/frontend/playwright.config.ts",
                icon: "file-code",
                index: 87,
                size: "1.95 KB",
                tokens: "477",
                score: "0.69"
            },
            {
                path: "apps/web/frontend/tailwind.config.js",
                icon: "file-code",
                index: 88,
                size: "1.77 KB",
                tokens: "479",
                score: "0.68"
            },
            {
                path: "packages/cli/src/commands/rename.ts",
                icon: "file-code",
                index: 89,
                size: "5.44 KB",
                tokens: "1,167",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/components/diagrams/CueShowcase.stories.tsx",
                icon: "file-code",
                index: 90,
                size: "3.11 KB",
                tokens: "643",
                score: "0.67"
            },
            {
                path: "apps/web/frontend/src/components/diagrams/index.ts",
                icon: "file-code",
                index: 91,
                size: "1.30 KB",
                tokens: "264",
                score: "0.66"
            },
            {
                path: "docs/webhooks.md",
                icon: "file-text",
                index: 92,
                size: "12.63 KB",
                tokens: "2,100",
                score: "0.26"
            },
            {
                path: "apps/web/frontend/src/design-system/components/Button.tsx",
                icon: "file-code",
                index: 93,
                size: "2.77 KB",
                tokens: "633",
                score: "0.65"
            },
            {
                path: "apps/web/frontend/vite.config.ts",
                icon: "file-code",
                index: 94,
                size: "911.00 B",
                tokens: "241",
                score: "0.64"
            },
            {
                path: "packages/shared/src/migration.ts",
                icon: "file-code",
                index: 95,
                size: "877.00 B",
                tokens: "212",
                score: "0.64"
            },
            {
                path: "apps/web/frontend/src/components/Handlers/Handlers.tsx",
                icon: "file-code",
                index: 96,
                size: "2.51 KB",
                tokens: "522",
                score: "0.64"
            },
            {
                path: "packages/cli/src/index.ts",
                icon: "file-code",
                index: 97,
                size: "703.00 B",
                tokens: "149",
                score: "0.63"
            },
            {
                path: "apps/web/frontend/eslint.config.js",
                icon: "file-code",
                index: 98,
                size: "617.00 B",
                tokens: "143",
                score: "0.63"
            },
            {
                path: "demo-project/src/App.tsx",
                icon: "file-code",
                index: 99,
                size: "179.00 B",
                tokens: "50",
                score: "0.52"
            },
            {
                path: "apps/web/frontend/src/components/diagrams/DataViewer.tsx",
                icon: "file-code",
                index: 100,
                size: "2.28 KB",
                tokens: "544",
                score: "0.62"
            },
            {
                path: "apps/web/frontend/src/components/Handlers/index.ts",
                icon: "file-code",
                index: 101,
                size: "342.00 B",
                tokens: "65",
                score: "0.61"
            },
            {
                path: "apps/web/frontend/src/components/Layout/Tabs.tsx",
                icon: "file-code",
                index: 102,
                size: "2.04 KB",
                tokens: "503",
                score: "0.61"
            },
            {
                path: "demo-project/vite.config.ts",
                icon: "file-code",
                index: 103,
                size: "329.00 B",
                tokens: "90",
                score: "0.61"
            },
            {
                path: "apps/web/frontend/src/components/diagrams/SplitViewShowcase.tsx",
                icon: "file-code",
                index: 104,
                size: "1.94 KB",
                tokens: "490",
                score: "0.61"
            },
            {
                path: "packages/shared/src/index.ts",
                icon: "file-code",
                index: 105,
                size: "202.00 B",
                tokens: "42",
                score: "0.61"
            },
            {
                path: "apps/api/src/handlers/types.ts",
                icon: "file-code",
                index: 106,
                size: "5.68 KB",
                tokens: "1,227",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/components/charts/index.ts",
                icon: "file-code",
                index: 107,
                size: "171.00 B",
                tokens: "36",
                score: "0.60"
            },
            {
                path: "packages/api-types/src/index.ts",
                icon: "file-code",
                index: 108,
                size: "122.00 B",
                tokens: "26",
                score: "0.60"
            },
            {
                path: "apps/web/frontend/postcss.config.js",
                icon: "file-code",
                index: 109,
                size: "81.00 B",
                tokens: "20",
                score: "0.60"
            },
            {
                path: "demo-project/src/vite-env.d.ts",
                icon: "file-code",
                index: 110,
                size: "38.00 B",
                tokens: "10",
                score: "0.60"
            },
            {
                path: "apps/web/frontend/src/components/Layout/TopBar.stories.tsx",
                icon: "file-code",
                index: 111,
                size: "3.17 KB",
                tokens: "757",
                score: "0.67"
            },
            {
                path: "apps/web/frontend/src/components/Handlers/HandlersErrorBoundary.tsx",
                icon: "file-code",
                index: 112,
                size: "4.08 KB",
                tokens: "867",
                score: "0.71"
            },
            {
                path: "scripts/local-ci.sh",
                icon: "terminal",
                index: 113,
                size: "1.12 KB",
                tokens: "309",
                score: "0.57"
            },
            {
                path: "apps/web/frontend/.storybook/decorators.tsx",
                icon: "file-code",
                index: 114,
                size: "867.00 B",
                tokens: "209",
                score: "0.55"
            },
            {
                path: "apps/web/frontend/tsconfig.json",
                icon: "braces",
                index: 115,
                size: "119.00 B",
                tokens: "31",
                score: "0.51"
            },
            {
                path: "packages/shared/package.json",
                icon: "package",
                index: 116,
                size: "748.00 B",
                tokens: "201",
                score: "0.51"
            },
            {
                path: "biome.json",
                icon: "braces",
                index: 117,
                size: "1.82 KB",
                tokens: "412",
                score: "0.51"
            },
            {
                path: "apps/web/frontend/tsconfig.node.json",
                icon: "braces",
                index: 118,
                size: "630.00 B",
                tokens: "145",
                score: "0.51"
            },
            {
                path: "packages/api-types/package.json",
                icon: "package",
                index: 119,
                size: "740.00 B",
                tokens: "197",
                score: "0.51"
            },
            {
                path: "packages/cli/tsconfig.json",
                icon: "braces",
                index: 120,
                size: "1.57 KB",
                tokens: "348",
                score: "0.51"
            },
            {
                path: "apps/web/frontend/tsconfig.app.json",
                icon: "braces",
                index: 121,
                size: "811.00 B",
                tokens: "185",
                score: "0.51"
            },
            {
                path: "packages/api-types/tsconfig.json",
                icon: "braces",
                index: 122,
                size: "366.00 B",
                tokens: "88",
                score: "0.51"
            },
            {
                path: ".prettierrc.json",
                icon: "braces",
                index: 123,
                size: "657.00 B",
                tokens: "176",
                score: "0.51"
            },
            {
                path: "tsconfig.json",
                icon: "braces",
                index: 124,
                size: "1.32 KB",
                tokens: "283",
                score: "0.51"
            },
            {
                path: "packages/cli/example-templates.json",
                icon: "braces",
                index: 125,
                size: "2.16 KB",
                tokens: "470",
                score: "0.51"
            },
            {
                path: "demo-project/package.json",
                icon: "package",
                index: 126,
                size: "519.00 B",
                tokens: "136",
                score: "0.51"
            },
            {
                path: "apps/api/tsconfig.json",
                icon: "braces",
                index: 127,
                size: "980.00 B",
                tokens: "205",
                score: "0.51"
            },
            {
                path: "docker-compose.yml",
                icon: "box",
                index: 128,
                size: "1.60 KB",
                tokens: "375",
                score: "0.51"
            },
            {
                path: "packages/shared/tsconfig.json",
                icon: "braces",
                index: 129,
                size: "384.00 B",
                tokens: "93",
                score: "0.51"
            },
            {
                path: ".arbiter/skald-config.json",
                icon: "braces",
                index: 130,
                size: "316.00 B",
                tokens: "87",
                score: "0.51"
            },
            {
                path: ".lintstagedrc.json",
                icon: "braces",
                index: 131,
                size: "143.00 B",
                tokens: "54",
                score: "0.51"
            },
            {
                path: "demo-project/tsconfig.json",
                icon: "braces",
                index: 132,
                size: "543.00 B",
                tokens: "133",
                score: "0.51"
            },
            {
                path: "apps/web/frontend/src/App.css",
                icon: "palette",
                index: 133,
                size: "606.00 B",
                tokens: "203",
                score: "0.54"
            },
            {
                path: "examples/sample-tasks.json",
                icon: "braces",
                index: 134,
                size: "2.69 KB",
                tokens: "521",
                score: "0.51"
            },
            {
                path: "demo-project/src/main.tsx",
                icon: "file-code",
                index: 135,
                size: "236.00 B",
                tokens: "53",
                score: "0.52"
            },
            {
                path: "apps/web/frontend/src/types/ui.ts",
                icon: "file-code",
                index: 136,
                size: "6.07 KB",
                tokens: "1,462",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/components/Layout/SplitPane.tsx",
                icon: "file-code",
                index: 137,
                size: "4.16 KB",
                tokens: "979",
                score: "0.72"
            },
            {
                path: "apps/web/frontend/src/components/diagrams/MermaidRenderer.tsx",
                icon: "file-code",
                index: 138,
                size: "3.83 KB",
                tokens: "934",
                score: "0.70"
            },
            {
                path: "packages/cli/src/constraints/index.ts",
                icon: "file-code",
                index: 139,
                size: "18.32 KB",
                tokens: "3,749",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/components/diagrams/NetworkDiagram.tsx",
                icon: "file-code",
                index: 140,
                size: "3.87 KB",
                tokens: "947",
                score: "0.70"
            },
            {
                path: "packages/cli/src/validation/__tests__/debug-spec.test.ts",
                icon: "file-code",
                index: 141,
                size: "2.04 KB",
                tokens: "449",
                score: "0.17"
            },
            {
                path: "packages/cli/example-script-template.sh",
                icon: "terminal",
                index: 142,
                size: "3.94 KB",
                tokens: "1,016",
                score: "0.71"
            },
            {
                path: "apps/web/frontend/src/design-system/components/StatusBadge.tsx",
                icon: "file-code",
                index: 143,
                size: "4.01 KB",
                tokens: "1,110",
                score: "0.71"
            },
            {
                path: "packages/cli/src/commands/export.ts",
                icon: "file-code",
                index: 144,
                size: "11.26 KB",
                tokens: "2,422",
                score: "0.85"
            },
            {
                path: "packages/cli/package.json",
                icon: "package",
                index: 145,
                size: "2.52 KB",
                tokens: "616",
                score: "0.51"
            },
            {
                path: "apps/web/frontend/src/index.css",
                icon: "palette",
                index: 146,
                size: "4.62 KB",
                tokens: "1,278",
                score: "0.74"
            },
            {
                path: "packages/cli/src/commands/check-constrained.ts",
                icon: "file-code",
                index: 147,
                size: "12.86 KB",
                tokens: "2,605",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/design-system/variants.ts",
                icon: "file-code",
                index: 148,
                size: "7.35 KB",
                tokens: "1,949",
                score: "0.85"
            },
            {
                path: "packages/cli/src/utils/github-sync.ts",
                icon: "file-code",
                index: 149,
                size: "30.92 KB",
                tokens: "6,346",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/design-system/components/Sidebar.tsx",
                icon: "file-code",
                index: 150,
                size: "6.28 KB",
                tokens: "1,505",
                score: "0.77"
            },
            {
                path: "apps/web/frontend/src/services/websocket.ts",
                icon: "file-code",
                index: 151,
                size: "10.39 KB",
                tokens: "2,133",
                score: "0.85"
            },
            {
                path: "apps/api/package.json",
                icon: "package",
                index: 152,
                size: "2.36 KB",
                tokens: "665",
                score: "0.51"
            },
            {
                path: "apps/web/frontend/src/minimal.css",
                icon: "palette",
                index: 153,
                size: "3.89 KB",
                tokens: "1,241",
                score: "0.70"
            },
            {
                path: "apps/web/frontend/src/App.tsx",
                icon: "file-code",
                index: 154,
                size: "7.24 KB",
                tokens: "1,660",
                score: "0.77"
            },
            {
                path: "apps/api/src/tests/integration/nats.test.ts",
                icon: "file-code",
                index: 155,
                size: "5.42 KB",
                tokens: "1,169",
                score: "0.17"
            },
            {
                path: "apps/web/frontend/src/design-system/components/NavItem.tsx",
                icon: "file-code",
                index: 156,
                size: "7.43 KB",
                tokens: "1,745",
                score: "0.77"
            },
            {
                path: "apps/web/frontend/src/design-system/components/Breadcrumbs.tsx",
                icon: "file-code",
                index: 157,
                size: "7.23 KB",
                tokens: "1,762",
                score: "0.77"
            },
            {
                path: "apps/web/frontend/src/components/diagrams/FlowDiagram.tsx",
                icon: "file-code",
                index: 158,
                size: "7.00 KB",
                tokens: "1,776",
                score: "0.77"
            },
            {
                path: "packages/cli/src/commands/preview.ts",
                icon: "file-code",
                index: 159,
                size: "12.97 KB",
                tokens: "3,172",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/design-system/components/Input.tsx",
                icon: "file-code",
                index: 160,
                size: "8.06 KB",
                tokens: "1,809",
                score: "0.77"
            },
            {
                path: "apps/web/frontend/src/components/diagrams/PlotsDiagram.tsx",
                icon: "file-code",
                index: 161,
                size: "8.22 KB",
                tokens: "1,818",
                score: "0.77"
            },
            {
                path: "apps/web/frontend/src/design-system/components/Card.tsx",
                icon: "file-code",
                index: 162,
                size: "8.29 KB",
                tokens: "1,823",
                score: "0.77"
            },
            {
                path: "packages/cli/src/utils/__tests__/git-detection.test.ts",
                icon: "file-code",
                index: 163,
                size: "7.43 KB",
                tokens: "1,627",
                score: "0.17"
            },
            {
                path: "packages/cli/src/templates/index.ts",
                icon: "file-code",
                index: 164,
                size: "13.03 KB",
                tokens: "2,791",
                score: "0.85"
            },
            {
                path: "packages/cli/src/commands/compat.ts",
                icon: "file-code",
                index: 165,
                size: "13.81 KB",
                tokens: "2,838",
                score: "0.85"
            },
            {
                path: "apps/web/frontend/src/design-system/components/Checkbox.tsx",
                icon: "file-code",
                index: 166,
                size: "8.44 KB",
                tokens: "1,896",
                score: "0.77"
            },
            {
                path: "packages/shared/src/__tests__/issue-schema.test.ts",
                icon: "file-code",
                index: 167,
                size: "5.45 KB",
                tokens: "1,199",
                score: "0.17"
            },
            {
                path: "apps/api/src/handlers/examples/spec-validator.ts",
                icon: "file-code",
                index: 168,
                size: "6.23 KB",
                tokens: "1,245",
                score: "0.17"
            },
            {
                path: "README.md",
                icon: "book-open",
                index: 169,
                size: "844.00 B",
                tokens: "143",
                score: "0.26"
            },
            {
                path: "docs/CLEANUP_BASELINE.md",
                icon: "file-text",
                index: 170,
                size: "73.00 B",
                tokens: "19",
                score: "0.26"
            },
            {
                path: "demo-project/index.html",
                icon: "globe",
                index: 171,
                size: "361.00 B",
                tokens: "125",
                score: "0.26"
            },
            {
                path: "apps/web/frontend/src/App.test.tsx",
                icon: "file-code",
                index: 172,
                size: "219.00 B",
                tokens: "48",
                score: "0.17"
            },
            {
                path: "tests/e2e-docker-compose/app/package.json",
                icon: "package",
                index: 173,
                size: "172.00 B",
                tokens: "53",
                score: "0.17"
            }
        ];

        // Initialize the file tree
        document.addEventListener('DOMContentLoaded', function() {
            if (window.ScribeFileTree) {
                const fileTree = new window.ScribeFileTree();
                const success = fileTree.renderTree('file-tree-container', fileData);
                
                if (success) {
                    console.log('File tree rendered successfully');
                } else {
                    console.error('Failed to render file tree');
                    // Fallback to simple list
                    const container = document.getElementById('file-tree-container');
                    if (container) {
                        container.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-muted);">Tree view failed to load. Use the file list below.</div>';
                    }
                }
            } else {
                console.error('ScribeFileTree not available');
            }
            
            // Initialize control buttons and ping mechanism
            initializeControls();
        });
        
        // Control functionality
        function initializeControls() {
            // Ping server every 30 seconds to keep alive
            setInterval(pingServer, 30000);
            
            // Initial ping
            pingServer();
            
            // Setup button event listeners
            const saveBtn = document.getElementById('save-btn');
            const shutdownBtn = document.getElementById('shutdown-btn');
            
            if (saveBtn) {
                saveBtn.addEventListener('click', handleSave);
            }
            
            if (shutdownBtn) {
                shutdownBtn.addEventListener('click', handleShutdown);
            }
        }
        
        async function pingServer() {
            try {
                const response = await fetch('/api/ping', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    updateConnectionStatus(true);
                } else {
                    updateConnectionStatus(false);
                }
            } catch (error) {
                console.warn('Ping failed:', error);
                updateConnectionStatus(false);
            }
        }
        
        function updateConnectionStatus(isOnline) {
            const statusDot = document.getElementById('connection-status');
            const statusText = document.getElementById('status-text');
            
            if (statusDot && statusText) {
                if (isOnline) {
                    statusDot.className = 'status-dot online';
                    statusText.textContent = 'Connected';
                } else {
                    statusDot.className = 'status-dot offline';
                    statusText.textContent = 'Disconnected';
                }
            }
        }
        
        async function handleSave() {
            const saveBtn = document.getElementById('save-btn');
            if (!saveBtn) return;
            
            // Disable button and show loading
            saveBtn.disabled = true;
            saveBtn.innerHTML = 'â³ Saving...';
            
            try {
                // Get current selected files from the tree
                const selectedFiles = getSelectedFiles();
                
                const response = await fetch('/api/bundle/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        files: selectedFiles
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    saveBtn.innerHTML = 'âœ… Saved!';
                    setTimeout(() => {
                        saveBtn.innerHTML = 'ğŸ’¾ Save Bundle';
                        saveBtn.disabled = false;
                    }, 2000);
                } else {
                    throw new Error('Save failed');
                }
            } catch (error) {
                console.error('Save error:', error);
                saveBtn.innerHTML = 'âŒ Save Failed';
                setTimeout(() => {
                    saveBtn.innerHTML = 'ğŸ’¾ Save Bundle';
                    saveBtn.disabled = false;
                }, 2000);
            }
        }
        
        async function handleShutdown() {
            if (!confirm('Are you sure you want to shutdown the server?')) {
                return;
            }
            
            const shutdownBtn = document.getElementById('shutdown-btn');
            if (!shutdownBtn) return;
            
            // Disable button and show loading
            shutdownBtn.disabled = true;
            shutdownBtn.innerHTML = 'â³ Shutting down...';
            
            try {
                const response = await fetch('/api/shutdown', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    shutdownBtn.innerHTML = 'âœ… Server stopped';
                    updateConnectionStatus(false);
                    // Show goodbye message
                    setTimeout(() => {
                        document.body.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 100vh; font-size: 24px; color: var(--text-primary);">ğŸ›‘ Server has been shut down</div>';
                    }, 1000);
                } else {
                    throw new Error('Shutdown failed');
                }
            } catch (error) {
                console.error('Shutdown error:', error);
                shutdownBtn.innerHTML = 'âŒ Shutdown Failed';
                setTimeout(() => {
                    shutdownBtn.innerHTML = 'ğŸ›‘ Shutdown Server';
                    shutdownBtn.disabled = false;
                }, 2000);
            }
        }
        
        function getSelectedFiles() {
            // This would integrate with the React tree component
            // For now, return all files as selected
            return fileData.map(file => file.path);
        }
    </script>
</body>
</html>