name: Workflow Orchestration

on:
  push:
    branches: [ main, develop, 'feature/**', 'hotfix/**' ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      force_full_pipeline:
        description: 'Force full pipeline execution (ignore path filters)'
        required: false
        default: false
        type: boolean
      target_environment:
        description: 'Target deployment environment'
        required: false
        default: 'staging'
        type: choice
        options:
        - staging
        - production

# Prevent concurrent orchestration runs
concurrency:
  group: orchestration-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Pipeline coordination and status tracking
  pipeline-coordinator:
    name: Pipeline Coordinator
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      pipeline-id: ${{ steps.setup.outputs.pipeline-id }}
      should-run-full: ${{ steps.setup.outputs.should-run-full }}
      target-env: ${{ steps.setup.outputs.target-env }}
    
    steps:
      - name: Setup pipeline coordination
        id: setup
        run: |
          PIPELINE_ID="${{ github.run_id }}-${{ github.run_attempt }}"
          echo "pipeline-id=$PIPELINE_ID" >> $GITHUB_OUTPUT
          
          # Determine if full pipeline should run
          FORCE_FULL="${{ github.event.inputs.force_full_pipeline || 'false' }}"
          IS_MAIN_BRANCH="${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' }}"
          
          if [ "$FORCE_FULL" = "true" ] || [ "$IS_MAIN_BRANCH" = "true" ]; then
            echo "should-run-full=true" >> $GITHUB_OUTPUT
          else
            echo "should-run-full=false" >> $GITHUB_OUTPUT
          fi
          
          # Determine target environment
          TARGET_ENV="${{ github.event.inputs.target_environment || 'staging' }}"
          if [ "${{ github.ref }}" = "refs/heads/main" ] && [ "${{ github.event_name }}" = "push" ]; then
            TARGET_ENV="production"
          fi
          echo "target-env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Initialize pipeline tracking
        run: |
          echo "# 🎯 CI/CD Pipeline Execution" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Pipeline ID**: \`${{ steps.setup.outputs.pipeline-id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Full Pipeline**: ${{ steps.setup.outputs.should-run-full }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target Environment**: ${{ steps.setup.outputs.target-env }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Pipeline Phases" >> $GITHUB_STEP_SUMMARY
          echo "1. 🚀 **Fast Feedback** - Lint, TypeScript, Unit Tests (2-3 min)" >> $GITHUB_STEP_SUMMARY
          echo "2. 🔗 **Integration** - Contracts, API Tests, Tutorials (5-7 min)" >> $GITHUB_STEP_SUMMARY
          echo "3. 🎭 **End-to-End** - Playwright, Chaos, Load Tests (10-15 min)" >> $GITHUB_STEP_SUMMARY
          echo "4. 🔒 **Quality Gates** - Performance, Security, Compliance (8-12 min)" >> $GITHUB_STEP_SUMMARY
          echo "5. 🚢 **Deployment** - Build, Deploy, Monitor (5-8 min)" >> $GITHUB_STEP_SUMMARY

  # Trigger fast feedback workflow
  trigger-fast-feedback:
    name: Trigger Fast Feedback
    runs-on: ubuntu-latest
    needs: pipeline-coordinator
    steps:
      - name: Trigger Fast Feedback Loop
        uses: actions/github-script@v7
        with:
          script: |
            const { data: workflow } = await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'fast-feedback.yml',
              ref: context.ref
            });
            console.log('Fast feedback workflow triggered');

  # Monitor workflow progress and provide status updates
  pipeline-monitor:
    name: Pipeline Monitor
    runs-on: ubuntu-latest
    needs: [pipeline-coordinator, trigger-fast-feedback]
    if: always()
    
    steps:
      - name: Wait for fast feedback completion
        timeout-minutes: 5
        run: |
          echo "Monitoring fast feedback workflow..."
          # In a real implementation, this would poll the workflow API
          sleep 30
          echo "Fast feedback monitoring complete"

      - name: Check fast feedback status
        uses: actions/github-script@v7
        id: check-fast-feedback
        with:
          script: |
            // Get recent workflow runs for fast feedback
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'fast-feedback.yml',
              head_sha: context.sha,
              per_page: 1
            });
            
            if (runs.workflow_runs.length > 0) {
              const run = runs.workflow_runs[0];
              console.log(`Fast feedback status: ${run.status} - ${run.conclusion}`);
              return run.conclusion === 'success';
            }
            return false;

      - name: Update pipeline status
        run: |
          echo "## 📊 Pipeline Status Update" >> $GITHUB_STEP_SUMMARY
          echo "**Fast Feedback**: ${{ steps.check-fast-feedback.outputs.result == 'true' && '✅ Completed' || '⏳ Running' }}" >> $GITHUB_STEP_SUMMARY

  # Quality gate enforcement
  quality-gate-enforcer:
    name: Quality Gate Enforcer
    runs-on: ubuntu-latest
    needs: pipeline-coordinator
    if: always()
    
    steps:
      - name: Evaluate quality gates
        uses: actions/github-script@v7
        with:
          script: |
            const workflows = [
              'fast-feedback.yml',
              'integration-tests.yml',
              'e2e-tests.yml',
              'performance-security-gates.yml'
            ];
            
            let allPassed = true;
            const results = {};
            
            for (const workflow of workflows) {
              try {
                const { data: runs } = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow,
                  head_sha: context.sha,
                  per_page: 1
                });
                
                if (runs.workflow_runs.length > 0) {
                  const run = runs.workflow_runs[0];
                  results[workflow] = run.conclusion;
                  if (run.conclusion !== 'success') {
                    allPassed = false;
                  }
                }
              } catch (error) {
                console.log(`Could not check ${workflow}: ${error.message}`);
              }
            }
            
            console.log('Quality gate results:', results);
            console.log('All quality gates passed:', allPassed);

      - name: Generate quality report
        run: |
          echo "## 🛡️ Quality Gate Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Workflow | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Fast Feedback | ⏳ Running |" >> $GITHUB_STEP_SUMMARY
          echo "| Integration Tests | ⏳ Pending |" >> $GITHUB_STEP_SUMMARY
          echo "| E2E Tests | ⏳ Pending |" >> $GITHUB_STEP_SUMMARY
          echo "| Security & Performance | ⏳ Pending |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployment | ⏳ Pending |" >> $GITHUB_STEP_SUMMARY

  # PR status update
  update-pr-status:
    name: Update PR Status
    runs-on: ubuntu-latest
    needs: [pipeline-coordinator, quality-gate-enforcer]
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const comment = `## 🔄 CI/CD Pipeline Status
            
            **Pipeline ID**: \`${{ needs.pipeline-coordinator.outputs.pipeline-id }}\`
            **Branch**: \`${{ github.ref_name }}\`
            
            ### Current Status
            - 🚀 **Fast Feedback**: ⏳ Running
            - 🔗 **Integration Tests**: ⏳ Queued
            - 🎭 **End-to-End Tests**: ⏳ Queued  
            - 🔒 **Security & Performance**: ⏳ Queued
            - 🚢 **Deployment**: ⏳ Queued
            
            Pipeline will update automatically as stages complete.
            
            ---
            *This comment will be updated with results as the pipeline progresses.*
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Failure notification and cleanup
  failure-handler:
    name: Failure Handler
    runs-on: ubuntu-latest
    needs: [pipeline-coordinator, pipeline-monitor, quality-gate-enforcer]
    if: failure()
    
    steps:
      - name: Analyze pipeline failures
        run: |
          echo "Analyzing pipeline failures..."
          echo "Pipeline ID: ${{ needs.pipeline-coordinator.outputs.pipeline-id }}"
          echo "Failed jobs detected - initiating failure handling"

      - name: Generate failure report
        run: |
          echo "## ❌ Pipeline Failure Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Pipeline ID**: \`${{ needs.pipeline-coordinator.outputs.pipeline-id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Failure Time**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Failed Jobs" >> $GITHUB_STEP_SUMMARY
          echo "- Pipeline Monitor: ${{ needs.pipeline-monitor.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Quality Gate Enforcer: ${{ needs.quality-gate-enforcer.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Review failed job logs" >> $GITHUB_STEP_SUMMARY
          echo "2. Fix identified issues" >> $GITHUB_STEP_SUMMARY
          echo "3. Push fixes to trigger new pipeline run" >> $GITHUB_STEP_SUMMARY

      - name: Notify on failure (if configured)
        run: |
          echo "Pipeline failure notification would be sent here"
          # Integration with Slack, Teams, email, etc.

  # Success handler
  success-handler:
    name: Success Handler
    runs-on: ubuntu-latest
    needs: [pipeline-coordinator, pipeline-monitor, quality-gate-enforcer]
    if: success()
    
    steps:
      - name: Generate success report
        run: |
          echo "## ✅ Pipeline Success Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Pipeline ID**: \`${{ needs.pipeline-coordinator.outputs.pipeline-id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Completion Time**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "**Target Environment**: ${{ needs.pipeline-coordinator.outputs.target-env }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pipeline Overview" >> $GITHUB_STEP_SUMMARY
          echo "All quality gates have been configured and pipeline orchestration is active." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Actions" >> $GITHUB_STEP_SUMMARY
          echo "- Monitor individual workflow executions" >> $GITHUB_STEP_SUMMARY
          echo "- Review quality gate results as they complete" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment will proceed automatically after all gates pass" >> $GITHUB_STEP_SUMMARY

      - name: Update final PR status
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const comment = `## ✅ Pipeline Orchestration Complete
            
            **Pipeline ID**: \`${{ needs.pipeline-coordinator.outputs.pipeline-id }}\`
            
            The CI/CD pipeline has been successfully orchestrated. Individual workflow stages will execute automatically with proper dependency management and quality gates.
            
            **Quality Gates Configured:**
            - ✅ Fast Feedback Loop (lint, typecheck, unit tests)
            - ✅ Integration Testing (contracts, API, tutorials) 
            - ✅ End-to-End Testing (Playwright, chaos, load)
            - ✅ Security & Performance Gates (scans, benchmarks)
            - ✅ Deployment Pipeline (build, deploy, monitor)
            
            Monitor the individual workflow runs for detailed results.
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });