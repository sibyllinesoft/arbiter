<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Repository Analysis: Scribe Analysis</title>

    <!-- CDN CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2a2a2a;
            --bg-tertiary: #3a3a3a;
            --text-primary: #e5e5e5;
            --text-secondary: #b5b5b5;
            --text-muted: #888;
            --accent-primary: #4f9cf9;
            --accent-secondary: #7c3aed;
            --border-color: #404040;
            --hover-color: #333333;
            --code-bg: #252525;
        }

        * { box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .header {
            background: rgba(255, 255, 255, 0.03);
            padding: 32px;
            border-bottom: 1px solid var(--border-color);
        }

        .header h1 {
            margin: 0;
            font-size: 32px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header .meta {
            margin-top: 20px;
            opacity: 0.9;
            font-size: 13px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            padding: 24px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .stat-card {
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: var(--accent-primary);
        }

        .content {
            padding: 24px;
        }

        .file-section {
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin-bottom: 24px;
            overflow: hidden;
        }

        .file-header {
            padding: 16px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-header:hover {
            background: var(--hover-color);
        }

        .file-path {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            font-weight: 500;
        }

        .file-meta {
            display: flex;
            gap: 16px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .file-content {
            display: none;
            padding: 0;
        }

        .file-content.expanded {
            display: block;
        }

        .code-block {
            background: var(--code-bg);
            padding: 16px;
            margin: 0;
            overflow-x: auto;
        }

        .code-block code {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.5;
        }

        .expand-all {
            margin-bottom: 16px;
            padding: 8px 16px;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .expand-all:hover {
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ“Š Scribe Analysis</h1>
            <div class="meta">
                <span>Generated: 2025-12-04 02:22:06 UTC</span>
                <span>Algorithm: v5-integrated</span>
                <span>Selection Time: 75ms</span>
            </div>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">Total Files</div>
                <div class="stat-value">23</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Total Tokens</div>
                <div class="stat-value">66,931</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Total Size</div>
                <div class="stat-value">295.40 KB</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Coverage</div>
                <div class="stat-value">104.5%</div>
            </div>
        </div>

        <div class="content">
            <button class="expand-all" onclick="toggleAllFiles()">Expand All Files</button>

            <div class="file-section">
                <div class="file-header" onclick="toggleFile(0)">
                    <span class="file-path">file-text DIRECTORY_MAP.txt</span>
                    <div class="file-meta">
                        <span>406.00 B</span>
                        <span>96 tokens</span>
                        <span>Score: 1.00</span>
                    </div>
                </div>
                <div class="file-content" id="file-0">
                    <pre class="code-block"><code>Repository Directory Map
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
Directory
---------
.
/
/home
/home/nathan
/home/nathan/Projects
/home/nathan/Projects/arbiter
/home/nathan/Projects/arbiter/packages
/home/nathan/Projects/arbiter/packages/importer
/home/nathan/Projects/arbiter/packages/importer/src
/home/nathan/Projects/arbiter/packages/importer/src/detection
/home/nathan/Projects/arbiter/packages/importer/src/plugins
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(1)">
                    <span class="file-path">book-open README.md</span>
                    <div class="file-meta">
                        <span>8.03 KB</span>
                        <span>1,263 tokens</span>
                        <span>Score: 3.53</span>
                    </div>
                </div>
                <div class="file-content" id="file-1">
                    <pre class="code-block"><code># @arbiter/importer

Codebase analysis and artifact detection for importing existing projects into
the Arbiter platform.

## Overview

This package provides a plugin-based system for analyzing existing codebases and
automatically detecting architectural artifacts such as services, binaries,
libraries, and jobs. It&amp;#39;s designed to help with reverse engineering and
understanding of legacy codebases for import into Arbiter specifications.

### CLI flags (quick reference)

| Flag | Purpose | Notes |
|------|---------|-------|
| &#x60;--github-url &amp;lt;url&amp;gt;&#x60; | Analyze a remote repo | Fetches branch metadata; good for public repos |
| &#x60;--local-path &amp;lt;path&amp;gt;&#x60; | Analyze a local checkout | Skips network; good for private code |
| &#x60;--ignore &amp;quot;&amp;lt;glob&amp;gt;&amp;quot;&#x60; | Skip expensive/noisy paths | Repeatable; defaults include node_modules/dist |
| &#x60;--deep-analysis&#x60; | Enable heavier heuristics | Slower, better for infra/tests/schema detection |
| &#x60;--target-languages ts,go&#x60; | Restrict plugins | Speeds up polyglot monorepos |
| &#x60;--min-confidence 0.4&#x60; | Filter low-confidence artifacts | Defaults to 0.3 in code |
| &#x60;--max-file-size 10485760&#x60; | Cap file size (bytes) | Guard against binaries |
| &#x60;--max-concurrency 8&#x60; | Tune parallelism | Increase on CI, lower on laptops |

## Features

- **Plugin-based Architecture**: Extensible system for language-specific
  analysis
- **Comprehensive Detection**: Identifies services, binaries, libraries, jobs,
  schemas, and more
- **Confidence Scoring**: Each detected artifact includes confidence metrics
- **Evidence Collection**: Maintains detailed provenance of how artifacts were
  detected
- **Multi-language Support**: Currently supports Rust, with extensible
  architecture for other languages

## Usage

&#x60;&#x60;&#x60;typescript
import { ScannerRunner, getAllPlugins } from &amp;#39;@arbiter/importer&amp;#39;;

// Create scanner with all available plugins
const scanner &#x3D; new ScannerRunner({
  projectRoot: &amp;#39;/path/to/project&amp;#39;,
  plugins: getAllPlugins(),
  parseOptions: {
    deepAnalysis: true,
    targetLanguages: [], // Auto-detect all languages
    maxFileSize: 10 * 1024 * 1024, // 10MB
  },
  inferenceOptions: {
    minConfidence: 0.3,
    inferRelationships: true,
  },
});

// Run analysis
const manifest &#x3D; await scanner.scan();
console.log(&#x60;Found ${manifest.artifacts.length} artifacts&#x60;);
&#x60;&#x60;&#x60;

### Using via the Arbiter CLI

Most users trigger the importer through the CLI instead of programmatic calls:

&#x60;&#x60;&#x60;bash
# Analyze a GitHub repo (recommended when you need branch metadata)
arbiter init --github-url https://github.com/org/project

# Analyze a local checkout
arbiter init --local-path ../project

# Speed up large repos by ignoring heavy folders
arbiter init --local-path ../project --ignore &amp;quot;**/node_modules/**&amp;quot; --ignore &amp;quot;**/dist/**&amp;quot;

# Enable deeper heuristics for infra/tests/schema detection
arbiter init --local-path ../project --deep-analysis
&#x60;&#x60;&#x60;

The CLI writes the detected specification into &#x60;.arbiter&#x60; fragments, which you
can immediately validate (&#x60;arbiter check&#x60;) or generate (&#x60;arbiter generate&#x60;).

## Plugin Development

To create a new language plugin, implement the &#x60;ImporterPlugin&#x60; interface:

&#x60;&#x60;&#x60;typescript
import { ImporterPlugin, Evidence, InferredArtifact } from &amp;#39;@arbiter/importer&amp;#39;;

export class MyLanguagePlugin implements ImporterPlugin {
  name(): string {
    return &amp;#39;my-language&amp;#39;;
  }

  supports(filePath: string, fileContent?: string): boolean {
    return filePath.endsWith(&amp;#39;.mylang&amp;#39;);
  }

  async parse(
    filePath: string,
    fileContent?: string,
    context?: ParseContext
  ): Promise&amp;lt;Evidence[]&amp;gt; {
    // Extract evidence from source files
    return [];
  }

  async infer(
    evidence: Evidence[],
    context: InferenceContext
  ): Promise&amp;lt;InferredArtifact[]&amp;gt; {
    // Infer artifacts from collected evidence
    return [];
  }
}
&#x60;&#x60;&#x60;

## Architecture

The import analysis follows a five-stage pipeline:

1. **Discovery**: File system scanning with ignore patterns
2. **Parse**: Plugin-based evidence collection from source files
3. **Infer**: Artifact inference from collected evidence
4. **Normalize**: De-duplication and confidence merging
5. **Validate**: Sanity checks and consistency validation

### Example Output (trimmed)

&#x60;&#x60;&#x60;json
{
  &amp;quot;project&amp;quot;: { &amp;quot;path&amp;quot;: &amp;quot;/repo&amp;quot;, &amp;quot;fileCount&amp;quot;: 1423, &amp;quot;totalBytes&amp;quot;: 58_230_144 },
  &amp;quot;artifacts&amp;quot;: [
    {
      &amp;quot;kind&amp;quot;: &amp;quot;service&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;api&amp;quot;,
      &amp;quot;language&amp;quot;: &amp;quot;typescript&amp;quot;,
      &amp;quot;framework&amp;quot;: &amp;quot;express&amp;quot;,
      &amp;quot;confidence&amp;quot;: 0.82,
      &amp;quot;evidence&amp;quot;: [&amp;quot;package.json:scripts[start]&amp;quot;, &amp;quot;src/server.ts:Express()&amp;quot;]
    },
    {
      &amp;quot;kind&amp;quot;: &amp;quot;binary&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;migrate&amp;quot;,
      &amp;quot;language&amp;quot;: &amp;quot;rust&amp;quot;,
      &amp;quot;confidence&amp;quot;: 0.74,
      &amp;quot;evidence&amp;quot;: [&amp;quot;Cargo.toml:bin.migrate&amp;quot;, &amp;quot;src/bin/migrate.rs:clap&amp;quot;]
    }
  ],
  &amp;quot;statistics&amp;quot;: { &amp;quot;evidenceCount&amp;quot;: 512, &amp;quot;pluginsUsed&amp;quot;: [&amp;quot;rust&amp;quot;] },
  &amp;quot;configuration&amp;quot;: { &amp;quot;deepAnalysis&amp;quot;: true, &amp;quot;minConfidence&amp;quot;: 0.3 }
}
&#x60;&#x60;&#x60;

## Supported Artifact Types

- **Services**: HTTP APIs, web services, microservices
- **Binaries**: Command-line tools, executables
- **Libraries**: Shared libraries, packages, modules
- **Jobs**: Background jobs, scheduled tasks, workers
- **Schemas**: Database schemas, API schemas
- **Frontends**: Web applications, SPAs
- **Databases**: Database instances, data stores
- **Infrastructure**: Deployment configs, infrastructure as code

## Configuration

The &#x60;ScannerRunner&#x60; accepts a rich configuration object that controls parsing
and inference. Important options include:

- &#x60;parseOptions.deepAnalysis&#x60;: enable more expensive heuristics at the cost of
  runtime
- &#x60;parseOptions.targetLanguages&#x60;: restricts plugins to a set of languages when
  working in polyglot repositories
- &#x60;parseOptions.maxFileSize&#x60;: guards against scanning large binaries that slow
  down the pipeline
- &#x60;inferenceOptions.minConfidence&#x60;: filters out artifacts that do not meet a
  minimum confidence score
- &#x60;ignorePatterns&#x60;: additional glob patterns merged with the built-in defaults
- &#x60;maxConcurrency&#x60;: controls the number of files parsed in parallel when the
  importer streams evidence

Covering these knobs in project-specific presets allows large organisations to
standardise how repositories are analysed.

## Evidence and Artifacts

Plugins collect &#x60;Evidence&#x60; objects during the parse phase; each evidence record
references the file that produced it, the detection heuristic that fired, and a
confidence value. During inference, evidence is aggregated into
&#x60;InferredArtifact&#x60; records that combine metadata, provenance, and supporting
sources. The resulting &#x60;ArtifactManifest&#x60; includes:

- &#x60;project&#x60; metadata such as file counts and aggregate size
- &#x60;artifacts&#x60; for every detected service, module, job, frontend, infrastructure
  asset, and more
- &#x60;provenance&#x60; mappings that explain which evidence justifies each artifact
- &#x60;statistics&#x60; summarising confidence distribution and plugin execution metrics
- &#x60;configuration&#x60; capturing the options used during the scan

## Extending the Pipeline

Implement the &#x60;ImporterPlugin&#x60; interface to add support for additional
languages, frameworks, or infrastructure formats. Plugins typically focus on:

1. Quick &#x60;supports()&#x60; checks to avoid loading unnecessary files
2. Structured parsing with robust error handling in &#x60;parse()&#x60;
3. Combining cross-file evidence inside &#x60;infer()&#x60; to produce confident artifacts

The shared &#x60;PluginRegistry&#x60; and &#x60;ScannerRunner&#x60; utilities handle concurrency,
error isolation, and manifest assembly so plugins can remain focused on their
specific detection logic.

## Performance and Accuracy Tips

- Ignore noisy or generated paths to cut runtime: &#x60;ignorePatterns: [&amp;quot;**/node_modules/**&amp;quot;, &amp;quot;**/dist/**&amp;quot;]&#x60;.
- For monorepos, set &#x60;parseOptions.targetLanguages&#x60; to the primary languages to avoid scanning everything.
- Increase &#x60;maxConcurrency&#x60; on fast disks/CI runners; decrease on laptops to keep fans quiet.
- Raise &#x60;inferenceOptions.minConfidence&#x60; (e.g., 0.5) when you prefer precision over recall.
- Enable &#x60;deepAnalysis&#x60; only when you need schema, infra, and test detection; it is slower but more thorough.

## License

MIT
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(2)">
                    <span class="file-path">book-open src/plugins/README.md</span>
                    <div class="file-meta">
                        <span>4.80 KB</span>
                        <span>793 tokens</span>
                        <span>Score: 3.44</span>
                    </div>
                </div>
                <div class="file-content" id="file-2">
                    <pre class="code-block"><code># Brownfield Detection Plugins

This directory contains plugins for the Arbiter brownfield detection system.
Each plugin implements the &#x60;BrownfieldPlugin&#x60; interface to analyze specific
programming languages and frameworks.

## Available Plugins

### Rust Plugin (&#x60;rust.ts&#x60;)

Comprehensive plugin for detecting Rust artifacts including binaries, libraries,
services, and jobs.

#### File Support Detection

The Rust plugin supports:

- **Cargo.toml** - Main package configuration file
- **Cargo.lock** - Dependency lock file
- **src/main.rs** - Main entry point files
- **src/lib.rs** - Library entry point files
- **src/bin/\*.rs** - Binary source files
- **build.rs** - Build script files

#### Parse Evidence

The plugin extracts structured evidence from:

1. **Cargo.toml Analysis**:
   - Package metadata (name, version, description)
   - Dependencies (runtime, dev, build)
   - Binary definitions (&#x60;[[bin]]&#x60; sections)
   - Library definitions (&#x60;[lib]&#x60; sections)

2. **Rust Source Analysis**:
   - Main function detection (&#x60;fn main()&#x60;)
   - Async runtime detection (&#x60;#[tokio::main]&#x60;, &#x60;#[async_std::main]&#x60;)
   - HTTP server patterns (axum, warp, actix-web, etc.)
   - Port binding detection
   - Public API exports (&#x60;pub mod&#x60;, &#x60;pub fn&#x60;)

3. **Cargo.lock Analysis**:
   - Locked dependency versions
   - Transitive dependency discovery

#### Infer Artifacts

The plugin can infer these artifact types:

1. **Service Artifacts**:
   - Detected when web frameworks are present (axum, warp, actix-web, rocket,
     tide)
   - Extracts port information, framework type, and service dependencies
   - High confidence (0.85) for explicit configurations

2. **Binary Artifacts**:
   - From &#x60;[[bin]]&#x60; sections in Cargo.toml
   - From &#x60;src/bin/*.rs&#x60; files with main functions
   - CLI tool detection via CLI frameworks (clap, structopt, argh)
   - Medium confidence (0.7-0.8) based on source

3. **Library Artifacts**:
   - From &#x60;[lib]&#x60; sections in Cargo.toml
   - From &#x60;src/lib.rs&#x60; files with public exports
   - Extracts public API information
   - High confidence (0.9) for explicit library configurations

4. **Job Artifacts**:
   - Detected when job scheduling frameworks are present
   - Background job and cron job detection
   - Medium confidence (0.75-0.8) based on dependencies

#### Confidence Scoring

- **High confidence (0.9)**: Explicit Cargo.toml configurations
- **Medium confidence (0.7)**: Conventional file layouts and patterns
- **Lower confidence (0.5)**: Dependency-based inferences

#### Framework Detection

The plugin recognizes these Rust frameworks:

- **Web Frameworks**: axum, warp, actix-web, rocket, tide, gotham, iron, poem
- **CLI Frameworks**: clap, structopt, argh, gumdrop
- **Database Drivers**: sqlx, diesel, rusqlite, postgres, mysql, mongodb, redis
- **Async Runtimes**: tokio, async-std, smol
- **Job Schedulers**: tokio-cron-scheduler, cron, job-scheduler
- **HTTP Clients**: reqwest, hyper, surf, ureq

## Usage Example

&#x60;&#x60;&#x60;typescript
import { rustPlugin } from &amp;#39;@arbiter/shared/brownfield/plugins&amp;#39;;
import type {
  ParseContext,
  InferenceContext,
} from &amp;#39;@arbiter/shared/brownfield/types&amp;#39;;

// Check if plugin supports a file
const supports &#x3D; rustPlugin.supports(&amp;#39;/path/to/Cargo.toml&amp;#39;);

// Parse evidence from a file
const evidence &#x3D; await rustPlugin.parse(
  &amp;#39;/path/to/Cargo.toml&amp;#39;,
  cargoTomlContent,
  parseContext
);

// Infer artifacts from evidence
const artifacts &#x3D; await rustPlugin.infer(evidence, inferenceContext);
&#x60;&#x60;&#x60;

## Testing

The plugin includes comprehensive tests that cover:

- File support detection
- TOML parsing accuracy
- Source code analysis
- Artifact inference for all types
- Confidence scoring

Run tests with:

&#x60;&#x60;&#x60;bash
bun test src/brownfield/plugins/__tests__/rust.test.ts
&#x60;&#x60;&#x60;

## Adding New Plugins

To add a new language plugin:

1. Create a new file (e.g., &#x60;python.ts&#x60;) implementing &#x60;BrownfieldPlugin&#x60;
2. Export both the class and an instance
3. Add the plugin to &#x60;index.ts&#x60;
4. Update the utility functions in &#x60;index.ts&#x60;
5. Create comprehensive tests

Each plugin should follow the same pattern:

- Implement &#x60;supports()&#x60; for file detection
- Implement &#x60;parse()&#x60; for evidence extraction
- Implement &#x60;infer()&#x60; for artifact inference
- Provide confidence scores and provenance tracking
- Include framework-specific detection logic

## Architecture Notes

The plugin system uses:

- **Evidence-based analysis**: Plugins collect structured evidence before
  inference
- **Confidence scoring**: All inferences include confidence metrics
- **Provenance tracking**: Full audit trail of how artifacts were inferred
- **Type safety**: Strong TypeScript typing throughout
- **Modular design**: Each plugin is independent and composable

This design enables accurate analysis of complex, multi-language codebases like
the Smith project.
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(3)">
                    <span class="file-path">file-code src/plugins/index.ts</span>
                    <div class="file-meta">
                        <span>802.00 B</span>
                        <span>167 tokens</span>
                        <span>Score: 1.64</span>
                    </div>
                </div>
                <div class="file-content" id="file-3">
                    <pre class="code-block"><code>/**
 * @packageDocumentation
 * Exposes the built-in importer plugins.
 */

import { DockerPlugin } from &amp;quot;./docker&amp;quot;;
import { goPlugin } from &amp;quot;./go&amp;quot;;
import { KubernetesPlugin } from &amp;quot;./kubernetes&amp;quot;;
import { NodeJSPlugin } from &amp;quot;./nodejs&amp;quot;;
import { pythonPlugin } from &amp;quot;./python&amp;quot;;
import { rustPlugin } from &amp;quot;./rust&amp;quot;;
import { TerraformPlugin } from &amp;quot;./terraform&amp;quot;;

// Export all plugins
export { DockerPlugin, KubernetesPlugin, NodeJSPlugin, TerraformPlugin };
export { goPlugin, pythonPlugin, rustPlugin };

/**
 * Returns all bundled importer plugins in their recommended registration order.
 */
export function getAllPlugins() {
  return [
    new DockerPlugin(),
    new NodeJSPlugin(),
    new KubernetesPlugin(),
    new TerraformPlugin(),
    rustPlugin,
    pythonPlugin,
    goPlugin,
  ];
}
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(4)">
                    <span class="file-path">file-code src/index.ts</span>
                    <div class="file-meta">
                        <span>273.00 B</span>
                        <span>56 tokens</span>
                        <span>Score: 1.42</span>
                    </div>
                </div>
                <div class="file-content" id="file-4">
                    <pre class="code-block"><code>/**
 * @packageDocumentation
 * Entry point for the Arbiter importer.
 *
 * Re-exports the core scanner, plugin registry, and type definitions used when
 * analysing existing repositories.
 */

export * from &amp;quot;./types&amp;quot;;
export * from &amp;quot;./scanner&amp;quot;;
export * from &amp;quot;./plugins&amp;quot;;
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(5)">
                    <span class="file-path">file-code src/test-docker-detection.ts</span>
                    <div class="file-meta">
                        <span>5.00 KB</span>
                        <span>1,231 tokens</span>
                        <span>Score: 0.78</span>
                    </div>
                </div>
                <div class="file-content" id="file-5">
                    <pre class="code-block"><code>#!/usr/bin/env bun

import { DockerPlugin } from &amp;quot;./plugins/docker&amp;quot;;
import type { InferenceContext, ParseContext, ProjectMetadata } from &amp;quot;./types&amp;quot;;

// Test with the actual Arbiter project&amp;#39;s docker-compose.yml content
async function testDockerDetection() {
  const plugin &#x3D; new DockerPlugin();

  const dockerComposeContent &#x3D; &#x60;version: &amp;#39;3.8&amp;#39;

services:
  # Spec Workbench Backend
  spec-workbench:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - &amp;#39;5050:5050&amp;#39;
    environment:
      - NODE_ENV&#x3D;development
      - PORT&#x3D;5050
      - NATS_URL&#x3D;nats://nats:4222
      - DATABASE_PATH&#x3D;/app/data/spec_workbench.db
    volumes:
      - ./data:/app/data
      - ./examples:/app/examples:ro
    depends_on:
      - nats
    networks:
      - spec-workbench

  # NATS Server for external agent communication
  nats:
    image: nats:2.10-alpine
    ports:
      - &amp;#39;4222:4222&amp;#39; # Client connections
      - &amp;#39;6222:6222&amp;#39; # Cluster connections
      - &amp;#39;8222:8222&amp;#39; # HTTP monitoring
    command:
      - &amp;#39;--cluster_name&#x3D;spec-workbench&amp;#39;
      - &amp;#39;--cluster&#x3D;nats://0.0.0.0:6222&amp;#39;
      - &amp;#39;--http_port&#x3D;8222&amp;#39;
      - &amp;#39;--port&#x3D;4222&amp;#39;
      - &amp;#39;--server_name&#x3D;nats-server&amp;#39;
    networks:
      - spec-workbench

  # NATS Monitoring Dashboard (optional)
  nats-surveyor:
    image: natsio/nats-surveyor:latest
    ports:
      - &amp;#39;7777:7777&amp;#39;
    command:
      - &amp;#39;-s&amp;#39;
      - &amp;#39;http://nats:8222&amp;#39;
      - &amp;#39;-p&amp;#39;
      - &amp;#39;7777&amp;#39;
    depends_on:
      - nats
    networks:
      - spec-workbench

  # Example External Agent
  example-agent:
    build:
      context: .
      dockerfile: Dockerfile.agent
    environment:
      - NATS_URL&#x3D;nats://nats:4222
      - AGENT_NAME&#x3D;ExampleAnalysisAgent
    depends_on:
      - nats
      - spec-workbench
    networks:
      - spec-workbench
    profiles:
      - agents # Only start with --profile agents

networks:
  spec-workbench:
    driver: bridge

volumes:
  spec-data:
    driver: local&#x60;;

  const testFile &#x3D; &amp;quot;/tmp/test-docker-compose.yml&amp;quot;;
  const parseContext: ParseContext &#x3D; {
    projectRoot: &amp;quot;/home/nathan/Projects/arbiter&amp;quot;,
    fileIndex: {
      root: &amp;quot;/home/nathan/Projects/arbiter&amp;quot;,
      files: new Map(),
      directories: new Map(),
      timestamp: Date.now(),
    },
    options: {
      deepAnalysis: false,
      targetLanguages: [],
      maxFileSize: 10 * 1024 * 1024,
      includeBinaries: false,
      patterns: { include: [&amp;quot;**/*&amp;quot;], exclude: [] },
    },
    cache: new Map(),
  };
  const evidence &#x3D; await plugin.parse(testFile, dockerComposeContent, parseContext);

  console.log(&amp;quot;Docker Compose Service Detection Results:&amp;quot;);
  console.log(&amp;quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&amp;quot;);

  for (const ev of evidence) {
    if (ev.type &#x3D;&#x3D;&#x3D; &amp;quot;config&amp;quot; &amp;amp;&amp;amp; (ev.data as any).configType &#x3D;&#x3D;&#x3D; &amp;quot;compose-service&amp;quot;) {
      const data &#x3D; ev.data as any;
      console.log(&#x60;Service: ${data.serviceName}&#x60;);
      console.log(&#x60;  Image: ${data.image || &amp;quot;(built locally)&amp;quot;}&#x60;);
      console.log(&#x60;  Build: ${data.build ? JSON.stringify(data.build) : &amp;quot;N/A&amp;quot;}&#x60;);
      console.log(
        &#x60;  Ports: ${data.ports &amp;amp;&amp;amp; data.ports.length &amp;gt; 0 ? data.ports.map((p: any) &#x3D;&amp;gt; &#x60;${p.host}:${p.container}&#x60;).join(&amp;quot;, &amp;quot;) : &amp;quot;none&amp;quot;}&#x60;,
      );
      console.log(&#x60;  Depends On: ${data.dependsOn ? data.dependsOn.join(&amp;quot;, &amp;quot;) : &amp;quot;none&amp;quot;}&#x60;);
      console.log(
        &#x60;  Environment: ${data.environment ? data.environment.slice(0, 3).join(&amp;quot;, &amp;quot;) + (data.environment.length &amp;gt; 3 ? &amp;quot;...&amp;quot; : &amp;quot;&amp;quot;) : &amp;quot;none&amp;quot;}&#x60;,
      );
      console.log(&amp;quot;&amp;quot;);
    }
  }

  // Now test inference to see what artifacts are created
  const projectMetadata: ProjectMetadata &#x3D; {
    name: &amp;quot;arbiter&amp;quot;,
    root: &amp;quot;/home/nathan/Projects/arbiter&amp;quot;,
    languages: [&amp;quot;typescript&amp;quot;, &amp;quot;javascript&amp;quot;],
    frameworks: [&amp;quot;react&amp;quot;, &amp;quot;express&amp;quot;],
    fileCount: 1000,
    totalSize: 5000000,
  };
  const inferenceContext: InferenceContext &#x3D; {
    projectRoot: &amp;quot;/home/nathan/Projects/arbiter&amp;quot;,
    fileIndex: parseContext.fileIndex,
    allEvidence: evidence,
    options: {
      minConfidence: 0.3,
      inferRelationships: true,
      maxDependencyDepth: 5,
      useHeuristics: true,
    },
    cache: new Map(),
    projectMetadata,
  };
  const inferred &#x3D; await plugin.infer(evidence, inferenceContext);

  console.log(&amp;quot;\nInferred Artifacts:&amp;quot;);
  console.log(&amp;quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&amp;quot;);

  for (const artifact of inferred) {
    console.log(&#x60;Artifact ID: ${artifact.artifact.id}&#x60;);
    console.log(&#x60;  Type: ${artifact.artifact.type}&#x60;);
    console.log(&#x60;  Name: ${artifact.artifact.name}&#x60;);
    console.log(&#x60;  Description: ${artifact.artifact.description}&#x60;);
    const metadata &#x3D; artifact.artifact.metadata as any;
    if (metadata.containerImage) {
      console.log(&#x60;  Container Image: ${metadata.containerImage}&#x60;);
    }
    if (metadata.buildContext) {
      console.log(&#x60;  Build Context: ${metadata.buildContext}&#x60;);
    }
    if (metadata.port) {
      console.log(&#x60;  Port: ${metadata.port}&#x60;);
    }
    console.log(&#x60;  Language: ${metadata.language}&#x60;);
    console.log(&amp;quot;&amp;quot;);
  }
}

testDockerDetection().catch(console.error);
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(6)">
                    <span class="file-path">file-code src/types.ts</span>
                    <div class="file-meta">
                        <span>25.99 KB</span>
                        <span>5,096 tokens</span>
                        <span>Score: 0.74</span>
                    </div>
                </div>
                <div class="file-content" id="file-6">
                    <pre class="code-block"><code>/**
 * @packageDocumentation
 * Core type system used by the importer pipeline.
 *
 * The declarations in this module power the plugin architecture, evidence
 * collection stages, and artifact manifests generated when scanning projects.
 */

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// Core Plugin Interface
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Base plugin interface for importer detection.
 *
 * @public
 */
export interface ImporterPlugin {
  /**
   * Unique identifier for this plugin
   */
  name(): string;

  /**
   * Check if this plugin can analyze the given file/directory
   *
   * @param filePath - Path to the file or directory to analyze
   * @param fileContent - Content of the file (for file-based plugins)
   * @returns true if this plugin can process the given input
   */
  supports(filePath: string, fileContent?: string): boolean;

  /**
   * Parse the file/directory and extract structured evidence
   *
   * @param filePath - Path to the file or directory
   * @param fileContent - Content of the file (for file-based plugins)
   * @param context - Additional context for parsing
   * @returns Structured evidence extracted from the file
   */
  parse(filePath: string, fileContent?: string, context?: ParseContext): Promise&amp;lt;Evidence[]&amp;gt;;

  /**
   * Infer artifacts from the collected evidence
   *
   * @param evidence - Array of evidence collected from all sources
   * @param context - Inference context with project-wide information
   * @returns Array of inferred artifacts with confidence scores
   */
  infer(evidence: Evidence[], context: InferenceContext): Promise&amp;lt;InferredArtifact[]&amp;gt;;
}

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// Context Types
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Context provided during the parsing phase.
 *
 * @public
 */
export interface ParseContext {
  /** Root directory of the project being analyzed */
  projectRoot?: string;
  /** File index containing information about all files in the project */
  fileIndex: FileIndex;
  /** Configuration options for parsing */
  options: ParseOptions;
  /** Cache for expensive operations */
  cache: Map&amp;lt;string, unknown&amp;gt;;
}

/**
 * Context provided during the inference phase.
 *
 * @public
 */
export interface InferenceContext {
  /** Root directory of the project being analyzed */
  projectRoot?: string;
  /** Complete file index of the project */
  fileIndex: FileIndex;
  /** All evidence collected from all plugins */
  allEvidence: Evidence[];
  /** Configuration options for inference */
  options: InferenceOptions;
  /** Cache for expensive operations */
  cache: Map&amp;lt;string, unknown&amp;gt;;
  /** Project metadata including overridden project name */
  projectMetadata: ProjectMetadata;
}

/**
 * Configuration options for the parsing phase.
 *
 * @public
 */
export interface ParseOptions {
  /** Whether to perform deep analysis (slower but more accurate) */
  deepAnalysis: boolean;
  /** Languages to focus on (empty array means all) */
  targetLanguages: string[];
  /** Maximum file size to analyze (in bytes) */
  maxFileSize: number;
  /** Whether to analyze binary files */
  includeBinaries: boolean;
  /** Custom patterns to include/exclude */
  patterns: {
    include: string[];
    exclude: string[];
  };
}

/**
 * Configuration options for the inference phase.
 *
 * @public
 */
export interface InferenceOptions {
  /** Minimum confidence threshold for including artifacts */
  minConfidence: number;
  /** Whether to infer relationships between artifacts */
  inferRelationships: boolean;
  /** Maximum depth for dependency analysis */
  maxDependencyDepth: number;
  /** Whether to use heuristics for ambiguous cases */
  useHeuristics: boolean;
}

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// Artifact Types
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Allowed artifact classifications that importer plugins may emit.
 *
 * @public
 */
export type ArtifactType &#x3D;
  | &amp;quot;service&amp;quot; // HTTP services, APIs, microservices
  | &amp;quot;binary&amp;quot; // Executable binaries
  | &amp;quot;tool&amp;quot; // Command-line interface tools
  | &amp;quot;package&amp;quot; // Reusable packages, modules, components, libraries
  | &amp;quot;job&amp;quot; // Background jobs, cron jobs, workers
  | &amp;quot;schema&amp;quot; // Database schemas, API schemas
  | &amp;quot;config&amp;quot; // Configuration files, environment settings
  | &amp;quot;deployment&amp;quot; // Deployment configurations, infrastructure
  | &amp;quot;test&amp;quot; // Test suites, test configurations
  | &amp;quot;frontend&amp;quot; // Web frontends, SPAs, static sites
  | &amp;quot;database&amp;quot; // Database instances, data stores
  | &amp;quot;cache&amp;quot; // Caching layers, in-memory stores
  | &amp;quot;queue&amp;quot; // Message queues, event streams
  | &amp;quot;proxy&amp;quot; // Load balancers, reverse proxies
  | &amp;quot;monitor&amp;quot; // Monitoring, logging, alerting
  | &amp;quot;auth&amp;quot; // Authentication, authorization services
  | &amp;quot;docs&amp;quot; // Documentation, specifications
  | &amp;quot;infrastructure&amp;quot;; // Infrastructure as code

/**
 * Base artifact interface shared by all detected resources.
 *
 * @public
 */
export interface BaseArtifact {
  /** Unique identifier for this artifact */
  id: string;
  /** Type of artifact */
  type: ArtifactType;
  /** Human-readable name */
  name: string;
  /** Detailed description */
  description?: string;
  /** Tags for categorization */
  tags: string[];
  /** Metadata specific to the artifact type */
  metadata: Record&amp;lt;string, unknown&amp;gt; &amp;amp; {
    sourceFile?: string;
  };
}

/**
 * Service artifact representing an HTTP service or API
 */
export interface ServiceArtifact extends BaseArtifact {
  type: &amp;quot;service&amp;quot;;
  metadata: {
    sourceFile?: string;
    root?: string;
    /** Programming language */
    language?: string | null;
    /** Framework used (e.g., &amp;#39;express&amp;#39;, &amp;#39;fastapi&amp;#39;, &amp;#39;spring&amp;#39;) */
    framework?: string;
    /** Port number the service runs on */
    port?: number;
    /** Base path or context root */
    basePath?: string;
    /** Environment variables required */
    environmentVariables: string[];
    /** Dependencies on other services */
    dependencies: ServiceDependency[];
    /** Endpoints exposed by this service */
    endpoints: ServiceEndpoint[];
    /** Health check configuration */
    healthCheck?: HealthCheckConfig;
    /** Container image name from Docker/compose files */
    containerImage?: string;
    /** Docker build context path */
    buildContext?: string;
    /** Dockerfile path relative to build context */
    dockerfile?: string;
    /** Raw Dockerfile contents when available */
    dockerfileContent?: string;
  };
}

/**
 * Binary artifact representing an executable
 */
export interface BinaryArtifact extends BaseArtifact {
  type: &amp;quot;binary&amp;quot;;
  metadata: {
    sourceFile?: string;
    root?: string;
    /** Programming language */
    language?: string | null;
    /** Build system (e.g., &amp;#39;maven&amp;#39;, &amp;#39;gradle&amp;#39;, &amp;#39;npm&amp;#39;) */
    buildSystem?: string;
    /** Entry point file */
    entryPoint: string;
    /** Command line arguments */
    arguments: string[];
    /** Environment variables required */
    environmentVariables: string[];
    /** Runtime dependencies */
    dependencies: string[];
  };
}

/**
 * Tool artifact representing a command-line interface tool
 */
export interface ToolArtifact extends BaseArtifact {
  type: &amp;quot;tool&amp;quot;;
  metadata: {
    /** Programming language */
    language?: string | null;
    /** Command-line framework used (e.g., &amp;#39;commander&amp;#39;, &amp;#39;click&amp;#39;, &amp;#39;clap&amp;#39;) */
    framework?: string;
    /** Build system (e.g., &amp;#39;maven&amp;#39;, &amp;#39;gradle&amp;#39;, &amp;#39;npm&amp;#39;) */
    buildSystem?: string;
    /** Entry point file */
    entryPoint: string;
    /** Available commands */
    commands: string[];
    /** Command line arguments */
    arguments: string[];
    /** Environment variables required */
    environmentVariables: string[];
    /** Runtime dependencies */
    dependencies: string[];
  };
}

/**
 * Package artifact representing reusable packages, modules, components, or libraries
 */
export interface PackageArtifact extends BaseArtifact {
  type: &amp;quot;package&amp;quot;;
  metadata: {
    sourceFile?: string;
    root?: string;
    /** Programming language */
    language?: string | null;
    /** Framework used (e.g., &amp;#39;react&amp;#39;, &amp;#39;vue&amp;#39;, &amp;#39;lodash&amp;#39;) */
    framework?: string;
    /** Package manager (e.g., &amp;#39;npm&amp;#39;, &amp;#39;pip&amp;#39;, &amp;#39;maven&amp;#39;) */
    packageManager?: string;
    /** Public API exposed by the package */
    publicApi: string[];
    /** Internal dependencies */
    dependencies: string[];
    /** Routes if frontend package */
    routes?: FrontendRoute[];
    /** API endpoints consumed */
    apiDependencies?: string[];
    /** Version information */
    version?: string;
  };
}

/**
 * Job artifact representing background jobs or scheduled tasks
 */
export interface JobArtifact extends BaseArtifact {
  type: &amp;quot;job&amp;quot;;
  metadata: {
    /** Programming language */
    language?: string | null;
    /** Job scheduler (e.g., &amp;#39;cron&amp;#39;, &amp;#39;kubernetes&amp;#39;, &amp;#39;airflow&amp;#39;) */
    scheduler?: string;
    /** Schedule expression */
    schedule?: string;
    /** Entry point for the job */
    entryPoint: string;
    /** Environment variables required */
    environmentVariables: string[];
    /** Dependencies on other services/jobs */
    dependencies: string[];
  };
}

/**
 * Schema artifact representing data schemas
 */
export interface SchemaArtifact extends BaseArtifact {
  type: &amp;quot;schema&amp;quot;;
  metadata: {
    /** Schema format (e.g., &amp;#39;json-schema&amp;#39;, &amp;#39;openapi&amp;#39;, &amp;#39;protobuf&amp;#39;) */
    format: string;
    /** Version of the schema */
    version?: string;
    /** Tables or entities defined */
    entities: SchemaEntity[];
    /** Database type if applicable */
    databaseType?: string;
  };
}

/**
 * Frontend artifact representing web frontends
 */
export interface FrontendArtifact extends BaseArtifact {
  type: &amp;quot;frontend&amp;quot;;
  metadata: {
    sourceFile?: string;
    root?: string;
    /** Frontend framework (e.g., &amp;#39;react&amp;#39;, &amp;#39;vue&amp;#39;, &amp;#39;angular&amp;#39;) */
    framework?: string;
    /** Build system (e.g., &amp;#39;webpack&amp;#39;, &amp;#39;vite&amp;#39;, &amp;#39;parcel&amp;#39;) */
    buildSystem?: string;
    /** Routes defined in the application */
    routes: FrontendRoute[];
    /** API endpoints this frontend consumes */
    apiDependencies: string[];
    /** Environment variables required */
    environmentVariables: string[];
  };
}

/**
 * Database artifact representing database instances
 */
export interface DatabaseArtifact extends BaseArtifact {
  type: &amp;quot;database&amp;quot;;
  metadata: {
    /** Database type (e.g., &amp;#39;postgresql&amp;#39;, &amp;#39;mysql&amp;#39;, &amp;#39;mongodb&amp;#39;) */
    databaseType: string;
    /** Database version */
    version?: string;
    /** Database schemas/collections */
    schemas: string[];
    /** Port number */
    port?: number;
    /** Configuration parameters */
    configuration: Record&amp;lt;string, unknown&amp;gt;;
  };
}

/**
 * Deployment artifact representing deployment configurations
 */
export interface DeploymentArtifact extends BaseArtifact {
  type: &amp;quot;deployment&amp;quot;;
  metadata: {
    sourceFile?: string;
    /** Deployment platform (e.g., &amp;#39;kubernetes&amp;#39;, &amp;#39;docker-compose&amp;#39;, &amp;#39;terraform&amp;#39;) */
    platform: string;
    /** Target environment */
    environment?: string;
    /** Namespace or scope */
    namespace?: string;
    /** Deployment resources */
    resources?: Array&amp;lt;{ kind: string; name: string; apiVersion?: string }&amp;gt;;
    /** Configuration files */
    configFiles?: string[];
    /** Deployment strategy */
    strategy?: string;
    /** Scaling configuration */
    scaling?: {
      min?: number;
      max?: number;
      targetCPU?: number;
    };
  };
}
/**
 * Infrastructure artifact representing IaC configurations (Kubernetes, Terraform)
 */
export interface InfrastructureArtifact extends BaseArtifact {
  type: &amp;quot;infrastructure&amp;quot;;
  metadata: {
    sourceFile?: string;
    /** Root directory containing the IaC files */
    root: string;
    /** List of all files in this infrastructure group */
    files: string[];
    /** Type of infrastructure: &amp;#39;kubernetes&amp;#39; or &amp;#39;terraform&amp;#39; */
    kind: &amp;quot;kubernetes&amp;quot; | &amp;quot;terraform&amp;quot;;
    /** Detected resources/deployments */
    resources?: Array&amp;lt;{ kind: string; name: string; apiVersion?: string }&amp;gt;;
  };
}

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// Supporting Types
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Service dependency representing a connection to another service
 */
export interface ServiceDependency {
  /** Name of the dependent service */
  serviceName: string;
  /** Type of dependency (e.g., &amp;#39;http&amp;#39;, &amp;#39;database&amp;#39;, &amp;#39;queue&amp;#39;) */
  type: string;
  /** Whether this dependency is required for the service to function */
  required: boolean;
  /** Configuration for the dependency */
  configuration?: Record&amp;lt;string, unknown&amp;gt;;
}

/**
 * Service endpoint representing an API endpoint
 */
export interface ServiceEndpoint {
  /** HTTP method */
  method: string;
  /** URL path */
  path: string;
  /** Request/response schema */
  schema?: string;
  /** Description of the endpoint */
  description?: string;
  /** Whether authentication is required */
  authenticated?: boolean;
}

/**
 * Health check configuration
 */
export interface HealthCheckConfig {
  /** Health check endpoint path */
  path: string;
  /** Expected status code */
  expectedStatusCode: number;
  /** Timeout in milliseconds */
  timeoutMs: number;
  /** Check interval in seconds */
  intervalSeconds: number;
}

/**
 * Schema entity representing a table or data structure
 */
export interface SchemaEntity {
  /** Entity name */
  name: string;
  /** Fields/columns in the entity */
  fields: SchemaField[];
  /** Relationships to other entities */
  relationships: SchemaRelationship[];
}

/**
 * Schema field representing a column or property
 */
export interface SchemaField {
  /** Field name */
  name: string;
  /** Data type */
  type: string;
  /** Whether the field is required */
  required: boolean;
  /** Field constraints */
  constraints?: string[];
}

/**
 * Schema relationship between entities
 */
export interface SchemaRelationship {
  /** Type of relationship (e.g., &amp;#39;one-to-many&amp;#39;, &amp;#39;many-to-many&amp;#39;) */
  type: string;
  /** Target entity */
  targetEntity: string;
  /** Foreign key field */
  foreignKey?: string;
}

/**
 * Frontend route definition
 */
export interface FrontendRoute {
  /** Route path */
  path: string;
  /** Component name */
  component?: string;
  /** Route name/title */
  name?: string;
  /** Whether authentication is required */
  authenticated?: boolean;
}

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// Evidence and File System Types
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Evidence collected during the parsing phase
 */
export interface Evidence {
  /** Unique identifier for this evidence */
  id: string;
  /** Plugin that collected this evidence */
  source: string;
  /** Type of evidence */
  type: EvidenceType;
  /** File path where evidence was found */
  filePath: string;
  /** Line number in the file (if applicable) */
  lineNumber?: number;
  /** Raw data extracted */
  data: Record&amp;lt;string, unknown&amp;gt;;
  /** Additional metadata */
  metadata: EvidenceMetadata;
}

/**
 * Types of evidence that can be collected
 */
export type EvidenceType &#x3D;
  | &amp;quot;dependency&amp;quot; // Package dependencies
  | &amp;quot;import&amp;quot; // Import statements
  | &amp;quot;export&amp;quot; // Export declarations
  | &amp;quot;function&amp;quot; // Function definitions
  | &amp;quot;class&amp;quot; // Class definitions
  | &amp;quot;interface&amp;quot; // Interface definitions
  | &amp;quot;config&amp;quot; // Configuration values
  | &amp;quot;route&amp;quot; // HTTP route definitions
  | &amp;quot;schema&amp;quot; // Schema definitions
  | &amp;quot;test&amp;quot; // Test cases
  | &amp;quot;comment&amp;quot; // Documentation comments
  | &amp;quot;annotation&amp;quot; // Decorators/annotations
  | &amp;quot;environment&amp;quot; // Environment variable usage
  | &amp;quot;build&amp;quot; // Build configuration
  | &amp;quot;deployment&amp;quot; // Deployment configuration
  | &amp;quot;infrastructure&amp;quot;; // Infrastructure as code

/**
 * Metadata attached to evidence
 */
export interface EvidenceMetadata {
  /** Timestamp when evidence was collected */
  timestamp: number;
  /** Size of the file in bytes */
  fileSize: number;
  /** MIME type of the file */
  mimeType?: string;
  /** Git information if available */
  git?: {
    lastModified: number;
    author?: string;
    commit?: string;
  };
  /** Additional context-specific metadata */
  [key: string]: unknown;
}

/**
 * Index of all files in the project
 */
export interface FileIndex {
  /** Root directory of the project */
  root: string;
  /** Map of file paths to file information */
  files: Map&amp;lt;string, FileInfo&amp;gt;;
  /** Map of directory paths to directory information */
  directories: Map&amp;lt;string, DirectoryInfo&amp;gt;;
  /** Generated timestamp */
  timestamp: number;
}

/**
 * Information about a single file
 */
export interface FileInfo {
  /** Absolute path to the file */
  path: string;
  /** Relative path from project root */
  relativePath: string;
  /** File size in bytes */
  size: number;
  /** Last modified timestamp */
  lastModified: number;
  /** MIME type */
  mimeType?: string;
  /** File extension */
  extension: string;
  /** Whether the file is binary */
  isBinary: boolean;
  /** File hash for change detection */
  hash?: string;
  /** Language detected (if applicable) */
  language?: string;
  /** Additional metadata including git information */
  metadata?: {
    git?: {
      lastModified?: number;
      author?: string;
      commit?: string;
    };
    [key: string]: unknown;
  };
}

/**
 * Information about a directory
 */
export interface DirectoryInfo {
  /** Absolute path to the directory */
  path: string;
  /** Relative path from project root */
  relativePath: string;
  /** Number of files in the directory (recursive) */
  fileCount: number;
  /** Total size of all files in the directory (recursive) */
  totalSize: number;
  /** Last modified timestamp (most recent file) */
  lastModified: number;
}

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// Confidence and Provenance
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Confidence scoring for inferred artifacts
 */
export interface ConfidenceScore {
  /** Overall confidence (0-1) */
  overall: number;
  /** Breakdown by evidence type */
  breakdown: Record&amp;lt;string, number&amp;gt;;
  /** Factors that contributed to the confidence */
  factors: ConfidenceFactor[];
}

/**
 * Individual factor contributing to confidence
 */
export interface ConfidenceFactor {
  /** Description of the factor */
  description: string;
  /** Weight of this factor (-1 to 1) */
  weight: number;
  /** Source of this factor */
  source: string;
}

/**
 * Provenance tracking for artifacts
 */
export interface Provenance {
  /** Evidence that led to this artifact */
  evidence: string[];
  /** Plugins involved in inference */
  plugins: string[];
  /** Inference rules applied */
  rules: string[];
  /** Timestamp of inference */
  timestamp: number;
  /** Version of the pipeline */
  pipelineVersion: string;
}

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// Inferred Artifacts and Output
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Artifact with inference metadata
 */
export interface InferredArtifact {
  /** The inferred artifact */
  artifact: BaseArtifact;
  /** Provenance information */
  provenance: Provenance;
  /** Relationships to other artifacts */
  relationships: ArtifactRelationship[];
}

/**
 * Relationship between artifacts
 */
export interface ArtifactRelationship {
  /** Type of relationship */
  type: RelationshipType;
  /** Target artifact ID */
  targetId: string;
  /** Confidence in this relationship */
  confidence: number;
  /** Additional metadata about the relationship */
  metadata?: Record&amp;lt;string, unknown&amp;gt;;
}

/**
 * Types of relationships between artifacts
 */
export type RelationshipType &#x3D;
  | &amp;quot;depends_on&amp;quot; // A depends on B
  | &amp;quot;provides&amp;quot; // A provides B
  | &amp;quot;consumes&amp;quot; // A consumes B
  | &amp;quot;deploys&amp;quot; // A deploys B
  | &amp;quot;tests&amp;quot; // A tests B
  | &amp;quot;configures&amp;quot; // A configures B
  | &amp;quot;documents&amp;quot; // A documents B
  | &amp;quot;implements&amp;quot; // A implements B
  | &amp;quot;extends&amp;quot; // A extends B
  | &amp;quot;contains&amp;quot;; // A contains B

/**
 * Final output of the importer detection pipeline
 * This is the stable contract that consumers can rely on
 */
export interface ArtifactManifest {
  /** Version of the manifest format */
  version: string;
  /** Metadata about the analyzed project */
  project: ProjectMetadata;
  /** Artifacts grouped by config file */
  perConfig: Record&amp;lt;string, InferredArtifact[]&amp;gt;;
  /** All inferred artifacts (flattened for backward compatibility) */
  artifacts: InferredArtifact[];
  /** Source-to-artifact provenance mapping: file basename -&amp;gt; array of artifact IDs */
  provenance: Record&amp;lt;string, string[]&amp;gt;;
  /** Global statistics and metrics */
  statistics: AnalysisStatistics;
  /** Configuration used for the analysis */
  configuration: AnalysisConfiguration;
  /** Generation timestamp */
  timestamp: number;
}

/**
 * Metadata about the analyzed project
 */
export interface ProjectMetadata {
  /** Project name */
  name: string;
  /** Project root directory */
  root: string;
  /** Detected languages */
  languages: string[];
  /** Detected frameworks */
  frameworks: string[];
  /** Total number of files analyzed */
  fileCount: number;
  /** Total size of all files */
  totalSize: number;
  /** Git information if available */
  git?: {
    repository?: string;
    branch?: string;
    commit?: string;
    lastModified?: number;
  };
}

/**
 * Statistics from the analysis
 */
export interface AnalysisStatistics {
  /** Number of artifacts by type */
  artifactCounts: Record&amp;lt;ArtifactType, number&amp;gt;;
  /** Number of evidence items by type */
  evidenceCounts: Record&amp;lt;EvidenceType, number&amp;gt;;
  /** Processing time in milliseconds */
  processingTimeMs: number;
  /** Plugins that were executed */
  pluginsExecuted: string[];
  /** Files that could not be processed */
  failedFiles: string[];
}

/**
 * Configuration used for the analysis
 */
export interface AnalysisConfiguration {
  /** Parse options */
  parseOptions: ParseOptions;
  /** Inference options */
  inferenceOptions: InferenceOptions;
  /** Plugins enabled */
  enabledPlugins: string[];
  /** Custom configuration per plugin */
  pluginConfiguration: Record&amp;lt;string, Record&amp;lt;string, unknown&amp;gt;&amp;gt;;
}

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// Persistence Types
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Specification revision for tracking artifact changes
 */
export interface Spec {
  /** Unique ID for this spec revision */
  revision_id: string;
  /** ID of the parent spec (null for root) */
  parent_revision_id?: string;
  /** Scope this spec applies to (e.g., &amp;#39;packages/utils&amp;#39;) */
  scope: string;
  /** Creation timestamp */
  timestamp: number;
  /** Config files that generated this spec */
  config_files?: string[];
}

/**
 * Log entry for artifact actions
 */
export interface ArtifactLogEntry {
  /** Unique ID for this log entry */
  id: string;
  /** Spec revision this action belongs to */
  spec_id: string;
  /** Name of the artifact */
  artifact_name: string;
  /** Type of the artifact */
  artifact_type: ArtifactType;
  /** Hash of the artifact content */
  artifact_hash: string;
  /** JSON stringified artifact data */
  artifact_data: string;
  /** JSON stringified provenance data */
  provenance_data?: string;
  /** JSON stringified confidence data */
  confidence_data?: string;
  /** Action type */
  action: ActionType;
  /** Timestamp of the action */
  timestamp: number;
}

/**
 * Possible actions in the artifact log
 */
export type ActionType &#x3D; &amp;quot;add&amp;quot; | &amp;quot;remove&amp;quot;;

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// Error Types
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

/**
 * Base error for importer detection operations
 */
export abstract class ImporterError extends Error {
  abstract readonly code: string;
  abstract readonly category: ErrorCategory;

  constructor(
    message: string,
    public readonly cause?: Error,
  ) {
    super(message);
    this.name &#x3D; this.constructor.name;
  }
}

/**
 * Categories of errors
 */
export type ErrorCategory &#x3D; &amp;quot;plugin&amp;quot; | &amp;quot;parsing&amp;quot; | &amp;quot;inference&amp;quot; | &amp;quot;filesystem&amp;quot; | &amp;quot;configuration&amp;quot;;

/**
 * Plugin execution error
 */
export class PluginError extends ImporterError {
  readonly code &#x3D; &amp;quot;PLUGIN_ERROR&amp;quot;;
  readonly category &#x3D; &amp;quot;plugin&amp;quot; as const;

  constructor(
    public readonly pluginName: string,
    message: string,
    cause?: Error,
  ) {
    super(&#x60;Plugin ${pluginName}: ${message}&#x60;, cause);
  }
}

/**
 * File parsing error
 */
export class ParseError extends ImporterError {
  readonly code &#x3D; &amp;quot;PARSE_ERROR&amp;quot;;
  readonly category &#x3D; &amp;quot;parsing&amp;quot; as const;

  constructor(
    public readonly filePath: string,
    message: string,
    cause?: Error,
  ) {
    super(&#x60;Failed to parse ${filePath}: ${message}&#x60;, cause);
  }
}

/**
 * Inference error
 */
export class InferenceError extends ImporterError {
  readonly code &#x3D; &amp;quot;INFERENCE_ERROR&amp;quot;;
  readonly category &#x3D; &amp;quot;inference&amp;quot; as const;

  constructor(message: string, cause?: Error) {
    super(&#x60;Inference failed: ${message}&#x60;, cause);
  }
}

/**
 * File system error
 */
export class FileSystemError extends ImporterError {
  readonly code &#x3D; &amp;quot;FILESYSTEM_ERROR&amp;quot;;
  readonly category &#x3D; &amp;quot;filesystem&amp;quot; as const;

  constructor(
    public readonly path: string,
    message: string,
    cause?: Error,
  ) {
    super(&#x60;File system error at ${path}: ${message}&#x60;, cause);
  }
}

/**
 * Configuration error
 */
export class ConfigurationError extends ImporterError {
  readonly code &#x3D; &amp;quot;CONFIGURATION_ERROR&amp;quot;;
  readonly category &#x3D; &amp;quot;configuration&amp;quot; as const;

  constructor(message: string, cause?: Error) {
    super(&#x60;Configuration error: ${message}&#x60;, cause);
  }
}
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(7)">
                    <span class="file-path">file-code src/plugins/nodejs.ts</span>
                    <div class="file-meta">
                        <span>33.76 KB</span>
                        <span>7,279 tokens</span>
                        <span>Score: 0.62</span>
                    </div>
                </div>
                <div class="file-content" id="file-7">
                    <pre class="code-block"><code>/**
 * Node.js Plugin for Brownfield Detection
 *
 * Simplified to focus on package.json parsing for name, description, type, and file path.
 */

import * as path from &amp;quot;path&amp;quot;;
import * as fs from &amp;quot;fs-extra&amp;quot;;
import { glob } from &amp;quot;glob&amp;quot;;
import type { ComponentDoc, PropItem } from &amp;quot;react-docgen-typescript&amp;quot;;

import {
  Evidence,
  type FileInfo,
  ImporterPlugin,
  InferenceContext,
  InferredArtifact,
  ParseContext,
} from &amp;quot;../types&amp;quot;;

import type { DetectionContext } from &amp;quot;../detection/artifact-detector&amp;quot;;
import { detectArtifactType } from &amp;quot;../detection/artifact-detector&amp;quot;;
import type { CategoryMatrix } from &amp;quot;../detection/dependency-matrix&amp;quot;;
import type { ArtifactType } from &amp;quot;../types&amp;quot;;

const NODE_WEB_FRAMEWORKS &#x3D; [
  &amp;quot;express&amp;quot;,
  &amp;quot;fastify&amp;quot;,
  &amp;quot;koa&amp;quot;,
  &amp;quot;hapi&amp;quot;,
  &amp;quot;nest&amp;quot;,
  &amp;quot;adonis&amp;quot;,
  &amp;quot;meteor&amp;quot;,
  &amp;quot;sails&amp;quot;,
  &amp;quot;loopback&amp;quot;,
  &amp;quot;restify&amp;quot;,
  &amp;quot;hono&amp;quot;,
];

const NODE_FRONTEND_FRAMEWORKS &#x3D; [
  &amp;quot;react&amp;quot;,
  &amp;quot;vue&amp;quot;,
  &amp;quot;angular&amp;quot;,
  &amp;quot;svelte&amp;quot;,
  &amp;quot;solid-js&amp;quot;,
  &amp;quot;preact&amp;quot;,
  &amp;quot;lit&amp;quot;,
  &amp;quot;stimulus&amp;quot;,
];

const NODE_CLI_FRAMEWORKS &#x3D; [
  &amp;quot;commander&amp;quot;,
  &amp;quot;yargs&amp;quot;,
  &amp;quot;inquirer&amp;quot;,
  &amp;quot;ora&amp;quot;,
  &amp;quot;chalk&amp;quot;,
  &amp;quot;boxen&amp;quot;,
  &amp;quot;cli-table3&amp;quot;,
];

interface FrontendComponentSummary {
  name: string;
  filePath: string;
  framework: &amp;quot;react&amp;quot; | &amp;quot;vue&amp;quot;;
  description?: string;
  props?: Array&amp;lt;{
    name: string;
    type?: string;
    required: boolean;
    description?: string;
  }&amp;gt;;
}

interface FrontendRouteSummary {
  type: &amp;quot;react-router&amp;quot; | &amp;quot;next&amp;quot;;
  routes: Array&amp;lt;{
    path: string;
    filePath?: string;
  }&amp;gt;;
}

interface FrontendAnalysis {
  frameworks: string[];
  components: FrontendComponentSummary[];
  routers: FrontendRouteSummary[];
}

type ReactDocgenModule &#x3D; typeof import(&amp;quot;react-docgen-typescript&amp;quot;);

export interface PackageJsonData extends Record&amp;lt;string, unknown&amp;gt; {
  name: string;
  description?: string;
  type: string;
  filePath: string;
}

export class NodeJSPlugin implements ImporterPlugin {
  private reactDocgenModule: ReactDocgenModule | null | undefined;
  private reactParserCache &#x3D; new Map&amp;lt;
    string,
    { parse: (filePaths: string[]) &#x3D;&amp;gt; ComponentDoc[] } | null
  &amp;gt;();

  name(): string {
    return &amp;quot;nodejs&amp;quot;;
  }

  supports(filePath: string, fileContent?: string): boolean {
    const fileName &#x3D; path.basename(filePath);
    return fileName &#x3D;&#x3D;&#x3D; &amp;quot;package.json&amp;quot;;
  }

  async parse(filePath: string, fileContent?: string, context?: ParseContext): Promise&amp;lt;Evidence[]&amp;gt; {
    if (!fileContent || path.basename(filePath) !&#x3D;&#x3D; &amp;quot;package.json&amp;quot;) return [];

    const evidence: Evidence[] &#x3D; [];
    const baseId &#x3D; path.relative(context?.projectRoot || &amp;quot;&amp;quot;, filePath);

    try {
      evidence.push(...(await this.parsePackageJson(filePath, fileContent, baseId)));
    } catch (error) {
      console.warn(&#x60;Node.js plugin failed to parse ${filePath}:&#x60;, error);
    }

    return evidence;
  }

  async infer(evidence: Evidence[], context: InferenceContext): Promise&amp;lt;InferredArtifact[]&amp;gt; {
    const nodeEvidence &#x3D; evidence.filter((e) &#x3D;&amp;gt; e.source &#x3D;&#x3D;&#x3D; &amp;quot;nodejs&amp;quot;);
    if (nodeEvidence.length &#x3D;&#x3D;&#x3D; 0) return [];

    const artifacts: InferredArtifact[] &#x3D; [];

    try {
      // Infer from package.json evidence
      const packageEvidence &#x3D; nodeEvidence.filter((e) &#x3D;&amp;gt; e.type &#x3D;&#x3D;&#x3D; &amp;quot;config&amp;quot;);
      for (const pkgEv of packageEvidence) {
        artifacts.push(...(await this.inferFromPackageJson(pkgEv, context)));
      }
    } catch (error) {
      console.warn(&amp;quot;Node.js plugin inference failed:&amp;quot;, error);
    }

    return artifacts;
  }

  private async parsePackageJson(
    filePath: string,
    content: string,
    baseId: string,
  ): Promise&amp;lt;Evidence[]&amp;gt; {
    const evidence: Evidence[] &#x3D; [];

    try {
      const pkg &#x3D; JSON.parse(content);

      // Compute logical file path based on package name
      const relativeDir &#x3D; path.dirname(baseId);
      const actualSubdir &#x3D; path.basename(relativeDir);
      const scopedPart &#x3D; pkg.name.replace(/^@[^/]+\//, &amp;quot;&amp;quot;);
      const logicalSubdir &#x3D; scopedPart;
      const logicalRelativeDir &#x3D; relativeDir.replace(
        new RegExp(&#x60;/${actualSubdir}$&#x60;),
        &#x60;/${logicalSubdir}&#x60;,
      );
      const logicalFilePath &#x3D; path.join(logicalRelativeDir, &amp;quot;package.json&amp;quot;);

      // Strip scope prefix from package name (@org/name -&amp;gt; name)
      const packageName &#x3D; pkg.name || path.basename(path.dirname(filePath));
      const nameWithoutScope &#x3D;
        typeof packageName &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; ? packageName.replace(/^@[^/]+\//, &amp;quot;&amp;quot;) : packageName;

      const packageData &#x3D; {
        name: nameWithoutScope,
        description: pkg.description || &amp;quot;&amp;quot;,
        fullPackage: pkg,
        filePath: logicalFilePath,
      };

      evidence.push({
        id: baseId,
        source: &amp;quot;nodejs&amp;quot;,
        type: &amp;quot;config&amp;quot;,
        filePath,
        data: packageData,
        metadata: {
          timestamp: Date.now(),
          fileSize: content.length,
        },
      });
    } catch (error) {
      console.warn(&amp;quot;Failed to parse package.json:&amp;quot;, error);
    }

    return evidence;
  }

  private async inferFromPackageJson(
    packageEvidence: Evidence,
    context: InferenceContext,
  ): Promise&amp;lt;InferredArtifact[]&amp;gt; {
    const artifacts: InferredArtifact[] &#x3D; [];
    const packageData &#x3D; packageEvidence.data as any;
    const pkg &#x3D; packageData.fullPackage;

    const scripts &#x3D; pkg.scripts || {};
    const dependenciesMap &#x3D; this.collectDependencies(pkg);
    const dependencyNames &#x3D; Object.keys(dependenciesMap);
    const packageRoot &#x3D; this.getPackageRelativeRoot(packageEvidence, context);
    const normalizedPackageRoot &#x3D;
      packageRoot &#x3D;&#x3D;&#x3D; &amp;quot;.&amp;quot; ? &amp;quot;&amp;quot; : this.normalizeRelativePath(packageRoot);
    const filePatterns &#x3D; Array.from(context.fileIndex.files.values())
      .filter((f) &#x3D;&amp;gt; {
        const rel &#x3D; this.normalizeRelativePath(f.relativePath);
        if (!normalizedPackageRoot) {
          return !rel.startsWith(&amp;quot;node_modules/&amp;quot;);
        }
        return rel &#x3D;&#x3D;&#x3D; normalizedPackageRoot || rel.startsWith(&#x60;${normalizedPackageRoot}/&#x60;);
      })
      .map((f) &#x3D;&amp;gt; this.normalizeRelativePath(f.relativePath));

    const detectionLanguage &#x3D; this.usesTypeScript(pkg, scripts) ? &amp;quot;typescript&amp;quot; : &amp;quot;javascript&amp;quot;;

    const manifestClassification &#x3D; this.determineManifestClassification(
      pkg,
      dependenciesMap,
      scripts,
    );

    let artifactType: ArtifactType;
    let detectedType: string;
    let classificationSource &#x3D; &amp;quot;manifest&amp;quot;;
    let classificationReason &#x3D; manifestClassification?.reason || &amp;quot;manifest-default&amp;quot;;

    if (manifestClassification) {
      artifactType &#x3D; manifestClassification.artifactType;
      detectedType &#x3D; manifestClassification.detectedType;
    } else {
      classificationSource &#x3D; &amp;quot;detector&amp;quot;;
      const detectionContext &#x3D; {
        language: detectionLanguage,
        dependencies: dependencyNames,
        scripts,
        filePatterns,
        packageConfig: pkg,
      };
      const { primaryType } &#x3D; this.detectArtifactType(detectionContext);
      artifactType &#x3D; this.mapCategoryToType(primaryType);
      detectedType &#x3D; primaryType;
      classificationReason &#x3D; &amp;quot;detector&amp;quot;;
    }

    const metadata: Record&amp;lt;string, unknown&amp;gt; &#x3D; {
      sourceFile: packageData.filePath,
      root: path.dirname(packageData.filePath),
      manifest: &amp;quot;package.json&amp;quot;,
      language: &amp;quot;javascript&amp;quot;,
      framework: this.inferFramework(pkg),
      detectedType,
      classification: {
        source: classificationSource,
        reason: classificationReason,
      },
    };

    if (artifactType &#x3D;&#x3D;&#x3D; &amp;quot;tool&amp;quot;) {
      metadata.framework &#x3D; metadata.framework || &amp;quot;cli&amp;quot;;
    }

    console.log(&amp;quot;[nodejs-plugin] inferred package&amp;quot;, {
      name: packageData.name,
      type: artifactType,
      detectedType,
      source: classificationSource,
      reason: classificationReason,
    });

    const mainArtifact &#x3D; {
      id: &#x60;${packageData.name}&#x60;,
      type: artifactType,
      name: packageData.name,
      description: packageData.description || &#x60;Node.js ${artifactType}: ${packageData.name}&#x60;,
      tags: [&amp;quot;nodejs&amp;quot;, artifactType],
      metadata,
    };

    const tsoaAnalysis &#x3D; await this.buildTsoaAnalysis(pkg, packageRoot, context, scripts);
    if (tsoaAnalysis) {
      if (!mainArtifact.tags.includes(&amp;quot;tsoa-candidate&amp;quot;)) {
        mainArtifact.tags.push(&amp;quot;tsoa-candidate&amp;quot;);
      }
      metadata.tsoaAnalysis &#x3D; tsoaAnalysis;
    }

    const frontendAnalysis &#x3D; await this.buildFrontendAnalysis(pkg, packageRoot, context);

    if (frontendAnalysis) {
      for (const framework of frontendAnalysis.frameworks) {
        if (!mainArtifact.tags.includes(framework)) {
          mainArtifact.tags.push(framework);
        }
      }

      metadata.frontendAnalysis &#x3D; frontendAnalysis;
    }

    const mainInferredArtifact &#x3D; {
      artifact: mainArtifact,
      provenance: {
        evidence: [packageEvidence.id],
        plugins: [&amp;quot;nodejs&amp;quot;],
        rules: [&amp;quot;advanced-package-detection&amp;quot;],
        timestamp: Date.now(),
        pipelineVersion: &amp;quot;1.0.0&amp;quot;,
      },
      relationships: [],
    };

    artifacts.push(mainInferredArtifact);

    return artifacts;
  }

  private async buildFrontendAnalysis(
    pkg: any,
    packageRoot: string,
    context: InferenceContext,
  ): Promise&amp;lt;FrontendAnalysis | null&amp;gt; {
    const dependencies &#x3D; this.collectDependencies(pkg);
    const hasReact &#x3D;
      Boolean(dependencies.react || dependencies[&amp;quot;react-dom&amp;quot;] || dependencies[&amp;quot;react-native&amp;quot;]) ||
      Boolean(dependencies.next);
    const hasVue &#x3D;
      Boolean(dependencies.vue) ||
      Boolean(dependencies[&amp;quot;@vue/runtime-dom&amp;quot;]) ||
      Boolean(dependencies[&amp;quot;@vue/runtime-core&amp;quot;]) ||
      Boolean(dependencies.nuxt) ||
      Boolean(dependencies[&amp;quot;nuxt3&amp;quot;]);
    const hasReactRouter &#x3D; Boolean(
      dependencies[&amp;quot;react-router&amp;quot;] || dependencies[&amp;quot;react-router-dom&amp;quot;],
    );
    const hasNext &#x3D; Boolean(dependencies.next);

    if (!hasReact &amp;amp;&amp;amp; !hasVue) {
      return null;
    }

    const projectRoot &#x3D; context.projectRoot ?? context.fileIndex.root ?? &amp;quot;&amp;quot;;
    if (!projectRoot) {
      return null;
    }

    const normalizedPackageRoot &#x3D;
      packageRoot &#x3D;&#x3D;&#x3D; &amp;quot;.&amp;quot; ? &amp;quot;&amp;quot; : this.normalizeRelativePath(packageRoot);
    const packageAbsoluteRoot &#x3D; normalizedPackageRoot
      ? path.resolve(projectRoot, normalizedPackageRoot)
      : projectRoot;

    const relevantFiles &#x3D; Array.from(context.fileIndex.files.values()).filter((fileInfo) &#x3D;&amp;gt;
      this.isWithinPackage(packageAbsoluteRoot, fileInfo.path),
    );

    if (relevantFiles.length &#x3D;&#x3D;&#x3D; 0) {
      return null;
    }

    const analysis: FrontendAnalysis &#x3D; {
      frameworks: [],
      components: [],
      routers: [],
    };

    if (hasReact) {
      this.addFramework(analysis, &amp;quot;react&amp;quot;);
      const tsconfigPath &#x3D; await this.findNearestTsconfig(packageAbsoluteRoot);
      const reactComponents &#x3D; await this.extractReactComponents(
        packageAbsoluteRoot,
        relevantFiles,
        tsconfigPath,
      );
      analysis.components.push(...reactComponents);

      if (hasReactRouter) {
        const reactRoutes &#x3D; await this.detectReactRouterRoutes(packageAbsoluteRoot, relevantFiles);
        if (reactRoutes) {
          analysis.routers.push(reactRoutes);
        }
      }
    }

    if (hasNext) {
      this.addFramework(analysis, &amp;quot;next&amp;quot;);
      const nextRoutes &#x3D; this.detectNextRoutes(packageAbsoluteRoot, relevantFiles);
      if (nextRoutes) {
        analysis.routers.push(nextRoutes);
      }
    }

    if (hasVue) {
      this.addFramework(analysis, &amp;quot;vue&amp;quot;);
      const vueComponents &#x3D; await this.extractVueComponents(packageAbsoluteRoot, relevantFiles);
      analysis.components.push(...vueComponents);
    }

    if (!analysis.frameworks.length &amp;amp;&amp;amp; !analysis.components.length &amp;amp;&amp;amp; !analysis.routers.length) {
      return null;
    }

    analysis.components &#x3D; this.deduplicateComponents(analysis.components).slice(0, 100);
    analysis.routers &#x3D; analysis.routers.map((router) &#x3D;&amp;gt; ({
      ...router,
      routes: router.routes.slice(0, 50),
    }));

    return analysis;
  }

  private async extractReactComponents(
    packageAbs: string,
    fileInfos: FileInfo[],
    tsconfigPath?: string,
  ): Promise&amp;lt;FrontendComponentSummary[]&amp;gt; {
    const results: FrontendComponentSummary[] &#x3D; [];
    const componentFiles &#x3D; fileInfos
      .filter((file) &#x3D;&amp;gt; /\.(tsx|ts|jsx|js)$/.test(file.path))
      .filter((file) &#x3D;&amp;gt; !file.path.includes(&#x60;${path.sep}node_modules${path.sep}&#x60;));

    if (componentFiles.length &#x3D;&#x3D;&#x3D; 0) {
      return results;
    }

    const tsxTargets &#x3D; componentFiles
      .map((file) &#x3D;&amp;gt; file.path)
      .filter((file) &#x3D;&amp;gt; /\.(tsx|ts)$/.test(file))
      .slice(0, 40);

    const parser &#x3D; tsxTargets.length ? await this.getReactParser(tsconfigPath) : null;
    const discoveredKeys &#x3D; new Set&amp;lt;string&amp;gt;();

    if (parser) {
      try {
        const docs &#x3D; parser.parse(tsxTargets);
        for (const doc of docs) {
          if (!doc.displayName) continue;
          const sourcePath &#x3D;
            doc.filePath &amp;amp;&amp;amp; this.isWithinPackage(packageAbs, doc.filePath)
              ? doc.filePath
              : (tsxTargets.find(
                  (file) &#x3D;&amp;gt; doc.filePath &amp;amp;&amp;amp; path.resolve(file) &#x3D;&#x3D;&#x3D; path.resolve(doc.filePath),
                ) ?? null);
          const relativePath &#x3D; sourcePath
            ? this.normalizeRelativePath(path.relative(packageAbs, sourcePath))
            : &amp;quot;&amp;quot;;
          const props &#x3D; doc.props
            ? Object.entries(doc.props)
                .slice(0, 25)
                .map(([propName, prop]) &#x3D;&amp;gt; {
                  const type &#x3D; this.describePropType(prop);
                  return {
                    name: propName,
                    ...(type ? { type } : {}),
                    required: Boolean(prop.required),
                    description: prop.description?.trim() || undefined,
                  };
                })
                .filter((propInfo) &#x3D;&amp;gt; propInfo.name)
            : undefined;

          const key &#x3D; &#x60;${doc.displayName}:${relativePath}&#x60;;
          if (!discoveredKeys.has(key)) {
            discoveredKeys.add(key);
            results.push({
              name: doc.displayName,
              filePath: relativePath,
              framework: &amp;quot;react&amp;quot;,
              description: doc.description?.trim() || undefined,
              props: props &amp;amp;&amp;amp; props.length &amp;gt; 0 ? props : undefined,
            });
          }
        }
      } catch (error) {
        console.warn(&amp;quot;react-docgen-typescript parsing failed:&amp;quot;, error);
      }
    }

    const fallbackTargets &#x3D; componentFiles.slice(0, 40);
    for (const fileInfo of fallbackTargets) {
      const relativePath &#x3D; this.normalizeRelativePath(path.relative(packageAbs, fileInfo.path));
      const componentName &#x3D; this.inferComponentNameFromFile(fileInfo.path);
      const key &#x3D; &#x60;${componentName}:${relativePath}&#x60;;
      if (!discoveredKeys.has(key)) {
        discoveredKeys.add(key);
        results.push({
          name: componentName,
          filePath: relativePath,
          framework: &amp;quot;react&amp;quot;,
        });
      }
    }

    return results;
  }

  private async getReactParser(
    tsconfigPath?: string,
  ): Promise&amp;lt;{ parse: (filePaths: string[]) &#x3D;&amp;gt; ComponentDoc[] } | null&amp;gt; {
    const cacheKey &#x3D; tsconfigPath ? path.resolve(tsconfigPath) : &amp;quot;__default__&amp;quot;;
    if (this.reactParserCache.has(cacheKey)) {
      return this.reactParserCache.get(cacheKey) ?? null;
    }

    const docgenModule &#x3D; await this.getReactDocgenModule();
    if (!docgenModule) {
      this.reactParserCache.set(cacheKey, null);
      return null;
    }

    try {
      const parserOptions &#x3D; {
        savePropValueAsString: true,
        shouldExtractLiteralValuesFromEnum: true,
        shouldRemoveUndefinedFromOptional: true,
      };
      const parser &#x3D;
        tsconfigPath &amp;amp;&amp;amp; (await fs.pathExists(tsconfigPath))
          ? docgenModule.withCustomConfig(tsconfigPath, parserOptions)
          : docgenModule.withDefaultConfig(parserOptions);
      this.reactParserCache.set(cacheKey, parser);
      return parser;
    } catch (error) {
      console.warn(&amp;quot;Failed to initialize react-docgen parser:&amp;quot;, error);
      this.reactParserCache.set(cacheKey, null);
      return null;
    }
  }

  private async getReactDocgenModule(): Promise&amp;lt;ReactDocgenModule | null&amp;gt; {
    if (this.reactDocgenModule !&#x3D;&#x3D; undefined) {
      return this.reactDocgenModule;
    }

    try {
      this.reactDocgenModule &#x3D; await import(&amp;quot;react-docgen-typescript&amp;quot;);
    } catch (error) {
      console.warn(&amp;quot;react-docgen-typescript module is not available:&amp;quot;, error);
      this.reactDocgenModule &#x3D; null;
    }

    return this.reactDocgenModule;
  }

  private async findNearestTsconfig(startDir: string): Promise&amp;lt;string | undefined&amp;gt; {
    let current &#x3D; path.resolve(startDir);
    const root &#x3D; path.parse(current).root;

    while (true) {
      const candidate &#x3D; path.join(current, &amp;quot;tsconfig.json&amp;quot;);
      if (await fs.pathExists(candidate)) {
        return candidate;
      }
      if (current &#x3D;&#x3D;&#x3D; root) {
        break;
      }
      current &#x3D; path.dirname(current);
    }

    return undefined;
  }

  private async extractVueComponents(
    packageAbs: string,
    fileInfos: FileInfo[],
  ): Promise&amp;lt;FrontendComponentSummary[]&amp;gt; {
    const vueFiles &#x3D; fileInfos
      .filter((file) &#x3D;&amp;gt; file.path.endsWith(&amp;quot;.vue&amp;quot;))
      .filter((file) &#x3D;&amp;gt; !file.path.includes(&#x60;${path.sep}node_modules${path.sep}&#x60;))
      .slice(0, 40);

    const results: FrontendComponentSummary[] &#x3D; [];

    for (const fileInfo of vueFiles) {
      try {
        const content &#x3D; await fs.readFile(fileInfo.path, &amp;quot;utf-8&amp;quot;);
        const nameMatch &#x3D; content.match(/\bname\s*:\s*[&amp;#39;&amp;quot;]([^&amp;#39;&amp;quot;\n]+)[&amp;#39;&amp;quot;]/);
        const defineMatch &#x3D; content.match(
          /defineComponent\s*\(\s*{[^}]*name\s*:\s*[&amp;#39;&amp;quot;]([^&amp;#39;&amp;quot;\n]+)[&amp;#39;&amp;quot;]/,
        );
        const scriptSetupMatch &#x3D; content.match(
          /&amp;lt;script[^&amp;gt;]*setup[^&amp;gt;]*&amp;gt;[^&amp;lt;]*const\s+([A-Z][A-Za-z0-9_]*)\s*&#x3D;/,
        );
        const fallbackName &#x3D; this.inferComponentNameFromFile(fileInfo.path);
        const componentName &#x3D;
          nameMatch?.[1] ?? defineMatch?.[1] ?? scriptSetupMatch?.[1] ?? fallbackName;
        const relativePath &#x3D; this.normalizeRelativePath(path.relative(packageAbs, fileInfo.path));
        results.push({
          name: componentName,
          filePath: relativePath,
          framework: &amp;quot;vue&amp;quot;,
        });
      } catch {
        continue;
      }
    }

    return results;
  }

  private async detectReactRouterRoutes(
    packageAbs: string,
    fileInfos: FileInfo[],
  ): Promise&amp;lt;FrontendRouteSummary | null&amp;gt; {
    const candidates &#x3D; fileInfos
      .filter((file) &#x3D;&amp;gt; /\.(tsx|ts|jsx|js)$/.test(file.path))
      .filter((file) &#x3D;&amp;gt; !file.path.includes(&#x60;${path.sep}node_modules${path.sep}&#x60;))
      .slice(0, 40);

    const routes &#x3D; new Map&amp;lt;string, string | undefined&amp;gt;();

    for (const file of candidates) {
      try {
        const content &#x3D; await fs.readFile(file.path, &amp;quot;utf-8&amp;quot;);
        if (!/react-router/.test(content)) {
          continue;
        }
        const truncated &#x3D; content.slice(0, 8000);
        const elementMatches &#x3D; truncated.matchAll(/&amp;lt;Route[^&amp;gt;]*path\s*&#x3D;\s*[&amp;#39;&amp;quot;&#x60;]([^&amp;#39;&amp;quot;&#x60;{}]+)[&amp;#39;&amp;quot;&#x60;]/g);
        for (const match of elementMatches) {
          const routePath &#x3D; match[1].trim();
          if (routePath) {
            routes.set(routePath, this.normalizeRelativePath(path.relative(packageAbs, file.path)));
          }
        }

        if (/createBrowserRouter|createRoutesFromElements|createHashRouter/.test(truncated)) {
          const objectMatches &#x3D; truncated.matchAll(/\bpath\s*:\s*[&amp;#39;&amp;quot;&#x60;]([^&amp;#39;&amp;quot;&#x60;{}]+)[&amp;#39;&amp;quot;&#x60;]/g);
          for (const match of objectMatches) {
            const routePath &#x3D; match[1].trim();
            if (routePath) {
              routes.set(
                routePath,
                this.normalizeRelativePath(path.relative(packageAbs, file.path)),
              );
            }
          }
        }
      } catch {
        continue;
      }
    }

    if (!routes.size) {
      return null;
    }

    return {
      type: &amp;quot;react-router&amp;quot;,
      routes: Array.from(routes.entries()).map(([pathName, filePath]) &#x3D;&amp;gt; ({
        path: pathName,
        filePath,
      })),
    };
  }

  private detectNextRoutes(packageAbs: string, fileInfos: FileInfo[]): FrontendRouteSummary | null {
    const routes &#x3D; new Map&amp;lt;string, string | undefined&amp;gt;();
    const normalizedPackage &#x3D; path.resolve(packageAbs);

    for (const file of fileInfos) {
      if (file.path.includes(&#x60;${path.sep}node_modules${path.sep}&#x60;)) {
        continue;
      }
      if (
        !file.path.endsWith(&amp;quot;.tsx&amp;quot;) &amp;amp;&amp;amp;
        !file.path.endsWith(&amp;quot;.jsx&amp;quot;) &amp;amp;&amp;amp;
        !file.path.endsWith(&amp;quot;.ts&amp;quot;) &amp;amp;&amp;amp;
        !file.path.endsWith(&amp;quot;.js&amp;quot;)
      ) {
        continue;
      }
      if (file.path.endsWith(&amp;quot;.d.ts&amp;quot;)) {
        continue;
      }

      const relativePath &#x3D; this.normalizeRelativePath(path.relative(normalizedPackage, file.path));
      if (!relativePath) {
        continue;
      }

      if (relativePath.startsWith(&amp;quot;pages/&amp;quot;)) {
        if (relativePath.startsWith(&amp;quot;pages/api/&amp;quot;)) {
          continue;
        }
        let route &#x3D; relativePath.slice(&amp;quot;pages/&amp;quot;.length).replace(/\.(tsx|jsx|ts|js)$/i, &amp;quot;&amp;quot;);
        const base &#x3D; path.basename(route);
        if ([&amp;quot;_app&amp;quot;, &amp;quot;_document&amp;quot;, &amp;quot;_error&amp;quot;].includes(base)) {
          continue;
        }
        route &#x3D; route.split(&amp;quot;\\&amp;quot;).join(&amp;quot;/&amp;quot;);
        if (route &#x3D;&#x3D;&#x3D; &amp;quot;index&amp;quot;) {
          routes.set(&amp;quot;/&amp;quot;, this.normalizeRelativePath(relativePath));
        } else {
          route &#x3D; route.split(&amp;quot;\\&amp;quot;).join(&amp;quot;/&amp;quot;);
          if (route.endsWith(&amp;quot;/index&amp;quot;)) {
            route &#x3D; route.slice(0, -&amp;quot;/index&amp;quot;.length);
          }
          const normalizedRoute &#x3D; this.normalizeNextRoute(route);
          routes.set(normalizedRoute, this.normalizeRelativePath(relativePath));
        }
        continue;
      }

      if (relativePath.startsWith(&amp;quot;app/&amp;quot;)) {
        const withoutExt &#x3D; relativePath.replace(/\.(tsx|jsx|ts|js)$/i, &amp;quot;&amp;quot;);
        if (!withoutExt.endsWith(&amp;quot;/page&amp;quot;)) {
          continue;
        }
        const routeSegment &#x3D; withoutExt.slice(&amp;quot;app/&amp;quot;.length, -&amp;quot;/page&amp;quot;.length);
        const normalizedRoute &#x3D; this.normalizeNextRoute(routeSegment || &amp;quot;/&amp;quot;);
        routes.set(normalizedRoute, this.normalizeRelativePath(relativePath));
      }
    }

    if (!routes.size) {
      return null;
    }

    return {
      type: &amp;quot;next&amp;quot;,
      routes: Array.from(routes.entries()).map(([pathName, filePath]) &#x3D;&amp;gt; ({
        path: pathName,
        filePath,
      })),
    };
  }

  private normalizeNextRoute(route: string): string {
    const cleaned &#x3D; route
      .split(&amp;quot;\\&amp;quot;)
      .join(&amp;quot;/&amp;quot;)
      .replace(/\/+/g, &amp;quot;/&amp;quot;)
      .replace(/^\//, &amp;quot;&amp;quot;)
      .replace(/\/$/, &amp;quot;&amp;quot;);
    if (!cleaned) {
      return &amp;quot;/&amp;quot;;
    }

    const segments &#x3D; cleaned.split(&amp;quot;/&amp;quot;).filter(Boolean);
    const transformed &#x3D; segments
      .map((segment) &#x3D;&amp;gt; this.transformNextSegment(segment))
      .filter(Boolean);
    const joined &#x3D; transformed.join(&amp;quot;/&amp;quot;);
    const prefixed &#x3D; &#x60;/${joined}&#x60;.replace(/\/+/g, &amp;quot;/&amp;quot;);
    return prefixed &#x3D;&#x3D;&#x3D; &amp;quot;/&amp;quot; ? &amp;quot;/&amp;quot; : prefixed.replace(/\/$/, &amp;quot;&amp;quot;);
  }

  private transformNextSegment(segment: string): string {
    if (!segment) {
      return &amp;quot;&amp;quot;;
    }
    if (segment.startsWith(&amp;quot;[[...&amp;quot;) &amp;amp;&amp;amp; segment.endsWith(&amp;quot;]]&amp;quot;)) {
      const inner &#x3D; segment.slice(4, -2);
      return &#x60;:${inner}*?&#x60;;
    }
    if (segment.startsWith(&amp;quot;[...&amp;quot;) &amp;amp;&amp;amp; segment.endsWith(&amp;quot;]&amp;quot;)) {
      const inner &#x3D; segment.slice(4, -1);
      return &#x60;:${inner}*&#x60;;
    }
    if (segment.startsWith(&amp;quot;[&amp;quot;) &amp;amp;&amp;amp; segment.endsWith(&amp;quot;]&amp;quot;)) {
      const inner &#x3D; segment.slice(1, -1);
      return &#x60;:${inner}&#x60;;
    }
    if (segment &#x3D;&#x3D;&#x3D; &amp;quot;index&amp;quot;) {
      return &amp;quot;&amp;quot;;
    }
    return segment;
  }

  private deduplicateComponents(
    components: FrontendComponentSummary[],
  ): FrontendComponentSummary[] {
    const seen &#x3D; new Map&amp;lt;string, FrontendComponentSummary&amp;gt;();
    for (const component of components) {
      if (!component.name) {
        continue;
      }
      const key &#x3D; &#x60;${component.framework}:${component.name}:${component.filePath}&#x60;;
      if (!seen.has(key)) {
        seen.set(key, component);
      }
    }
    return Array.from(seen.values());
  }

  private addFramework(analysis: FrontendAnalysis, framework: string): void {
    if (!analysis.frameworks.includes(framework)) {
      analysis.frameworks.push(framework);
    }
  }

  private isWithinPackage(packageAbs: string, target: string): boolean {
    const base &#x3D; path.resolve(packageAbs);
    const candidate &#x3D; path.resolve(target);
    if (base &#x3D;&#x3D;&#x3D; candidate) {
      return true;
    }
    const prefix &#x3D; base.endsWith(path.sep) ? base : &#x60;${base}${path.sep}&#x60;;
    return candidate.startsWith(prefix);
  }

  private describePropType(prop: PropItem): string | undefined {
    const propAny &#x3D; prop as any;
    const typeSource: any &#x3D; propAny.tsType ?? prop.type;
    if (!typeSource) {
      return undefined;
    }
    if (typeof typeSource.raw &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; &amp;amp;&amp;amp; typeSource.raw.trim().length &amp;gt; 0) {
      return typeSource.raw.trim();
    }
    if (typeSource.name &#x3D;&#x3D;&#x3D; &amp;quot;union&amp;quot; &amp;amp;&amp;amp; Array.isArray(typeSource.value)) {
      const unionValues &#x3D; typeSource.value
        .map((item: any) &#x3D;&amp;gt; item.name || item.value)
        .filter(Boolean);
      if (unionValues.length) {
        return unionValues.join(&amp;quot; | &amp;quot;);
      }
    }
    if (typeSource.name &#x3D;&#x3D;&#x3D; &amp;quot;enum&amp;quot; &amp;amp;&amp;amp; Array.isArray(typeSource.value)) {
      const enumValues &#x3D; typeSource.value.map((item: any) &#x3D;&amp;gt; item.value).filter(Boolean);
      if (enumValues.length) {
        return enumValues.join(&amp;quot; | &amp;quot;);
      }
    }
    if (typeof typeSource.name &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; &amp;amp;&amp;amp; typeSource.name.length &amp;gt; 0) {
      return typeSource.name;
    }
    return undefined;
  }

  private inferComponentNameFromFile(filePath: string): string {
    return this.toPascalCase(path.basename(filePath, path.extname(filePath))) || &amp;quot;Component&amp;quot;;
  }

  private toPascalCase(value: string): string {
    return value
      .split(/[-_\s]+/)
      .filter(Boolean)
      .map((part) &#x3D;&amp;gt; part.charAt(0).toUpperCase() + part.slice(1))
      .join(&amp;quot;&amp;quot;);
  }

  private getPackageRelativeRoot(evidence: Evidence, context: InferenceContext): string {
    const projectRoot &#x3D; context.projectRoot ?? context.fileIndex.root ?? &amp;quot;&amp;quot;;
    const packageDir &#x3D; path.dirname(evidence.filePath);
    const relative &#x3D; projectRoot ? path.relative(projectRoot, packageDir) : packageDir;
    const normalized &#x3D; this.normalizeRelativePath(relative);
    return normalized &#x3D;&#x3D;&#x3D; &amp;quot;&amp;quot; ? &amp;quot;.&amp;quot; : normalized;
  }

  private normalizeRelativePath(value: string): string {
    const normalized &#x3D; value.replace(/\\+/g, &amp;quot;/&amp;quot;);
    if (normalized &#x3D;&#x3D;&#x3D; &amp;quot;.&amp;quot;) {
      return &amp;quot;.&amp;quot;;
    }
    if (normalized.startsWith(&amp;quot;./&amp;quot;)) {
      return normalized.slice(2);
    }
    return normalized;
  }

  private collectDependencies(pkg: any): Record&amp;lt;string, string&amp;gt; {
    return {
      ...(pkg.dependencies || {}),
      ...(pkg.devDependencies || {}),
      ...(pkg.optionalDependencies || {}),
      ...(pkg.peerDependencies || {}),
    };
  }

  private detectFrameworkDependencies(pkg: any): string[] {
    const deps &#x3D; this.collectDependencies(pkg);
    return NODE_WEB_FRAMEWORKS.filter((dep) &#x3D;&amp;gt; deps[dep]);
  }

  private determineManifestClassification(
    pkg: any,
    dependencies: Record&amp;lt;string, string&amp;gt;,
    scripts: Record&amp;lt;string, string&amp;gt;,
  ): {
    artifactType: ArtifactType;
    detectedType: string;
    reason: string;
  } | null {
    const depsLower &#x3D; new Set(Object.keys(dependencies).map((dep) &#x3D;&amp;gt; dep.toLowerCase()));
    const hasAnyDependency &#x3D; (candidates: string[]) &#x3D;&amp;gt;
      candidates.some((candidate) &#x3D;&amp;gt; depsLower.has(candidate));

    const hasTypesField &#x3D; typeof pkg.types &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; || typeof pkg.typings &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;;
    const hasRuntimeScript &#x3D; [&amp;quot;start&amp;quot;, &amp;quot;serve&amp;quot;, &amp;quot;dev&amp;quot;, &amp;quot;run&amp;quot;].some((scriptName) &#x3D;&amp;gt; {
      const command &#x3D; scripts[scriptName];
      if (typeof command !&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
        return false;
      }
      const normalized &#x3D; command.toLowerCase();
      return (
        normalized.includes(&amp;quot;server&amp;quot;) ||
        normalized.includes(&amp;quot;serve&amp;quot;) ||
        normalized.includes(&amp;quot;start&amp;quot;) ||
        normalized.includes(&amp;quot;node &amp;quot;) ||
        normalized.includes(&amp;quot;bun &amp;quot;) ||
        normalized.includes(&amp;quot;ts-node&amp;quot;) ||
        normalized.includes(&amp;quot;tsx&amp;quot;) ||
        normalized.includes(&amp;quot;hono&amp;quot;) ||
        normalized.includes(&amp;quot;express&amp;quot;)
      );
    });
    const hasBin &#x3D; Boolean(
      (typeof pkg.bin &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; &amp;amp;&amp;amp; pkg.bin.trim().length &amp;gt; 0) ||
        (pkg.bin &amp;amp;&amp;amp; typeof pkg.bin &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot; &amp;amp;&amp;amp; Object.keys(pkg.bin).length &amp;gt; 0),
    );

    if (hasTypesField &amp;amp;&amp;amp; !hasRuntimeScript &amp;amp;&amp;amp; !hasBin) {
      return {
        artifactType: &amp;quot;package&amp;quot;,
        detectedType: &amp;quot;package&amp;quot;,
        reason: &amp;quot;types-package&amp;quot;,
      };
    }

    const hasWebFramework &#x3D; hasAnyDependency(NODE_WEB_FRAMEWORKS);
    if (hasWebFramework) {
      return {
        artifactType: &amp;quot;service&amp;quot;,
        detectedType: &amp;quot;web_service&amp;quot;,
        reason: &amp;quot;web-framework&amp;quot;,
      };
    }

    const hasFrontendFramework &#x3D;
      hasAnyDependency(NODE_FRONTEND_FRAMEWORKS) || Boolean(pkg.browserslist);
    if (hasFrontendFramework) {
      return {
        artifactType: &amp;quot;frontend&amp;quot;,
        detectedType: &amp;quot;frontend&amp;quot;,
        reason: &amp;quot;frontend-framework&amp;quot;,
      };
    }

    const hasCliDependency &#x3D; hasAnyDependency(NODE_CLI_FRAMEWORKS);
    if (hasBin || hasCliDependency) {
      return {
        artifactType: &amp;quot;tool&amp;quot;,
        detectedType: &amp;quot;tool&amp;quot;,
        reason: hasBin ? &amp;quot;manifest-bin&amp;quot; : &amp;quot;cli-dependency&amp;quot;,
      };
    }

    return {
      artifactType: &amp;quot;package&amp;quot;,
      detectedType: &amp;quot;package&amp;quot;,
      reason: &amp;quot;default-package&amp;quot;,
    };
  }

  private usesTypeScript(pkg: any, scripts: Record&amp;lt;string, string&amp;gt;): boolean {
    const deps &#x3D; this.collectDependencies(pkg);
    const signals &#x3D; [&amp;quot;typescript&amp;quot;, &amp;quot;ts-node&amp;quot;, &amp;quot;ts-node-dev&amp;quot;, &amp;quot;tsx&amp;quot;, &amp;quot;tsup&amp;quot;, &amp;quot;@swc/core&amp;quot;];
    const hasDependency &#x3D; signals.some((signal) &#x3D;&amp;gt; Boolean(deps[signal]));
    if (hasDependency) {
      return true;
    }

    if (typeof pkg.types &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; || typeof pkg.typings &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
      return true;
    }

    const scriptSignals &#x3D; [&amp;quot;ts-node&amp;quot;, &amp;quot;tsx&amp;quot;, &amp;quot;ts-node-dev&amp;quot;, &amp;quot;tsup&amp;quot;, &amp;quot;tsc&amp;quot;];
    return Object.values(scripts)
      .filter((command): command is string &#x3D;&amp;gt; typeof command &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;)
      .some((command) &#x3D;&amp;gt; scriptSignals.some((signal) &#x3D;&amp;gt; command.includes(signal)));
  }

  private async buildTsoaAnalysis(
    pkg: any,
    packageRoot: string,
    context: InferenceContext,
    scripts: Record&amp;lt;string, string&amp;gt;,
  ): Promise&amp;lt;Record&amp;lt;string, unknown&amp;gt; | null&amp;gt; {
    const frameworks &#x3D; this.detectFrameworkDependencies(pkg);
    if (frameworks.length &#x3D;&#x3D;&#x3D; 0) {
      return null;
    }

    if (!this.usesTypeScript(pkg, scripts)) {
      return null;
    }

    const deps &#x3D; this.collectDependencies(pkg);
    const hasTsoaDependency &#x3D; Boolean(deps.tsoa);
    const projectRoot &#x3D; context.projectRoot ?? context.fileIndex.root ?? &amp;quot;&amp;quot;;
    if (!projectRoot) {
      return null;
    }

    const normalizedRoot &#x3D; packageRoot &#x3D;&#x3D;&#x3D; &amp;quot;.&amp;quot; ? &amp;quot;&amp;quot; : this.normalizeRelativePath(packageRoot);
    const packageAbsoluteRoot &#x3D; normalizedRoot
      ? path.resolve(projectRoot, normalizedRoot)
      : projectRoot;

    let tsFiles: string[] &#x3D; [];
    let configFiles: string[] &#x3D; [];

    try {
      tsFiles &#x3D; (
        await glob(&amp;quot;**/*.{ts,tsx}&amp;quot;, {
          cwd: packageAbsoluteRoot,
          ignore: [
            &amp;quot;**/node_modules/**&amp;quot;,
            &amp;quot;**/.next/**&amp;quot;,
            &amp;quot;**/dist/**&amp;quot;,
            &amp;quot;**/build/**&amp;quot;,
            &amp;quot;**/.turbo/**&amp;quot;,
          ],
          absolute: false,
          nodir: true,
        })
      ).map((rel) &#x3D;&amp;gt; this.normalizeRelativePath(rel));

      configFiles &#x3D; (
        await glob(&amp;quot;**/tsoa*.json&amp;quot;, {
          cwd: packageAbsoluteRoot,
          ignore: [
            &amp;quot;**/node_modules/**&amp;quot;,
            &amp;quot;**/.next/**&amp;quot;,
            &amp;quot;**/dist/**&amp;quot;,
            &amp;quot;**/build/**&amp;quot;,
            &amp;quot;**/.turbo/**&amp;quot;,
          ],
          absolute: false,
          nodir: true,
        })
      ).map((rel) &#x3D;&amp;gt; this.normalizeRelativePath(rel));
    } catch {
      return null;
    }

    const controllerCandidates &#x3D; tsFiles
      .filter((rel) &#x3D;&amp;gt; /controller|route|api/i.test(rel))
      .filter((rel) &#x3D;&amp;gt; !/\.d\.ts$/i.test(rel))
      .filter((rel) &#x3D;&amp;gt; !/\btests?\//i.test(rel) &amp;amp;&amp;amp; !/__tests__\//i.test(rel))
      .slice(0, 50);
    const scriptsUsingTsoa &#x3D; Object.entries(scripts)
      .filter(([, command]) &#x3D;&amp;gt; typeof command &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; &amp;amp;&amp;amp; command.includes(&amp;quot;tsoa&amp;quot;))
      .map(([name]) &#x3D;&amp;gt; name);

    return {
      root: packageRoot,
      frameworks,
      usesTypeScript: true,
      hasTsoaDependency,
      totalTypeScriptFiles: tsFiles.length,
      controllerCandidates,
      configFiles: configFiles.slice(0, 10),
      scriptsUsingTsoa,
      recommendedCommands: hasTsoaDependency
        ? [&amp;quot;npx tsoa spec&amp;quot;, &amp;quot;npx tsoa routes&amp;quot;]
        : [&amp;quot;npm install --save-dev tsoa&amp;quot;, &amp;quot;npx tsoa spec&amp;quot;, &amp;quot;npx tsoa routes&amp;quot;],
    };
  }

  private detectArtifactType(context: DetectionContext): {
    primaryType: keyof CategoryMatrix;
    confidence: number;
  } {
    const result &#x3D; detectArtifactType(context);
    return { primaryType: result.primaryType, confidence: result.confidence };
  }

  private mapCategoryToType(category: keyof CategoryMatrix): ArtifactType {
    const mapping: Record&amp;lt;keyof CategoryMatrix, ArtifactType&amp;gt; &#x3D; {
      tool: &amp;quot;tool&amp;quot;,
      web_service: &amp;quot;service&amp;quot;,
      frontend: &amp;quot;frontend&amp;quot;,
      package: &amp;quot;package&amp;quot;,
      desktop_app: &amp;quot;binary&amp;quot;,
      data_processing: &amp;quot;package&amp;quot;,
      testing: &amp;quot;test&amp;quot;,
      build_tool: &amp;quot;package&amp;quot;,
      game: &amp;quot;frontend&amp;quot;,
      mobile: &amp;quot;frontend&amp;quot;,
    };
    return mapping[category] || &amp;quot;package&amp;quot;;
  }

  private inferFramework(pkg: any): string {
    const deps &#x3D; { ...(pkg.dependencies || {}), ...(pkg.devDependencies || {}) };
    if (NODE_WEB_FRAMEWORKS.some((fw) &#x3D;&amp;gt; deps[fw])) return &amp;quot;web&amp;quot;;
    if (NODE_FRONTEND_FRAMEWORKS.some((fw) &#x3D;&amp;gt; deps[fw])) return &amp;quot;frontend&amp;quot;;
    if (NODE_CLI_FRAMEWORKS.some((fw) &#x3D;&amp;gt; deps[fw])) return &amp;quot;tool&amp;quot;;
    return &amp;quot;&amp;quot;;
  }
}

export const nodejsPlugin &#x3D; new NodeJSPlugin();
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(8)">
                    <span class="file-path">package package.json</span>
                    <div class="file-meta">
                        <span>1.31 KB</span>
                        <span>325 tokens</span>
                        <span>Score: 0.52</span>
                    </div>
                </div>
                <div class="file-content" id="file-8">
                    <pre class="code-block"><code>{
  &amp;quot;name&amp;quot;: &amp;quot;@arbiter/importer&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.1.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;Codebase analysis and artifact detection for importing existing projects&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;./dist/index.js&amp;quot;,
  &amp;quot;types&amp;quot;: &amp;quot;./dist/index.d.ts&amp;quot;,
  &amp;quot;exports&amp;quot;: {
    &amp;quot;.&amp;quot;: {
      &amp;quot;types&amp;quot;: &amp;quot;./dist/index.d.ts&amp;quot;,
      &amp;quot;import&amp;quot;: &amp;quot;./dist/index.js&amp;quot;
    },
    &amp;quot;./scanner&amp;quot;: {
      &amp;quot;types&amp;quot;: &amp;quot;./dist/scanner.d.ts&amp;quot;,
      &amp;quot;import&amp;quot;: &amp;quot;./dist/scanner.js&amp;quot;
    },
    &amp;quot;./plugins&amp;quot;: {
      &amp;quot;types&amp;quot;: &amp;quot;./dist/plugins/index.d.ts&amp;quot;,
      &amp;quot;import&amp;quot;: &amp;quot;./dist/plugins/index.js&amp;quot;
    },
    &amp;quot;./plugins/*&amp;quot;: {
      &amp;quot;types&amp;quot;: &amp;quot;./dist/plugins/*.d.ts&amp;quot;,
      &amp;quot;import&amp;quot;: &amp;quot;./dist/plugins/*.js&amp;quot;
    }
  },
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;build&amp;quot;: &amp;quot;tsc&amp;quot;,
    &amp;quot;dev&amp;quot;: &amp;quot;tsc --watch&amp;quot;,
    &amp;quot;clean&amp;quot;: &amp;quot;rm -rf dist&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;bun test&amp;quot;,
    &amp;quot;lint&amp;quot;: &amp;quot;biome check src/&amp;quot;,
    &amp;quot;format&amp;quot;: &amp;quot;biome format --write src/&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;fs-extra&amp;quot;: &amp;quot;^11.2.0&amp;quot;,
    &amp;quot;glob&amp;quot;: &amp;quot;^10.3.10&amp;quot;,
    &amp;quot;react-docgen-typescript&amp;quot;: &amp;quot;^2.4.0&amp;quot;
  },
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;@types/fs-extra&amp;quot;: &amp;quot;^11.0.4&amp;quot;,
    &amp;quot;@types/node&amp;quot;: &amp;quot;^20.11.5&amp;quot;,
    &amp;quot;typescript&amp;quot;: &amp;quot;^5.3.3&amp;quot;
  },
  &amp;quot;files&amp;quot;: [
    &amp;quot;dist/**/*&amp;quot;,
    &amp;quot;README.md&amp;quot;
  ],
  &amp;quot;keywords&amp;quot;: [
    &amp;quot;importer&amp;quot;,
    &amp;quot;codebase-analysis&amp;quot;,
    &amp;quot;artifact-detection&amp;quot;,
    &amp;quot;plugin-system&amp;quot;,
    &amp;quot;brownfield&amp;quot;
  ],
  &amp;quot;author&amp;quot;: &amp;quot;Arbiter Team&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;
}
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(9)">
                    <span class="file-path">file-code src/scanner.ts</span>
                    <div class="file-meta">
                        <span>37.04 KB</span>
                        <span>7,899 tokens</span>
                        <span>Score: 0.40</span>
                    </div>
                </div>
                <div class="file-content" id="file-9">
                    <pre class="code-block"><code>/**
 * @packageDocumentation
 * Implements the importer scanning pipeline that discovers files, dispatches
 * plugin analysis, and aggregates inferred artifacts.
 */

import { spawn } from &amp;quot;child_process&amp;quot;;
import * as path from &amp;quot;path&amp;quot;;
import * as fs from &amp;quot;fs-extra&amp;quot;;
import { glob } from &amp;quot;glob&amp;quot;;
import {
  AnalysisConfiguration,
  AnalysisStatistics,
  ArtifactManifest,
  ArtifactType,
  ConfigurationError,
  DirectoryInfo,
  Evidence,
  EvidenceType,
  FileIndex,
  FileInfo,
  FileSystemError,
  ImporterError,
  ImporterPlugin,
  InferenceContext,
  InferenceError,
  InferenceOptions,
  InferredArtifact,
  ParseContext,
  ParseError,
  ParseOptions,
  PluginError,
  ProjectMetadata,
} from &amp;quot;./types&amp;quot;;

/**
 * Configuration used to control the scanner pipeline.
 *
 * @public
 */
export interface ScannerConfig {
  /** Root directory to analyze */
  projectRoot: string;
  /** Optional project name override */
  projectName?: string;
  /** Parse options */
  parseOptions: ParseOptions;
  /** Inference options */
  inferenceOptions: InferenceOptions;
  /** Registered plugins */
  plugins: ImporterPlugin[];
  /** Ignore patterns */
  ignorePatterns: string[];
  /** Max concurrency */
  maxConcurrency: number;
  /** Debug mode */
  debug: boolean;
}

/**
 * Default configuration applied when callers do not specify overrides.
 */
const DEFAULT_SCANNER_CONFIG: Partial&amp;lt;ScannerConfig&amp;gt; &#x3D; {
  parseOptions: {
    deepAnalysis: false,
    targetLanguages: [],
    maxFileSize: 10 * 1024 * 1024, // 10MB
    includeBinaries: false,
    patterns: {
      include: [],
      exclude: [],
    },
  },
  inferenceOptions: {
    minConfidence: 0.3,
    inferRelationships: false,
    maxDependencyDepth: 3,
    useHeuristics: true,
  },
  ignorePatterns: [
    &amp;quot;node_modules/**&amp;quot;,
    &amp;quot;.git/**&amp;quot;,
    &amp;quot;**/.DS_Store&amp;quot;,
    &amp;quot;**/Thumbs.db&amp;quot;,
    &amp;quot;**/*.log&amp;quot;,
    &amp;quot;dist/**&amp;quot;,
    &amp;quot;build/**&amp;quot;,
    &amp;quot;target/**&amp;quot;,
    &amp;quot;**/__pycache__/**&amp;quot;,
    &amp;quot;**/*.pyc&amp;quot;,
    &amp;quot;.next/**&amp;quot;,
    &amp;quot;.nuxt/**&amp;quot;,
    &amp;quot;coverage/**&amp;quot;,
  ],
  maxConcurrency: 10,
  debug: false,
};

/**
 * Maintains the set of importer plugins available to the scanner.
 *
 * @public
 */
export class PluginRegistry {
  private plugins &#x3D; new Map&amp;lt;string, ImporterPlugin&amp;gt;();
  private enabledPlugins &#x3D; new Set&amp;lt;string&amp;gt;();

  /**
   * Registers a plugin so it can participate in future scans.
   *
   * @param plugin - Plugin instance to register.
   */
  register(plugin: ImporterPlugin): void {
    const name &#x3D; plugin.name();
    if (this.plugins.has(name)) {
      throw new ConfigurationError(&#x60;Plugin ${name} is already registered&#x60;);
    }
    this.plugins.set(name, plugin);
    this.enabledPlugins.add(name);
  }

  /**
   * Returns all plugins that are currently enabled.
   */
  getEnabled(): ImporterPlugin[] {
    return Array.from(this.enabledPlugins)
      .map((name) &#x3D;&amp;gt; this.plugins.get(name))
      .filter((plugin): plugin is ImporterPlugin &#x3D;&amp;gt; plugin !&#x3D;&#x3D; undefined);
  }

  /**
   * Filters registered plugins to those that support the provided file.
   *
   * @param filePath - Absolute file path to check.
   * @param fileContent - Optional file content available for heuristics.
   */
  getSupportingPlugins(filePath: string, fileContent?: string): ImporterPlugin[] {
    return this.getEnabled().filter((plugin) &#x3D;&amp;gt; {
      try {
        return plugin.supports(filePath, fileContent);
      } catch {
        return false;
      }
    });
  }
}

/**
 * Builds an index of files and directories that will participate in parsing.
 *
 * @param projectRoot - Root directory of the project under analysis.
 * @param ignorePatterns - Glob patterns to exclude from scanning.
 * @param parseOptions - Current parse options controlling file guards.
 */
async function buildFileIndex(
  projectRoot: string,
  ignorePatterns: string[],
  parseOptions: ParseOptions,
): Promise&amp;lt;FileIndex&amp;gt; {
  const files &#x3D; new Map&amp;lt;string, FileInfo&amp;gt;();
  const directories &#x3D; new Map&amp;lt;string, DirectoryInfo&amp;gt;();

  let allFiles: string[];
  try {
    allFiles &#x3D; await tryGitFileEnumeration(projectRoot);
  } catch {
    allFiles &#x3D; await fallbackGlobEnumeration(projectRoot, ignorePatterns, parseOptions);
  }

  for (const filePath of allFiles) {
    try {
      const stats &#x3D; await fs.stat(filePath);
      if (!stats.isFile()) continue;

      if (stats.size &amp;gt; parseOptions.maxFileSize) continue;

      const relativePath &#x3D; path.relative(projectRoot, filePath);
      const basename &#x3D; path.basename(filePath);
      const extension &#x3D; path.extname(filePath).toLowerCase();

      if (!passesConfigAllowlist(relativePath, basename)) continue;

      const isBinary &#x3D; await isFileBinary(filePath, parseOptions.includeBinaries);
      if (isBinary &amp;amp;&amp;amp; !parseOptions.includeBinaries) continue;

      if (!(await passesContentGuard(filePath, extension))) continue;

      const fileInfo: FileInfo &#x3D; {
        path: filePath,
        relativePath,
        size: stats.size,
        lastModified: stats.mtime.getTime(),
        extension,
        isBinary,
        metadata: {},
      };

      files.set(filePath, fileInfo);

      const dirPath &#x3D; path.dirname(filePath);
      if (!directories.has(dirPath)) {
        const dirStats &#x3D; await fs.stat(dirPath);
        directories.set(dirPath, {
          path: dirPath,
          relativePath: path.relative(projectRoot, dirPath),
          fileCount: 0,
          totalSize: 0,
          lastModified: dirStats.mtime.getTime(),
        });
      }

      const dirInfo &#x3D; directories.get(dirPath)!;
      dirInfo.fileCount++;
      dirInfo.totalSize +&#x3D; stats.size;
      dirInfo.lastModified &#x3D; Math.max(dirInfo.lastModified, stats.mtime.getTime());
    } catch {
      continue;
    }
  }

  return {
    root: projectRoot,
    files,
    directories,
    timestamp: Date.now(),
  };
}

/**
 * Enumerates files by delegating to &#x60;git ls-files&#x60; when the project is a Git repository.
 */
async function tryGitFileEnumeration(projectRoot: string): Promise&amp;lt;string[]&amp;gt; {
  const gitDir &#x3D; path.join(projectRoot, &amp;quot;.git&amp;quot;);
  if (!(await fs.pathExists(gitDir))) {
    throw new Error(&amp;quot;No git repo&amp;quot;);
  }

  return new Promise((resolve, reject) &#x3D;&amp;gt; {
    const gitProcess &#x3D; spawn(&amp;quot;git&amp;quot;, [&amp;quot;ls-files&amp;quot;, &amp;quot;-z&amp;quot;], {
      cwd: projectRoot,
      stdio: [&amp;quot;ignore&amp;quot;, &amp;quot;pipe&amp;quot;, &amp;quot;pipe&amp;quot;],
    });

    let stdout &#x3D; &amp;quot;&amp;quot;;
    let stderr &#x3D; &amp;quot;&amp;quot;;

    gitProcess.stdout?.on(&amp;quot;data&amp;quot;, (data) &#x3D;&amp;gt; {
      stdout +&#x3D; data.toString();
    });

    gitProcess.stderr?.on(&amp;quot;data&amp;quot;, (data) &#x3D;&amp;gt; {
      stderr +&#x3D; data.toString();
    });

    gitProcess.on(&amp;quot;close&amp;quot;, (code) &#x3D;&amp;gt; {
      if (code !&#x3D;&#x3D; 0) {
        reject(new Error(&#x60;git ls-files failed: ${stderr}&#x60;));
        return;
      }

      const relativeFiles &#x3D; stdout.split(&amp;quot;\0&amp;quot;).filter((f) &#x3D;&amp;gt; f.length &amp;gt; 0);
      const absoluteFiles &#x3D; relativeFiles.map((f) &#x3D;&amp;gt; path.resolve(projectRoot, f));
      resolve(absoluteFiles);
    });

    gitProcess.on(&amp;quot;error&amp;quot;, reject);
  });
}

/**
 * Glob-based fallback for projects that are not tracked by Git.
 */
async function fallbackGlobEnumeration(
  projectRoot: string,
  ignorePatterns: string[],
  parseOptions: ParseOptions,
): Promise&amp;lt;string[]&amp;gt; {
  const configPatterns &#x3D; [
    &amp;quot;**/Dockerfile&amp;quot;,
    &amp;quot;**/docker-compose*.{yaml,yml}&amp;quot;,
    &amp;quot;**/compose*.{yaml,yml}&amp;quot;,
    &amp;quot;**/kubernetes/*.{yaml,yml}&amp;quot;,
    &amp;quot;**/helm/**/Chart.yaml&amp;quot;,
    &amp;quot;**/helm/**/values*.{yaml,yml}&amp;quot;,
    &amp;quot;**/*.tf&amp;quot;,
    &amp;quot;**/terragrunt.hcl&amp;quot;,
    &amp;quot;**/*.bicep&amp;quot;,
    &amp;quot;**/*.cloudformation.{yaml,yml}&amp;quot;,
    &amp;quot;**/package.json&amp;quot;,
    &amp;quot;**/pnpm-workspace.yaml&amp;quot;,
    &amp;quot;**/yarn.lock&amp;quot;,
    &amp;quot;**/pyproject.toml&amp;quot;,
    &amp;quot;**/requirements*.txt&amp;quot;,
    &amp;quot;**/Pipfile&amp;quot;,
    &amp;quot;**/setup.cfg&amp;quot;,
    &amp;quot;**/poetry.lock&amp;quot;,
    &amp;quot;**/go.mod&amp;quot;,
    &amp;quot;**/go.sum&amp;quot;,
    &amp;quot;**/Cargo.toml&amp;quot;,
    &amp;quot;**/Cargo.lock&amp;quot;,
    &amp;quot;**/pom.xml&amp;quot;,
    &amp;quot;**/build.gradle*&amp;quot;,
    &amp;quot;**/settings.gradle*&amp;quot;,
    &amp;quot;**/Makefile&amp;quot;,
    &amp;quot;**/CMakeLists.txt&amp;quot;,
    &amp;quot;**/Gemfile&amp;quot;,
    &amp;quot;**/mix.exs&amp;quot;,
    &amp;quot;**/composer.json&amp;quot;,
    &amp;quot;**/.env&amp;quot;,
    &amp;quot;**/.env.*&amp;quot;,
    &amp;quot;**/Procfile&amp;quot;,
    &amp;quot;**/supervisord.conf&amp;quot;,
    &amp;quot;**/systemd/*.service&amp;quot;,
    &amp;quot;**/github/workflows/*.yaml&amp;quot;,
    &amp;quot;**/gitlab-ci.yml&amp;quot;,
    &amp;quot;**/azure-pipelines.yml&amp;quot;,
    &amp;quot;**/circle.yml&amp;quot;,
    &amp;quot;**/circleci/config.yml&amp;quot;,
    &amp;quot;**/Jenkinsfile&amp;quot;,
    &amp;quot;**/skaffold.yaml&amp;quot;,
    &amp;quot;**/Tiltfile&amp;quot;,
    &amp;quot;**/migrations/*&amp;quot;,
    &amp;quot;**/*.sql&amp;quot;,
    &amp;quot;**/schema.prisma&amp;quot;,
    &amp;quot;**/prisma/schema.prisma&amp;quot;,
    &amp;quot;**/openapi*.{yaml,yml}&amp;quot;,
    &amp;quot;**/*.proto&amp;quot;,
    &amp;quot;**/nginx/*.conf&amp;quot;,
    &amp;quot;**/haproxy/*.cfg&amp;quot;,
    &amp;quot;**/Caddyfile&amp;quot;,
  ];

  const excludePatterns &#x3D; [...ignorePatterns, ...parseOptions.patterns.exclude];

  return await glob(configPatterns, {
    cwd: projectRoot,
    ignore: excludePatterns,
    absolute: true,
    nodir: true,
    dot: true,
  });
}

/**
 * Filters out files that are unlikely to contain configuration or infrastructure hints.
 */
function passesConfigAllowlist(relativePath: string, basename: string): boolean {
  const configPatterns &#x3D; [
    /^Dockerfile$/,
    /^docker-compose.*\.ya?ml$/,
    /^compose.*\.ya?ml$/,
    /kubernetes\/.*\.ya?ml$/,
    /helm\//,
    /^Chart\.yaml$/,
    /^values.*\.ya?ml$/,
    /\.tf$/,
    /^terragrunt\.hcl$/,
    /\.bicep$/,
    /\.cloudformation\.ya?ml$/,
    /^package\.json$/,
    /^pnpm-workspace\.yaml$/,
    /^yarn\.lock$/,
    /^pyproject\.toml$/,
    /^requirements.*\.txt$/,
    /^Pipfile$/,
    /^setup\.cfg$/,
    /^poetry\.lock$/,
    /^go\.mod$/,
    /^go\.sum$/,
    /^Cargo\.toml$/,
    /^Cargo\.lock$/,
    /^pom\.xml$/,
    /^build\.gradle(\.kts)?$/,
    /^settings\.gradle(\.kts)?$/,
    /^Makefile$/,
    /^CMakeLists\.txt$/,
    /^Gemfile$/,
    /^mix\.exs$/,
    /^composer\.json$/,
    /^\.env$/,
    /^\.env\./,
    /^Procfile$/,
    /^supervisord\.conf$/,
    /systemd\/.*\.service$/,
    /^\.github\/workflows\/.*\.ya?ml$/,
    /^\.gitlab-ci\.yml$/,
    /^azure-pipelines\.yml$/,
    /^circle\.yml$/,
    /^\.circleci\/config\.yml$/,
    /^Jenkinsfile$/,
    /^skaffold\.yaml$/,
    /^Tiltfile$/,
    /^migrations\//,
    /\.sql$/,
    /^schema\.prisma$/,
    /^prisma\/schema\.prisma$/,
    /^openapi.*\.ya?ml$/,
    /\.proto$/,
    /nginx\/.*\.conf$/,
    /haproxy\/.*\.cfg$/,
    /^Caddyfile$/,
  ];

  return configPatterns.some((pattern) &#x3D;&amp;gt; pattern.test(basename) || pattern.test(relativePath));
}

/**
 * Guards against scanning files that are known to be generated or extremely large.
 */
async function passesContentGuard(filePath: string, extension: string): Promise&amp;lt;boolean&amp;gt; {
  try {
    const basename &#x3D; path.basename(filePath);
    const shouldGuard &#x3D;
      basename.includes(&amp;quot;docker-compose&amp;quot;) ||
      basename.includes(&amp;quot;compose&amp;quot;) ||
      basename.startsWith(&amp;quot;Dockerfile&amp;quot;) ||
      extension &#x3D;&#x3D;&#x3D; &amp;quot;.tf&amp;quot; ||
      basename.includes(&amp;quot;kubernetes&amp;quot;) ||
      basename &#x3D;&#x3D;&#x3D; &amp;quot;Chart.yaml&amp;quot; ||
      basename.startsWith(&amp;quot;values&amp;quot;) ||
      basename.includes(&amp;quot;openapi&amp;quot;);

    if (!shouldGuard) return true;

    const buffer &#x3D; await fs.readFile(filePath, { flag: &amp;quot;r&amp;quot; });
    const sample &#x3D; buffer.subarray(0, Math.min(1024, buffer.length)).toString(&amp;quot;utf-8&amp;quot;);

    if (basename.includes(&amp;quot;docker-compose&amp;quot;) || basename.includes(&amp;quot;compose&amp;quot;)) {
      return /services:\s*$/m.test(sample) || /version:\s*[&amp;#39;&amp;quot;]?[0-9]/m.test(sample);
    }

    if (extension &#x3D;&#x3D;&#x3D; &amp;quot;.yaml&amp;quot; || extension &#x3D;&#x3D;&#x3D; &amp;quot;.yml&amp;quot;) {
      return (/apiVersion:\s*/.test(sample) &amp;amp;&amp;amp; /kind:\s*/.test(sample)) || /\w+:\s*/.test(sample);
    }

    if (extension &#x3D;&#x3D;&#x3D; &amp;quot;.tf&amp;quot;) {
      return (
        /provider\s*&amp;quot;/.test(sample) || /resource\s*&amp;quot;/.test(sample) || /variable\s*&amp;quot;/.test(sample)
      );
    }

    if (basename.includes(&amp;quot;openapi&amp;quot;)) {
      return /openapi:\s*[&amp;#39;&amp;quot;]?[0-9]/.test(sample) || /swagger:\s*[&amp;#39;&amp;quot;]?[0-9]/.test(sample);
    }

    return true;
  } catch {
    return true;
  }
}

/**
 * Performs a lightweight heuristic to determine whether a file should be treated as binary.
 */
async function isFileBinary(filePath: string, includeBinaries: boolean): Promise&amp;lt;boolean&amp;gt; {
  if (includeBinaries) return false;

  try {
    const buffer &#x3D; await fs.readFile(filePath, { flag: &amp;quot;r&amp;quot; });
    const sample &#x3D; buffer.subarray(0, Math.min(1024, buffer.length));

    for (let i &#x3D; 0; i &amp;lt; sample.length; i++) {
      if (sample[i] &#x3D;&#x3D;&#x3D; 0) return true;
    }

    return false;
  } catch {
    return true;
  }
}

/**
 * Orchestrates the multi-stage importer pipeline.
 *
 * @public
 */
export class ScannerRunner {
  private config: ScannerConfig;
  private pluginRegistry: PluginRegistry;
  private cache &#x3D; new Map&amp;lt;string, unknown&amp;gt;();

  constructor(config: Partial&amp;lt;ScannerConfig&amp;gt; &#x3D; {}) {
    this.config &#x3D; { ...DEFAULT_SCANNER_CONFIG, ...config } as ScannerConfig;
    this.pluginRegistry &#x3D; new PluginRegistry();

    if (config.plugins) {
      for (const plugin of config.plugins) {
        this.pluginRegistry.register(plugin);
      }
    }
  }

  /**
   * Executes discovery, parsing, inference, and manifest generation.
   *
   * @returns Manifest containing all inferred artifacts.
   */
  async scan(): Promise&amp;lt;ArtifactManifest&amp;gt; {
    const startTime &#x3D; Date.now();

    try {
      this.debug(&amp;quot;Starting simplified scanner pipeline&amp;quot;);

      // Stage 1: Discovery
      const fileIndex &#x3D; await this.discoverFiles();

      // Stage 2: Parse
      const evidence &#x3D; await this.parseFiles(fileIndex);

      // Stage 3: Infer
      const artifacts &#x3D; await this.inferArtifacts(evidence, fileIndex);

      // Generate manifest
      const manifest &#x3D; await this.generateManifest(artifacts, evidence, fileIndex, startTime);

      this.debug(&#x60;Pipeline completed in ${Date.now() - startTime}ms&#x60;);
      return manifest;
    } catch (error) {
      if (error instanceof ImporterError) {
        throw error;
      }
      throw new InferenceError(&#x60;Pipeline failed: ${error}&#x60;);
    }
  }

  /**
   * Discovers files to analyse by building a file index.
   */
  private async discoverFiles(): Promise&amp;lt;FileIndex&amp;gt; {
    try {
      return await buildFileIndex(
        this.config.projectRoot,
        this.config.ignorePatterns,
        this.config.parseOptions,
      );
    } catch (error) {
      throw new FileSystemError(this.config.projectRoot, &#x60;Failed to build file index: ${error}&#x60;);
    }
  }

  /**
   * Runs the parsing stage by dispatching matching plugins across files.
   */
  private async parseFiles(fileIndex: FileIndex): Promise&amp;lt;Evidence[]&amp;gt; {
    const allEvidence: Evidence[] &#x3D; [];
    const failedFiles: string[] &#x3D; [];

    const parseContext: ParseContext &#x3D; {
      projectRoot: this.config.projectRoot,
      fileIndex,
      options: this.config.parseOptions,
      cache: this.cache,
    };

    const files &#x3D; Array.from(fileIndex.files.values());
    const batchSize &#x3D; this.config.maxConcurrency;

    for (let i &#x3D; 0; i &amp;lt; files.length; i +&#x3D; batchSize) {
      const batch &#x3D; files.slice(i, i + batchSize);

      const batchPromises &#x3D; batch.map(async (fileInfo) &#x3D;&amp;gt; {
        try {
          return await this.parseFile(fileInfo, parseContext);
        } catch (error) {
          failedFiles.push(fileInfo.path);
          if (error instanceof ParseError) {
            this.debug(&#x60;Parse error for ${fileInfo.path}: ${error.message}&#x60;);
          } else {
            this.debug(&#x60;Unexpected error parsing ${fileInfo.path}: ${error}&#x60;);
          }
          return [];
        }
      });

      const batchResults &#x3D; await Promise.all(batchPromises);
      allEvidence.push(...batchResults.flat());
    }

    this.debug(
      &#x60;Collected ${allEvidence.length} evidence from ${files.length - failedFiles.length}/${files.length} files&#x60;,
    );

    if (failedFiles.length &amp;gt; 0) {
      this.debug(&#x60;Failed to parse ${failedFiles.length} files&#x60;);
    }

    return allEvidence;
  }

  /**
   * Parses a single file and collects evidence from all supporting plugins.
   */
  private async parseFile(fileInfo: FileInfo, parseContext: ParseContext): Promise&amp;lt;Evidence[]&amp;gt; {
    if (fileInfo.isBinary &amp;amp;&amp;amp; !this.config.parseOptions.includeBinaries) {
      return [];
    }

    let fileContent: string | undefined;
    if (!fileInfo.isBinary) {
      try {
        fileContent &#x3D; await fs.readFile(fileInfo.path, &amp;quot;utf-8&amp;quot;);
      } catch (error) {
        throw new ParseError(fileInfo.path, &#x60;Failed to read file: ${error}&#x60;);
      }
    }

    const supportingPlugins &#x3D; this.pluginRegistry.getSupportingPlugins(fileInfo.path, fileContent);

    if (supportingPlugins.length &#x3D;&#x3D;&#x3D; 0) {
      return [];
    }

    const evidence: Evidence[] &#x3D; [];

    for (const plugin of supportingPlugins) {
      try {
        const pluginEvidence &#x3D; await plugin.parse(fileInfo.path, fileContent, parseContext);
        evidence.push(...pluginEvidence);
      } catch (error) {
        throw new PluginError(
          plugin.name(),
          &#x60;Failed to parse ${fileInfo.path}: ${error}&#x60;,
          error as Error,
        );
      }
    }

    return evidence;
  }

  /**
   * Executes the inference stage for all registered plugins.
   */
  private async inferArtifacts(
    evidence: Evidence[],
    fileIndex: FileIndex,
  ): Promise&amp;lt;InferredArtifact[]&amp;gt; {
    const projectMetadata &#x3D; await this.generateProjectMetadata(fileIndex);
    this.debug(&#x60;Generated project metadata for ${projectMetadata.name}&#x60;);

    const allArtifacts: InferredArtifact[] &#x3D; [];
    const enabledPlugins &#x3D; this.pluginRegistry.getEnabled();

    const inferenceContext: InferenceContext &#x3D; {
      projectRoot: this.config.projectRoot,
      fileIndex,
      allEvidence: evidence,
      options: this.config.inferenceOptions,
      cache: this.cache,
      projectMetadata,
    };

    for (const plugin of enabledPlugins) {
      try {
        const pluginArtifacts &#x3D; await plugin.infer(evidence, inferenceContext);
        allArtifacts.push(...pluginArtifacts);
      } catch (error) {
        throw new PluginError(plugin.name(), &#x60;Failed to infer artifacts: ${error}&#x60;, error as Error);
      }
    }

    this.augmentArtifactsWithDockerMetadata(allArtifacts, evidence, inferenceContext.projectRoot);

    // Consolidate duplicate services (e.g., Dockerfile + package.json representing same service)
    const consolidated &#x3D; this.consolidateDuplicateServices(allArtifacts);

    this.debug(
      &#x60;Inferred ${consolidated.length} artifacts from ${evidence.length} evidence items (${allArtifacts.length - consolidated.length} duplicates merged)&#x60;,
    );
    return consolidated;
  }

  /**
   * Enriches inferred artifacts with metadata extracted from Docker evidence.
   */
  private augmentArtifactsWithDockerMetadata(
    artifacts: InferredArtifact[],
    evidence: Evidence[],
    projectRoot?: string,
  ): void {
    const dockerEvidence &#x3D; evidence.filter((ev) &#x3D;&amp;gt; ev.source &#x3D;&#x3D;&#x3D; &amp;quot;docker&amp;quot; &amp;amp;&amp;amp; ev.type &#x3D;&#x3D;&#x3D; &amp;quot;config&amp;quot;);
    if (dockerEvidence.length &#x3D;&#x3D;&#x3D; 0) return;

    const baseProjectRoot &#x3D; projectRoot ?? &amp;quot;&amp;quot;;

    const normalizeRelativePath &#x3D; (value: string | undefined): string &#x3D;&amp;gt; {
      if (!value) return &amp;quot;&amp;quot;;
      const normalized &#x3D; value.replace(/\\/g, &amp;quot;/&amp;quot;);
      if (normalized &#x3D;&#x3D;&#x3D; &amp;quot;.&amp;quot; || normalized &#x3D;&#x3D;&#x3D; &amp;quot;./&amp;quot;) return &amp;quot;&amp;quot;;
      return normalized.replace(/^\.\//, &amp;quot;&amp;quot;).replace(/\/$/, &amp;quot;&amp;quot;);
    };

    interface ComposeServiceInfo {
      composeFilePath: string;
      composeFileRelative: string;
      composeServiceName: string;
      serviceConfig: Record&amp;lt;string, unknown&amp;gt;;
      serviceYaml?: string;
      buildContextAbsolute?: string;
      buildContextRelative?: string;
      dockerfilePathAbsolute?: string;
      dockerfilePathRelative?: string;
      dockerfileContent?: string;
    }

    const composeServices: ComposeServiceInfo[] &#x3D; [];
    const dockerfiles &#x3D; new Map&amp;lt;string, string&amp;gt;();

    for (const ev of dockerEvidence) {
      const data &#x3D; ev.data as Record&amp;lt;string, unknown&amp;gt; | undefined;
      if (!data || typeof data !&#x3D;&#x3D; &amp;quot;object&amp;quot;) continue;

      const dataTypeRaw &#x3D; data.type;
      const dataType &#x3D; typeof dataTypeRaw &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; ? dataTypeRaw.toLowerCase() : &amp;quot;&amp;quot;;

      if (dataType &#x3D;&#x3D;&#x3D; &amp;quot;dockerfile&amp;quot;) {
        const filePath &#x3D; data.filePath;
        const content &#x3D; data.dockerfileContent;
        if (typeof filePath &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; &amp;amp;&amp;amp; typeof content &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
          dockerfiles.set(path.resolve(filePath), content);
        }
        continue;
      }

      if (dataType !&#x3D;&#x3D; &amp;quot;service&amp;quot;) continue;

      const composeFilePath &#x3D; data.filePath;
      const composeServiceConfig &#x3D; data.composeServiceConfig;
      if (typeof composeFilePath !&#x3D;&#x3D; &amp;quot;string&amp;quot;) continue;
      if (!composeServiceConfig || typeof composeServiceConfig !&#x3D;&#x3D; &amp;quot;object&amp;quot;) continue;

      const composeServiceNameRaw &#x3D; data.name;
      const composeServiceName &#x3D;
        typeof composeServiceNameRaw &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; ? composeServiceNameRaw : &amp;quot;&amp;quot;;
      const composeServiceYaml &#x3D;
        typeof data.composeServiceYaml &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; ? data.composeServiceYaml : undefined;

      const composeDir &#x3D; path.dirname(composeFilePath);
      const composeFileRelative &#x3D; normalizeRelativePath(
        path.relative(baseProjectRoot, composeFilePath),
      );

      let buildContextAbsolute: string | undefined;
      let dockerfilePathAbsolute: string | undefined;

      const buildConfig &#x3D; (composeServiceConfig as Record&amp;lt;string, unknown&amp;gt;).build;

      if (typeof buildConfig &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
        buildContextAbsolute &#x3D; path.resolve(composeDir, buildConfig);
        dockerfilePathAbsolute &#x3D; path.resolve(buildContextAbsolute, &amp;quot;Dockerfile&amp;quot;);
      } else if (buildConfig &amp;amp;&amp;amp; typeof buildConfig &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot;) {
        const build &#x3D; buildConfig as Record&amp;lt;string, unknown&amp;gt;;
        const contextValue &#x3D; build.context;
        const dockerfileValue &#x3D; build.dockerfile;

        if (typeof contextValue &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
          buildContextAbsolute &#x3D; path.resolve(composeDir, contextValue);
        } else {
          buildContextAbsolute &#x3D; composeDir;
        }

        if (typeof dockerfileValue &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
          const baseDir &#x3D; buildContextAbsolute ?? composeDir;
          dockerfilePathAbsolute &#x3D; path.resolve(baseDir, dockerfileValue);
        } else if (buildContextAbsolute) {
          dockerfilePathAbsolute &#x3D; path.resolve(buildContextAbsolute, &amp;quot;Dockerfile&amp;quot;);
        }
      }

      const buildContextRelative &#x3D; buildContextAbsolute
        ? normalizeRelativePath(path.relative(baseProjectRoot, buildContextAbsolute))
        : undefined;
      const dockerfilePathRelative &#x3D; dockerfilePathAbsolute
        ? normalizeRelativePath(path.relative(baseProjectRoot, dockerfilePathAbsolute))
        : undefined;

      composeServices.push({
        composeFilePath,
        composeFileRelative,
        composeServiceName,
        serviceConfig: composeServiceConfig as Record&amp;lt;string, unknown&amp;gt;,
        serviceYaml: composeServiceYaml,
        buildContextAbsolute,
        buildContextRelative,
        dockerfilePathAbsolute,
        dockerfilePathRelative,
      });
    }

    if (composeServices.length &#x3D;&#x3D;&#x3D; 0) return;

    for (const service of composeServices) {
      if (!service.dockerfilePathAbsolute) continue;
      const content &#x3D; dockerfiles.get(path.resolve(service.dockerfilePathAbsolute));
      if (content) {
        service.dockerfileContent &#x3D; content;
      }
    }

    const scoredMatch &#x3D; (artifact: InferredArtifact): ComposeServiceInfo | undefined &#x3D;&amp;gt; {
      if (artifact.artifact.type !&#x3D;&#x3D; &amp;quot;service&amp;quot;) return undefined;

      const metadata &#x3D; artifact.artifact.metadata as Record&amp;lt;string, unknown&amp;gt;;
      const artifactRootRaw &#x3D; typeof metadata.root &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; ? metadata.root : undefined;
      const artifactRoot &#x3D; normalizeRelativePath(artifactRootRaw);
      const artifactName &#x3D; artifact.artifact.name;
      const containerImage &#x3D;
        typeof metadata.containerImage &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; ? metadata.containerImage : undefined;

      const candidates &#x3D; composeServices
        .map((service) &#x3D;&amp;gt; {
          let score &#x3D; 0;

          if (!artifactRoot &amp;amp;&amp;amp; !service.buildContextRelative) {
            score +&#x3D; 80;
          }

          if (artifactRoot &amp;amp;&amp;amp; service.buildContextRelative) {
            if (service.buildContextRelative &#x3D;&#x3D;&#x3D; artifactRoot) {
              score +&#x3D; 100;
            } else if (service.buildContextRelative.startsWith(&#x60;${artifactRoot}/&#x60;)) {
              score +&#x3D; 60;
            } else if (artifactRoot.startsWith(&#x60;${service.buildContextRelative}/&#x60;)) {
              score +&#x3D; 40;
            }
          }

          if (artifactName &amp;amp;&amp;amp; service.composeServiceName &#x3D;&#x3D;&#x3D; artifactName) {
            score +&#x3D; 50;
          }

          const serviceImage &#x3D; (service.serviceConfig as { image?: unknown }).image;
          if (
            containerImage &amp;amp;&amp;amp;
            typeof serviceImage &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; &amp;amp;&amp;amp;
            serviceImage &#x3D;&#x3D;&#x3D; containerImage
          ) {
            score +&#x3D; 40;
          }

          if (!score &amp;amp;&amp;amp; composeServices.length &#x3D;&#x3D;&#x3D; 1) {
            score &#x3D; 10;
          }

          return { service, score };
        })
        .filter((candidate) &#x3D;&amp;gt; candidate.score &amp;gt; 0)
        .sort((a, b) &#x3D;&amp;gt; b.score - a.score);

      return candidates.length &amp;gt; 0 ? candidates[0].service : undefined;
    };

    for (const artifact of artifacts) {
      const match &#x3D; scoredMatch(artifact);
      if (!match) continue;

      const metadata &#x3D; artifact.artifact.metadata as Record&amp;lt;string, unknown&amp;gt;;

      const dockerMetadata &#x3D;
        metadata.docker &amp;amp;&amp;amp; typeof metadata.docker &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot;
          ? (metadata.docker as Record&amp;lt;string, unknown&amp;gt;)
          : {};

      const clone &#x3D; &amp;lt;T&amp;gt;(value: T): T &#x3D;&amp;gt; {
        try {
          return JSON.parse(JSON.stringify(value)) as T;
        } catch {
          return value;
        }
      };

      if (!metadata.docker || typeof metadata.docker !&#x3D;&#x3D; &amp;quot;object&amp;quot;) {
        metadata.docker &#x3D; dockerMetadata;
      }

      dockerMetadata.composeFile &#x3D; match.composeFileRelative || match.composeFilePath;
      dockerMetadata.composeServiceName &#x3D; match.composeServiceName;
      dockerMetadata.composeService &#x3D; clone(match.serviceConfig);
      if (match.serviceYaml) {
        dockerMetadata.composeServiceYaml &#x3D; match.serviceYaml;
      }
      if (match.buildContextRelative !&#x3D;&#x3D; undefined) {
        dockerMetadata.buildContext &#x3D; match.buildContextRelative;
      }
      if (match.dockerfilePathRelative) {
        dockerMetadata.dockerfilePath &#x3D; match.dockerfilePathRelative;
      }
      if (match.dockerfileContent) {
        dockerMetadata.dockerfile &#x3D; match.dockerfileContent;
        metadata.dockerfileContent &#x3D; match.dockerfileContent;
      }

      if (!metadata.containerImage) {
        const candidateImage &#x3D; (match.serviceConfig as { image?: unknown }).image;
        if (typeof candidateImage &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
          metadata.containerImage &#x3D; candidateImage;
        }
      }

      if (!metadata.buildContext &amp;amp;&amp;amp; match.buildContextRelative !&#x3D;&#x3D; undefined) {
        metadata.buildContext &#x3D; match.buildContextRelative;
      }
      if (!metadata.dockerfilePath &amp;amp;&amp;amp; match.dockerfilePathRelative) {
        metadata.dockerfilePath &#x3D; match.dockerfilePathRelative;
      }
    }
  }

  /**
   * Consolidates duplicate services that represent the same application.
   * This happens when both a Dockerfile and a package file (package.json, go.mod, etc.)
   * exist in the same directory and create separate service artifacts.
   */
  private consolidateDuplicateServices(artifacts: InferredArtifact[]): InferredArtifact[] {
    const serviceArtifacts &#x3D; artifacts.filter((a) &#x3D;&amp;gt; a.artifact.type &#x3D;&#x3D;&#x3D; &amp;quot;service&amp;quot;);
    const nonServiceArtifacts &#x3D; artifacts.filter((a) &#x3D;&amp;gt; a.artifact.type !&#x3D;&#x3D; &amp;quot;service&amp;quot;);

    if (serviceArtifacts.length &amp;lt;&#x3D; 1) {
      return artifacts;
    }

    // Group services by their root directory
    const servicesByRoot &#x3D; new Map&amp;lt;string, InferredArtifact[]&amp;gt;();

    for (const artifact of serviceArtifacts) {
      const metadata &#x3D; artifact.artifact.metadata as Record&amp;lt;string, unknown&amp;gt;;
      const root &#x3D; this.normalizeServiceRoot(metadata.root);

      if (!servicesByRoot.has(root)) {
        servicesByRoot.set(root, []);
      }
      servicesByRoot.get(root)!.push(artifact);
    }

    // Consolidate services in the same root directory
    const consolidated: InferredArtifact[] &#x3D; [];

    for (const [root, services] of servicesByRoot.entries()) {
      if (services.length &#x3D;&#x3D;&#x3D; 1) {
        consolidated.push(services[0]);
        continue;
      }

      // Check if we have both Docker and package-based services
      const dockerService &#x3D; services.find((s) &#x3D;&amp;gt; {
        const evidence &#x3D; s.provenance?.evidence || [];
        return evidence.some((e) &#x3D;&amp;gt; e.toLowerCase().includes(&amp;quot;dockerfile&amp;quot;));
      });

      const packageService &#x3D; services.find((s) &#x3D;&amp;gt; {
        const plugins &#x3D; s.provenance?.plugins || [];
        return (
          plugins.includes(&amp;quot;nodejs&amp;quot;) ||
          plugins.includes(&amp;quot;python&amp;quot;) ||
          plugins.includes(&amp;quot;go&amp;quot;) ||
          plugins.includes(&amp;quot;rust&amp;quot;)
        );
      });

      if (dockerService &amp;amp;&amp;amp; packageService) {
        // Merge them, preferring the package service as the base
        const merged &#x3D; this.mergeServices(packageService, dockerService);
        consolidated.push(merged);
        this.debug(
          &#x60;Consolidated services at root &amp;quot;${root}&amp;quot;: ${packageService.artifact.name} + docker metadata&#x60;,
        );
      } else {
        // No clear consolidation pattern, keep all services
        consolidated.push(...services);
      }
    }

    return [...consolidated, ...nonServiceArtifacts];
  }

  /**
   * Merges two service artifacts, combining their metadata and provenance.
   */
  private mergeServices(primary: InferredArtifact, secondary: InferredArtifact): InferredArtifact {
    const primaryMetadata &#x3D; primary.artifact.metadata as Record&amp;lt;string, unknown&amp;gt;;
    const secondaryMetadata &#x3D; secondary.artifact.metadata as Record&amp;lt;string, unknown&amp;gt;;

    // Merge metadata, preferring primary but adding missing fields from secondary
    const mergedMetadata: Record&amp;lt;string, unknown&amp;gt; &#x3D; { ...primaryMetadata };

    // Copy over Docker-specific metadata if not already present
    if (secondaryMetadata.dockerfileContent &amp;amp;&amp;amp; !mergedMetadata.dockerfileContent) {
      mergedMetadata.dockerfileContent &#x3D; secondaryMetadata.dockerfileContent;
    }
    if (secondaryMetadata.dockerfile &amp;amp;&amp;amp; !mergedMetadata.dockerfile) {
      mergedMetadata.dockerfile &#x3D; secondaryMetadata.dockerfile;
    }

    // Merge docker metadata object
    if (secondaryMetadata.docker &amp;amp;&amp;amp; typeof secondaryMetadata.docker &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot;) {
      if (!mergedMetadata.docker || typeof mergedMetadata.docker !&#x3D;&#x3D; &amp;quot;object&amp;quot;) {
        mergedMetadata.docker &#x3D; {};
      }
      const primaryDocker &#x3D; mergedMetadata.docker as Record&amp;lt;string, unknown&amp;gt;;
      const secondaryDocker &#x3D; secondaryMetadata.docker as Record&amp;lt;string, unknown&amp;gt;;

      Object.assign(primaryDocker, secondaryDocker);
    }

    // Merge tags
    const primaryTags &#x3D; new Set(primary.artifact.tags || []);
    const secondaryTags &#x3D; secondary.artifact.tags || [];
    for (const tag of secondaryTags) {
      primaryTags.add(tag);
    }

    // Merge provenance
    const mergedEvidence &#x3D; [
      ...(primary.provenance?.evidence || []),
      ...(secondary.provenance?.evidence || []),
    ];
    const mergedPlugins &#x3D; Array.from(
      new Set([...(primary.provenance?.plugins || []), ...(secondary.provenance?.plugins || [])]),
    );
    const mergedRules &#x3D; Array.from(
      new Set([
        ...(primary.provenance?.rules || []),
        ...(secondary.provenance?.rules || []),
        &amp;quot;service-consolidation&amp;quot;,
      ]),
    );

    return {
      artifact: {
        ...primary.artifact,
        tags: Array.from(primaryTags),
        metadata: mergedMetadata,
      },
      provenance: {
        evidence: mergedEvidence,
        plugins: mergedPlugins,
        rules: mergedRules,
        timestamp: Date.now(),
        pipelineVersion: primary.provenance?.pipelineVersion || &amp;quot;1.0.0&amp;quot;,
      },
      relationships: [...(primary.relationships || []), ...(secondary.relationships || [])],
    };
  }

  /**
   * Normalizes a service root path for comparison.
   */
  private normalizeServiceRoot(root: unknown): string {
    if (typeof root !&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
      return &amp;quot;&amp;quot;;
    }
    const normalized &#x3D; root.replace(/\\/g, &amp;quot;/&amp;quot;);
    if (normalized &#x3D;&#x3D;&#x3D; &amp;quot;.&amp;quot; || normalized &#x3D;&#x3D;&#x3D; &amp;quot;./&amp;quot;) {
      return &amp;quot;&amp;quot;;
    }
    return normalized.replace(/^\.\//, &amp;quot;&amp;quot;).replace(/\/$/, &amp;quot;&amp;quot;);
  }

  /**
   * Combines artifacts, evidence, and statistics into a manifest structure.
   */
  private async generateManifest(
    artifacts: InferredArtifact[],
    evidence: Evidence[],
    fileIndex: FileIndex,
    startTime: number,
  ): Promise&amp;lt;ArtifactManifest&amp;gt; {
    const projectMetadata &#x3D; await this.generateProjectMetadata(fileIndex);
    const statistics &#x3D; this.generateStatistics(artifacts, evidence, startTime);
    const configuration &#x3D; this.generateConfiguration();
    const perConfig &#x3D; this.groupArtifactsByConfig(artifacts);
    const provenance &#x3D; this.buildProvenanceMap(artifacts);

    return {
      version: &amp;quot;1.0.0&amp;quot;,
      project: projectMetadata,
      perConfig,
      artifacts,
      provenance,
      statistics,
      configuration,
      timestamp: Date.now(),
    };
  }

  /**
   * Derives high-level metadata about the analysed project.
   */
  private async generateProjectMetadata(fileIndex: FileIndex): Promise&amp;lt;ProjectMetadata&amp;gt; {
    const files &#x3D; Array.from(fileIndex.files.values());
    const totalSize &#x3D; files.reduce((sum, f) &#x3D;&amp;gt; sum + f.size, 0);
    const projectName &#x3D; this.config.projectName || path.basename(this.config.projectRoot);

    return {
      name: projectName,
      root: this.config.projectRoot,
      languages: [],
      frameworks: [],
      fileCount: files.length,
      totalSize,
    };
  }

  /**
   * Computes aggregate statistics for the scan run.
   */
  private generateStatistics(
    artifacts: InferredArtifact[],
    evidence: Evidence[],
    startTime: number,
  ): AnalysisStatistics {
    const artifactCounts: Record&amp;lt;ArtifactType, number&amp;gt; &#x3D; {} as Record&amp;lt;ArtifactType, number&amp;gt;;
    for (const artifact of artifacts) {
      const type &#x3D; artifact.artifact.type;
      artifactCounts[type] &#x3D; (artifactCounts[type] || 0) + 1;
    }

    const evidenceCounts: Record&amp;lt;EvidenceType, number&amp;gt; &#x3D; {} as Record&amp;lt;EvidenceType, number&amp;gt;;
    for (const item of evidence) {
      const type &#x3D; item.type;
      evidenceCounts[type] &#x3D; (evidenceCounts[type] || 0) + 1;
    }

    return {
      artifactCounts,
      evidenceCounts,
      processingTimeMs: Date.now() - startTime,
      pluginsExecuted: this.pluginRegistry.getEnabled().map((p) &#x3D;&amp;gt; p.name()),
      failedFiles: [],
    };
  }

  /**
   * Captures configuration details that influenced the scan.
   */
  private generateConfiguration(): AnalysisConfiguration {
    return {
      parseOptions: this.config.parseOptions,
      inferenceOptions: this.config.inferenceOptions,
      enabledPlugins: this.pluginRegistry.getEnabled().map((p) &#x3D;&amp;gt; p.name()),
      pluginConfiguration: {},
    };
  }

  /**
   * Groups artifacts by the configuration evidence that identified them.
   */
  private groupArtifactsByConfig(
    artifacts: InferredArtifact[],
  ): Record&amp;lt;string, InferredArtifact[]&amp;gt; {
    const grouped: Record&amp;lt;string, InferredArtifact[]&amp;gt; &#x3D; {};

    for (const artifact of artifacts) {
      const evidenceKey &#x3D; this.getPrimaryEvidenceKey(artifact.provenance?.evidence ?? []);
      if (!evidenceKey) continue;
      if (!grouped[evidenceKey]) {
        grouped[evidenceKey] &#x3D; [];
      }
      grouped[evidenceKey].push(artifact);
    }

    return grouped;
  }

  /**
   * Produces a lookup of artifact IDs to their supporting evidence IDs.
   */
  private buildProvenanceMap(artifacts: InferredArtifact[]): Record&amp;lt;string, string[]&amp;gt; {
    const provenance &#x3D; new Map&amp;lt;string, Set&amp;lt;string&amp;gt;&amp;gt;();

    for (const artifact of artifacts) {
      const artifactId &#x3D; artifact.artifact.id;
      const evidenceIds &#x3D; artifact.provenance?.evidence ?? [];

      for (const rawId of evidenceIds) {
        const evidenceKey &#x3D; this.normalizeEvidenceId(rawId);
        if (!evidenceKey) continue;

        if (!provenance.has(evidenceKey)) {
          provenance.set(evidenceKey, new Set());
        }
        provenance.get(evidenceKey)!.add(artifactId);
      }
    }

    const entries: [string, string[]][] &#x3D; Array.from(provenance.entries()).map(([key, value]) &#x3D;&amp;gt; [
      key,
      Array.from(value),
    ]);

    return Object.fromEntries(entries);
  }

  private getPrimaryEvidenceKey(evidence: string[]): string | null {
    if (!evidence.length) return null;
    for (const id of evidence) {
      const normalized &#x3D; this.normalizeEvidenceId(id);
      if (normalized) {
        return normalized;
      }
    }
    return null;
  }

  private normalizeEvidenceId(id: string | undefined): string | null {
    if (!id) return null;
    const trimmed &#x3D; id.trim();
    if (!trimmed) return null;

    // Remove leading ./ or / for consistency
    const withoutLeading &#x3D; trimmed.replace(/^\.?\/+/, &amp;quot;&amp;quot;);
    return withoutLeading || null;
  }

  registerPlugin(plugin: ImporterPlugin): void {
    this.pluginRegistry.register(plugin);
  }

  getPluginRegistry(): PluginRegistry {
    return this.pluginRegistry;
  }

  /**
   * Emits debug logging when the scanner is running in debug mode.
   */
  private debug(message: string): void {
    if (this.config.debug) {
      console.debug(&#x60;[Scanner] ${message}&#x60;);
    }
  }
}

export { DEFAULT_SCANNER_CONFIG };
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(10)">
                    <span class="file-path">file-code src/plugins/docker.ts</span>
                    <div class="file-meta">
                        <span>9.53 KB</span>
                        <span>2,030 tokens</span>
                        <span>Score: 0.39</span>
                    </div>
                </div>
                <div class="file-content" id="file-10">
                    <pre class="code-block"><code>import * as path from &amp;quot;path&amp;quot;;
import * as fs from &amp;quot;fs-extra&amp;quot;;
import * as yaml from &amp;quot;yaml&amp;quot;;
import type {
  ConfidenceScore,
  Evidence,
  ImporterPlugin,
  InferenceContext,
  InferredArtifact,
  ParseContext,
  Provenance,
} from &amp;quot;../types&amp;quot;;
import type { ProjectMetadata } from &amp;quot;../types&amp;quot;;

export interface DockerData {
  name: string;
  description: string;
  type: string;
  filePath: string;
  dockerfileContent?: string;
  composeServiceConfig?: Record&amp;lt;string, unknown&amp;gt;;
  composeServiceYaml?: string;
  [key: string]: unknown;
}

export class DockerPlugin implements ImporterPlugin {
  name(): string {
    return &amp;quot;docker&amp;quot;;
  }

  supports(filePath: string): boolean {
    const basename &#x3D; path.basename(filePath).toLowerCase();
    return (
      basename &#x3D;&#x3D;&#x3D; &amp;quot;dockerfile&amp;quot; ||
      basename &#x3D;&#x3D;&#x3D; &amp;quot;docker-compose.yml&amp;quot; ||
      basename &#x3D;&#x3D;&#x3D; &amp;quot;docker-compose.yaml&amp;quot; ||
      basename.includes(&amp;quot;compose&amp;quot;)
    );
  }

  async parse(filePath: string, fileContent?: string, context?: ParseContext): Promise&amp;lt;Evidence[]&amp;gt; {
    if (!fileContent) {
      throw new Error(&amp;quot;File content required for Docker parsing&amp;quot;);
    }

    const evidence: Evidence[] &#x3D; [];
    const basename &#x3D; path.basename(filePath).toLowerCase();

    try {
      let parsed;
      if (basename &#x3D;&#x3D;&#x3D; &amp;quot;dockerfile&amp;quot;) {
        // Don&amp;#39;t use YAML for Dockerfile
        parsed &#x3D; null;
      } else {
        parsed &#x3D; yaml.parse(fileContent);
      }

      if (basename &#x3D;&#x3D;&#x3D; &amp;quot;dockerfile&amp;quot;) {
        // Parse Dockerfile
        const dockerfileEvidence &#x3D; await this.parseDockerfile(
          fileContent,
          filePath,
          context?.projectRoot || &amp;quot;/&amp;quot;,
        );
        evidence.push(...dockerfileEvidence);
      } else if (basename.includes(&amp;quot;docker-compose&amp;quot;)) {
        // Parse docker-compose.yml
        if (parsed &amp;amp;&amp;amp; typeof parsed &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot;) {
          const composeEvidence &#x3D; this.parseDockerCompose(
            parsed,
            filePath,
            context?.projectRoot || &amp;quot;/&amp;quot;,
          );
          evidence.push(...composeEvidence);
        }
      }

      return evidence;
    } catch (error) {
      console.warn(&#x60;Failed to parse Docker file ${filePath}:&#x60;, error);
      return [];
    }
  }

  private async parseDockerfile(
    content: string,
    filePath: string,
    projectRoot: string,
  ): Promise&amp;lt;Evidence[]&amp;gt; {
    const evidence: Evidence[] &#x3D; [];

    // Try to find a better name from adjacent package files
    const dockerfileDir &#x3D; path.dirname(filePath);
    const name &#x3D; await this.inferServiceNameFromDirectory(dockerfileDir);

    const data: DockerData &#x3D; {
      name,
      description: &amp;quot;Docker build configuration&amp;quot;,
      type: &amp;quot;dockerfile&amp;quot;,
      filePath,
      dockerfileContent: content,
    };

    const evidenceId &#x3D; path.relative(projectRoot, filePath);
    evidence.push({
      id: evidenceId,
      source: this.name(),
      type: &amp;quot;config&amp;quot;,
      filePath,
      data,
      metadata: {
        timestamp: Date.now(),
        fileSize: content.length,
      },
    });

    return evidence;
  }

  /**
   * Attempts to infer a service name from package files in the directory.
   * Checks for package.json, go.mod, Cargo.toml, pyproject.toml, etc.
   */
  private async inferServiceNameFromDirectory(dirPath: string): Promise&amp;lt;string&amp;gt; {
    // Package file priority order
    const packageFiles &#x3D; [
      { file: &amp;quot;package.json&amp;quot;, extractor: this.extractNameFromPackageJson },
      { file: &amp;quot;go.mod&amp;quot;, extractor: this.extractNameFromGoMod },
      { file: &amp;quot;Cargo.toml&amp;quot;, extractor: this.extractNameFromCargoToml },
      { file: &amp;quot;pyproject.toml&amp;quot;, extractor: this.extractNameFromPyprojectToml },
      { file: &amp;quot;pom.xml&amp;quot;, extractor: this.extractNameFromPomXml },
    ];

    for (const { file, extractor } of packageFiles) {
      const packagePath &#x3D; path.join(dirPath, file);
      try {
        if (await fs.pathExists(packagePath)) {
          const content &#x3D; await fs.readFile(packagePath, &amp;quot;utf-8&amp;quot;);
          const name &#x3D; extractor.call(this, content);
          if (name) {
            return name;
          }
        }
      } catch (error) {
        // Continue to next package file
        continue;
      }
    }

    // Fallback to directory name
    return path.basename(dirPath) || &amp;quot;docker-build&amp;quot;;
  }

  private extractNameFromPackageJson(content: string): string | null {
    try {
      const pkg &#x3D; JSON.parse(content);
      if (pkg.name &amp;amp;&amp;amp; typeof pkg.name &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
        // Remove scope prefix if present (@org/name -&amp;gt; name)
        return pkg.name.replace(/^@[^/]+\//, &amp;quot;&amp;quot;);
      }
    } catch {
      // Invalid JSON
    }
    return null;
  }

  private extractNameFromGoMod(content: string): string | null {
    const match &#x3D; content.match(/^module\s+([^\s\n]+)/m);
    if (match &amp;amp;&amp;amp; match[1]) {
      // Extract last segment (github.com/user/repo -&amp;gt; repo)
      const segments &#x3D; match[1].split(&amp;quot;/&amp;quot;);
      return segments[segments.length - 1];
    }
    return null;
  }

  private extractNameFromCargoToml(content: string): string | null {
    const match &#x3D; content.match(/^\[package\][^[]*name\s*&#x3D;\s*&amp;quot;([^&amp;quot;]+)&amp;quot;/ms);
    return match ? match[1] : null;
  }

  private extractNameFromPyprojectToml(content: string): string | null {
    const match &#x3D; content.match(/^\[project\][^[]*name\s*&#x3D;\s*&amp;quot;([^&amp;quot;]+)&amp;quot;/ms);
    if (match) return match[1];

    // Try poetry format
    const poetryMatch &#x3D; content.match(/^\[tool\.poetry\][^[]*name\s*&#x3D;\s*&amp;quot;([^&amp;quot;]+)&amp;quot;/ms);
    return poetryMatch ? poetryMatch[1] : null;
  }

  private extractNameFromPomXml(content: string): string | null {
    const match &#x3D; content.match(/&amp;lt;artifactId&amp;gt;([^&amp;lt;]+)&amp;lt;\/artifactId&amp;gt;/);
    return match ? match[1] : null;
  }

  private parseDockerCompose(parsed: any, filePath: string, projectRoot: string): Evidence[] {
    const evidence: Evidence[] &#x3D; [];

    const services &#x3D; parsed.services;
    if (!services || typeof services !&#x3D;&#x3D; &amp;quot;object&amp;quot;) {
      return evidence;
    }

    const relativeComposePath &#x3D; path.relative(projectRoot, filePath);

    for (const [serviceName, serviceConfigRaw] of Object.entries(services)) {
      const serviceConfig &#x3D; serviceConfigRaw as any;
      if (typeof serviceConfig !&#x3D;&#x3D; &amp;quot;object&amp;quot; || serviceConfig &#x3D;&#x3D;&#x3D; null) continue;

      const evidenceId &#x3D; relativeComposePath;
      const data: DockerData &#x3D; {
        name: serviceName as string,
        description: &amp;quot;Docker service&amp;quot;,
        type: &amp;quot;service&amp;quot;,
        filePath,
        composeServiceConfig: serviceConfig,
        composeServiceYaml: yaml.stringify({ [serviceName]: serviceConfig }, { indent: 2 }),
      };

      evidence.push({
        id: evidenceId,
        source: this.name(),
        type: &amp;quot;config&amp;quot;,
        filePath,
        data,
        metadata: {
          timestamp: Date.now(),
          fileSize: JSON.stringify(serviceConfig).length,
        },
      });
    }

    return evidence;
  }

  async infer(evidence: Evidence[], context: InferenceContext): Promise&amp;lt;InferredArtifact[]&amp;gt; {
    const artifacts: InferredArtifact[] &#x3D; [];

    // Filter Docker evidence
    const dockerEvidence &#x3D; evidence.filter((e) &#x3D;&amp;gt; e.source &#x3D;&#x3D;&#x3D; this.name() &amp;amp;&amp;amp; e.type &#x3D;&#x3D;&#x3D; &amp;quot;config&amp;quot;);

    const hasCompose &#x3D; dockerEvidence.some((e) &#x3D;&amp;gt; e.filePath.toLowerCase().includes(&amp;quot;compose&amp;quot;));

    for (const ev of dockerEvidence) {
      const data &#x3D; ev.data as unknown as DockerData;
      if (data.type !&#x3D;&#x3D; &amp;quot;service&amp;quot; &amp;amp;&amp;amp; (hasCompose || data.type !&#x3D;&#x3D; &amp;quot;dockerfile&amp;quot;)) continue;

      const artifactType &#x3D; data.type &#x3D;&#x3D;&#x3D; &amp;quot;dockerfile&amp;quot; ? &amp;quot;service&amp;quot; : data.type;

      // Calculate relative path for root to match nodejs plugin behavior
      const projectRoot &#x3D; context.projectRoot || &amp;quot;&amp;quot;;
      const relativeFilePath &#x3D; projectRoot
        ? path.relative(projectRoot, data.filePath)
        : data.filePath;
      const root &#x3D; hasCompose ? path.basename(relativeFilePath) : path.dirname(relativeFilePath);

      const dockerMetadata: Record&amp;lt;string, unknown&amp;gt; &#x3D; {};
      if (data.composeServiceConfig) {
        dockerMetadata.composeService &#x3D; data.composeServiceConfig;
      }
      if (data.composeServiceYaml) {
        dockerMetadata.composeServiceYaml &#x3D; data.composeServiceYaml;
      }
      const metadata: Record&amp;lt;string, unknown&amp;gt; &#x3D; {
        sourceFile: relativeFilePath,
        root,
      };

      if (Object.keys(dockerMetadata).length &amp;gt; 0) {
        metadata.docker &#x3D; dockerMetadata;
      }

      if (data.composeServiceConfig &amp;amp;&amp;amp; typeof data.composeServiceConfig &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot;) {
        const composeConfig &#x3D; data.composeServiceConfig as Record&amp;lt;string, unknown&amp;gt;;
        if (typeof composeConfig.image &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
          metadata.containerImage &#x3D; composeConfig.image;
        }
        if (composeConfig.build !&#x3D;&#x3D; undefined) {
          metadata.dockerBuild &#x3D; composeConfig.build;
        }
      }

      if (data.dockerfileContent) {
        dockerMetadata.dockerfile &#x3D; data.dockerfileContent;
        metadata.dockerfileContent &#x3D; data.dockerfileContent;
      }

      if (relativeFilePath) {
        metadata.dockerfile &#x3D; relativeFilePath;
      }

      const artifact &#x3D; {
        id: &#x60;docker-${artifactType}-${data.name}&#x60;,
        type: artifactType as any,
        name: data.name,
        description: data.description,
        tags: [&amp;quot;docker&amp;quot;, artifactType],
        metadata,
      };

      artifacts.push({
        artifact,
        provenance: {
          evidence: [ev.id],
          plugins: [&amp;quot;docker&amp;quot;],
          rules: [&amp;quot;docker-simplification&amp;quot;],
          timestamp: Date.now(),
          pipelineVersion: &amp;quot;1.0.0&amp;quot;,
        },
        relationships: [],
      });
    }

    return artifacts;
  }
}
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(11)">
                    <span class="file-path">file-code src/export-detection-data.ts</span>
                    <div class="file-meta">
                        <span>5.86 KB</span>
                        <span>1,299 tokens</span>
                        <span>Score: 0.35</span>
                    </div>
                </div>
                <div class="file-content" id="file-11">
                    <pre class="code-block"><code>#!/usr/bin/env bun
/**
 * Export intermediate detection data for faster iteration on type detection logic
 *
 * This script scans a project and exports the detection context data to JSON
 * so we can test detection logic changes without re-scanning.
 */

import * as path from &amp;quot;path&amp;quot;;
import * as fs from &amp;quot;fs-extra&amp;quot;;
import { glob } from &amp;quot;glob&amp;quot;;
import { NodeJSPlugin } from &amp;quot;./plugins/nodejs&amp;quot;;
import type { PackageJsonData } from &amp;quot;./plugins/nodejs&amp;quot;;
import type { InferenceContext } from &amp;quot;./types&amp;quot;;

interface DetectionData {
  projectPath: string;
  projectName: string;
  packages: PackageDetectionData[];
}

interface PackageDetectionData {
  name: string;
  path: string;
  packageJson: PackageJsonData;
  filePatterns: string[];
  detectedType?: string;
}

async function scanProject(projectPath: string): Promise&amp;lt;DetectionData&amp;gt; {
  const projectName &#x3D; path.basename(projectPath);
  console.log(&#x60;ðŸ“¦ Scanning project: ${projectName} at ${projectPath}&#x60;);

  // Find all package.json files
  const packageJsonPaths &#x3D; await glob(&amp;quot;**/package.json&amp;quot;, {
    cwd: projectPath,
    ignore: [&amp;quot;**/node_modules/**&amp;quot;, &amp;quot;**/dist/**&amp;quot;, &amp;quot;**/build/**&amp;quot;, &amp;quot;**/.next/**&amp;quot;],
    absolute: false,
  });

  const packages: PackageDetectionData[] &#x3D; [];
  const plugin &#x3D; new NodeJSPlugin();

  for (const pkgPath of packageJsonPaths) {
    const fullPath &#x3D; path.join(projectPath, pkgPath);
    const packageDir &#x3D; path.join(projectPath, path.dirname(pkgPath));

    try {
      const packageJson &#x3D; await fs.readJson(fullPath);

      // Get file patterns in the package directory - use projectPath as cwd
      const filePatterns &#x3D; await glob(&amp;quot;**/*.{js,jsx,ts,tsx,mjs,cjs}&amp;quot;, {
        cwd: packageDir,
        ignore: [&amp;quot;**/node_modules/**&amp;quot;, &amp;quot;**/dist/**&amp;quot;, &amp;quot;**/build/**&amp;quot;],
        absolute: false,
      });

      // Build a simple fileIndex for hasSourceFiles check
      const fileIndex &#x3D; {
        root: projectPath,
        files: new Map(),
        directories: new Map(),
        timestamp: Date.now(),
      };
      const sourceFiles &#x3D; await glob(&amp;quot;**/*.{js,jsx,ts,tsx,mjs,cjs}&amp;quot;, {
        cwd: packageDir,
        ignore: [&amp;quot;**/node_modules/**&amp;quot;, &amp;quot;**/dist/**&amp;quot;, &amp;quot;**/build/**&amp;quot;],
        absolute: false,
      });
      sourceFiles.forEach((relPath) &#x3D;&amp;gt; {
        const absPath &#x3D; path.join(packageDir, relPath);
        fileIndex.files.set(absPath, {
          path: absPath,
          relativePath: path.relative(projectPath, absPath),
          size: 0, // Mock
          lastModified: Date.now(),
          extension: path.extname(relPath),
          isBinary: false,
          hash: &amp;quot;&amp;quot;,
          language: undefined,
          metadata: {},
        });
      });

      // Create mock evidence for detection
      const evidence &#x3D; [
        {
          id: &amp;quot;test-package&amp;quot;,
          source: &amp;quot;nodejs&amp;quot;,
          type: &amp;quot;config&amp;quot; as const,
          filePath: pkgPath,
          data: {
            name: packageJson.name,
            description: packageJson.description,
            type: &amp;quot;package&amp;quot;,
            filePath: pkgPath,
          },
          confidence: 0.95,
          metadata: {
            timestamp: Date.now(),
            fileSize: JSON.stringify(packageJson).length,
          },
        },
      ];

      // Create full inference context with proper fileIndex
      const fullEvidence &#x3D; evidence;
      const projectMetadata &#x3D; {
        name: projectName,
        root: projectPath,
        languages: [],
        frameworks: [],
        fileCount: 0,
        totalSize: 0,
      };
      const inferenceContext: InferenceContext &#x3D; {
        projectRoot: projectPath,
        fileIndex,
        allEvidence: fullEvidence,
        options: {
          minConfidence: 0.3,
          inferRelationships: true,
          maxDependencyDepth: 5,
          useHeuristics: true,
        },
        cache: new Map(),
        projectMetadata,
      };
      // Run detection to get the type
      const artifacts &#x3D; await plugin.infer(fullEvidence, inferenceContext);
      const detectedType &#x3D; artifacts[0]?.artifact?.type;

      packages.push({
        name: packageJson.name || path.basename(packageDir),
        path: pkgPath,
        packageJson: {
          name: packageJson.name,
          description: packageJson.description,
          type: &amp;quot;package&amp;quot;,
          filePath: pkgPath,
        },
        filePatterns: filePatterns.slice(0, 20), // Limit to first 20 files for brevity
        detectedType,
      });

      console.log(
        &#x60;  âœ… ${packageJson.name || path.basename(packageDir)}: ${detectedType} (found ${filePatterns.length} source files)&#x60;,
      );
    } catch (error) {
      console.error(&#x60;  âŒ Error processing ${pkgPath}:&#x60;, error);
    }
  }

  return {
    projectPath,
    projectName,
    packages,
  };
}

async function main() {
  const projects &#x3D; [&amp;quot;/home/nathan/Projects/arbiter&amp;quot;, &amp;quot;/home/nathan/Projects/smith&amp;quot;];

  const allData: DetectionData[] &#x3D; [];

  for (const projectPath of projects) {
    if (await fs.pathExists(projectPath)) {
      const data &#x3D; await scanProject(projectPath);
      allData.push(data);
    } else {
      console.log(&#x60;âš ï¸  Project not found: ${projectPath}&#x60;);
    }
  }

  // Save the detection data
  const outputPath &#x3D; &amp;quot;/home/nathan/Projects/arbiter/detection-test-data.json&amp;quot;;
  await fs.writeJson(outputPath, allData, { spaces: 2 });
  console.log(&#x60;\nðŸ’¾ Detection data saved to: ${outputPath}&#x60;);

  // Summary
  console.log(&amp;quot;\nðŸ“Š Summary:&amp;quot;);
  for (const project of allData) {
    console.log(&#x60;\n${project.projectName}:&#x60;);
    const typeCounts: Record&amp;lt;string, number&amp;gt; &#x3D; {};
    for (const pkg of project.packages) {
      if (pkg.detectedType) {
        typeCounts[pkg.detectedType] &#x3D; (typeCounts[pkg.detectedType] || 0) + 1;
      }
    }
    for (const [type, count] of Object.entries(typeCounts)) {
      console.log(&#x60;  ${type}: ${count}&#x60;);
    }
  }
}

main().catch(console.error);
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(12)">
                    <span class="file-path">file-code src/detection/artifact-detector.ts</span>
                    <div class="file-meta">
                        <span>23.11 KB</span>
                        <span>5,030 tokens</span>
                        <span>Score: 0.30</span>
                    </div>
                </div>
                <div class="file-content" id="file-12">
                    <pre class="code-block"><code>/**
 * Artifact Type Detection Engine
 *
 * This module provides intelligent artifact type detection using the dependency matrix
 * and additional heuristics to accurately classify codebases into their primary purposes.
 */

import {
  type CategoryMatrix,
  DEPENDENCY_MATRIX,
  determineMostLikelyCategory,
  getAllCategoriesByConfidence,
  getCategoryExplanation,
} from &amp;quot;./dependency-matrix&amp;quot;;

export interface DetectionContext {
  /** Primary language detected */
  language: string;
  /** All dependencies found in the project */
  dependencies: string[];
  /** Scripts or commands found (e.g., npm scripts, cargo commands) */
  scripts: Record&amp;lt;string, string&amp;gt;;
  /** File patterns that might indicate artifact type */
  filePatterns: string[];
  /** Package configuration (package.json, Cargo.toml, etc.) */
  packageConfig: Record&amp;lt;string, any&amp;gt;;
  /** Source code analysis results */
  sourceAnalysis?: SourceAnalysis;
}

export interface SourceAnalysis {
  /** Indicates if binary execution patterns are found */
  hasBinaryExecution: boolean;
  /** Server/service patterns detected */
  hasServerPatterns: boolean;
  /** Frontend/UI patterns detected */
  hasFrontendPatterns: boolean;
  /** CLI interaction patterns */
  hasCliPatterns: boolean;
  /** Data processing patterns */
  hasDataProcessingPatterns: boolean;
  /** Test patterns */
  hasTestPatterns: boolean;
  /** Build/packaging patterns */
  hasBuildPatterns: boolean;
  /** Game-specific patterns */
  hasGamePatterns: boolean;
  /** Mobile-specific patterns */
  hasMobilePatterns: boolean;
  /** Desktop app patterns */
  hasDesktopPatterns: boolean;
}

export interface DetectionResult {
  /** Primary artifact type */
  primaryType: keyof CategoryMatrix;
  /** Confidence score (0-1) */
  confidence: number;
  /** All possible types ranked by confidence */
  alternativeTypes: Array&amp;lt;{ type: keyof CategoryMatrix; confidence: number }&amp;gt;;
  /** Human-readable explanation of the decision */
  explanation: string[];
  /** Detailed breakdown of factors */
  factors: DetectionFactors;
}

export interface DetectionFactors {
  /** Dependency-based detection results */
  dependencyFactors: Array&amp;lt;{
    category: keyof CategoryMatrix;
    confidence: number;
    matches: string[];
  }&amp;gt;;
  /** Script-based indicators */
  scriptFactors: Array&amp;lt;{
    category: keyof CategoryMatrix;
    confidence: number;
    scripts: string[];
  }&amp;gt;;
  /** File pattern indicators */
  filePatternFactors: Array&amp;lt;{
    category: keyof CategoryMatrix;
    confidence: number;
    patterns: string[];
  }&amp;gt;;
  /** Package configuration indicators */
  configFactors: Array&amp;lt;{
    category: keyof CategoryMatrix;
    confidence: number;
    indicators: string[];
  }&amp;gt;;
  /** Source code analysis factors */
  sourceFactors?: Array&amp;lt;{
    category: keyof CategoryMatrix;
    confidence: number;
    patterns: string[];
  }&amp;gt;;
}

/**
 * Main artifact detection engine
 */
export class ArtifactDetector {
  /**
   * Detect the primary artifact type and alternatives
   */
  detect(context: DetectionContext): DetectionResult {
    const factors &#x3D; this.analyzeAllFactors(context);
    const hasEvidence &#x3D;
      factors.dependencyFactors.length &amp;gt; 0 ||
      factors.scriptFactors.length &amp;gt; 0 ||
      factors.filePatternFactors.length &amp;gt; 0 ||
      factors.configFactors.length &amp;gt; 0 ||
      (factors.sourceFactors?.length ?? 0) &amp;gt; 0;

    if (!hasEvidence) {
      const explanation &#x3D; [&amp;quot;Detected as package based on:&amp;quot;, &amp;quot;no strong detection signals&amp;quot;];
      const confidence &#x3D; DEPENDENCY_MATRIX[context.language] ? 0.2 : 0;
      return {
        primaryType: &amp;quot;package&amp;quot;,
        confidence,
        alternativeTypes: [],
        explanation,
        factors,
      };
    }

    const aggregatedScores &#x3D; this.aggregateScores(factors);

    // Sort by confidence
    const sortedTypes &#x3D; Object.entries(aggregatedScores)
      .map(([type, confidence]) &#x3D;&amp;gt; ({
        type: type as keyof CategoryMatrix,
        confidence,
      }))
      .sort((a, b) &#x3D;&amp;gt; b.confidence - a.confidence);

    const primaryType &#x3D; sortedTypes[0]?.type || &amp;quot;package&amp;quot;;
    const confidence &#x3D; sortedTypes[0]?.confidence || 0.1;
    const alternativeTypes &#x3D; sortedTypes.slice(1);

    const explanation &#x3D; this.generateExplanation(context, factors, primaryType);

    return {
      primaryType,
      confidence,
      alternativeTypes,
      explanation,
      factors,
    };
  }

  /**
   * Analyze all factors that contribute to artifact type detection
   */
  private analyzeAllFactors(context: DetectionContext): DetectionFactors {
    const dependencyFactors &#x3D; this.analyzeDependencyFactors(context);
    const scriptFactors &#x3D; this.analyzeScriptFactors(context);
    const filePatternFactors &#x3D; this.analyzeFilePatternFactors(context);
    const configFactors &#x3D; this.analyzeConfigFactors(context);
    const sourceFactors &#x3D; context.sourceAnalysis ? this.analyzeSourceFactors(context) : undefined;

    return {
      dependencyFactors,
      scriptFactors,
      filePatternFactors,
      configFactors,
      sourceFactors,
    };
  }

  /**
   * Analyze dependencies using the dependency matrix
   */
  private analyzeDependencyFactors(context: DetectionContext): Array&amp;lt;{
    category: keyof CategoryMatrix;
    confidence: number;
    matches: string[];
  }&amp;gt; {
    const results &#x3D; getAllCategoriesByConfidence(context.dependencies, context.language);

    return results.map(({ category, confidence }) &#x3D;&amp;gt; ({
      category,
      confidence,
      matches: getCategoryExplanation(context.dependencies, context.language, category),
    }));
  }

  /**
   * Analyze scripts for artifact type indicators
   */
  private analyzeScriptFactors(context: DetectionContext): Array&amp;lt;{
    category: keyof CategoryMatrix;
    confidence: number;
    scripts: string[];
  }&amp;gt; {
    const factors: Array&amp;lt;{
      category: keyof CategoryMatrix;
      confidence: number;
      scripts: string[];
    }&amp;gt; &#x3D; [];

    // CLI indicators in scripts
    const cliScripts &#x3D; this.findScriptsMatching(context.scripts, [
      /bin\/.*$/, // Binary execution
      /cli/i, // CLI mentions
      /command/i, // Command mentions
      /--help/, // Help flags
      /--version/, // Version flags
      /go\s+run/i, // Go CLI entry point
      /dotnet\s+run/i, // .NET CLI entry point
    ]);
    if (cliScripts.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;tool&amp;quot;,
        confidence: Math.min(0.8, cliScripts.length * 0.3),
        scripts: cliScripts,
      });
    }

    // Web service indicators
    const webScripts &#x3D; this.findScriptsMatching(context.scripts, [
      /start.*server/i, // Server start
      /serve/i, // Serve commands
      /dev.*server/i, // Development server
      /nodemon/, // Development tool
      /pm2/, // Process manager
    ]);
    if (webScripts.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;web_service&amp;quot;,
        confidence: Math.min(0.7, webScripts.length * 0.25),
        scripts: webScripts,
      });
    }

    // Frontend indicators
    const frontendScripts &#x3D; this.findScriptsMatching(context.scripts, [
      /webpack/i,
      /vite/i,
      /rollup/i,
      /parcel/i,
      /react-scripts/i,
      /next\s+dev/i,
      /nuxt\s+dev/i,
      /start.*dev/i,
      /preview/i,
    ]);
    if (frontendScripts.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;frontend&amp;quot;,
        confidence: Math.min(0.6, frontendScripts.length * 0.2),
        scripts: frontendScripts,
      });
    }

    // Testing indicators
    const testScripts &#x3D; this.findScriptsMatching(context.scripts, [
      /test/i, // Test commands
      /jest/, // Jest
      /vitest/, // Vitest
      /cypress/, // E2E testing
      /playwright/, // E2E testing
    ]);
    if (testScripts.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;testing&amp;quot;,
        confidence: Math.min(0.5, testScripts.length * 0.15),
        scripts: testScripts,
      });
    }

    // Build tool indicators
    const buildScripts &#x3D; this.findScriptsMatching(context.scripts, [
      /build/i, // Build commands
      /compile/i, // Compilation
      /bundle/i, // Bundling
      /pack/i, // Packaging
      /dist/i, // Distribution
    ]);
    if (buildScripts.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;build_tool&amp;quot;,
        confidence: Math.min(0.4, buildScripts.length * 0.1),
        scripts: buildScripts,
      });
    }

    return factors;
  }

  /**
   * Analyze file patterns for artifact type indicators
   */
  private analyzeFilePatternFactors(context: DetectionContext): Array&amp;lt;{
    category: keyof CategoryMatrix;
    confidence: number;
    patterns: string[];
  }&amp;gt; {
    const factors: Array&amp;lt;{
      category: keyof CategoryMatrix;
      confidence: number;
      patterns: string[];
    }&amp;gt; &#x3D; [];

    // CLI indicators
    const cliPatterns &#x3D; context.filePatterns.filter(
      (pattern) &#x3D;&amp;gt;
        /bin\//.test(pattern) ||
        /cli\./.test(pattern) ||
        /command\./.test(pattern) ||
        /main\./.test(pattern) ||
        /cmd\//i.test(pattern),
    );
    if (cliPatterns.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;tool&amp;quot;,
        confidence: Math.min(0.6, cliPatterns.length * 0.2),
        patterns: cliPatterns,
      });
    }

    // Web service patterns
    const webPatterns &#x3D; context.filePatterns.filter(
      (pattern) &#x3D;&amp;gt;
        /server\./.test(pattern) ||
        /app\./.test(pattern) ||
        /routes?\//.test(pattern) ||
        /controllers?\//.test(pattern) ||
        /middleware\//.test(pattern),
    );
    if (webPatterns.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;web_service&amp;quot;,
        confidence: Math.min(0.7, webPatterns.length * 0.15),
        patterns: webPatterns,
      });
    }

    // Frontend patterns
    const frontendPatterns &#x3D; context.filePatterns.filter(
      (pattern) &#x3D;&amp;gt;
        /components?\//.test(pattern) ||
        /pages?\//.test(pattern) ||
        /views?\//.test(pattern) ||
        /public\//.test(pattern) ||
        /assets?\//.test(pattern) ||
        /src\/.*\.(tsx?|jsx?|vue|svelte)$/.test(pattern),
    );
    if (frontendPatterns.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;frontend&amp;quot;,
        confidence: Math.min(0.6, frontendPatterns.length * 0.1),
        patterns: frontendPatterns,
      });
    }

    // Library/module patterns
    const modulePatterns &#x3D; context.filePatterns.filter(
      (pattern) &#x3D;&amp;gt;
        /lib\//.test(pattern) || /src\/.*index\.(ts|js)$/.test(pattern) || /dist\//.test(pattern),
    );
    if (modulePatterns.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;package&amp;quot;,
        confidence: Math.min(0.4, modulePatterns.length * 0.1),
        patterns: modulePatterns,
      });
    }

    // Desktop app patterns
    const desktopPatterns &#x3D; context.filePatterns.filter(
      (pattern) &#x3D;&amp;gt;
        /electron/.test(pattern) ||
        /tauri/.test(pattern) ||
        /native/.test(pattern) ||
        /desktop/.test(pattern),
    );
    if (desktopPatterns.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;desktop_app&amp;quot;,
        confidence: Math.min(0.8, desktopPatterns.length * 0.3),
        patterns: desktopPatterns,
      });
    }

    // Game patterns
    const gamePatterns &#x3D; context.filePatterns.filter(
      (pattern) &#x3D;&amp;gt;
        /game/.test(pattern) ||
        /scenes?\//.test(pattern) ||
        /sprites?\//.test(pattern) ||
        /assets\/.*\.(png|jpg|wav|mp3)$/.test(pattern),
    );
    if (gamePatterns.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;game&amp;quot;,
        confidence: Math.min(0.7, gamePatterns.length * 0.2),
        patterns: gamePatterns,
      });
    }

    // Mobile patterns
    const mobilePatterns &#x3D; context.filePatterns.filter(
      (pattern) &#x3D;&amp;gt;
        /mobile/.test(pattern) ||
        /ios\//.test(pattern) ||
        /android\//.test(pattern) ||
        /react-native/.test(pattern),
    );
    if (mobilePatterns.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;mobile&amp;quot;,
        confidence: Math.min(0.8, mobilePatterns.length * 0.25),
        patterns: mobilePatterns,
      });
    }

    return factors;
  }

  /**
   * Analyze package configuration for indicators
   */
  private analyzeConfigFactors(context: DetectionContext): Array&amp;lt;{
    category: keyof CategoryMatrix;
    confidence: number;
    indicators: string[];
  }&amp;gt; {
    const factors: Array&amp;lt;{
      category: keyof CategoryMatrix;
      confidence: number;
      indicators: string[];
    }&amp;gt; &#x3D; [];

    const config &#x3D; context.packageConfig;

    // CLI indicators
    const cliIndicators: string[] &#x3D; [];
    if (config.bin) {
      cliIndicators.push(&amp;quot;has bin field&amp;quot;);
      if (typeof config.bin &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot;) {
        cliIndicators.push(&amp;quot;binary command definitions&amp;quot;);
        cliIndicators.push(&amp;quot;explicit CLI entry point&amp;quot;);
      }
    }
    if (config.main &amp;amp;&amp;amp; typeof config.main &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; &amp;amp;&amp;amp; config.main.includes(&amp;quot;bin&amp;quot;)) {
      cliIndicators.push(&amp;quot;main points to bin&amp;quot;);
    }
    if (config.preferGlobal) {
      cliIndicators.push(&amp;quot;preferGlobal flag&amp;quot;);
    }
    if (config.entry_points?.console_scripts) {
      cliIndicators.push(&amp;quot;console script entry points&amp;quot;);
      cliIndicators.push(&amp;quot;exposed console commands&amp;quot;);
    }
    if (cliIndicators.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;tool&amp;quot;,
        confidence: Math.min(0.9, cliIndicators.length * 0.4),
        indicators: cliIndicators,
      });
    }

    // Module indicators - enhanced detection
    const moduleIndicators: string[] &#x3D; [];
    if (config.main &amp;amp;&amp;amp; !config.bin) {
      moduleIndicators.push(&amp;quot;has main without bin&amp;quot;);
    }
    if (config.exports) {
      moduleIndicators.push(&amp;quot;has exports field&amp;quot;);
    }
    if (config.types || config.typings) {
      moduleIndicators.push(&amp;quot;provides TypeScript types&amp;quot;);
    }
    if (&amp;quot;private&amp;quot; in config &amp;amp;&amp;amp; !config.private &amp;amp;&amp;amp; !config.bin) {
      moduleIndicators.push(&amp;quot;public package without CLI&amp;quot;);
    }
    // Check for module-specific fields
    if (config.module) {
      moduleIndicators.push(&amp;quot;has ESM module field&amp;quot;);
    }
    if (config.peerDependencies &amp;amp;&amp;amp; Object.keys(config.peerDependencies).length &amp;gt; 0) {
      moduleIndicators.push(&amp;quot;has peer dependencies&amp;quot;);
    }
    if (config.keywords?.some((k: string) &#x3D;&amp;gt; /module|util|helper|plugin|middleware/i.test(k))) {
      moduleIndicators.push(&amp;quot;module-related keywords&amp;quot;);
    }
    if (moduleIndicators.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;package&amp;quot;,
        confidence: Math.min(0.8, moduleIndicators.length * 0.2),
        indicators: moduleIndicators,
      });
    }

    // Frontend indicators - enhanced detection
    const frontendIndicators: string[] &#x3D; [];
    if (config.private &amp;amp;&amp;amp; (config.scripts?.build || config.scripts?.dev)) {
      frontendIndicators.push(&amp;quot;private package with build/dev scripts&amp;quot;);
    }
    if (config.homepage) {
      frontendIndicators.push(&amp;quot;has homepage field&amp;quot;);
    }
    if (config.browserslist) {
      frontendIndicators.push(&amp;quot;has browserslist config&amp;quot;);
    }
    if (config.scripts?.start &amp;amp;&amp;amp; !config.scripts?.start.includes(&amp;quot;node&amp;quot;)) {
      frontendIndicators.push(&amp;quot;non-node start script&amp;quot;);
    }
    if (frontendIndicators.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;frontend&amp;quot;,
        confidence: Math.min(0.6, frontendIndicators.length * 0.2),
        indicators: frontendIndicators,
      });
    }

    // Web service indicators - new detection
    const webServiceIndicators: string[] &#x3D; [];
    if (config.scripts?.start?.includes(&amp;quot;node&amp;quot;)) {
      webServiceIndicators.push(&amp;quot;node start script&amp;quot;);
    }
    if (config.scripts?.[&amp;quot;start:prod&amp;quot;] || config.scripts?.production) {
      webServiceIndicators.push(&amp;quot;production start scripts&amp;quot;);
    }
    if (config.engines?.node &amp;amp;&amp;amp; !config.bin) {
      webServiceIndicators.push(&amp;quot;node engine requirement without CLI&amp;quot;);
    }
    if (webServiceIndicators.length &amp;gt; 0) {
      factors.push({
        category: &amp;quot;web_service&amp;quot;,
        confidence: Math.min(0.5, webServiceIndicators.length * 0.2),
        indicators: webServiceIndicators,
      });
    }

    return factors;
  }

  /**
   * Analyze source code patterns
   */
  private analyzeSourceFactors(context: DetectionContext): Array&amp;lt;{
    category: keyof CategoryMatrix;
    confidence: number;
    patterns: string[];
  }&amp;gt; {
    const factors: Array&amp;lt;{
      category: keyof CategoryMatrix;
      confidence: number;
      patterns: string[];
    }&amp;gt; &#x3D; [];

    const analysis &#x3D; context.sourceAnalysis!;

    if (analysis.hasBinaryExecution || analysis.hasCliPatterns) {
      const patterns: string[] &#x3D; [];
      if (analysis.hasBinaryExecution) patterns.push(&amp;quot;binary execution patterns&amp;quot;);
      if (analysis.hasCliPatterns) patterns.push(&amp;quot;CLI interaction patterns&amp;quot;);

      factors.push({
        category: &amp;quot;tool&amp;quot;,
        confidence: 0.8,
        patterns,
      });
    }

    if (analysis.hasServerPatterns) {
      factors.push({
        category: &amp;quot;web_service&amp;quot;,
        confidence: 0.9,
        patterns: [&amp;quot;server/service patterns detected&amp;quot;],
      });
    }

    if (analysis.hasFrontendPatterns) {
      factors.push({
        category: &amp;quot;frontend&amp;quot;,
        confidence: 0.8,
        patterns: [&amp;quot;frontend/UI patterns detected&amp;quot;],
      });
    }

    if (analysis.hasDataProcessingPatterns) {
      factors.push({
        category: &amp;quot;data_processing&amp;quot;,
        confidence: 0.7,
        patterns: [&amp;quot;data processing patterns detected&amp;quot;],
      });
    }

    if (analysis.hasGamePatterns) {
      factors.push({
        category: &amp;quot;game&amp;quot;,
        confidence: 0.9,
        patterns: [&amp;quot;game development patterns detected&amp;quot;],
      });
    }

    if (analysis.hasMobilePatterns) {
      factors.push({
        category: &amp;quot;mobile&amp;quot;,
        confidence: 0.8,
        patterns: [&amp;quot;mobile development patterns detected&amp;quot;],
      });
    }

    if (analysis.hasDesktopPatterns) {
      factors.push({
        category: &amp;quot;desktop_app&amp;quot;,
        confidence: 0.8,
        patterns: [&amp;quot;desktop application patterns detected&amp;quot;],
      });
    }

    return factors;
  }

  /**
   * Aggregate scores from all factors using weighted combination
   */
  private aggregateScores(factors: DetectionFactors): Record&amp;lt;string, number&amp;gt; {
    const scores: Record&amp;lt;string, number&amp;gt; &#x3D; {};

    const hasSource &#x3D; (factors.sourceFactors?.length ?? 0) &amp;gt; 0;
    const hasConfig &#x3D; factors.configFactors.length &amp;gt; 0;

    // When we only have lightweight signals (e.g., Go or C# binaries) lean on
    // dependencies more heavily so obvious CLI frameworks still rank highly.
    const weights &#x3D;
      hasSource || hasConfig
        ? {
            dependency: 0.5,
            source: 0.25,
            config: 0.25,
            script: 0.08,
            filePattern: 0.05,
          }
        : {
            dependency: 0.7,
            source: 0,
            config: 0,
            script: 0.2,
            filePattern: 0.1,
          };

    // Aggregate dependency factors
    factors.dependencyFactors.forEach((factor) &#x3D;&amp;gt; {
      scores[factor.category] &#x3D;
        (scores[factor.category] || 0) + factor.confidence * weights.dependency;
    });

    // Aggregate source factors (if available)
    factors.sourceFactors?.forEach((factor) &#x3D;&amp;gt; {
      scores[factor.category] &#x3D; (scores[factor.category] || 0) + factor.confidence * weights.source;
    });

    // Aggregate config factors
    factors.configFactors.forEach((factor) &#x3D;&amp;gt; {
      scores[factor.category] &#x3D; (scores[factor.category] || 0) + factor.confidence * weights.config;
    });

    // Aggregate script factors
    factors.scriptFactors.forEach((factor) &#x3D;&amp;gt; {
      scores[factor.category] &#x3D; (scores[factor.category] || 0) + factor.confidence * weights.script;
    });

    // Aggregate file pattern factors
    factors.filePatternFactors.forEach((factor) &#x3D;&amp;gt; {
      scores[factor.category] &#x3D;
        (scores[factor.category] || 0) + factor.confidence * weights.filePattern;
    });

    // Enhanced default detection based on common patterns
    if (Object.keys(scores).length &#x3D;&#x3D;&#x3D; 0 || Math.max(...Object.values(scores)) &amp;lt; 0.1) {
      // Try to make a more intelligent guess based on available evidence

      // Strong CLI indicators
      if (factors.configFactors.some((f) &#x3D;&amp;gt; f.category &#x3D;&#x3D;&#x3D; &amp;quot;tool&amp;quot; &amp;amp;&amp;amp; f.confidence &amp;gt; 0.5)) {
        scores[&amp;quot;tool&amp;quot;] &#x3D; 0.7;
      }
      // Strong package indicators
      else if (factors.configFactors.some((f) &#x3D;&amp;gt; f.category &#x3D;&#x3D;&#x3D; &amp;quot;package&amp;quot; &amp;amp;&amp;amp; f.confidence &amp;gt; 0.3)) {
        scores[&amp;quot;package&amp;quot;] &#x3D; 0.5;
      }
      // Check for web service patterns
      else if (
        factors.sourceFactors?.some((f) &#x3D;&amp;gt; f.category &#x3D;&#x3D;&#x3D; &amp;quot;web_service&amp;quot; &amp;amp;&amp;amp; f.confidence &amp;gt; 0.5)
      ) {
        scores[&amp;quot;web_service&amp;quot;] &#x3D; 0.6;
      }
      // Check for frontend patterns
      else if (
        factors.filePatternFactors.some((f) &#x3D;&amp;gt; f.category &#x3D;&#x3D;&#x3D; &amp;quot;frontend&amp;quot; &amp;amp;&amp;amp; f.confidence &amp;gt; 0.3)
      ) {
        scores[&amp;quot;frontend&amp;quot;] &#x3D; 0.5;
      }
      // Default to package with low confidence
      else {
        scores[&amp;quot;package&amp;quot;] &#x3D; 0.2;
      }
    }

    // Normalize scores but keep them reasonable
    Object.keys(scores).forEach((key) &#x3D;&amp;gt; {
      scores[key] &#x3D; Math.min(1.0, scores[key]);
    });

    return scores;
  }

  /**
   * Generate human-readable explanation
   */
  private generateExplanation(
    context: DetectionContext,
    factors: DetectionFactors,
    primaryType: keyof CategoryMatrix,
  ): string[] {
    const explanation: string[] &#x3D; [];

    explanation.push(&#x60;Detected as ${primaryType} based on:&#x60;);

    // Add dependency explanations
    const depFactor &#x3D; factors.dependencyFactors.find((f) &#x3D;&amp;gt; f.category &#x3D;&#x3D;&#x3D; primaryType);
    if (depFactor &amp;amp;&amp;amp; depFactor.matches.length &amp;gt; 0) {
      explanation.push(&amp;quot;Dependencies:&amp;quot;);
      explanation.push(...depFactor.matches.slice(0, 3));
    }

    // Add source code explanations
    const sourceFactor &#x3D; factors.sourceFactors?.find((f) &#x3D;&amp;gt; f.category &#x3D;&#x3D;&#x3D; primaryType);
    if (sourceFactor &amp;amp;&amp;amp; sourceFactor.patterns.length &amp;gt; 0) {
      explanation.push(&amp;quot;Source code:&amp;quot;);
      explanation.push(...sourceFactor.patterns);
    }

    // Add config explanations
    const configFactor &#x3D; factors.configFactors.find((f) &#x3D;&amp;gt; f.category &#x3D;&#x3D;&#x3D; primaryType);
    if (configFactor &amp;amp;&amp;amp; configFactor.indicators.length &amp;gt; 0) {
      explanation.push(&amp;quot;Configuration:&amp;quot;);
      explanation.push(...configFactor.indicators);
    }

    // Add script explanations
    const scriptFactor &#x3D; factors.scriptFactors.find((f) &#x3D;&amp;gt; f.category &#x3D;&#x3D;&#x3D; primaryType);
    if (scriptFactor &amp;amp;&amp;amp; scriptFactor.scripts.length &amp;gt; 0) {
      explanation.push(&amp;quot;Scripts:&amp;quot;);
      explanation.push(...scriptFactor.scripts.slice(0, 2));
    }

    return explanation;
  }

  /**
   * Helper method to find scripts matching patterns
   */
  private findScriptsMatching(scripts: Record&amp;lt;string, string&amp;gt;, patterns: RegExp[]): string[] {
    const matches: string[] &#x3D; [];

    Object.entries(scripts).forEach(([name, command]) &#x3D;&amp;gt; {
      if (patterns.some((pattern) &#x3D;&amp;gt; pattern.test(name) || pattern.test(command))) {
        matches.push(&#x60;${name}: ${command}&#x60;);
      }
    });

    return matches;
  }
}

/**
 * Convenience function to detect artifact type
 */
export function detectArtifactType(context: DetectionContext): DetectionResult {
  const detector &#x3D; new ArtifactDetector();
  return detector.detect(context);
}
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(13)">
                    <span class="file-path">file-code src/detection/dependency-matrix.ts</span>
                    <div class="file-meta">
                        <span>59.84 KB</span>
                        <span>16,958 tokens</span>
                        <span>Score: 0.30</span>
                    </div>
                </div>
                <div class="file-content" id="file-13">
                    <pre class="code-block"><code>/**
 * Dependency Matrix for Language/Category Detection
 *
 * This module provides comprehensive mapping of dependencies to artifact categories
 * across multiple programming languages. Each category has distinguishing imports
 * that help identify the primary purpose of a codebase.
 */

export interface DependencyPattern {
  /** The dependency/import name or pattern */
  name: string;
  /** Weight of this dependency for category determination (0-1) */
  weight: number;
  /** Additional context or notes about this dependency */
  context?: string;
  /** Alternative names or aliases for this dependency */
  aliases?: string[];
}

export interface CategoryMatrix {
  tool: DependencyPattern[];
  web_service: DependencyPattern[];
  frontend: DependencyPattern[];
  package: DependencyPattern[];
  desktop_app: DependencyPattern[];
  data_processing: DependencyPattern[];
  testing: DependencyPattern[];
  build_tool: DependencyPattern[];
  game: DependencyPattern[];
  mobile: DependencyPattern[];
}

export interface LanguageMatrix {
  [language: string]: CategoryMatrix;
}

/**
 * Comprehensive dependency matrix for multiple languages
 */
export const DEPENDENCY_MATRIX: LanguageMatrix &#x3D; {
  javascript: {
    tool: [
      { name: &amp;quot;commander&amp;quot;, weight: 0.9, context: &amp;quot;Command-line argument parsing&amp;quot; },
      { name: &amp;quot;yargs&amp;quot;, weight: 0.9, context: &amp;quot;Command-line argument parsing&amp;quot; },
      { name: &amp;quot;inquirer&amp;quot;, weight: 0.8, context: &amp;quot;Interactive CLI prompts&amp;quot; },
      { name: &amp;quot;chalk&amp;quot;, weight: 0.7, context: &amp;quot;Terminal text styling&amp;quot; },
      { name: &amp;quot;ora&amp;quot;, weight: 0.7, context: &amp;quot;Terminal spinners&amp;quot; },
      { name: &amp;quot;boxen&amp;quot;, weight: 0.6, context: &amp;quot;Terminal boxes&amp;quot; },
      { name: &amp;quot;cli-table3&amp;quot;, weight: 0.6, context: &amp;quot;Terminal tables&amp;quot; },
      { name: &amp;quot;figlet&amp;quot;, weight: 0.6, context: &amp;quot;ASCII art text&amp;quot; },
      { name: &amp;quot;minimist&amp;quot;, weight: 0.5, context: &amp;quot;Minimal argument parsing&amp;quot; },
      { name: &amp;quot;cosmiconfig&amp;quot;, weight: 0.5, context: &amp;quot;Configuration loading&amp;quot; },
      { name: &amp;quot;meow&amp;quot;, weight: 0.8, context: &amp;quot;CLI app helper&amp;quot; },
      { name: &amp;quot;arg&amp;quot;, weight: 0.6, context: &amp;quot;Argument parsing&amp;quot; },
      { name: &amp;quot;prompts&amp;quot;, weight: 0.7, context: &amp;quot;Terminal prompts&amp;quot; },
      { name: &amp;quot;cli-progress&amp;quot;, weight: 0.6, context: &amp;quot;Progress bars&amp;quot; },
      { name: &amp;quot;kleur&amp;quot;, weight: 0.6, context: &amp;quot;Terminal colors&amp;quot; },
      { name: &amp;quot;cfonts&amp;quot;, weight: 0.5, context: &amp;quot;ASCII fonts&amp;quot; },
      { name: &amp;quot;terminal-kit&amp;quot;, weight: 0.6, context: &amp;quot;Terminal UI toolkit&amp;quot; },
      { name: &amp;quot;blessed&amp;quot;, weight: 0.7, context: &amp;quot;Terminal UI library&amp;quot; },
      { name: &amp;quot;ink&amp;quot;, weight: 0.8, context: &amp;quot;React for CLI apps&amp;quot; },
      { name: &amp;quot;caporal&amp;quot;, weight: 0.7, context: &amp;quot;CLI framework&amp;quot; },
    ],
    web_service: [
      { name: &amp;quot;express&amp;quot;, weight: 0.9, context: &amp;quot;Web framework&amp;quot; },
      { name: &amp;quot;fastify&amp;quot;, weight: 0.9, context: &amp;quot;High-performance web framework&amp;quot; },
      { name: &amp;quot;koa&amp;quot;, weight: 0.9, context: &amp;quot;Web framework&amp;quot; },
      { name: &amp;quot;hono&amp;quot;, weight: 0.9, context: &amp;quot;Ultrafast web framework&amp;quot; },
      { name: &amp;quot;hapi&amp;quot;, weight: 0.8, context: &amp;quot;Web framework&amp;quot; },
      {
        name: &amp;quot;nestjs&amp;quot;,
        weight: 0.8,
        context: &amp;quot;Enterprise web framework&amp;quot;,
        aliases: [&amp;quot;@nestjs/core&amp;quot;],
      },
      { name: &amp;quot;apollo-server&amp;quot;, weight: 0.8, context: &amp;quot;GraphQL server&amp;quot; },
      { name: &amp;quot;socket.io&amp;quot;, weight: 0.7, context: &amp;quot;WebSocket server&amp;quot; },
      { name: &amp;quot;cors&amp;quot;, weight: 0.6, context: &amp;quot;CORS middleware&amp;quot; },
      { name: &amp;quot;helmet&amp;quot;, weight: 0.6, context: &amp;quot;Security middleware&amp;quot; },
      { name: &amp;quot;body-parser&amp;quot;, weight: 0.5, context: &amp;quot;Request parsing middleware&amp;quot; },
      { name: &amp;quot;restify&amp;quot;, weight: 0.8, context: &amp;quot;REST API framework&amp;quot; },
      { name: &amp;quot;loopback&amp;quot;, weight: 0.7, context: &amp;quot;API framework&amp;quot; },
      { name: &amp;quot;sails&amp;quot;, weight: 0.7, context: &amp;quot;MVC framework&amp;quot; },
      { name: &amp;quot;feathers&amp;quot;, weight: 0.7, context: &amp;quot;Real-time framework&amp;quot; },
      { name: &amp;quot;strapi&amp;quot;, weight: 0.8, context: &amp;quot;Headless CMS&amp;quot; },
      { name: &amp;quot;adonis&amp;quot;, weight: 0.8, context: &amp;quot;Full-stack framework&amp;quot; },
      { name: &amp;quot;micro&amp;quot;, weight: 0.6, context: &amp;quot;Microservice framework&amp;quot; },
      { name: &amp;quot;polka&amp;quot;, weight: 0.6, context: &amp;quot;Micro web framework&amp;quot; },
      { name: &amp;quot;graphql&amp;quot;, weight: 0.6, context: &amp;quot;GraphQL&amp;quot; },
      { name: &amp;quot;graphql-yoga&amp;quot;, weight: 0.7, context: &amp;quot;GraphQL server&amp;quot; },
      { name: &amp;quot;ws&amp;quot;, weight: 0.6, context: &amp;quot;WebSocket library&amp;quot; },
      { name: &amp;quot;compression&amp;quot;, weight: 0.5, context: &amp;quot;Compression middleware&amp;quot; },
      { name: &amp;quot;morgan&amp;quot;, weight: 0.5, context: &amp;quot;HTTP logger&amp;quot; },
      { name: &amp;quot;express-session&amp;quot;, weight: 0.5, context: &amp;quot;Session middleware&amp;quot; },
      { name: &amp;quot;passport&amp;quot;, weight: 0.6, context: &amp;quot;Authentication middleware&amp;quot; },
      { name: &amp;quot;jsonwebtoken&amp;quot;, weight: 0.5, context: &amp;quot;JWT implementation&amp;quot; },
      { name: &amp;quot;bcrypt&amp;quot;, weight: 0.5, context: &amp;quot;Password hashing&amp;quot; },
      { name: &amp;quot;bcryptjs&amp;quot;, weight: 0.5, context: &amp;quot;Password hashing&amp;quot; },
    ],
    frontend: [
      { name: &amp;quot;react&amp;quot;, weight: 0.9, context: &amp;quot;UI library&amp;quot; },
      { name: &amp;quot;vue&amp;quot;, weight: 0.9, context: &amp;quot;UI framework&amp;quot; },
      { name: &amp;quot;angular&amp;quot;, weight: 0.9, context: &amp;quot;UI framework&amp;quot;, aliases: [&amp;quot;@angular/core&amp;quot;] },
      { name: &amp;quot;svelte&amp;quot;, weight: 0.9, context: &amp;quot;UI framework&amp;quot; },
      { name: &amp;quot;solid-js&amp;quot;, weight: 0.8, context: &amp;quot;UI library&amp;quot; },
      { name: &amp;quot;preact&amp;quot;, weight: 0.8, context: &amp;quot;Lightweight React alternative&amp;quot; },
      { name: &amp;quot;lit&amp;quot;, weight: 0.7, context: &amp;quot;Web components library&amp;quot; },
      { name: &amp;quot;stimulus&amp;quot;, weight: 0.6, context: &amp;quot;Modest JavaScript framework&amp;quot; },
      { name: &amp;quot;alpine.js&amp;quot;, weight: 0.6, context: &amp;quot;Lightweight JavaScript framework&amp;quot; },
      { name: &amp;quot;next&amp;quot;, weight: 0.8, context: &amp;quot;React framework&amp;quot;, aliases: [&amp;quot;next.js&amp;quot;] },
    ],
    package: [
      { name: &amp;quot;lodash&amp;quot;, weight: 0.7, context: &amp;quot;Utility library&amp;quot; },
      { name: &amp;quot;axios&amp;quot;, weight: 0.6, context: &amp;quot;HTTP client&amp;quot; },
      { name: &amp;quot;moment&amp;quot;, weight: 0.6, context: &amp;quot;Date manipulation&amp;quot; },
      { name: &amp;quot;uuid&amp;quot;, weight: 0.5, context: &amp;quot;UUID generation&amp;quot; },
      { name: &amp;quot;ramda&amp;quot;, weight: 0.6, context: &amp;quot;Functional programming utilities&amp;quot; },
      { name: &amp;quot;date-fns&amp;quot;, weight: 0.6, context: &amp;quot;Date utility library&amp;quot; },
      { name: &amp;quot;immutable&amp;quot;, weight: 0.6, context: &amp;quot;Immutable data structures&amp;quot; },
      { name: &amp;quot;rxjs&amp;quot;, weight: 0.6, context: &amp;quot;Reactive programming&amp;quot; },
      { name: &amp;quot;zod&amp;quot;, weight: 0.6, context: &amp;quot;Schema validation&amp;quot; },
      { name: &amp;quot;joi&amp;quot;, weight: 0.6, context: &amp;quot;Schema validation&amp;quot; },
      { name: &amp;quot;underscore&amp;quot;, weight: 0.6, context: &amp;quot;Utility library&amp;quot; },
      { name: &amp;quot;dayjs&amp;quot;, weight: 0.5, context: &amp;quot;Date library&amp;quot; },
      { name: &amp;quot;luxon&amp;quot;, weight: 0.5, context: &amp;quot;Date/time library&amp;quot; },
      { name: &amp;quot;validator&amp;quot;, weight: 0.6, context: &amp;quot;Validation library&amp;quot; },
      { name: &amp;quot;nanoid&amp;quot;, weight: 0.5, context: &amp;quot;ID generation&amp;quot; },
      { name: &amp;quot;shortid&amp;quot;, weight: 0.5, context: &amp;quot;Short ID generation&amp;quot; },
      { name: &amp;quot;slugify&amp;quot;, weight: 0.5, context: &amp;quot;URL slug generation&amp;quot; },
      { name: &amp;quot;classnames&amp;quot;, weight: 0.5, context: &amp;quot;CSS class helper&amp;quot; },
      { name: &amp;quot;clsx&amp;quot;, weight: 0.5, context: &amp;quot;CSS class helper&amp;quot; },
      { name: &amp;quot;qs&amp;quot;, weight: 0.5, context: &amp;quot;Query string parser&amp;quot; },
      { name: &amp;quot;query-string&amp;quot;, weight: 0.5, context: &amp;quot;Query string parser&amp;quot; },
      { name: &amp;quot;path-to-regexp&amp;quot;, weight: 0.5, context: &amp;quot;Path matching&amp;quot; },
      { name: &amp;quot;js-cookie&amp;quot;, weight: 0.4, context: &amp;quot;Cookie handling&amp;quot; },
      { name: &amp;quot;localforage&amp;quot;, weight: 0.4, context: &amp;quot;Storage module&amp;quot; },
      { name: &amp;quot;yup&amp;quot;, weight: 0.6, context: &amp;quot;Schema validation&amp;quot; },
    ],
    desktop_app: [
      { name: &amp;quot;electron&amp;quot;, weight: 0.9, context: &amp;quot;Desktop app framework&amp;quot; },
      { name: &amp;quot;tauri&amp;quot;, weight: 0.9, context: &amp;quot;Desktop app framework&amp;quot; },
      { name: &amp;quot;nw.js&amp;quot;, weight: 0.8, context: &amp;quot;Desktop app framework&amp;quot; },
      { name: &amp;quot;node-ffi&amp;quot;, weight: 0.6, context: &amp;quot;Native library bindings&amp;quot; },
      { name: &amp;quot;robotjs&amp;quot;, weight: 0.6, context: &amp;quot;Desktop automation&amp;quot; },
      { name: &amp;quot;electron-builder&amp;quot;, weight: 0.7, context: &amp;quot;Electron packaging&amp;quot; },
      { name: &amp;quot;electron-updater&amp;quot;, weight: 0.6, context: &amp;quot;Auto-updater for Electron&amp;quot; },
      { name: &amp;quot;menubar&amp;quot;, weight: 0.5, context: &amp;quot;Menu bar applications&amp;quot; },
      { name: &amp;quot;systray&amp;quot;, weight: 0.5, context: &amp;quot;System tray applications&amp;quot; },
      { name: &amp;quot;node-notifier&amp;quot;, weight: 0.4, context: &amp;quot;Desktop notifications&amp;quot; },
    ],
    data_processing: [
      { name: &amp;quot;cheerio&amp;quot;, weight: 0.7, context: &amp;quot;HTML parsing and manipulation&amp;quot; },
      { name: &amp;quot;csv-parser&amp;quot;, weight: 0.7, context: &amp;quot;CSV processing&amp;quot; },
      { name: &amp;quot;xml2js&amp;quot;, weight: 0.6, context: &amp;quot;XML processing&amp;quot; },
      { name: &amp;quot;sharp&amp;quot;, weight: 0.7, context: &amp;quot;Image processing&amp;quot; },
      { name: &amp;quot;jimp&amp;quot;, weight: 0.6, context: &amp;quot;Image manipulation&amp;quot; },
      { name: &amp;quot;pdf-parse&amp;quot;, weight: 0.6, context: &amp;quot;PDF processing&amp;quot; },
      { name: &amp;quot;stream-transform&amp;quot;, weight: 0.6, context: &amp;quot;Stream processing&amp;quot; },
      { name: &amp;quot;papaparse&amp;quot;, weight: 0.6, context: &amp;quot;CSV parsing&amp;quot; },
      { name: &amp;quot;fast-csv&amp;quot;, weight: 0.6, context: &amp;quot;CSV processing&amp;quot; },
      { name: &amp;quot;mammoth&amp;quot;, weight: 0.5, context: &amp;quot;Document processing&amp;quot; },
    ],
    testing: [
      { name: &amp;quot;jest&amp;quot;, weight: 0.8, context: &amp;quot;Testing framework&amp;quot; },
      { name: &amp;quot;mocha&amp;quot;, weight: 0.8, context: &amp;quot;Testing framework&amp;quot; },
      { name: &amp;quot;vitest&amp;quot;, weight: 0.8, context: &amp;quot;Testing framework&amp;quot; },
      { name: &amp;quot;cypress&amp;quot;, weight: 0.7, context: &amp;quot;E2E testing&amp;quot; },
      { name: &amp;quot;playwright&amp;quot;, weight: 0.7, context: &amp;quot;E2E testing&amp;quot; },
      { name: &amp;quot;puppeteer&amp;quot;, weight: 0.7, context: &amp;quot;Browser automation&amp;quot; },
      { name: &amp;quot;chai&amp;quot;, weight: 0.6, context: &amp;quot;Assertion library&amp;quot; },
      { name: &amp;quot;sinon&amp;quot;, weight: 0.6, context: &amp;quot;Mocking library&amp;quot; },
      { name: &amp;quot;supertest&amp;quot;, weight: 0.6, context: &amp;quot;HTTP assertion library&amp;quot; },
      { name: &amp;quot;@testing-library/react&amp;quot;, weight: 0.6, context: &amp;quot;React testing utilities&amp;quot; },
    ],
    build_tool: [
      { name: &amp;quot;webpack&amp;quot;, weight: 0.8, context: &amp;quot;Module bundler&amp;quot; },
      { name: &amp;quot;vite&amp;quot;, weight: 0.8, context: &amp;quot;Build tool&amp;quot; },
      { name: &amp;quot;rollup&amp;quot;, weight: 0.8, context: &amp;quot;Module bundler&amp;quot; },
      { name: &amp;quot;parcel&amp;quot;, weight: 0.7, context: &amp;quot;Build tool&amp;quot; },
      { name: &amp;quot;esbuild&amp;quot;, weight: 0.7, context: &amp;quot;Fast bundler&amp;quot; },
      { name: &amp;quot;babel&amp;quot;, weight: 0.6, context: &amp;quot;JavaScript compiler&amp;quot;, aliases: [&amp;quot;@babel/core&amp;quot;] },
      { name: &amp;quot;typescript&amp;quot;, weight: 0.6, context: &amp;quot;TypeScript compiler&amp;quot; },
      { name: &amp;quot;eslint&amp;quot;, weight: 0.5, context: &amp;quot;Code linter&amp;quot; },
      { name: &amp;quot;prettier&amp;quot;, weight: 0.4, context: &amp;quot;Code formatter&amp;quot; },
      { name: &amp;quot;gulp&amp;quot;, weight: 0.6, context: &amp;quot;Task runner&amp;quot; },
    ],
    game: [
      { name: &amp;quot;phaser&amp;quot;, weight: 0.9, context: &amp;quot;Game framework&amp;quot; },
      { name: &amp;quot;three&amp;quot;, weight: 0.8, context: &amp;quot;3D graphics library&amp;quot; },
      { name: &amp;quot;babylon.js&amp;quot;, weight: 0.8, context: &amp;quot;3D engine&amp;quot; },
      { name: &amp;quot;pixi.js&amp;quot;, weight: 0.7, context: &amp;quot;2D graphics library&amp;quot; },
      { name: &amp;quot;matter.js&amp;quot;, weight: 0.6, context: &amp;quot;Physics engine&amp;quot; },
      { name: &amp;quot;cannon&amp;quot;, weight: 0.6, context: &amp;quot;Physics engine&amp;quot; },
      { name: &amp;quot;howler&amp;quot;, weight: 0.5, context: &amp;quot;Audio library&amp;quot; },
      { name: &amp;quot;createjs&amp;quot;, weight: 0.5, context: &amp;quot;Interactive content creation&amp;quot; },
      { name: &amp;quot;konva&amp;quot;, weight: 0.5, context: &amp;quot;2D canvas library&amp;quot; },
      { name: &amp;quot;aframe&amp;quot;, weight: 0.6, context: &amp;quot;VR/AR framework&amp;quot; },
    ],
    mobile: [
      { name: &amp;quot;react-native&amp;quot;, weight: 0.9, context: &amp;quot;Mobile app framework&amp;quot; },
      { name: &amp;quot;expo&amp;quot;, weight: 0.8, context: &amp;quot;React Native platform&amp;quot; },
      {
        name: &amp;quot;ionic&amp;quot;,
        weight: 0.8,
        context: &amp;quot;Hybrid mobile framework&amp;quot;,
        aliases: [&amp;quot;@ionic/react&amp;quot;, &amp;quot;@ionic/angular&amp;quot;],
      },
      { name: &amp;quot;capacitor&amp;quot;, weight: 0.7, context: &amp;quot;Native bridge&amp;quot; },
      { name: &amp;quot;cordova&amp;quot;, weight: 0.6, context: &amp;quot;Mobile app platform&amp;quot; },
      { name: &amp;quot;nativescript&amp;quot;, weight: 0.7, context: &amp;quot;Mobile framework&amp;quot; },
      { name: &amp;quot;quasar&amp;quot;, weight: 0.6, context: &amp;quot;Vue-based mobile framework&amp;quot; },
      { name: &amp;quot;framework7&amp;quot;, weight: 0.6, context: &amp;quot;Mobile framework&amp;quot; },
      { name: &amp;quot;onsen&amp;quot;, weight: 0.5, context: &amp;quot;Mobile UI framework&amp;quot; },
      { name: &amp;quot;phonegap&amp;quot;, weight: 0.4, context: &amp;quot;Mobile app platform (deprecated)&amp;quot; },
    ],
  },

  typescript: {
    tool: [
      { name: &amp;quot;commander&amp;quot;, weight: 0.9, context: &amp;quot;Command-line argument parsing&amp;quot; },
      { name: &amp;quot;yargs&amp;quot;, weight: 0.9, context: &amp;quot;Command-line argument parsing&amp;quot; },
      { name: &amp;quot;inquirer&amp;quot;, weight: 0.8, context: &amp;quot;Interactive CLI prompts&amp;quot; },
      { name: &amp;quot;chalk&amp;quot;, weight: 0.7, context: &amp;quot;Terminal text styling&amp;quot; },
      { name: &amp;quot;ora&amp;quot;, weight: 0.7, context: &amp;quot;Terminal spinners&amp;quot; },
      { name: &amp;quot;boxen&amp;quot;, weight: 0.6, context: &amp;quot;Terminal boxes&amp;quot; },
      { name: &amp;quot;cli-table3&amp;quot;, weight: 0.6, context: &amp;quot;Terminal tables&amp;quot; },
      { name: &amp;quot;oclif&amp;quot;, weight: 0.8, context: &amp;quot;CLI framework&amp;quot; },
      { name: &amp;quot;clipanion&amp;quot;, weight: 0.7, context: &amp;quot;Type-safe CLI framework&amp;quot; },
      { name: &amp;quot;cac&amp;quot;, weight: 0.6, context: &amp;quot;Command and Conquer CLI framework&amp;quot; },
    ],
    web_service: [
      { name: &amp;quot;express&amp;quot;, weight: 0.9, context: &amp;quot;Web framework&amp;quot; },
      { name: &amp;quot;fastify&amp;quot;, weight: 0.9, context: &amp;quot;High-performance web framework&amp;quot; },
      { name: &amp;quot;koa&amp;quot;, weight: 0.9, context: &amp;quot;Web framework&amp;quot; },
      { name: &amp;quot;hono&amp;quot;, weight: 0.9, context: &amp;quot;Ultrafast web framework&amp;quot; },
      { name: &amp;quot;@nestjs/core&amp;quot;, weight: 0.9, context: &amp;quot;Enterprise framework&amp;quot; },
      { name: &amp;quot;hapi&amp;quot;, weight: 0.8, context: &amp;quot;Web framework&amp;quot; },
      { name: &amp;quot;apollo-server-express&amp;quot;, weight: 0.8, context: &amp;quot;GraphQL server&amp;quot; },
      { name: &amp;quot;type-graphql&amp;quot;, weight: 0.7, context: &amp;quot;GraphQL with TypeScript&amp;quot; },
      { name: &amp;quot;typeorm&amp;quot;, weight: 0.7, context: &amp;quot;ORM with TypeScript&amp;quot; },
      { name: &amp;quot;prisma&amp;quot;, weight: 0.7, context: &amp;quot;Next-generation ORM&amp;quot; },
      { name: &amp;quot;trpc&amp;quot;, weight: 0.8, context: &amp;quot;Type-safe API framework&amp;quot; },
    ],
    frontend: [
      { name: &amp;quot;react&amp;quot;, weight: 0.9, context: &amp;quot;UI library&amp;quot; },
      { name: &amp;quot;vue&amp;quot;, weight: 0.9, context: &amp;quot;UI framework&amp;quot; },
      { name: &amp;quot;@angular/core&amp;quot;, weight: 0.9, context: &amp;quot;UI framework&amp;quot; },
      { name: &amp;quot;svelte&amp;quot;, weight: 0.9, context: &amp;quot;UI framework&amp;quot; },
      { name: &amp;quot;solid-js&amp;quot;, weight: 0.8, context: &amp;quot;UI library&amp;quot; },
      { name: &amp;quot;next&amp;quot;, weight: 0.8, context: &amp;quot;React framework&amp;quot; },
      { name: &amp;quot;nuxt&amp;quot;, weight: 0.8, context: &amp;quot;Vue framework&amp;quot; },
      { name: &amp;quot;remix&amp;quot;, weight: 0.7, context: &amp;quot;Full-stack React framework&amp;quot; },
      { name: &amp;quot;gatsby&amp;quot;, weight: 0.7, context: &amp;quot;Static site generator&amp;quot; },
      { name: &amp;quot;lit&amp;quot;, weight: 0.7, context: &amp;quot;Web components library&amp;quot; },
    ],
    package: [
      { name: &amp;quot;zod&amp;quot;, weight: 0.8, context: &amp;quot;Schema validation&amp;quot; },
      { name: &amp;quot;joi&amp;quot;, weight: 0.7, context: &amp;quot;Schema validation&amp;quot; },
      { name: &amp;quot;class-validator&amp;quot;, weight: 0.7, context: &amp;quot;Decorator-based validation&amp;quot; },
      { name: &amp;quot;fp-ts&amp;quot;, weight: 0.7, context: &amp;quot;Functional programming&amp;quot; },
      { name: &amp;quot;io-ts&amp;quot;, weight: 0.6, context: &amp;quot;Runtime type checking&amp;quot; },
      { name: &amp;quot;rxjs&amp;quot;, weight: 0.7, context: &amp;quot;Reactive programming&amp;quot; },
      { name: &amp;quot;ramda&amp;quot;, weight: 0.6, context: &amp;quot;Functional utilities&amp;quot; },
      { name: &amp;quot;date-fns&amp;quot;, weight: 0.6, context: &amp;quot;Date utilities&amp;quot; },
      { name: &amp;quot;class-transformer&amp;quot;, weight: 0.6, context: &amp;quot;Object transformation&amp;quot; },
      { name: &amp;quot;reflect-metadata&amp;quot;, weight: 0.5, context: &amp;quot;Metadata reflection&amp;quot; },
    ],
    desktop_app: [
      { name: &amp;quot;electron&amp;quot;, weight: 0.9, context: &amp;quot;Desktop app framework&amp;quot; },
      { name: &amp;quot;tauri&amp;quot;, weight: 0.9, context: &amp;quot;Rust-based desktop framework&amp;quot; },
      { name: &amp;quot;@electron/remote&amp;quot;, weight: 0.7, context: &amp;quot;Electron remote module&amp;quot; },
      { name: &amp;quot;electron-builder&amp;quot;, weight: 0.7, context: &amp;quot;Electron packaging&amp;quot; },
      { name: &amp;quot;electron-updater&amp;quot;, weight: 0.6, context: &amp;quot;Auto-updater&amp;quot; },
      { name: &amp;quot;spectron&amp;quot;, weight: 0.5, context: &amp;quot;Electron testing&amp;quot; },
      { name: &amp;quot;nw.js&amp;quot;, weight: 0.7, context: &amp;quot;Desktop app framework&amp;quot; },
      { name: &amp;quot;neutralino&amp;quot;, weight: 0.6, context: &amp;quot;Lightweight desktop framework&amp;quot; },
      { name: &amp;quot;node-ffi-napi&amp;quot;, weight: 0.5, context: &amp;quot;Native bindings&amp;quot; },
      { name: &amp;quot;ref-napi&amp;quot;, weight: 0.4, context: &amp;quot;Native type handling&amp;quot; },
    ],
    data_processing: [
      { name: &amp;quot;csv-parse&amp;quot;, weight: 0.7, context: &amp;quot;CSV processing with types&amp;quot; },
      { name: &amp;quot;xml2js&amp;quot;, weight: 0.6, context: &amp;quot;XML processing&amp;quot; },
      { name: &amp;quot;sharp&amp;quot;, weight: 0.7, context: &amp;quot;Image processing&amp;quot; },
      { name: &amp;quot;pdf2pic&amp;quot;, weight: 0.6, context: &amp;quot;PDF to image conversion&amp;quot; },
      { name: &amp;quot;xlsx&amp;quot;, weight: 0.7, context: &amp;quot;Excel file processing&amp;quot; },
      { name: &amp;quot;cheerio&amp;quot;, weight: 0.6, context: &amp;quot;Server-side jQuery&amp;quot; },
      { name: &amp;quot;node-html-parser&amp;quot;, weight: 0.6, context: &amp;quot;Fast HTML parser&amp;quot; },
      { name: &amp;quot;fast-xml-parser&amp;quot;, weight: 0.6, context: &amp;quot;Fast XML parser&amp;quot; },
      { name: &amp;quot;papaparse&amp;quot;, weight: 0.5, context: &amp;quot;CSV parser&amp;quot; },
      { name: &amp;quot;jsdom&amp;quot;, weight: 0.5, context: &amp;quot;DOM implementation&amp;quot; },
    ],
    testing: [
      { name: &amp;quot;jest&amp;quot;, weight: 0.8, context: &amp;quot;Testing framework&amp;quot; },
      { name: &amp;quot;vitest&amp;quot;, weight: 0.8, context: &amp;quot;Vite-native testing&amp;quot; },
      { name: &amp;quot;playwright&amp;quot;, weight: 0.7, context: &amp;quot;E2E testing&amp;quot; },
      { name: &amp;quot;@playwright/test&amp;quot;, weight: 0.7, context: &amp;quot;Playwright test runner&amp;quot; },
      { name: &amp;quot;cypress&amp;quot;, weight: 0.7, context: &amp;quot;E2E testing&amp;quot; },
      { name: &amp;quot;@testing-library/react&amp;quot;, weight: 0.6, context: &amp;quot;React testing&amp;quot; },
      { name: &amp;quot;supertest&amp;quot;, weight: 0.6, context: &amp;quot;HTTP testing&amp;quot; },
      { name: &amp;quot;ts-jest&amp;quot;, weight: 0.6, context: &amp;quot;Jest TypeScript support&amp;quot; },
      { name: &amp;quot;@types/jest&amp;quot;, weight: 0.5, context: &amp;quot;Jest type definitions&amp;quot; },
      { name: &amp;quot;ava&amp;quot;, weight: 0.6, context: &amp;quot;Test runner&amp;quot; },
    ],
    build_tool: [
      { name: &amp;quot;typescript&amp;quot;, weight: 0.9, context: &amp;quot;TypeScript compiler&amp;quot; },
      { name: &amp;quot;vite&amp;quot;, weight: 0.8, context: &amp;quot;Build tool&amp;quot; },
      { name: &amp;quot;webpack&amp;quot;, weight: 0.7, context: &amp;quot;Module bundler&amp;quot; },
      { name: &amp;quot;rollup&amp;quot;, weight: 0.7, context: &amp;quot;Module bundler&amp;quot; },
      { name: &amp;quot;esbuild&amp;quot;, weight: 0.7, context: &amp;quot;Fast bundler&amp;quot; },
      { name: &amp;quot;tsup&amp;quot;, weight: 0.7, context: &amp;quot;TypeScript bundler&amp;quot; },
      { name: &amp;quot;microbundle&amp;quot;, weight: 0.6, context: &amp;quot;Zero-config bundler&amp;quot; },
      { name: &amp;quot;ts-node&amp;quot;, weight: 0.6, context: &amp;quot;TypeScript execution&amp;quot; },
      { name: &amp;quot;tsx&amp;quot;, weight: 0.6, context: &amp;quot;TypeScript execution&amp;quot; },
      { name: &amp;quot;tsc-watch&amp;quot;, weight: 0.5, context: &amp;quot;TypeScript watch mode&amp;quot; },
    ],
    game: [
      { name: &amp;quot;phaser&amp;quot;, weight: 0.9, context: &amp;quot;Game framework&amp;quot; },
      { name: &amp;quot;three&amp;quot;, weight: 0.8, context: &amp;quot;3D graphics&amp;quot; },
      { name: &amp;quot;@types/three&amp;quot;, weight: 0.7, context: &amp;quot;Three.js types&amp;quot; },
      { name: &amp;quot;babylon.js&amp;quot;, weight: 0.8, context: &amp;quot;3D engine&amp;quot; },
      { name: &amp;quot;pixi.js&amp;quot;, weight: 0.7, context: &amp;quot;2D graphics&amp;quot; },
      { name: &amp;quot;matter.js&amp;quot;, weight: 0.6, context: &amp;quot;Physics engine&amp;quot; },
      { name: &amp;quot;@types/matter-js&amp;quot;, weight: 0.5, context: &amp;quot;Matter.js types&amp;quot; },
      { name: &amp;quot;cannon-es&amp;quot;, weight: 0.6, context: &amp;quot;Physics engine&amp;quot; },
      { name: &amp;quot;howler&amp;quot;, weight: 0.5, context: &amp;quot;Audio library&amp;quot; },
      { name: &amp;quot;excalibur&amp;quot;, weight: 0.6, context: &amp;quot;TypeScript game engine&amp;quot; },
    ],
    mobile: [
      { name: &amp;quot;react-native&amp;quot;, weight: 0.9, context: &amp;quot;Mobile framework&amp;quot; },
      { name: &amp;quot;@react-native/metro-config&amp;quot;, weight: 0.7, context: &amp;quot;React Native config&amp;quot; },
      { name: &amp;quot;expo&amp;quot;, weight: 0.8, context: &amp;quot;React Native platform&amp;quot; },
      { name: &amp;quot;@ionic/react&amp;quot;, weight: 0.8, context: &amp;quot;Ionic React&amp;quot; },
      { name: &amp;quot;@ionic/angular&amp;quot;, weight: 0.8, context: &amp;quot;Ionic Angular&amp;quot; },
      { name: &amp;quot;@capacitor/core&amp;quot;, weight: 0.7, context: &amp;quot;Capacitor core&amp;quot; },
      { name: &amp;quot;nativescript&amp;quot;, weight: 0.7, context: &amp;quot;NativeScript&amp;quot; },
      { name: &amp;quot;@nativescript/core&amp;quot;, weight: 0.7, context: &amp;quot;NativeScript core&amp;quot; },
      { name: &amp;quot;quasar&amp;quot;, weight: 0.6, context: &amp;quot;Vue mobile framework&amp;quot; },
      { name: &amp;quot;framework7&amp;quot;, weight: 0.5, context: &amp;quot;Mobile UI framework&amp;quot; },
    ],
  },

  python: {
    tool: [
      { name: &amp;quot;click&amp;quot;, weight: 0.9, context: &amp;quot;Command-line interface creation kit&amp;quot; },
      { name: &amp;quot;argparse&amp;quot;, weight: 0.8, context: &amp;quot;Argument parsing (built-in)&amp;quot; },
      { name: &amp;quot;typer&amp;quot;, weight: 0.9, context: &amp;quot;Modern CLI framework&amp;quot; },
      { name: &amp;quot;fire&amp;quot;, weight: 0.7, context: &amp;quot;Automatic CLI generation&amp;quot; },
      { name: &amp;quot;docopt&amp;quot;, weight: 0.6, context: &amp;quot;Command-line interface from docstrings&amp;quot; },
      { name: &amp;quot;rich&amp;quot;, weight: 0.7, context: &amp;quot;Rich text and beautiful formatting&amp;quot; },
      { name: &amp;quot;colorama&amp;quot;, weight: 0.6, context: &amp;quot;Cross-platform colored terminal text&amp;quot; },
      { name: &amp;quot;tqdm&amp;quot;, weight: 0.6, context: &amp;quot;Progress bars&amp;quot; },
      { name: &amp;quot;questionary&amp;quot;, weight: 0.6, context: &amp;quot;Interactive command line prompts&amp;quot; },
      { name: &amp;quot;prompt_toolkit&amp;quot;, weight: 0.5, context: &amp;quot;Building interactive command lines&amp;quot; },
    ],
    web_service: [
      { name: &amp;quot;fastapi&amp;quot;, weight: 0.9, context: &amp;quot;Modern web framework&amp;quot; },
      { name: &amp;quot;django&amp;quot;, weight: 0.9, context: &amp;quot;High-level web framework&amp;quot; },
      { name: &amp;quot;flask&amp;quot;, weight: 0.9, context: &amp;quot;Micro web framework&amp;quot; },
      { name: &amp;quot;tornado&amp;quot;, weight: 0.7, context: &amp;quot;Asynchronous web framework&amp;quot; },
      { name: &amp;quot;sanic&amp;quot;, weight: 0.7, context: &amp;quot;Async web framework&amp;quot; },
      { name: &amp;quot;starlette&amp;quot;, weight: 0.7, context: &amp;quot;ASGI framework&amp;quot; },
      { name: &amp;quot;aiohttp&amp;quot;, weight: 0.7, context: &amp;quot;Async HTTP client/server&amp;quot; },
      { name: &amp;quot;bottle&amp;quot;, weight: 0.6, context: &amp;quot;Micro web framework&amp;quot; },
      { name: &amp;quot;falcon&amp;quot;, weight: 0.6, context: &amp;quot;Minimalist web framework&amp;quot; },
      { name: &amp;quot;pyramid&amp;quot;, weight: 0.6, context: &amp;quot;Web framework&amp;quot; },
    ],
    frontend: [
      { name: &amp;quot;streamlit&amp;quot;, weight: 0.9, context: &amp;quot;Data app framework&amp;quot; },
      { name: &amp;quot;dash&amp;quot;, weight: 0.8, context: &amp;quot;Web app framework for Python&amp;quot; },
      { name: &amp;quot;gradio&amp;quot;, weight: 0.8, context: &amp;quot;ML model interfaces&amp;quot; },
      { name: &amp;quot;panel&amp;quot;, weight: 0.7, context: &amp;quot;Data visualization apps&amp;quot; },
      { name: &amp;quot;bokeh&amp;quot;, weight: 0.7, context: &amp;quot;Interactive visualization&amp;quot; },
      { name: &amp;quot;plotly&amp;quot;, weight: 0.6, context: &amp;quot;Interactive plotting&amp;quot; },
      { name: &amp;quot;voila&amp;quot;, weight: 0.6, context: &amp;quot;Jupyter notebook as web app&amp;quot; },
      { name: &amp;quot;anvil&amp;quot;, weight: 0.5, context: &amp;quot;Web app framework&amp;quot; },
      { name: &amp;quot;nicegui&amp;quot;, weight: 0.6, context: &amp;quot;Modern web UI framework&amp;quot; },
      { name: &amp;quot;reflex&amp;quot;, weight: 0.7, context: &amp;quot;Pure Python web framework&amp;quot; },
    ],
    package: [
      { name: &amp;quot;requests&amp;quot;, weight: 0.7, context: &amp;quot;HTTP library&amp;quot; },
      { name: &amp;quot;numpy&amp;quot;, weight: 0.7, context: &amp;quot;Numerical computing&amp;quot; },
      { name: &amp;quot;pandas&amp;quot;, weight: 0.7, context: &amp;quot;Data analysis&amp;quot; },
      { name: &amp;quot;scipy&amp;quot;, weight: 0.6, context: &amp;quot;Scientific computing&amp;quot; },
      { name: &amp;quot;matplotlib&amp;quot;, weight: 0.6, context: &amp;quot;Plotting library&amp;quot; },
      { name: &amp;quot;pydantic&amp;quot;, weight: 0.7, context: &amp;quot;Data validation&amp;quot; },
      { name: &amp;quot;attrs&amp;quot;, weight: 0.5, context: &amp;quot;Classes without boilerplate&amp;quot; },
      { name: &amp;quot;httpx&amp;quot;, weight: 0.6, context: &amp;quot;HTTP client&amp;quot; },
      { name: &amp;quot;aiofiles&amp;quot;, weight: 0.5, context: &amp;quot;Async file operations&amp;quot; },
      { name: &amp;quot;python-dateutil&amp;quot;, weight: 0.5, context: &amp;quot;Date utilities&amp;quot; },
    ],
    desktop_app: [
      { name: &amp;quot;tkinter&amp;quot;, weight: 0.8, context: &amp;quot;GUI toolkit (built-in)&amp;quot; },
      { name: &amp;quot;pyqt5&amp;quot;, weight: 0.8, context: &amp;quot;Qt-based GUI toolkit&amp;quot; },
      { name: &amp;quot;pyqt6&amp;quot;, weight: 0.8, context: &amp;quot;Qt6-based GUI toolkit&amp;quot; },
      { name: &amp;quot;pyside2&amp;quot;, weight: 0.8, context: &amp;quot;Qt for Python&amp;quot; },
      { name: &amp;quot;pyside6&amp;quot;, weight: 0.8, context: &amp;quot;Qt6 for Python&amp;quot; },
      { name: &amp;quot;kivy&amp;quot;, weight: 0.7, context: &amp;quot;Multi-platform GUI framework&amp;quot; },
      { name: &amp;quot;wxpython&amp;quot;, weight: 0.6, context: &amp;quot;Native GUI toolkit&amp;quot; },
      { name: &amp;quot;toga&amp;quot;, weight: 0.6, context: &amp;quot;Native GUI toolkit&amp;quot; },
      { name: &amp;quot;flet&amp;quot;, weight: 0.7, context: &amp;quot;Flutter-based GUI&amp;quot; },
      { name: &amp;quot;customtkinter&amp;quot;, weight: 0.6, context: &amp;quot;Modern tkinter&amp;quot; },
    ],
    data_processing: [
      { name: &amp;quot;pandas&amp;quot;, weight: 0.9, context: &amp;quot;Data manipulation and analysis&amp;quot; },
      { name: &amp;quot;numpy&amp;quot;, weight: 0.8, context: &amp;quot;Numerical arrays&amp;quot; },
      { name: &amp;quot;dask&amp;quot;, weight: 0.7, context: &amp;quot;Parallel computing&amp;quot; },
      { name: &amp;quot;polars&amp;quot;, weight: 0.7, context: &amp;quot;Fast DataFrame library&amp;quot; },
      { name: &amp;quot;openpyxl&amp;quot;, weight: 0.6, context: &amp;quot;Excel file processing&amp;quot; },
      { name: &amp;quot;xlsxwriter&amp;quot;, weight: 0.5, context: &amp;quot;Excel file creation&amp;quot; },
      { name: &amp;quot;beautifulsoup4&amp;quot;, weight: 0.6, context: &amp;quot;HTML/XML parsing&amp;quot; },
      { name: &amp;quot;lxml&amp;quot;, weight: 0.6, context: &amp;quot;XML processing&amp;quot; },
      { name: &amp;quot;pyarrow&amp;quot;, weight: 0.6, context: &amp;quot;Columnar data processing&amp;quot; },
      { name: &amp;quot;h5py&amp;quot;, weight: 0.5, context: &amp;quot;HDF5 file processing&amp;quot; },
    ],
    testing: [
      { name: &amp;quot;pytest&amp;quot;, weight: 0.9, context: &amp;quot;Testing framework&amp;quot; },
      { name: &amp;quot;unittest&amp;quot;, weight: 0.7, context: &amp;quot;Testing framework (built-in)&amp;quot; },
      { name: &amp;quot;nose2&amp;quot;, weight: 0.5, context: &amp;quot;Testing framework&amp;quot; },
      { name: &amp;quot;hypothesis&amp;quot;, weight: 0.6, context: &amp;quot;Property-based testing&amp;quot; },
      { name: &amp;quot;mock&amp;quot;, weight: 0.5, context: &amp;quot;Mock object library&amp;quot; },
      { name: &amp;quot;responses&amp;quot;, weight: 0.5, context: &amp;quot;HTTP mocking&amp;quot; },
      { name: &amp;quot;factory_boy&amp;quot;, weight: 0.5, context: &amp;quot;Test data generation&amp;quot; },
      { name: &amp;quot;faker&amp;quot;, weight: 0.5, context: &amp;quot;Fake data generation&amp;quot; },
      { name: &amp;quot;selenium&amp;quot;, weight: 0.6, context: &amp;quot;Web testing&amp;quot; },
      { name: &amp;quot;playwright&amp;quot;, weight: 0.6, context: &amp;quot;Modern web testing&amp;quot; },
    ],
    build_tool: [
      { name: &amp;quot;setuptools&amp;quot;, weight: 0.7, context: &amp;quot;Package building&amp;quot; },
      { name: &amp;quot;wheel&amp;quot;, weight: 0.6, context: &amp;quot;Built distribution format&amp;quot; },
      { name: &amp;quot;build&amp;quot;, weight: 0.6, context: &amp;quot;PEP 517 build frontend&amp;quot; },
      { name: &amp;quot;poetry&amp;quot;, weight: 0.8, context: &amp;quot;Dependency management and packaging&amp;quot; },
      { name: &amp;quot;hatch&amp;quot;, weight: 0.7, context: &amp;quot;Modern project manager&amp;quot; },
      { name: &amp;quot;flit&amp;quot;, weight: 0.6, context: &amp;quot;Simple packaging tool&amp;quot; },
      { name: &amp;quot;pdm&amp;quot;, weight: 0.6, context: &amp;quot;Modern dependency manager&amp;quot; },
      { name: &amp;quot;pipenv&amp;quot;, weight: 0.5, context: &amp;quot;Package manager&amp;quot; },
      { name: &amp;quot;black&amp;quot;, weight: 0.5, context: &amp;quot;Code formatter&amp;quot; },
      { name: &amp;quot;ruff&amp;quot;, weight: 0.6, context: &amp;quot;Fast linter&amp;quot; },
    ],
    game: [
      { name: &amp;quot;pygame&amp;quot;, weight: 0.9, context: &amp;quot;Game development library&amp;quot; },
      { name: &amp;quot;arcade&amp;quot;, weight: 0.8, context: &amp;quot;Modern Python game library&amp;quot; },
      { name: &amp;quot;panda3d&amp;quot;, weight: 0.7, context: &amp;quot;3D game engine&amp;quot; },
      { name: &amp;quot;pyglet&amp;quot;, weight: 0.6, context: &amp;quot;OpenGL graphics library&amp;quot; },
      { name: &amp;quot;kivy&amp;quot;, weight: 0.6, context: &amp;quot;Multi-platform framework&amp;quot; },
      { name: &amp;quot;cocos2d&amp;quot;, weight: 0.5, context: &amp;quot;2D game framework&amp;quot; },
      { name: &amp;quot;moderngl&amp;quot;, weight: 0.5, context: &amp;quot;Modern OpenGL wrapper&amp;quot; },
      { name: &amp;quot;pymunk&amp;quot;, weight: 0.5, context: &amp;quot;Physics engine&amp;quot; },
      { name: &amp;quot;wasabi2d&amp;quot;, weight: 0.4, context: &amp;quot;Easy game development&amp;quot; },
      { name: &amp;quot;ren-py&amp;quot;, weight: 0.6, context: &amp;quot;Visual novel engine&amp;quot;, aliases: [&amp;quot;renpy&amp;quot;] },
    ],
    mobile: [
      { name: &amp;quot;kivy&amp;quot;, weight: 0.8, context: &amp;quot;Cross-platform framework&amp;quot; },
      { name: &amp;quot;kivymd&amp;quot;, weight: 0.7, context: &amp;quot;Material Design for Kivy&amp;quot; },
      { name: &amp;quot;beeware&amp;quot;, weight: 0.7, context: &amp;quot;Native app development&amp;quot; },
      { name: &amp;quot;toga&amp;quot;, weight: 0.7, context: &amp;quot;Native GUI toolkit&amp;quot; },
      { name: &amp;quot;briefcase&amp;quot;, weight: 0.6, context: &amp;quot;App packaging tool&amp;quot; },
      { name: &amp;quot;python-for-android&amp;quot;, weight: 0.6, context: &amp;quot;Android development&amp;quot; },
      { name: &amp;quot;rubicon-java&amp;quot;, weight: 0.4, context: &amp;quot;Java bridge for mobile&amp;quot; },
      { name: &amp;quot;chaquopy&amp;quot;, weight: 0.5, context: &amp;quot;Python on Android&amp;quot; },
      { name: &amp;quot;pyjnius&amp;quot;, weight: 0.4, context: &amp;quot;Python-Java bridge&amp;quot; },
      { name: &amp;quot;plyer&amp;quot;, weight: 0.4, context: &amp;quot;Platform-specific features&amp;quot; },
    ],
  },

  rust: {
    tool: [
      { name: &amp;quot;clap&amp;quot;, weight: 0.9, context: &amp;quot;Command line argument parser&amp;quot; },
      { name: &amp;quot;structopt&amp;quot;, weight: 0.8, context: &amp;quot;Derive-based CLI (deprecated, use clap)&amp;quot; },
      { name: &amp;quot;argh&amp;quot;, weight: 0.7, context: &amp;quot;Derive-based CLI&amp;quot; },
      { name: &amp;quot;gumdrop&amp;quot;, weight: 0.6, context: &amp;quot;Option parser&amp;quot; },
      { name: &amp;quot;anyhow&amp;quot;, weight: 0.7, context: &amp;quot;Error handling&amp;quot; },
      { name: &amp;quot;thiserror&amp;quot;, weight: 0.6, context: &amp;quot;Error derive macros&amp;quot; },
      { name: &amp;quot;color-eyre&amp;quot;, weight: 0.6, context: &amp;quot;Error reporting&amp;quot; },
      { name: &amp;quot;indicatif&amp;quot;, weight: 0.7, context: &amp;quot;Progress bars&amp;quot; },
      { name: &amp;quot;console&amp;quot;, weight: 0.6, context: &amp;quot;Terminal utilities&amp;quot; },
      { name: &amp;quot;dialoguer&amp;quot;, weight: 0.6, context: &amp;quot;Interactive prompts&amp;quot; },
    ],
    web_service: [
      { name: &amp;quot;axum&amp;quot;, weight: 0.9, context: &amp;quot;Modern web framework&amp;quot; },
      { name: &amp;quot;warp&amp;quot;, weight: 0.8, context: &amp;quot;Composable web framework&amp;quot; },
      { name: &amp;quot;actix-web&amp;quot;, weight: 0.8, context: &amp;quot;Actor-based web framework&amp;quot; },
      { name: &amp;quot;rocket&amp;quot;, weight: 0.8, context: &amp;quot;Type-safe web framework&amp;quot; },
      { name: &amp;quot;tide&amp;quot;, weight: 0.7, context: &amp;quot;Modular web framework&amp;quot; },
      { name: &amp;quot;hyper&amp;quot;, weight: 0.7, context: &amp;quot;HTTP implementation&amp;quot; },
      { name: &amp;quot;tower&amp;quot;, weight: 0.6, context: &amp;quot;Service trait and utilities&amp;quot; },
      { name: &amp;quot;tokio&amp;quot;, weight: 0.8, context: &amp;quot;Async runtime&amp;quot; },
      { name: &amp;quot;async-std&amp;quot;, weight: 0.6, context: &amp;quot;Async standard library&amp;quot; },
      { name: &amp;quot;sqlx&amp;quot;, weight: 0.7, context: &amp;quot;SQL database driver&amp;quot; },
    ],
    frontend: [
      { name: &amp;quot;yew&amp;quot;, weight: 0.9, context: &amp;quot;React-like framework for WebAssembly&amp;quot; },
      { name: &amp;quot;leptos&amp;quot;, weight: 0.8, context: &amp;quot;Full-stack web framework&amp;quot; },
      { name: &amp;quot;dioxus&amp;quot;, weight: 0.8, context: &amp;quot;Cross-platform GUI&amp;quot; },
      { name: &amp;quot;sycamore&amp;quot;, weight: 0.7, context: &amp;quot;Reactive web framework&amp;quot; },
      { name: &amp;quot;seed&amp;quot;, weight: 0.6, context: &amp;quot;Frontend framework&amp;quot; },
      { name: &amp;quot;wasm-bindgen&amp;quot;, weight: 0.7, context: &amp;quot;WebAssembly bindings&amp;quot; },
      { name: &amp;quot;js-sys&amp;quot;, weight: 0.6, context: &amp;quot;JavaScript API bindings&amp;quot; },
      { name: &amp;quot;web-sys&amp;quot;, weight: 0.6, context: &amp;quot;Web API bindings&amp;quot; },
      { name: &amp;quot;stdweb&amp;quot;, weight: 0.5, context: &amp;quot;Web platform (deprecated)&amp;quot; },
      { name: &amp;quot;gloo&amp;quot;, weight: 0.6, context: &amp;quot;Web development utilities&amp;quot; },
    ],
    package: [
      { name: &amp;quot;serde&amp;quot;, weight: 0.8, context: &amp;quot;Serialization framework&amp;quot; },
      { name: &amp;quot;tokio&amp;quot;, weight: 0.7, context: &amp;quot;Async runtime&amp;quot; },
      { name: &amp;quot;reqwest&amp;quot;, weight: 0.7, context: &amp;quot;HTTP client&amp;quot; },
      { name: &amp;quot;chrono&amp;quot;, weight: 0.6, context: &amp;quot;Date and time library&amp;quot; },
      { name: &amp;quot;uuid&amp;quot;, weight: 0.5, context: &amp;quot;UUID generation&amp;quot; },
      { name: &amp;quot;regex&amp;quot;, weight: 0.6, context: &amp;quot;Regular expressions&amp;quot; },
      { name: &amp;quot;log&amp;quot;, weight: 0.6, context: &amp;quot;Logging facade&amp;quot; },
      { name: &amp;quot;env_logger&amp;quot;, weight: 0.5, context: &amp;quot;Logger implementation&amp;quot; },
      { name: &amp;quot;rayon&amp;quot;, weight: 0.6, context: &amp;quot;Data parallelism&amp;quot; },
      { name: &amp;quot;itertools&amp;quot;, weight: 0.5, context: &amp;quot;Iterator utilities&amp;quot; },
    ],
    desktop_app: [
      { name: &amp;quot;tauri&amp;quot;, weight: 0.9, context: &amp;quot;Desktop app framework&amp;quot; },
      { name: &amp;quot;egui&amp;quot;, weight: 0.8, context: &amp;quot;Immediate mode GUI&amp;quot; },
      { name: &amp;quot;iced&amp;quot;, weight: 0.8, context: &amp;quot;Cross-platform GUI&amp;quot; },
      { name: &amp;quot;druid&amp;quot;, weight: 0.7, context: &amp;quot;Native GUI toolkit&amp;quot; },
      { name: &amp;quot;gtk4&amp;quot;, weight: 0.7, context: &amp;quot;GTK bindings&amp;quot; },
      { name: &amp;quot;fltk&amp;quot;, weight: 0.6, context: &amp;quot;FLTK bindings&amp;quot; },
      { name: &amp;quot;slint&amp;quot;, weight: 0.7, context: &amp;quot;Native GUI toolkit&amp;quot; },
      { name: &amp;quot;conrod&amp;quot;, weight: 0.5, context: &amp;quot;GUI library&amp;quot; },
      { name: &amp;quot;azul&amp;quot;, weight: 0.5, context: &amp;quot;Desktop app framework&amp;quot; },
      { name: &amp;quot;relm4&amp;quot;, weight: 0.6, context: &amp;quot;GTK4 GUI library&amp;quot; },
    ],
    data_processing: [
      { name: &amp;quot;polars&amp;quot;, weight: 0.8, context: &amp;quot;Fast DataFrame library&amp;quot; },
      { name: &amp;quot;csv&amp;quot;, weight: 0.7, context: &amp;quot;CSV processing&amp;quot; },
      { name: &amp;quot;serde_json&amp;quot;, weight: 0.7, context: &amp;quot;JSON processing&amp;quot; },
      { name: &amp;quot;toml&amp;quot;, weight: 0.6, context: &amp;quot;TOML parsing&amp;quot; },
      { name: &amp;quot;yaml-rust&amp;quot;, weight: 0.5, context: &amp;quot;YAML processing&amp;quot; },
      { name: &amp;quot;roxmltree&amp;quot;, weight: 0.5, context: &amp;quot;XML parsing&amp;quot; },
      { name: &amp;quot;image&amp;quot;, weight: 0.6, context: &amp;quot;Image processing&amp;quot; },
      { name: &amp;quot;calamine&amp;quot;, weight: 0.5, context: &amp;quot;Excel file reading&amp;quot; },
      { name: &amp;quot;arrow&amp;quot;, weight: 0.6, context: &amp;quot;Columnar data processing&amp;quot; },
      { name: &amp;quot;datafusion&amp;quot;, weight: 0.6, context: &amp;quot;Query engine&amp;quot; },
    ],
    testing: [
      { name: &amp;quot;criterion&amp;quot;, weight: 0.7, context: &amp;quot;Benchmarking library&amp;quot; },
      { name: &amp;quot;proptest&amp;quot;, weight: 0.6, context: &amp;quot;Property-based testing&amp;quot; },
      { name: &amp;quot;quickcheck&amp;quot;, weight: 0.5, context: &amp;quot;Property-based testing&amp;quot; },
      { name: &amp;quot;mockall&amp;quot;, weight: 0.6, context: &amp;quot;Mock generation&amp;quot; },
      { name: &amp;quot;serial_test&amp;quot;, weight: 0.5, context: &amp;quot;Serial test execution&amp;quot; },
      { name: &amp;quot;rstest&amp;quot;, weight: 0.6, context: &amp;quot;Parameterized testing&amp;quot; },
      { name: &amp;quot;pretty_assertions&amp;quot;, weight: 0.4, context: &amp;quot;Better assertion output&amp;quot; },
      { name: &amp;quot;insta&amp;quot;, weight: 0.5, context: &amp;quot;Snapshot testing&amp;quot; },
      { name: &amp;quot;wiremock&amp;quot;, weight: 0.4, context: &amp;quot;HTTP mocking&amp;quot; },
      { name: &amp;quot;assert_cmd&amp;quot;, weight: 0.5, context: &amp;quot;CLI testing&amp;quot; },
    ],
    build_tool: [
      { name: &amp;quot;cargo&amp;quot;, weight: 0.9, context: &amp;quot;Package manager and build tool&amp;quot; },
      { name: &amp;quot;cargo-watch&amp;quot;, weight: 0.6, context: &amp;quot;File watching&amp;quot; },
      { name: &amp;quot;cargo-make&amp;quot;, weight: 0.5, context: &amp;quot;Task runner&amp;quot; },
      { name: &amp;quot;cargo-edit&amp;quot;, weight: 0.5, context: &amp;quot;Dependency management&amp;quot; },
      { name: &amp;quot;cargo-outdated&amp;quot;, weight: 0.4, context: &amp;quot;Outdated dependencies check&amp;quot; },
      { name: &amp;quot;cargo-audit&amp;quot;, weight: 0.4, context: &amp;quot;Security audit&amp;quot; },
      { name: &amp;quot;cargo-deny&amp;quot;, weight: 0.4, context: &amp;quot;Cargo plugin for linting&amp;quot; },
      { name: &amp;quot;cargo-clippy&amp;quot;, weight: 0.5, context: &amp;quot;Linting tool&amp;quot; },
      { name: &amp;quot;cargo-fmt&amp;quot;, weight: 0.4, context: &amp;quot;Code formatting&amp;quot; },
      { name: &amp;quot;cross&amp;quot;, weight: 0.5, context: &amp;quot;Cross compilation&amp;quot; },
    ],
    game: [
      { name: &amp;quot;bevy&amp;quot;, weight: 0.9, context: &amp;quot;Game engine&amp;quot; },
      { name: &amp;quot;ggez&amp;quot;, weight: 0.7, context: &amp;quot;2D game framework&amp;quot; },
      { name: &amp;quot;macroquad&amp;quot;, weight: 0.7, context: &amp;quot;Simple game library&amp;quot; },
      { name: &amp;quot;bracket-lib&amp;quot;, weight: 0.6, context: &amp;quot;Roguelike toolkit&amp;quot; },
      { name: &amp;quot;piston&amp;quot;, weight: 0.6, context: &amp;quot;Game engine&amp;quot; },
      { name: &amp;quot;kiss3d&amp;quot;, weight: 0.5, context: &amp;quot;3D graphics engine&amp;quot; },
      { name: &amp;quot;coffee&amp;quot;, weight: 0.5, context: &amp;quot;2D game engine&amp;quot; },
      { name: &amp;quot;tetra&amp;quot;, weight: 0.5, context: &amp;quot;2D game framework&amp;quot; },
      { name: &amp;quot;good-web-game&amp;quot;, weight: 0.4, context: &amp;quot;Web game framework&amp;quot; },
      { name: &amp;quot;amethyst&amp;quot;, weight: 0.6, context: &amp;quot;Game engine (archived)&amp;quot; },
    ],
    mobile: [
      { name: &amp;quot;tauri&amp;quot;, weight: 0.8, context: &amp;quot;Mobile app framework&amp;quot; },
      { name: &amp;quot;dioxus&amp;quot;, weight: 0.7, context: &amp;quot;Cross-platform mobile&amp;quot; },
      { name: &amp;quot;cargo-mobile&amp;quot;, weight: 0.6, context: &amp;quot;Mobile development tools&amp;quot; },
      { name: &amp;quot;jni&amp;quot;, weight: 0.5, context: &amp;quot;Java Native Interface&amp;quot; },
      { name: &amp;quot;android-ndk&amp;quot;, weight: 0.5, context: &amp;quot;Android development&amp;quot; },
      { name: &amp;quot;winit&amp;quot;, weight: 0.4, context: &amp;quot;Window creation (mobile support)&amp;quot; },
      { name: &amp;quot;wgpu&amp;quot;, weight: 0.4, context: &amp;quot;Graphics API (mobile support)&amp;quot; },
      { name: &amp;quot;glutin&amp;quot;, weight: 0.3, context: &amp;quot;OpenGL context (mobile)&amp;quot; },
      { name: &amp;quot;ndk&amp;quot;, weight: 0.4, context: &amp;quot;Android NDK bindings&amp;quot; },
      { name: &amp;quot;mobile-entry-point&amp;quot;, weight: 0.3, context: &amp;quot;Mobile app entry point&amp;quot; },
    ],
  },

  go: {
    tool: [
      { name: &amp;quot;cobra&amp;quot;, weight: 0.9, context: &amp;quot;CLI library&amp;quot;, aliases: [&amp;quot;github.com/spf13/cobra&amp;quot;] },
      { name: &amp;quot;cli&amp;quot;, weight: 0.8, context: &amp;quot;CLI library&amp;quot;, aliases: [&amp;quot;github.com/urfave/cli&amp;quot;] },
      { name: &amp;quot;flag&amp;quot;, weight: 0.7, context: &amp;quot;Command-line flag parsing (built-in)&amp;quot; },
      {
        name: &amp;quot;pflag&amp;quot;,
        weight: 0.7,
        context: &amp;quot;POSIX/GNU-style flags&amp;quot;,
        aliases: [&amp;quot;github.com/spf13/pflag&amp;quot;],
      },
      {
        name: &amp;quot;kingpin&amp;quot;,
        weight: 0.6,
        context: &amp;quot;Command line parser&amp;quot;,
        aliases: [&amp;quot;github.com/alecthomas/kingpin&amp;quot;],
      },
      {
        name: &amp;quot;viper&amp;quot;,
        weight: 0.7,
        context: &amp;quot;Configuration management&amp;quot;,
        aliases: [&amp;quot;github.com/spf13/viper&amp;quot;],
      },
      {
        name: &amp;quot;survey&amp;quot;,
        weight: 0.6,
        context: &amp;quot;Interactive prompts&amp;quot;,
        aliases: [&amp;quot;github.com/AlecAivazis/survey&amp;quot;],
      },
      {
        name: &amp;quot;color&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Terminal colors&amp;quot;,
        aliases: [&amp;quot;github.com/fatih/color&amp;quot;],
      },
      {
        name: &amp;quot;progressbar&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Progress bars&amp;quot;,
        aliases: [&amp;quot;github.com/schollz/progressbar&amp;quot;],
      },
      {
        name: &amp;quot;spinner&amp;quot;,
        weight: 0.4,
        context: &amp;quot;Terminal spinners&amp;quot;,
        aliases: [&amp;quot;github.com/briandowns/spinner&amp;quot;],
      },
    ],
    web_service: [
      { name: &amp;quot;gin&amp;quot;, weight: 0.9, context: &amp;quot;Web framework&amp;quot;, aliases: [&amp;quot;github.com/gin-gonic/gin&amp;quot;] },
      {
        name: &amp;quot;echo&amp;quot;,
        weight: 0.8,
        context: &amp;quot;Web framework&amp;quot;,
        aliases: [&amp;quot;github.com/labstack/echo&amp;quot;],
      },
      {
        name: &amp;quot;fiber&amp;quot;,
        weight: 0.8,
        context: &amp;quot;Express-inspired web framework&amp;quot;,
        aliases: [&amp;quot;github.com/gofiber/fiber&amp;quot;],
      },
      {
        name: &amp;quot;chi&amp;quot;,
        weight: 0.7,
        context: &amp;quot;Lightweight router&amp;quot;,
        aliases: [&amp;quot;github.com/go-chi/chi&amp;quot;],
      },
      { name: &amp;quot;mux&amp;quot;, weight: 0.7, context: &amp;quot;HTTP router&amp;quot;, aliases: [&amp;quot;github.com/gorilla/mux&amp;quot;] },
      {
        name: &amp;quot;httprouter&amp;quot;,
        weight: 0.6,
        context: &amp;quot;HTTP router&amp;quot;,
        aliases: [&amp;quot;github.com/julienschmidt/httprouter&amp;quot;],
      },
      { name: &amp;quot;net/http&amp;quot;, weight: 0.8, context: &amp;quot;HTTP server (built-in)&amp;quot; },
      {
        name: &amp;quot;fasthttp&amp;quot;,
        weight: 0.6,
        context: &amp;quot;Fast HTTP package&amp;quot;,
        aliases: [&amp;quot;github.com/valyala/fasthttp&amp;quot;],
      },
      { name: &amp;quot;iris&amp;quot;, weight: 0.6, context: &amp;quot;Web framework&amp;quot;, aliases: [&amp;quot;github.com/kataras/iris&amp;quot;] },
      {
        name: &amp;quot;revel&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Full-stack framework&amp;quot;,
        aliases: [&amp;quot;github.com/revel/revel&amp;quot;],
      },
    ],
    frontend: [
      { name: &amp;quot;templ&amp;quot;, weight: 0.8, context: &amp;quot;HTML templating&amp;quot;, aliases: [&amp;quot;github.com/a-h/templ&amp;quot;] },
      { name: &amp;quot;html/template&amp;quot;, weight: 0.7, context: &amp;quot;HTML templates (built-in)&amp;quot; },
      { name: &amp;quot;text/template&amp;quot;, weight: 0.6, context: &amp;quot;Text templates (built-in)&amp;quot; },
      {
        name: &amp;quot;goview&amp;quot;,
        weight: 0.6,
        context: &amp;quot;Template engine&amp;quot;,
        aliases: [&amp;quot;github.com/foolin/goview&amp;quot;],
      },
      {
        name: &amp;quot;pongo2&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Django-like templates&amp;quot;,
        aliases: [&amp;quot;github.com/flosch/pongo2&amp;quot;],
      },
      {
        name: &amp;quot;jet&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Template engine&amp;quot;,
        aliases: [&amp;quot;github.com/CloudyKit/jet&amp;quot;],
      },
      {
        name: &amp;quot;htmx&amp;quot;,
        weight: 0.6,
        context: &amp;quot;HTMX integration&amp;quot;,
        aliases: [&amp;quot;github.com/bigskysoftware/htmx&amp;quot;],
      },
      {
        name: &amp;quot;vecty&amp;quot;,
        weight: 0.5,
        context: &amp;quot;React-like framework&amp;quot;,
        aliases: [&amp;quot;github.com/gopherjs/vecty&amp;quot;],
      },
      {
        name: &amp;quot;vugu&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Vue.js-inspired framework&amp;quot;,
        aliases: [&amp;quot;github.com/vugu/vugu&amp;quot;],
      },
      { name: &amp;quot;tview&amp;quot;, weight: 0.4, context: &amp;quot;Terminal UI&amp;quot;, aliases: [&amp;quot;github.com/rivo/tview&amp;quot;] },
    ],
    package: [
      {
        name: &amp;quot;logrus&amp;quot;,
        weight: 0.7,
        context: &amp;quot;Structured logging&amp;quot;,
        aliases: [&amp;quot;github.com/sirupsen/logrus&amp;quot;],
      },
      { name: &amp;quot;zap&amp;quot;, weight: 0.7, context: &amp;quot;Fast logging&amp;quot;, aliases: [&amp;quot;go.uber.org/zap&amp;quot;] },
      {
        name: &amp;quot;uuid&amp;quot;,
        weight: 0.6,
        context: &amp;quot;UUID generation&amp;quot;,
        aliases: [&amp;quot;github.com/google/uuid&amp;quot;],
      },
      {
        name: &amp;quot;jwt-go&amp;quot;,
        weight: 0.6,
        context: &amp;quot;JWT implementation&amp;quot;,
        aliases: [&amp;quot;github.com/golang-jwt/jwt&amp;quot;],
      },
      {
        name: &amp;quot;bcrypt&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Password hashing&amp;quot;,
        aliases: [&amp;quot;golang.org/x/crypto/bcrypt&amp;quot;],
      },
      {
        name: &amp;quot;validator&amp;quot;,
        weight: 0.6,
        context: &amp;quot;Struct validation&amp;quot;,
        aliases: [&amp;quot;github.com/go-playground/validator&amp;quot;],
      },
      { name: &amp;quot;cast&amp;quot;, weight: 0.5, context: &amp;quot;Type conversion&amp;quot;, aliases: [&amp;quot;github.com/spf13/cast&amp;quot;] },
      {
        name: &amp;quot;mapstructure&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Struct mapping&amp;quot;,
        aliases: [&amp;quot;github.com/mitchellh/mapstructure&amp;quot;],
      },
      {
        name: &amp;quot;copier&amp;quot;,
        weight: 0.4,
        context: &amp;quot;Struct copying&amp;quot;,
        aliases: [&amp;quot;github.com/jinzhu/copier&amp;quot;],
      },
      {
        name: &amp;quot;decimal&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Decimal numbers&amp;quot;,
        aliases: [&amp;quot;github.com/shopspring/decimal&amp;quot;],
      },
    ],
    desktop_app: [
      { name: &amp;quot;fyne&amp;quot;, weight: 0.9, context: &amp;quot;Cross-platform GUI&amp;quot;, aliases: [&amp;quot;fyne.io/fyne/v2&amp;quot;] },
      { name: &amp;quot;walk&amp;quot;, weight: 0.7, context: &amp;quot;Windows GUI&amp;quot;, aliases: [&amp;quot;github.com/lxn/walk&amp;quot;] },
      { name: &amp;quot;gtk&amp;quot;, weight: 0.6, context: &amp;quot;GTK bindings&amp;quot;, aliases: [&amp;quot;github.com/gotk3/gotk3&amp;quot;] },
      { name: &amp;quot;ui&amp;quot;, weight: 0.6, context: &amp;quot;Native GUI&amp;quot;, aliases: [&amp;quot;github.com/andlabs/ui&amp;quot;] },
      { name: &amp;quot;qt&amp;quot;, weight: 0.5, context: &amp;quot;Qt bindings&amp;quot;, aliases: [&amp;quot;github.com/therecipe/qt&amp;quot;] },
      {
        name: &amp;quot;systray&amp;quot;,
        weight: 0.5,
        context: &amp;quot;System tray&amp;quot;,
        aliases: [&amp;quot;github.com/getlantern/systray&amp;quot;],
      },
      {
        name: &amp;quot;webview&amp;quot;,
        weight: 0.6,
        context: &amp;quot;WebView wrapper&amp;quot;,
        aliases: [&amp;quot;github.com/webview/webview&amp;quot;],
      },
      {
        name: &amp;quot;wails&amp;quot;,
        weight: 0.7,
        context: &amp;quot;Desktop app framework&amp;quot;,
        aliases: [&amp;quot;github.com/wailsapp/wails&amp;quot;],
      },
      { name: &amp;quot;gio&amp;quot;, weight: 0.6, context: &amp;quot;Immediate mode GUI&amp;quot;, aliases: [&amp;quot;gioui.org&amp;quot;] },
      {
        name: &amp;quot;nucular&amp;quot;,
        weight: 0.4,
        context: &amp;quot;Immediate mode GUI&amp;quot;,
        aliases: [&amp;quot;github.com/aarzilli/nucular&amp;quot;],
      },
    ],
    data_processing: [
      { name: &amp;quot;csv&amp;quot;, weight: 0.7, context: &amp;quot;CSV processing (built-in)&amp;quot;, aliases: [&amp;quot;encoding/csv&amp;quot;] },
      {
        name: &amp;quot;json&amp;quot;,
        weight: 0.8,
        context: &amp;quot;JSON processing (built-in)&amp;quot;,
        aliases: [&amp;quot;encoding/json&amp;quot;],
      },
      { name: &amp;quot;xml&amp;quot;, weight: 0.6, context: &amp;quot;XML processing (built-in)&amp;quot;, aliases: [&amp;quot;encoding/xml&amp;quot;] },
      { name: &amp;quot;yaml&amp;quot;, weight: 0.6, context: &amp;quot;YAML processing&amp;quot;, aliases: [&amp;quot;gopkg.in/yaml.v3&amp;quot;] },
      {
        name: &amp;quot;excelize&amp;quot;,
        weight: 0.6,
        context: &amp;quot;Excel file processing&amp;quot;,
        aliases: [&amp;quot;github.com/xuri/excelize&amp;quot;],
      },
      {
        name: &amp;quot;goquery&amp;quot;,
        weight: 0.6,
        context: &amp;quot;jQuery-like HTML parsing&amp;quot;,
        aliases: [&amp;quot;github.com/PuerkitoBio/goquery&amp;quot;],
      },
      {
        name: &amp;quot;colly&amp;quot;,
        weight: 0.6,
        context: &amp;quot;Web scraping&amp;quot;,
        aliases: [&amp;quot;github.com/gocolly/colly&amp;quot;],
      },
      {
        name: &amp;quot;imaging&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Image processing&amp;quot;,
        aliases: [&amp;quot;github.com/disintegration/imaging&amp;quot;],
      },
      {
        name: &amp;quot;gjson&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Fast JSON parsing&amp;quot;,
        aliases: [&amp;quot;github.com/tidwall/gjson&amp;quot;],
      },
      {
        name: &amp;quot;arrow&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Columnar data&amp;quot;,
        aliases: [&amp;quot;github.com/apache/arrow/go&amp;quot;],
      },
    ],
    testing: [
      { name: &amp;quot;testing&amp;quot;, weight: 0.9, context: &amp;quot;Testing framework (built-in)&amp;quot; },
      {
        name: &amp;quot;testify&amp;quot;,
        weight: 0.8,
        context: &amp;quot;Testing toolkit&amp;quot;,
        aliases: [&amp;quot;github.com/stretchr/testify&amp;quot;],
      },
      {
        name: &amp;quot;ginkgo&amp;quot;,
        weight: 0.7,
        context: &amp;quot;BDD testing framework&amp;quot;,
        aliases: [&amp;quot;github.com/onsi/ginkgo&amp;quot;],
      },
      {
        name: &amp;quot;gomega&amp;quot;,
        weight: 0.6,
        context: &amp;quot;Matcher library&amp;quot;,
        aliases: [&amp;quot;github.com/onsi/gomega&amp;quot;],
      },
      {
        name: &amp;quot;httptest&amp;quot;,
        weight: 0.6,
        context: &amp;quot;HTTP testing (built-in)&amp;quot;,
        aliases: [&amp;quot;net/http/httptest&amp;quot;],
      },
      {
        name: &amp;quot;mock&amp;quot;,
        weight: 0.6,
        context: &amp;quot;Mock generation&amp;quot;,
        aliases: [&amp;quot;github.com/golang/mock&amp;quot;],
      },
      {
        name: &amp;quot;testcontainers&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Integration testing&amp;quot;,
        aliases: [&amp;quot;github.com/testcontainers/testcontainers-go&amp;quot;],
      },
      {
        name: &amp;quot;dockertest&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Docker testing&amp;quot;,
        aliases: [&amp;quot;github.com/ory/dockertest&amp;quot;],
      },
      {
        name: &amp;quot;counterfeiter&amp;quot;,
        weight: 0.4,
        context: &amp;quot;Fake generation&amp;quot;,
        aliases: [&amp;quot;github.com/maxbrunsfeld/counterfeiter&amp;quot;],
      },
      {
        name: &amp;quot;goconvey&amp;quot;,
        weight: 0.5,
        context: &amp;quot;BDD testing&amp;quot;,
        aliases: [&amp;quot;github.com/smartystreets/goconvey&amp;quot;],
      },
    ],
    build_tool: [
      { name: &amp;quot;go&amp;quot;, weight: 0.9, context: &amp;quot;Go toolchain (built-in)&amp;quot; },
      { name: &amp;quot;make&amp;quot;, weight: 0.6, context: &amp;quot;Build automation&amp;quot; },
      { name: &amp;quot;task&amp;quot;, weight: 0.6, context: &amp;quot;Task runner&amp;quot;, aliases: [&amp;quot;github.com/go-task/task&amp;quot;] },
      { name: &amp;quot;mage&amp;quot;, weight: 0.5, context: &amp;quot;Build tool&amp;quot;, aliases: [&amp;quot;github.com/magefile/mage&amp;quot;] },
      {
        name: &amp;quot;goreleaser&amp;quot;,
        weight: 0.6,
        context: &amp;quot;Release automation&amp;quot;,
        aliases: [&amp;quot;github.com/goreleaser/goreleaser&amp;quot;],
      },
      { name: &amp;quot;golangci-lint&amp;quot;, weight: 0.5, context: &amp;quot;Linter runner&amp;quot; },
      { name: &amp;quot;gofmt&amp;quot;, weight: 0.4, context: &amp;quot;Code formatter (built-in)&amp;quot; },
      {
        name: &amp;quot;goimports&amp;quot;,
        weight: 0.4,
        context: &amp;quot;Import management&amp;quot;,
        aliases: [&amp;quot;golang.org/x/tools/cmd/goimports&amp;quot;],
      },
      {
        name: &amp;quot;wire&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Dependency injection&amp;quot;,
        aliases: [&amp;quot;github.com/google/wire&amp;quot;],
      },
      { name: &amp;quot;dep&amp;quot;, weight: 0.3, context: &amp;quot;Dependency manager (deprecated)&amp;quot; },
    ],
    game: [
      {
        name: &amp;quot;ebiten&amp;quot;,
        weight: 0.9,
        context: &amp;quot;2D game library&amp;quot;,
        aliases: [&amp;quot;github.com/hajimehoshi/ebiten&amp;quot;],
      },
      {
        name: &amp;quot;pixel&amp;quot;,
        weight: 0.7,
        context: &amp;quot;2D game library&amp;quot;,
        aliases: [&amp;quot;github.com/faiface/pixel&amp;quot;],
      },
      {
        name: &amp;quot;raylib-go&amp;quot;,
        weight: 0.6,
        context: &amp;quot;Raylib bindings&amp;quot;,
        aliases: [&amp;quot;github.com/gen2brain/raylib-go&amp;quot;],
      },
      { name: &amp;quot;oak&amp;quot;, weight: 0.6, context: &amp;quot;Game engine&amp;quot;, aliases: [&amp;quot;github.com/oakmound/oak&amp;quot;] },
      {
        name: &amp;quot;engo&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Entity Component System&amp;quot;,
        aliases: [&amp;quot;github.com/EngoEngine/engo&amp;quot;],
      },
      { name: &amp;quot;g3n&amp;quot;, weight: 0.5, context: &amp;quot;3D game engine&amp;quot;, aliases: [&amp;quot;github.com/g3n/engine&amp;quot;] },
      {
        name: &amp;quot;nano&amp;quot;,
        weight: 0.4,
        context: &amp;quot;Lightweight game server&amp;quot;,
        aliases: [&amp;quot;github.com/lonng/nano&amp;quot;],
      },
      {
        name: &amp;quot;leaf&amp;quot;,
        weight: 0.4,
        context: &amp;quot;Game server framework&amp;quot;,
        aliases: [&amp;quot;github.com/name5566/leaf&amp;quot;],
      },
      {
        name: &amp;quot;termloop&amp;quot;,
        weight: 0.3,
        context: &amp;quot;Terminal-based games&amp;quot;,
        aliases: [&amp;quot;github.com/JoelOtter/termloop&amp;quot;],
      },
      {
        name: &amp;quot;goworld&amp;quot;,
        weight: 0.4,
        context: &amp;quot;Game server engine&amp;quot;,
        aliases: [&amp;quot;github.com/xiaonanln/goworld&amp;quot;],
      },
    ],
    mobile: [
      {
        name: &amp;quot;gomobile&amp;quot;,
        weight: 0.8,
        context: &amp;quot;Mobile app development&amp;quot;,
        aliases: [&amp;quot;golang.org/x/mobile&amp;quot;],
      },
      { name: &amp;quot;fyne&amp;quot;, weight: 0.7, context: &amp;quot;Cross-platform mobile&amp;quot;, aliases: [&amp;quot;fyne.io/fyne/v2&amp;quot;] },
      { name: &amp;quot;gio&amp;quot;, weight: 0.6, context: &amp;quot;Mobile GUI&amp;quot;, aliases: [&amp;quot;gioui.org&amp;quot;] },
      {
        name: &amp;quot;mobile&amp;quot;,
        weight: 0.6,
        context: &amp;quot;Mobile package (built-in)&amp;quot;,
        aliases: [&amp;quot;golang.org/x/mobile/app&amp;quot;],
      },
      {
        name: &amp;quot;gl&amp;quot;,
        weight: 0.4,
        context: &amp;quot;OpenGL ES bindings&amp;quot;,
        aliases: [&amp;quot;golang.org/x/mobile/gl&amp;quot;],
      },
      {
        name: &amp;quot;sensor&amp;quot;,
        weight: 0.3,
        context: &amp;quot;Mobile sensors&amp;quot;,
        aliases: [&amp;quot;golang.org/x/mobile/sensor&amp;quot;],
      },
      {
        name: &amp;quot;bind&amp;quot;,
        weight: 0.3,
        context: &amp;quot;Language binding&amp;quot;,
        aliases: [&amp;quot;golang.org/x/mobile/bind&amp;quot;],
      },
      { name: &amp;quot;wails&amp;quot;, weight: 0.5, context: &amp;quot;Mobile support in desktop framework&amp;quot; },
      { name: &amp;quot;nativescript&amp;quot;, weight: 0.3, context: &amp;quot;NativeScript with Go backend&amp;quot; },
      { name: &amp;quot;flutter&amp;quot;, weight: 0.3, context: &amp;quot;Flutter with Go backend&amp;quot; },
    ],
  },

  csharp: {
    tool: [
      { name: &amp;quot;CommandLineParser&amp;quot;, weight: 0.8, context: &amp;quot;Command line parsing&amp;quot; },
      { name: &amp;quot;System.CommandLine&amp;quot;, weight: 0.9, context: &amp;quot;Microsoft&amp;#39;s CLI library&amp;quot; },
      { name: &amp;quot;McMaster.Extensions.CommandLineUtils&amp;quot;, weight: 0.7, context: &amp;quot;CLI utilities&amp;quot; },
      { name: &amp;quot;Spectre.Console&amp;quot;, weight: 0.8, context: &amp;quot;Rich console applications&amp;quot; },
      { name: &amp;quot;ConsoleTables&amp;quot;, weight: 0.5, context: &amp;quot;Console table formatting&amp;quot; },
      { name: &amp;quot;Colorful.Console&amp;quot;, weight: 0.5, context: &amp;quot;Colored console output&amp;quot; },
      { name: &amp;quot;ShellProgressBar&amp;quot;, weight: 0.5, context: &amp;quot;Progress bars&amp;quot; },
      { name: &amp;quot;Inquirer.cs&amp;quot;, weight: 0.6, context: &amp;quot;Interactive prompts&amp;quot; },
      { name: &amp;quot;Figgle&amp;quot;, weight: 0.4, context: &amp;quot;ASCII art text&amp;quot; },
      { name: &amp;quot;Kurukuru&amp;quot;, weight: 0.4, context: &amp;quot;Console spinners&amp;quot; },
    ],
    web_service: [
      { name: &amp;quot;Microsoft.AspNetCore&amp;quot;, weight: 0.9, context: &amp;quot;ASP.NET Core web framework&amp;quot; },
      { name: &amp;quot;Carter&amp;quot;, weight: 0.7, context: &amp;quot;Minimal web framework&amp;quot; },
      { name: &amp;quot;Nancy&amp;quot;, weight: 0.6, context: &amp;quot;Lightweight web framework&amp;quot; },
      { name: &amp;quot;ServiceStack&amp;quot;, weight: 0.7, context: &amp;quot;Web services framework&amp;quot; },
      { name: &amp;quot;FastEndpoints&amp;quot;, weight: 0.6, context: &amp;quot;Fast web API framework&amp;quot; },
      { name: &amp;quot;Swashbuckle.AspNetCore&amp;quot;, weight: 0.6, context: &amp;quot;Swagger/OpenAPI&amp;quot; },
      { name: &amp;quot;MediatR&amp;quot;, weight: 0.6, context: &amp;quot;Mediator pattern implementation&amp;quot; },
      { name: &amp;quot;Serilog&amp;quot;, weight: 0.5, context: &amp;quot;Structured logging&amp;quot; },
      { name: &amp;quot;FluentValidation&amp;quot;, weight: 0.5, context: &amp;quot;Validation library&amp;quot; },
      { name: &amp;quot;AutoMapper&amp;quot;, weight: 0.5, context: &amp;quot;Object mapping&amp;quot; },
    ],
    frontend: [
      {
        name: &amp;quot;Blazor&amp;quot;,
        weight: 0.9,
        context: &amp;quot;Web UI framework&amp;quot;,
        aliases: [&amp;quot;Microsoft.AspNetCore.Blazor&amp;quot;],
      },
      { name: &amp;quot;MudBlazor&amp;quot;, weight: 0.7, context: &amp;quot;Blazor component library&amp;quot; },
      { name: &amp;quot;Radzen.Blazor&amp;quot;, weight: 0.6, context: &amp;quot;Blazor components&amp;quot; },
      { name: &amp;quot;MatBlazor&amp;quot;, weight: 0.5, context: &amp;quot;Material Design for Blazor&amp;quot; },
      { name: &amp;quot;Blazorise&amp;quot;, weight: 0.5, context: &amp;quot;Bootstrap Blazor components&amp;quot; },
      { name: &amp;quot;MAUI&amp;quot;, weight: 0.8, context: &amp;quot;Multi-platform app UI&amp;quot;, aliases: [&amp;quot;Microsoft.Maui&amp;quot;] },
      { name: &amp;quot;Avalonia&amp;quot;, weight: 0.8, context: &amp;quot;Cross-platform XAML UI&amp;quot; },
      { name: &amp;quot;Uno Platform&amp;quot;, weight: 0.7, context: &amp;quot;Cross-platform UI&amp;quot; },
      { name: &amp;quot;ElectronNET&amp;quot;, weight: 0.6, context: &amp;quot;Electron wrapper for .NET&amp;quot; },
      { name: &amp;quot;Photino&amp;quot;, weight: 0.5, context: &amp;quot;Lightweight desktop framework&amp;quot; },
    ],
    package: [
      { name: &amp;quot;Newtonsoft.Json&amp;quot;, weight: 0.8, context: &amp;quot;JSON serialization&amp;quot; },
      { name: &amp;quot;System.Text.Json&amp;quot;, weight: 0.7, context: &amp;quot;JSON serialization (built-in)&amp;quot; },
      { name: &amp;quot;RestSharp&amp;quot;, weight: 0.6, context: &amp;quot;REST client library&amp;quot; },
      { name: &amp;quot;HttpClient&amp;quot;, weight: 0.7, context: &amp;quot;HTTP client (built-in)&amp;quot; },
      { name: &amp;quot;Dapper&amp;quot;, weight: 0.6, context: &amp;quot;Micro ORM&amp;quot; },
      { name: &amp;quot;NodaTime&amp;quot;, weight: 0.5, context: &amp;quot;Date and time API&amp;quot; },
      { name: &amp;quot;MoreLINQ&amp;quot;, weight: 0.5, context: &amp;quot;LINQ extensions&amp;quot; },
      { name: &amp;quot;Polly&amp;quot;, weight: 0.6, context: &amp;quot;Resilience and transient-fault-handling&amp;quot; },
      { name: &amp;quot;CsvHelper&amp;quot;, weight: 0.5, context: &amp;quot;CSV processing&amp;quot; },
      { name: &amp;quot;FluentAssertions&amp;quot;, weight: 0.5, context: &amp;quot;Fluent assertion framework&amp;quot; },
    ],
    desktop_app: [
      {
        name: &amp;quot;WPF&amp;quot;,
        weight: 0.8,
        context: &amp;quot;Windows Presentation Foundation&amp;quot;,
        aliases: [&amp;quot;Microsoft.WindowsDesktop.App&amp;quot;],
      },
      {
        name: &amp;quot;WinForms&amp;quot;,
        weight: 0.7,
        context: &amp;quot;Windows Forms&amp;quot;,
        aliases: [&amp;quot;System.Windows.Forms&amp;quot;],
      },
      { name: &amp;quot;Avalonia&amp;quot;, weight: 0.8, context: &amp;quot;Cross-platform XAML UI framework&amp;quot; },
      { name: &amp;quot;MAUI&amp;quot;, weight: 0.8, context: &amp;quot;Multi-platform App UI&amp;quot;, aliases: [&amp;quot;Microsoft.Maui&amp;quot;] },
      { name: &amp;quot;Uno Platform&amp;quot;, weight: 0.7, context: &amp;quot;Cross-platform UI platform&amp;quot; },
      { name: &amp;quot;Eto.Forms&amp;quot;, weight: 0.6, context: &amp;quot;Cross-platform GUI framework&amp;quot; },
      { name: &amp;quot;GTK#&amp;quot;, weight: 0.5, context: &amp;quot;GTK bindings for .NET&amp;quot; },
      { name: &amp;quot;MonoMac&amp;quot;, weight: 0.4, context: &amp;quot;macOS app development&amp;quot; },
      { name: &amp;quot;Xamarin.Mac&amp;quot;, weight: 0.5, context: &amp;quot;macOS development&amp;quot; },
      { name: &amp;quot;ElectronNET&amp;quot;, weight: 0.6, context: &amp;quot;Electron for .NET&amp;quot; },
    ],
    data_processing: [
      { name: &amp;quot;CsvHelper&amp;quot;, weight: 0.7, context: &amp;quot;CSV reading and writing&amp;quot; },
      { name: &amp;quot;ExcelDataReader&amp;quot;, weight: 0.6, context: &amp;quot;Excel file reading&amp;quot; },
      { name: &amp;quot;EPPlus&amp;quot;, weight: 0.7, context: &amp;quot;Excel file manipulation&amp;quot; },
      { name: &amp;quot;ClosedXML&amp;quot;, weight: 0.6, context: &amp;quot;Excel file manipulation&amp;quot; },
      { name: &amp;quot;HtmlAgilityPack&amp;quot;, weight: 0.6, context: &amp;quot;HTML parsing&amp;quot; },
      { name: &amp;quot;AngleSharp&amp;quot;, weight: 0.5, context: &amp;quot;HTML/CSS/SVG parsing&amp;quot; },
      { name: &amp;quot;YamlDotNet&amp;quot;, weight: 0.5, context: &amp;quot;YAML processing&amp;quot; },
      { name: &amp;quot;iTextSharp&amp;quot;, weight: 0.5, context: &amp;quot;PDF manipulation&amp;quot; },
      { name: &amp;quot;ImageSharp&amp;quot;, weight: 0.6, context: &amp;quot;Image processing&amp;quot; },
      { name: &amp;quot;System.Drawing&amp;quot;, weight: 0.5, context: &amp;quot;Image processing (built-in)&amp;quot; },
    ],
    testing: [
      { name: &amp;quot;xUnit&amp;quot;, weight: 0.8, context: &amp;quot;Testing framework&amp;quot;, aliases: [&amp;quot;xunit&amp;quot;] },
      { name: &amp;quot;NUnit&amp;quot;, weight: 0.7, context: &amp;quot;Testing framework&amp;quot; },
      { name: &amp;quot;MSTest&amp;quot;, weight: 0.6, context: &amp;quot;Microsoft testing framework&amp;quot; },
      { name: &amp;quot;Moq&amp;quot;, weight: 0.7, context: &amp;quot;Mocking framework&amp;quot; },
      { name: &amp;quot;NSubstitute&amp;quot;, weight: 0.6, context: &amp;quot;Mocking framework&amp;quot; },
      { name: &amp;quot;AutoFixture&amp;quot;, weight: 0.5, context: &amp;quot;Test data generation&amp;quot; },
      { name: &amp;quot;FluentAssertions&amp;quot;, weight: 0.6, context: &amp;quot;Assertion library&amp;quot; },
      { name: &amp;quot;Bogus&amp;quot;, weight: 0.5, context: &amp;quot;Fake data generation&amp;quot; },
      { name: &amp;quot;Selenium&amp;quot;, weight: 0.6, context: &amp;quot;Web testing&amp;quot;, aliases: [&amp;quot;Selenium.WebDriver&amp;quot;] },
      { name: &amp;quot;Playwright&amp;quot;, weight: 0.6, context: &amp;quot;Modern web testing&amp;quot; },
    ],
    build_tool: [
      { name: &amp;quot;MSBuild&amp;quot;, weight: 0.9, context: &amp;quot;Build platform&amp;quot; },
      { name: &amp;quot;dotnet&amp;quot;, weight: 0.9, context: &amp;quot;.NET CLI&amp;quot; },
      { name: &amp;quot;NUKE&amp;quot;, weight: 0.6, context: &amp;quot;Build automation&amp;quot; },
      { name: &amp;quot;Cake&amp;quot;, weight: 0.6, context: &amp;quot;Build automation&amp;quot; },
      { name: &amp;quot;FAKE&amp;quot;, weight: 0.5, context: &amp;quot;F# build automation&amp;quot; },
      { name: &amp;quot;psake&amp;quot;, weight: 0.4, context: &amp;quot;PowerShell build automation&amp;quot; },
      { name: &amp;quot;Paket&amp;quot;, weight: 0.4, context: &amp;quot;Dependency manager&amp;quot; },
      { name: &amp;quot;GitVersion&amp;quot;, weight: 0.4, context: &amp;quot;Semantic versioning&amp;quot; },
      { name: &amp;quot;BenchmarkDotNet&amp;quot;, weight: 0.5, context: &amp;quot;Benchmarking library&amp;quot; },
      { name: &amp;quot;StyleCop&amp;quot;, weight: 0.3, context: &amp;quot;Code analysis&amp;quot; },
    ],
    game: [
      { name: &amp;quot;Unity&amp;quot;, weight: 0.9, context: &amp;quot;Game engine&amp;quot; },
      { name: &amp;quot;MonoGame&amp;quot;, weight: 0.8, context: &amp;quot;Cross-platform game framework&amp;quot; },
      { name: &amp;quot;Godot&amp;quot;, weight: 0.7, context: &amp;quot;Game engine with C# support&amp;quot; },
      { name: &amp;quot;Wave Engine&amp;quot;, weight: 0.6, context: &amp;quot;Cross-platform game engine&amp;quot; },
      { name: &amp;quot;FlatRedBall&amp;quot;, weight: 0.5, context: &amp;quot;2D game engine&amp;quot; },
      { name: &amp;quot;Stride&amp;quot;, weight: 0.6, context: &amp;quot;Open-source C# game engine&amp;quot; },
      { name: &amp;quot;Duality&amp;quot;, weight: 0.4, context: &amp;quot;2D game development framework&amp;quot; },
      { name: &amp;quot;Delta Engine&amp;quot;, weight: 0.3, context: &amp;quot;Cross-platform game engine&amp;quot; },
      { name: &amp;quot;ANX.Framework&amp;quot;, weight: 0.3, context: &amp;quot;XNA-like framework&amp;quot; },
      { name: &amp;quot;RLNET&amp;quot;, weight: 0.3, context: &amp;quot;Roguelike development library&amp;quot; },
    ],
    mobile: [
      { name: &amp;quot;Xamarin&amp;quot;, weight: 0.8, context: &amp;quot;Cross-platform mobile development&amp;quot; },
      { name: &amp;quot;MAUI&amp;quot;, weight: 0.9, context: &amp;quot;Multi-platform App UI&amp;quot;, aliases: [&amp;quot;Microsoft.Maui&amp;quot;] },
      { name: &amp;quot;Uno Platform&amp;quot;, weight: 0.7, context: &amp;quot;Cross-platform development&amp;quot; },
      { name: &amp;quot;Avalonia&amp;quot;, weight: 0.6, context: &amp;quot;Cross-platform UI (mobile support)&amp;quot; },
      { name: &amp;quot;Xamarin.Forms&amp;quot;, weight: 0.7, context: &amp;quot;Cross-platform UI toolkit&amp;quot; },
      { name: &amp;quot;Xamarin.iOS&amp;quot;, weight: 0.6, context: &amp;quot;iOS development&amp;quot; },
      { name: &amp;quot;Xamarin.Android&amp;quot;, weight: 0.6, context: &amp;quot;Android development&amp;quot; },
      { name: &amp;quot;Tizen.NET&amp;quot;, weight: 0.4, context: &amp;quot;Tizen platform development&amp;quot; },
      {
        name: &amp;quot;Essentials&amp;quot;,
        weight: 0.5,
        context: &amp;quot;Cross-platform APIs&amp;quot;,
        aliases: [&amp;quot;Xamarin.Essentials&amp;quot;],
      },
      { name: &amp;quot;ReactiveUI&amp;quot;, weight: 0.5, context: &amp;quot;MVVM framework for mobile&amp;quot; },
    ],
  },
};

/**
 * Calculate confidence score for artifact type based on dependencies
 */
export function calculateCategoryConfidence(
  dependencies: string[],
  language: string,
  category: keyof CategoryMatrix,
): number {
  const languageMatrix &#x3D; DEPENDENCY_MATRIX[language];
  if (!languageMatrix) return 0;

  const categoryPatterns &#x3D; languageMatrix[category];
  if (!categoryPatterns) return 0;

  let matchedWeight &#x3D; 0;
  let maxPossibleWeight &#x3D; 0;

  for (const pattern of categoryPatterns) {
    // Check if dependency matches pattern name or aliases
    const isMatch &#x3D; dependencies.some((dep) &#x3D;&amp;gt; {
      if (dep &#x3D;&#x3D;&#x3D; pattern.name) return true;
      if (pattern.aliases?.some((alias) &#x3D;&amp;gt; dep &#x3D;&#x3D;&#x3D; alias)) return true;
      // Partial matches help with scoped packages like &amp;quot;@nestjs/core&amp;quot;
      if (dep.includes(pattern.name)) return true;
      return false;
    });

    if (isMatch) {
      matchedWeight +&#x3D; pattern.weight;
      maxPossibleWeight +&#x3D; pattern.weight;
    } else {
      // Only count high-weight patterns as &amp;quot;missing&amp;quot; for normalization
      if (pattern.weight &amp;gt;&#x3D; 0.8) {
        maxPossibleWeight +&#x3D; pattern.weight;
      }
    }
  }

  // If we have matches, normalize by the weight we actually accumulated
  if (matchedWeight &amp;gt; 0) {
    // Cap at 1.0 and ensure we get high confidence for strong matches
    return Math.min(1.0, matchedWeight);
  }

  return 0;
}

/**
 * Determine the most likely artifact type for given dependencies
 */
export function determineMostLikelyCategory(
  dependencies: string[],
  language: string,
): { category: keyof CategoryMatrix; confidence: number } {
  const languageMatrix &#x3D; DEPENDENCY_MATRIX[language];
  if (!languageMatrix) {
    return { category: &amp;quot;package&amp;quot;, confidence: 0 };
  }

  const scores: Array&amp;lt;{ category: keyof CategoryMatrix; confidence: number }&amp;gt; &#x3D; [];

  for (const category of Object.keys(languageMatrix) as Array&amp;lt;keyof CategoryMatrix&amp;gt;) {
    const confidence &#x3D; calculateCategoryConfidence(dependencies, language, category);
    scores.push({ category, confidence });
  }

  // Sort by confidence and return the highest
  scores.sort((a, b) &#x3D;&amp;gt; b.confidence - a.confidence);

  const best &#x3D; scores[0];

  // If no clear winner, default to package with low confidence
  if (best.confidence &#x3D;&#x3D;&#x3D; 0) {
    return { category: &amp;quot;package&amp;quot;, confidence: 0.1 };
  }

  return best;
}

/**
 * Get all categories sorted by confidence for given dependencies
 */
export function getAllCategoriesByConfidence(
  dependencies: string[],
  language: string,
): Array&amp;lt;{ category: keyof CategoryMatrix; confidence: number }&amp;gt; {
  const languageMatrix &#x3D; DEPENDENCY_MATRIX[language];
  if (!languageMatrix) return [];

  const scores: Array&amp;lt;{ category: keyof CategoryMatrix; confidence: number }&amp;gt; &#x3D; [];

  for (const category of Object.keys(languageMatrix) as Array&amp;lt;keyof CategoryMatrix&amp;gt;) {
    const confidence &#x3D; calculateCategoryConfidence(dependencies, language, category);
    if (confidence &amp;gt; 0) {
      scores.push({ category, confidence });
    }
  }

  return scores.sort((a, b) &#x3D;&amp;gt; b.confidence - a.confidence);
}

/**
 * Get explanation of why a category was chosen
 */
export function getCategoryExplanation(
  dependencies: string[],
  language: string,
  category: keyof CategoryMatrix,
): string[] {
  const languageMatrix &#x3D; DEPENDENCY_MATRIX[language];
  if (!languageMatrix) return [];

  const categoryPatterns &#x3D; languageMatrix[category];
  if (!categoryPatterns) return [];

  const matches: string[] &#x3D; [];

  for (const pattern of categoryPatterns) {
    const matchingDeps &#x3D; dependencies.filter((dep) &#x3D;&amp;gt; {
      if (dep &#x3D;&#x3D;&#x3D; pattern.name) return true;
      if (pattern.aliases?.some((alias) &#x3D;&amp;gt; dep &#x3D;&#x3D;&#x3D; alias)) return true;
      if (dep.includes(pattern.name)) return true;
      return false;
    });

    if (matchingDeps.length &amp;gt; 0) {
      matches.push(&#x60;${matchingDeps.join(&amp;quot;, &amp;quot;)} â†’ ${pattern.context} (weight: ${pattern.weight})&#x60;);
    }
  }

  return matches;
}
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(14)">
                    <span class="file-path">file-code src/persistence.ts</span>
                    <div class="file-meta">
                        <span>8.49 KB</span>
                        <span>1,940 tokens</span>
                        <span>Score: 0.30</span>
                    </div>
                </div>
                <div class="file-content" id="file-14">
                    <pre class="code-block"><code>/**
 * @packageDocumentation
 * Persistence helpers for storing importer artefacts during iterative scans.
 */

import * as crypto from &amp;quot;crypto&amp;quot;;
import * as path from &amp;quot;path&amp;quot;;
import * as fs from &amp;quot;fs-extra&amp;quot;;
import type {
  ActionType,
  ArtifactLogEntry as ArtifactLog,
  ArtifactType,
  InferredArtifact,
  Spec,
} from &amp;quot;./types&amp;quot;;

/**
 * Minimal persistence contract used by the importer.
 *
 * @public
 */
export interface IPersister {
  /**
   * Creates a snapshot specification for the provided scope.
   */
  createSpec(scope: string, config_files?: string[]): Promise&amp;lt;string&amp;gt;;
  /**
   * Appends an artifact mutation entry to the log.
   */
  logArtifact(specId: string, artifact: InferredArtifact, action: ActionType): Promise&amp;lt;void&amp;gt;;
  /**
   * Records that an artifact was removed from a scope.
   */
  logRemove(specId: string, lastAddLog: ArtifactLog): Promise&amp;lt;void&amp;gt;;
  /**
   * Retrieves the most recent specification identifier for the scope.
   */
  getLatestSpecId(scope: string): Promise&amp;lt;string | null&amp;gt;;
  /**
   * Replays the log to determine the current set of artifacts for a scope.
   */
  deriveCurrentArtifacts(scope: string): Promise&amp;lt;InferredArtifact[]&amp;gt;;
  /**
   * Returns the log chain associated with a specification.
   */
  getAllLogsForSpecChain(specId: string): Promise&amp;lt;ArtifactLog[]&amp;gt;;
  /**
   * Checks whether the artefact is still active in the latest spec.
   */
  isArtifactCurrent(scope: string, artifact: InferredArtifact): Promise&amp;lt;boolean&amp;gt;;
  /**
   * Finds the most recent add-log entry for a named artifact.
   */
  getLastAddLog(scope: string, artifactName: string): Promise&amp;lt;ArtifactLog | null&amp;gt;;
}

/**
 * Simple JSON-backed implementation of {@link IPersister}.
 *
 * @public
 */
export class SimpleJsonPersister implements IPersister {
  private specsPath: string;
  private logsPath: string;
  private projectRoot: string;

  /**
   * Creates a persister rooted at the supplied project directory.
   */
  constructor(projectRoot: string) {
    this.projectRoot &#x3D; projectRoot;
    this.specsPath &#x3D; path.join(projectRoot, &amp;quot;importer-specs.json&amp;quot;);
    this.logsPath &#x3D; path.join(projectRoot, &amp;quot;importer-artifact-log.json&amp;quot;);
    this.ensureFiles();
  }

  /**
   * Ensures the JSON backing files exist before reads or writes.
   */
  private ensureFiles() {
    if (!fs.existsSync(this.specsPath)) {
      fs.writeJsonSync(this.specsPath, { scopes: {} }, { spaces: 2 });
    }
    if (!fs.existsSync(this.logsPath)) {
      fs.writeJsonSync(this.logsPath, [], { spaces: 2 });
    }
  }

  private generateId(): string {
    return crypto.randomUUID();
  }

  private computeArtifactHash(artifact: InferredArtifact): string {
    const data &#x3D; JSON.stringify({
      name: artifact.artifact.name,
      type: artifact.artifact.type,
      metadata: artifact.artifact.metadata,
      provenance: artifact.provenance,
    });
    return crypto.createHash(&amp;quot;sha256&amp;quot;).update(data).digest(&amp;quot;hex&amp;quot;);
  }

  async createSpec(scope: string, config_files?: string[]): Promise&amp;lt;string&amp;gt; {
    const specs &#x3D; fs.readJsonSync(this.specsPath);
    const scopeSpecs &#x3D; specs.scopes[scope] || [];
    const previousRevision &#x3D;
      scopeSpecs.length &amp;gt; 0 ? scopeSpecs[scopeSpecs.length - 1].revision_id : null;
    const newRevision &#x3D; this.generateId();
    const newSpec: Spec &#x3D; {
      revision_id: newRevision,
      parent_revision_id: previousRevision,
      scope,
      timestamp: Date.now(),
      config_files,
    };
    scopeSpecs.push(newSpec);
    specs.scopes[scope] &#x3D; scopeSpecs;
    fs.writeJsonSync(this.specsPath, specs, { spaces: 2 });
    return newRevision;
  }

  async getLatestSpecId(scope: string): Promise&amp;lt;string | null&amp;gt; {
    const specs &#x3D; fs.readJsonSync(this.specsPath);
    const scopeSpecs &#x3D; specs.scopes[scope] || [];
    return scopeSpecs.length &amp;gt; 0 ? scopeSpecs[scopeSpecs.length - 1].revision_id : null;
  }

  async logArtifact(specId: string, artifact: InferredArtifact, action: ActionType): Promise&amp;lt;void&amp;gt; {
    const logs &#x3D; fs.readJsonSync(this.logsPath);
    const logEntry: ArtifactLog &#x3D; {
      id: this.generateId(),
      spec_id: specId,
      artifact_name: artifact.artifact.name,
      artifact_type: artifact.artifact.type,
      artifact_hash: this.computeArtifactHash(artifact),
      artifact_data: JSON.stringify(artifact.artifact),
      provenance_data: JSON.stringify(artifact.provenance),
      action,
      timestamp: Date.now(),
    };
    logs.push(logEntry);
    fs.writeJsonSync(this.logsPath, logs, { spaces: 2 });
  }

  async logRemove(specId: string, lastAddLog: ArtifactLog): Promise&amp;lt;void&amp;gt; {
    const logs &#x3D; fs.readJsonSync(this.logsPath);
    const logEntry: ArtifactLog &#x3D; {
      id: this.generateId(),
      spec_id: specId,
      artifact_name: lastAddLog.artifact_name,
      artifact_type: lastAddLog.artifact_type,
      artifact_hash: lastAddLog.artifact_hash,
      artifact_data: lastAddLog.artifact_data,
      provenance_data: lastAddLog.provenance_data,
      action: &amp;quot;remove&amp;quot;,
      timestamp: Date.now(),
    };
    logs.push(logEntry);
    fs.writeJsonSync(this.logsPath, logs, { spaces: 2 });
  }

  async isArtifactCurrent(scope: string, artifact: InferredArtifact): Promise&amp;lt;boolean&amp;gt; {
    const latestSpecId &#x3D; await this.getLatestSpecId(scope);
    if (!latestSpecId) return false;
    const allLogs &#x3D; await this.getAllLogsForSpecChain(latestSpecId);
    const nameLogs &#x3D; allLogs
      .filter((l) &#x3D;&amp;gt; l.artifact_name &#x3D;&#x3D;&#x3D; artifact.artifact.name &amp;amp;&amp;amp; l.action &#x3D;&#x3D;&#x3D; &amp;quot;add&amp;quot;)
      .sort((a, b) &#x3D;&amp;gt; b.timestamp - a.timestamp);
    if (nameLogs.length &#x3D;&#x3D;&#x3D; 0) return false;
    const lastHash &#x3D; nameLogs[0].artifact_hash;
    return lastHash &#x3D;&#x3D;&#x3D; this.computeArtifactHash(artifact);
  }

  async getLastAddLog(scope: string, artifactName: string): Promise&amp;lt;ArtifactLog | null&amp;gt; {
    const latestSpecId &#x3D; await this.getLatestSpecId(scope);
    if (!latestSpecId) return null;
    const allLogs &#x3D; await this.getAllLogsForSpecChain(latestSpecId);
    const nameLogs &#x3D; allLogs
      .filter((l) &#x3D;&amp;gt; l.artifact_name &#x3D;&#x3D;&#x3D; artifactName &amp;amp;&amp;amp; l.action &#x3D;&#x3D;&#x3D; &amp;quot;add&amp;quot;)
      .sort((a, b) &#x3D;&amp;gt; b.timestamp - a.timestamp);
    return nameLogs.length &amp;gt; 0 ? nameLogs[0] : null;
  }

  async getAllLogsForSpecChain(specId: string): Promise&amp;lt;ArtifactLog[]&amp;gt; {
    const specs &#x3D; fs.readJsonSync(this.specsPath);
    const logs &#x3D; fs.readJsonSync(this.logsPath);
    const specChain: string[] &#x3D; [];
    let current: string | null &#x3D; specId;
    while (current) {
      specChain.push(current);
      const spec &#x3D; this.findSpecById(specs, current);
      current &#x3D; spec?.parent_revision_id || null;
    }
    return logs.filter((log: ArtifactLog) &#x3D;&amp;gt; specChain.includes(log.spec_id));
  }

  private findSpecById(specsData: any, revisionId: string): Spec | null {
    for (const scopeSpecs of Object.values(specsData.scopes)) {
      for (const spec of scopeSpecs as Spec[]) {
        if (spec.revision_id &#x3D;&#x3D;&#x3D; revisionId) return spec;
      }
    }
    return null;
  }

  async deriveCurrentArtifacts(scope: string): Promise&amp;lt;InferredArtifact[]&amp;gt; {
    const latestSpecId &#x3D; await this.getLatestSpecId(scope);
    if (!latestSpecId) return [];
    const allLogs &#x3D; await this.getAllLogsForSpecChain(latestSpecId);
    const artifactsByName: Map&amp;lt;string, InferredArtifact&amp;gt; &#x3D; new Map();
    const processedHashes &#x3D; new Set&amp;lt;string&amp;gt;();

    const logsByName &#x3D; new Map&amp;lt;string, ArtifactLog[]&amp;gt;();
    for (const log of allLogs) {
      if (!logsByName.has(log.artifact_name)) {
        logsByName.set(log.artifact_name, []);
      }
      logsByName.get(log.artifact_name)!.push(log);
    }

    for (const [name, nameLogs] of logsByName) {
      const adds &#x3D; nameLogs
        .filter((log) &#x3D;&amp;gt; log.action &#x3D;&#x3D;&#x3D; &amp;quot;add&amp;quot;)
        .sort((a, b) &#x3D;&amp;gt; b.timestamp - a.timestamp);
      if (adds.length &#x3D;&#x3D;&#x3D; 0) continue;
      const lastAdd &#x3D; adds[0];
      if (processedHashes.has(lastAdd.artifact_hash)) continue;

      const artifactData &#x3D; JSON.parse(lastAdd.artifact_data);
      const provenanceData &#x3D; lastAdd.provenance_data
        ? JSON.parse(lastAdd.provenance_data)
        : {
            evidence: [],
            plugins: [],
            rules: [],
            timestamp: lastAdd.timestamp,
            pipelineVersion: &amp;quot;1.0&amp;quot;,
          };
      const reconstructed: InferredArtifact &#x3D; {
        artifact: artifactData,
        provenance: provenanceData,
        relationships: [],
      };
      artifactsByName.set(name, reconstructed);
      processedHashes.add(lastAdd.artifact_hash);
    }

    return Array.from(artifactsByName.values());
  }
}
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(15)">
                    <span class="file-path">file-code src/test-detection.ts</span>
                    <div class="file-meta">
                        <span>6.79 KB</span>
                        <span>1,656 tokens</span>
                        <span>Score: 0.28</span>
                    </div>
                </div>
                <div class="file-content" id="file-15">
                    <pre class="code-block"><code>#!/usr/bin/env bun
/**
 * Test detection logic using pre-exported JSON data
 * This allows rapid iteration on detection rules without re-scanning projects
 */

import * as fs from &amp;quot;fs-extra&amp;quot;;
import type { PackageJsonData } from &amp;quot;./plugins/nodejs&amp;quot;;

interface PackageDetectionData {
  name: string;
  path: string;
  packageJson: PackageJsonData;
  filePatterns: string[];
  detectedType?: string;
}

interface DetectionData {
  projectPath: string;
  projectName: string;
  packages: PackageDetectionData[];
}

// Simplified detection logic for testing
function detectPackageType(pkg: PackageDetectionData): string {
  const { packageJson } &#x3D; pkg;
  const name &#x3D; packageJson.name;

  // Merge all dependencies for checking
  const depsObj &#x3D; packageJson as any;
  const deps &#x3D; { ...(depsObj.dependencies || {}), ...(depsObj.devDependencies || {}) };

  // 1. CLI - Has bin field or CLI framework
  if (packageJson.bin) {
    return &amp;quot;tool&amp;quot;;
  }

  // Check for CLI frameworks even without bin field
  const cliFrameworks &#x3D; [
    &amp;quot;commander&amp;quot;,
    &amp;quot;yargs&amp;quot;,
    &amp;quot;inquirer&amp;quot;,
    &amp;quot;oclif&amp;quot;,
    &amp;quot;meow&amp;quot;,
    &amp;quot;caporal&amp;quot;,
    &amp;quot;cac&amp;quot;,
    &amp;quot;clipanion&amp;quot;,
  ];
  const hasCliFramework &#x3D; Object.keys(deps).some((dep) &#x3D;&amp;gt;
    cliFrameworks.some((cli) &#x3D;&amp;gt; dep.toLowerCase().includes(cli)),
  );

  if (hasCliFramework &amp;amp;&amp;amp; !packageJson.private) {
    return &amp;quot;tool&amp;quot;;
  }

  // 2. Types packages - Special case for type definition packages
  // These are libraries even if they have web framework dependencies
  const isTypesPackage &#x3D;
    name.toLowerCase().includes(&amp;quot;types&amp;quot;) ||
    name.toLowerCase().includes(&amp;quot;type-definitions&amp;quot;) ||
    (packageJson.types &amp;amp;&amp;amp; !packageJson.main) ||
    (packageJson.typings &amp;amp;&amp;amp; !packageJson.main);

  if (isTypesPackage) {
    return &amp;quot;package&amp;quot;;
  }

  // 3. Web Service - Has web framework, database driver, or server-related scripts
  const webFrameworks &#x3D; [
    &amp;quot;express&amp;quot;,
    &amp;quot;fastify&amp;quot;,
    &amp;quot;koa&amp;quot;,
    &amp;quot;hono&amp;quot;,
    &amp;quot;hapi&amp;quot;,
    &amp;quot;nestjs&amp;quot;,
    &amp;quot;restify&amp;quot;,
    &amp;quot;sails&amp;quot;,
    &amp;quot;feathers&amp;quot;,
    &amp;quot;apollo-server&amp;quot;,
    &amp;quot;graphql-yoga&amp;quot;,
    &amp;quot;trpc&amp;quot;,
    &amp;quot;socket.io&amp;quot;,
    &amp;quot;ws&amp;quot;,
  ];
  const databases &#x3D; [
    &amp;quot;mongoose&amp;quot;,
    &amp;quot;sequelize&amp;quot;,
    &amp;quot;typeorm&amp;quot;,
    &amp;quot;prisma&amp;quot;,
    &amp;quot;drizzle-orm&amp;quot;,
    &amp;quot;pg&amp;quot;,
    &amp;quot;mysql&amp;quot;,
    &amp;quot;mysql2&amp;quot;,
    &amp;quot;mongodb&amp;quot;,
    &amp;quot;redis&amp;quot;,
    &amp;quot;ioredis&amp;quot;,
    &amp;quot;knex&amp;quot;,
    &amp;quot;objection&amp;quot;,
    &amp;quot;mikro-orm&amp;quot;,
  ];

  const hasWebFramework &#x3D; Object.keys(deps).some((dep) &#x3D;&amp;gt;
    webFrameworks.some((fw) &#x3D;&amp;gt; dep.toLowerCase().includes(fw)),
  );

  const hasDatabase &#x3D; Object.keys(deps).some((dep) &#x3D;&amp;gt;
    databases.some((db) &#x3D;&amp;gt; dep.toLowerCase().includes(db)),
  );

  const hasServerScript &#x3D;
    (packageJson as any).scripts &amp;amp;&amp;amp;
    (((packageJson as any).scripts.start as string)?.includes(&amp;quot;server&amp;quot;) ||
      ((packageJson as any).scripts.start as string)?.includes(&amp;quot;src/server&amp;quot;) ||
      ((packageJson as any).scripts.dev as string)?.includes(&amp;quot;server&amp;quot;) ||
      ((packageJson as any).scripts.serve as string | boolean) ||
      ((packageJson as any).main as string)?.includes(&amp;quot;server&amp;quot;));

  if (hasWebFramework || hasDatabase || hasServerScript) {
    return &amp;quot;service&amp;quot;;
  }

  // 4. Build tools - webpack, rollup, etc.
  const buildTools &#x3D; [
    &amp;quot;webpack&amp;quot;,
    &amp;quot;rollup&amp;quot;,
    &amp;quot;parcel&amp;quot;,
    &amp;quot;esbuild&amp;quot;,
    &amp;quot;turbopack&amp;quot;,
    &amp;quot;tsup&amp;quot;,
    &amp;quot;vite&amp;quot;,
    &amp;quot;snowpack&amp;quot;,
  ];
  const hasBuildTool &#x3D; Object.keys(deps).some((dep) &#x3D;&amp;gt;
    buildTools.some((tool) &#x3D;&amp;gt; dep.toLowerCase().includes(tool)),
  );

  // Check if it&amp;#39;s primarily a build tool (not a frontend app using vite)
  const isBuildTool &#x3D; hasBuildTool &amp;amp;&amp;amp; !packageJson.private &amp;amp;&amp;amp; !packageJson.browserslist;
  if (isBuildTool) {
    return &amp;quot;tool&amp;quot;;
  }

  // 5. Frontend - Has frontend framework AND is private or has browserslist
  const frontendFrameworks &#x3D; [
    &amp;quot;react&amp;quot;,
    &amp;quot;vue&amp;quot;,
    &amp;quot;angular&amp;quot;,
    &amp;quot;svelte&amp;quot;,
    &amp;quot;solid&amp;quot;,
    &amp;quot;preact&amp;quot;,
    &amp;quot;next&amp;quot;,
    &amp;quot;nuxt&amp;quot;,
    &amp;quot;gatsby&amp;quot;,
  ];
  const hasFrontendFramework &#x3D; Object.keys(deps).some((dep) &#x3D;&amp;gt;
    frontendFrameworks.some((fw) &#x3D;&amp;gt; dep.toLowerCase().includes(fw)),
  );

  if (hasFrontendFramework) {
    const isComponentLibrary &#x3D;
      packageJson.peerDependencies &amp;amp;&amp;amp;
      Object.keys(packageJson.peerDependencies).some((peer) &#x3D;&amp;gt;
        frontendFrameworks.some((fw) &#x3D;&amp;gt; peer.toLowerCase().includes(fw)),
      );

    if (isComponentLibrary) {
      return &amp;quot;package&amp;quot;;
    }

    if (packageJson.private || packageJson.browserslist) {
      return &amp;quot;frontend&amp;quot;;
    }
  }

  // 6. Package - Everything else
  return &amp;quot;package&amp;quot;;
}

// Define expected types for key packages
const expectedTypes: Record&amp;lt;string, string&amp;gt; &#x3D; {
  // Arbiter packages
  &amp;quot;@arbiter/cli&amp;quot;: &amp;quot;tool&amp;quot;,
  &amp;quot;@arbiter/api&amp;quot;: &amp;quot;service&amp;quot;,
  &amp;quot;@arbiter/shared&amp;quot;: &amp;quot;package&amp;quot;,
  &amp;quot;@arbiter/shared-types&amp;quot;: &amp;quot;package&amp;quot;,
  &amp;quot;@arbiter/api-types&amp;quot;: &amp;quot;package&amp;quot;,
  &amp;quot;@arbiter/importer&amp;quot;: &amp;quot;package&amp;quot;,
  &amp;quot;@arbiter/cue-runner&amp;quot;: &amp;quot;package&amp;quot;,
  &amp;quot;spec-workbench-frontend&amp;quot;: &amp;quot;frontend&amp;quot;,
  arbiter: &amp;quot;tool&amp;quot;, // Root has bin field

  // Smith packages
  &amp;quot;smith-agent-visualizer&amp;quot;: &amp;quot;frontend&amp;quot;,
  &amp;quot;@smith/protocol&amp;quot;: &amp;quot;package&amp;quot;,
};

async function runTests() {
  const dataPath &#x3D; &amp;quot;/home/nathan/Projects/arbiter/detection-test-data.json&amp;quot;;
  const data: DetectionData[] &#x3D; await fs.readJson(dataPath);

  console.log(&amp;quot;ðŸ§ª Testing Package Type Detection\n&amp;quot;);
  console.log(&amp;quot;&#x3D;&amp;quot;.repeat(80));

  let totalPass &#x3D; 0;
  let totalFail &#x3D; 0;
  const failures: string[] &#x3D; [];

  for (const project of data) {
    console.log(&#x60;\nðŸ“¦ Project: ${project.projectName}&#x60;);
    console.log(&amp;quot;-&amp;quot;.repeat(40));

    for (const pkg of project.packages) {
      const detected &#x3D; detectPackageType(pkg);
      const expected &#x3D; expectedTypes[pkg.name] || pkg.detectedType;
      const pass &#x3D; detected &#x3D;&#x3D;&#x3D; expected;

      if (pass) {
        totalPass++;
        console.log(&#x60;  âœ… ${pkg.name}: ${detected}&#x60;);
      } else {
        totalFail++;
        failures.push(&#x60;${pkg.name}: expected ${expected}, got ${detected}&#x60;);
        console.log(&#x60;  âŒ ${pkg.name}: expected ${expected}, got ${detected}&#x60;);

        // Debug info for failures
        const pkgJson &#x3D; pkg.packageJson as any;
        const deps &#x3D; Object.keys({
          ...(pkgJson.dependencies || {}),
          ...(pkgJson.devDependencies || {}),
        });
        console.log(
          &#x60;     Dependencies: ${deps.slice(0, 5).join(&amp;quot;, &amp;quot;)}${deps.length &amp;gt; 5 ? &amp;quot;...&amp;quot; : &amp;quot;&amp;quot;}&#x60;,
        );
        console.log(&#x60;     Has bin: ${!!pkg.packageJson.bin}&#x60;);
        console.log(&#x60;     Private: ${!!pkg.packageJson.private}&#x60;);
        console.log(&#x60;     Main: ${pkg.packageJson.main || &amp;quot;none&amp;quot;}&#x60;);
      }
    }
  }

  console.log(&amp;quot;\n&amp;quot; + &amp;quot;&#x3D;&amp;quot;.repeat(80));
  console.log(&#x60;\nðŸ“Š Results: ${totalPass} passed, ${totalFail} failed\n&#x60;);

  if (failures.length &amp;gt; 0) {
    console.log(&amp;quot;âŒ Failed detections:&amp;quot;);
    failures.forEach((f) &#x3D;&amp;gt; console.log(&#x60;  - ${f}&#x60;));
  }

  return totalFail &#x3D;&#x3D;&#x3D; 0;
}

runTests().then((success) &#x3D;&amp;gt; {
  process.exit(success ? 0 : 1);
});
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(16)">
                    <span class="file-path">file-code src/test-scanner.ts</span>
                    <div class="file-meta">
                        <span>2.35 KB</span>
                        <span>541 tokens</span>
                        <span>Score: 0.28</span>
                    </div>
                </div>
                <div class="file-content" id="file-16">
                    <pre class="code-block"><code>#!/usr/bin/env bun
/**
 * Test scanner to verify package type detection
 */

import { getAllPlugins } from &amp;quot;./plugins/index&amp;quot;;
import { ScannerRunner } from &amp;quot;./scanner&amp;quot;;

async function main() {
  const projectPath &#x3D; process.argv[2] || &amp;quot;/home/nathan/Projects/arbiter&amp;quot;;

  console.log(&#x60;ðŸ“¦ Scanning project: ${projectPath}\n&#x60;);

  try {
    const scanner &#x3D; new ScannerRunner({
      projectRoot: projectPath,
      debug: true,
      plugins: getAllPlugins(),
    });

    const manifest &#x3D; await scanner.scan();

    console.log(&amp;quot;\nAll Artifacts:&amp;quot;);
    for (const inferred of manifest.artifacts) {
      console.log(
        &#x60;Type: ${inferred.artifact.type}, Name: ${inferred.artifact.name}, Source: ${inferred.provenance.evidence.join(&amp;quot;, &amp;quot;)}&#x60;,
      );
    }
    console.log(&amp;quot;\nDetected Artifacts per Config:&amp;quot;);
    console.log(&amp;quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&amp;quot;);

    for (const [config, artifacts] of Object.entries(manifest.perConfig)) {
      console.log(&#x60;\nConfig: ${config}&#x60;);
      console.log(&amp;quot;----------------&amp;quot;);

      // Group by type for this config
      const byType: Record&amp;lt;string, any[]&amp;gt; &#x3D; {};
      for (const artifact of artifacts) {
        const type &#x3D; artifact.artifact?.type || &amp;quot;other&amp;quot;;
        if (!byType[type]) byType[type] &#x3D; [];
        byType[type].push(artifact);
      }

      for (const [type, arts] of Object.entries(byType)) {
        console.log(&#x60;  ${type.toUpperCase()}: ${arts.length}&#x60;);
        for (const art of arts.slice(0, 3)) {
          // Show first 3
          console.log(&#x60;    - ${art.artifact.name}&#x60;);
        }
        if (arts.length &amp;gt; 3) console.log(&#x60;      ... and ${arts.length - 3} more&#x60;);
      }
    }

    const allArtifacts &#x3D; Object.values(manifest.perConfig).flat();
    console.log(&#x60;\nðŸ“Š Summary:&#x60;);
    console.log(&#x60;  Total configs: ${Object.keys(manifest.perConfig).length}&#x60;);
    console.log(&#x60;  Total artifacts: ${allArtifacts.length}&#x60;);

    // Overall type counts
    const typeCounts: Record&amp;lt;string, number&amp;gt; &#x3D; {};
    for (const artifact of allArtifacts) {
      const type &#x3D; artifact.artifact?.type;
      typeCounts[type] &#x3D; (typeCounts[type] || 0) + 1;
    }

    for (const [type, count] of Object.entries(typeCounts)) {
      console.log(&#x60;  ${type}: ${count}&#x60;);
    }
  } catch (error) {
    console.error(&amp;quot;Error scanning project:&amp;quot;, error);
    process.exit(1);
  }
}

main();
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(17)">
                    <span class="file-path">braces tsconfig.json</span>
                    <div class="file-meta">
                        <span>314.00 B</span>
                        <span>74 tokens</span>
                        <span>Score: 0.27</span>
                    </div>
                </div>
                <div class="file-content" id="file-17">
                    <pre class="code-block"><code>{
  &amp;quot;extends&amp;quot;: &amp;quot;../../tsconfig.json&amp;quot;,
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;outDir&amp;quot;: &amp;quot;./dist&amp;quot;,
    &amp;quot;rootDir&amp;quot;: &amp;quot;./src&amp;quot;,
    &amp;quot;declaration&amp;quot;: true,
    &amp;quot;declarationMap&amp;quot;: true,
    &amp;quot;sourceMap&amp;quot;: true,
    &amp;quot;composite&amp;quot;: true
  },
  &amp;quot;include&amp;quot;: [&amp;quot;src/**/*&amp;quot;],
  &amp;quot;exclude&amp;quot;: [&amp;quot;node_modules&amp;quot;, &amp;quot;dist&amp;quot;, &amp;quot;**/*.test.ts&amp;quot;, &amp;quot;**/__tests__/**&amp;quot;]
}
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(18)">
                    <span class="file-path">file-code src/plugins/kubernetes.ts</span>
                    <div class="file-meta">
                        <span>8.54 KB</span>
                        <span>1,797 tokens</span>
                        <span>Score: 0.26</span>
                    </div>
                </div>
                <div class="file-content" id="file-18">
                    <pre class="code-block"><code>import * as path from &amp;quot;path&amp;quot;;
import * as yaml from &amp;quot;yaml&amp;quot;;
import type {
  Evidence,
  ImporterPlugin,
  InferenceContext,
  InferredArtifact,
  ParseContext,
} from &amp;quot;../types&amp;quot;;

export interface KubernetesData {
  name: string;
  kind: string;
  apiVersion: string;
  namespace?: string;
  fullParsed?: any;
  filePath: string;
  [key: string]: unknown;
}

export class KubernetesPlugin implements ImporterPlugin {
  name(): string {
    return &amp;quot;kubernetes&amp;quot;;
  }

  supports(filePath: string): boolean {
    const basename &#x3D; path.basename(filePath).toLowerCase();
    const relative &#x3D; path.relative(process.cwd(), filePath).toLowerCase();
    return (
      (basename.endsWith(&amp;quot;.yaml&amp;quot;) || basename.endsWith(&amp;quot;.yml&amp;quot;)) &amp;amp;&amp;amp;
      (relative.includes(&amp;quot;kubernetes&amp;quot;) ||
        relative.includes(&amp;quot;k8s&amp;quot;) ||
        relative.includes(&amp;quot;manifests&amp;quot;))
    );
  }

  async parse(filePath: string, fileContent?: string, context?: ParseContext): Promise&amp;lt;Evidence[]&amp;gt; {
    if (!fileContent) {
      throw new Error(&amp;quot;File content required for Kubernetes parsing&amp;quot;);
    }

    const evidence: Evidence[] &#x3D; [];
    const basename &#x3D; path.basename(filePath).toLowerCase();
    const projectRoot &#x3D; context?.projectRoot || process.cwd();

    try {
      const documents &#x3D; yaml.parseAllDocuments(fileContent);
      if (documents.length &#x3D;&#x3D;&#x3D; 0) {
        return evidence;
      }
      const parsedItems &#x3D; documents
        .map((doc) &#x3D;&amp;gt; doc.toJSON())
        .filter((item) &#x3D;&amp;gt; item &amp;amp;&amp;amp; typeof item &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot; &amp;amp;&amp;amp; item !&#x3D;&#x3D; null);
      if (parsedItems.length &#x3D;&#x3D;&#x3D; 0) {
        return evidence;
      }
      const kubeEvidence &#x3D; this.parseKubernetesManifest(parsedItems, filePath, projectRoot);
      evidence.push(...kubeEvidence);
    } catch (error) {
      console.warn(&#x60;Failed to parse Kubernetes file ${filePath}:&#x60;, error);
    }

    return evidence;
  }

  private parseKubernetesManifest(parsed: any, filePath: string, projectRoot: string): Evidence[] {
    const evidence: Evidence[] &#x3D; [];

    if (Array.isArray(parsed)) {
      parsed.forEach((item, index) &#x3D;&amp;gt; {
        if (typeof item &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot; &amp;amp;&amp;amp; item !&#x3D;&#x3D; null) {
          const itemEvidence &#x3D; this.parseSingleItem(item, filePath, projectRoot, index);
          evidence.push(itemEvidence);
        }
      });
    } else if (typeof parsed &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot; &amp;amp;&amp;amp; parsed !&#x3D;&#x3D; null) {
      const itemEvidence &#x3D; this.parseSingleItem(parsed, filePath, projectRoot, 0);
      evidence.push(itemEvidence);
    }

    return evidence;
  }

  private parseSingleItem(
    parsed: any,
    filePath: string,
    projectRoot: string,
    index: number,
  ): Evidence {
    const name &#x3D; parsed.metadata?.name;
    const kind &#x3D; parsed.kind;
    const apiVersion &#x3D; parsed.apiVersion;
    const namespace &#x3D; parsed.metadata?.namespace;

    const relativePath &#x3D; path.relative(projectRoot, filePath);
    const data: KubernetesData &#x3D; {
      name,
      kind,
      apiVersion,
      namespace,
      fullParsed: parsed,
      filePath: relativePath,
      index,
    };

    const evidenceId &#x3D; &#x60;${relativePath}#${index}&#x60;;
    return {
      id: evidenceId,
      source: this.name(),
      type: &amp;quot;infrastructure&amp;quot;,
      filePath: relativePath,
      data,
      metadata: {
        timestamp: Date.now(),
        fileSize: JSON.stringify(parsed).length,
      },
    };
  }

  async infer(evidence: Evidence[], context: InferenceContext): Promise&amp;lt;InferredArtifact[]&amp;gt; {
    const artifacts: InferredArtifact[] &#x3D; [];

    // Filter Kubernetes evidence
    const kubeEvidence &#x3D; evidence.filter(
      (e) &#x3D;&amp;gt; e.source &#x3D;&#x3D;&#x3D; this.name() &amp;amp;&amp;amp; e.type &#x3D;&#x3D;&#x3D; &amp;quot;infrastructure&amp;quot;,
    );

    if (kubeEvidence.length &#x3D;&#x3D;&#x3D; 0) return artifacts;

    // Group by root directory (find common ancestor for all kube files)
    const rootDir &#x3D; this.findRootDirectory(kubeEvidence, context.projectRoot || process.cwd());
    if (!rootDir) return artifacts;

    for (const e of kubeEvidence) {
      const data &#x3D; e.data as KubernetesData;
      const safeName &#x3D; (data.name || &#x60;resource-${data.index}&#x60;).replace(/[^a-zA-Z0-9-]/g, &amp;quot;-&amp;quot;);
      const artifactId &#x3D; &#x60;${data.kind.toLowerCase()}-${safeName}&#x60;;
      const artifactName &#x3D; data.name || &#x60;Unnamed Resource&#x60;;
      const fullParsed &#x3D; (data as any).fullParsed;
      let description: string;
      if (!fullParsed) {
        description &#x3D; &#x60;Kubernetes ${data.kind} resource&#x60;;
      } else {
        switch (data.kind) {
          case &amp;quot;Deployment&amp;quot;: {
            const replicas &#x3D; fullParsed.spec?.replicas || 1;
            const containers &#x3D; fullParsed.spec?.template?.spec?.containers || [];
            const images &#x3D; containers.map((c: any) &#x3D;&amp;gt; c.image).join(&amp;quot;, &amp;quot;);
            description &#x3D; &#x60;Deploys ${data.name || &amp;quot;unnamed&amp;quot;} with ${replicas} replicas using images: ${images}&#x60;;
            if (data.namespace) description +&#x3D; &#x60; in namespace ${data.namespace}&#x60;;
            break;
          }
          case &amp;quot;Service&amp;quot;: {
            const portValues &#x3D; (fullParsed.spec?.ports || [])
              .map((p: any) &#x3D;&amp;gt; p?.port)
              .filter(
                (port: any) &#x3D;&amp;gt;
                  typeof port &#x3D;&#x3D;&#x3D; &amp;quot;number&amp;quot; || (typeof port &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; &amp;amp;&amp;amp; port.trim().length &amp;gt; 0),
              );
            const selector &#x3D; JSON.stringify(fullParsed.spec?.selector || {});
            const portSegment &#x3D;
              portValues.length &amp;gt; 0
                ? &#x60;on ports ${portValues.join(&amp;quot;, &amp;quot;)}&#x60;
                : &amp;quot;without explicit port configuration&amp;quot;;
            description &#x3D; &#x60;Exposes service ${data.name || &amp;quot;unnamed&amp;quot;} ${portSegment} selecting pods by ${selector}&#x60;;
            if (data.namespace) description +&#x3D; &#x60; in namespace ${data.namespace}&#x60;;
            break;
          }
          case &amp;quot;ConfigMap&amp;quot;: {
            const keys &#x3D; Object.keys(fullParsed.data || {}).length;
            description &#x3D; &#x60;Provides configuration for ${data.name || &amp;quot;unnamed&amp;quot;} with ${keys} key-value pairs&#x60;;
            if (data.namespace) description +&#x3D; &#x60; in namespace ${data.namespace}&#x60;;
            break;
          }
          case &amp;quot;Secret&amp;quot;: {
            const secretType &#x3D; fullParsed.type || &amp;quot;Opaque&amp;quot;;
            const dataKeys &#x3D; Object.keys(fullParsed.data || {}).length;
            description &#x3D; &#x60;Stores ${secretType} secret ${data.name || &amp;quot;unnamed&amp;quot;} with ${dataKeys} entries&#x60;;
            if (data.namespace) description +&#x3D; &#x60; in namespace ${data.namespace}&#x60;;
            break;
          }
          default:
            description &#x3D; &#x60;Kubernetes ${data.kind} named ${data.name || &amp;quot;unnamed&amp;quot;}&#x60;;
            if (data.namespace) description +&#x3D; &#x60; in namespace ${data.namespace}&#x60;;
        }
      }

      const artifact &#x3D; {
        id: artifactId,
        type: &amp;quot;infrastructure&amp;quot; as const,
        name: artifactName,
        description,
        tags: [&amp;quot;kubernetes&amp;quot;, &amp;quot;infrastructure&amp;quot;],
        metadata: {
          root: rootDir,
          filePath: e.filePath,
          kind: data.kind,
          name: data.name,
          apiVersion: data.apiVersion,
          namespace: data.namespace,
          index: data.index,
        },
      };

      artifacts.push({
        artifact,
        provenance: {
          evidence: [e.id],
          plugins: [this.name()],
          rules: [&amp;quot;kube-parsing&amp;quot;, &amp;quot;resource-extraction&amp;quot;],
          timestamp: Date.now(),
          pipelineVersion: &amp;quot;1.0.0&amp;quot;,
        },
        relationships: [],
      });
    }

    return artifacts;
  }

  private findRootDirectory(evidence: Evidence[], projectRoot: string): string | null {
    if (evidence.length &#x3D;&#x3D;&#x3D; 0) return null;

    // Get all file paths (already relative)
    const relativePaths &#x3D; evidence.map((e) &#x3D;&amp;gt; e.filePath);

    // Extract directory paths (remove filename and #index)
    const dirPaths &#x3D; relativePaths.map((relPath) &#x3D;&amp;gt; {
      const withoutIndex &#x3D; relPath.split(&amp;quot;#&amp;quot;)[0];
      return path.dirname(withoutIndex);
    });

    if (dirPaths.length &#x3D;&#x3D;&#x3D; 0) return null;

    // Split all dir paths into parts
    const dirPartsList &#x3D; dirPaths.map((dir) &#x3D;&amp;gt; dir.split(path.sep));

    // Find the minimum length
    const minLength &#x3D; Math.min(...dirPartsList.map((parts) &#x3D;&amp;gt; parts.length));

    // Find the first index where not all parts match
    let commonLength &#x3D; 0;
    for (let i &#x3D; 0; i &amp;lt; minLength; i++) {
      const part &#x3D; dirPartsList[0][i];
      if (!dirPartsList.every((parts) &#x3D;&amp;gt; parts[i] &#x3D;&#x3D;&#x3D; part)) {
        break;
      }
      commonLength &#x3D; i + 1;
    }

    // Join the common parts
    const commonDir &#x3D; dirPartsList[0].slice(0, commonLength).join(path.sep);

    if (commonDir &#x3D;&#x3D;&#x3D; &amp;quot;&amp;quot;) return &amp;quot;.&amp;quot;;
    return commonDir;
  }
}

export const kubernetesPlugin &#x3D; new KubernetesPlugin();
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(19)">
                    <span class="file-path">file-code src/plugins/rust.ts</span>
                    <div class="file-meta">
                        <span>13.80 KB</span>
                        <span>2,964 tokens</span>
                        <span>Score: 0.26</span>
                    </div>
                </div>
                <div class="file-content" id="file-19">
                    <pre class="code-block"><code>/**
 * Rust plugin with lightweight heuristics.
 *
 * Focused on a handful of strong signals that are simple to understand and
 * maintain: Cargo manifests, obvious CLI/web frameworks, and basic source
 * patterns. The goal is to surface useful artifacts without deep AST analysis.
 */

import * as path from &amp;quot;path&amp;quot;;
import { parse } from &amp;quot;@iarna/toml&amp;quot;;
import {
  type ArtifactType,
  type Evidence,
  type ImporterPlugin,
  type InferenceContext,
  type InferredArtifact,
  type ParseContext,
  type Provenance,
} from &amp;quot;../types&amp;quot;;

// Heuristic dependency buckets ------------------------------------------------
const RUST_WEB_FRAMEWORKS &#x3D; [
  &amp;quot;axum&amp;quot;,
  &amp;quot;warp&amp;quot;,
  &amp;quot;actix-web&amp;quot;,
  &amp;quot;rocket&amp;quot;,
  &amp;quot;tide&amp;quot;,
  &amp;quot;gotham&amp;quot;,
  &amp;quot;iron&amp;quot;,
  &amp;quot;nickel&amp;quot;,
  &amp;quot;tower-web&amp;quot;,
  &amp;quot;salvo&amp;quot;,
  &amp;quot;poem&amp;quot;,
];

const RUST_CLI_FRAMEWORKS &#x3D; [&amp;quot;clap&amp;quot;, &amp;quot;structopt&amp;quot;, &amp;quot;argh&amp;quot;, &amp;quot;gumdrop&amp;quot;];
const RUST_JOB_FRAMEWORKS &#x3D; [&amp;quot;tokio-cron-scheduler&amp;quot;, &amp;quot;cron&amp;quot;, &amp;quot;job-scheduler&amp;quot;];
const RUST_DATABASE_DRIVERS &#x3D; [
  &amp;quot;sqlx&amp;quot;,
  &amp;quot;diesel&amp;quot;,
  &amp;quot;rusqlite&amp;quot;,
  &amp;quot;postgres&amp;quot;,
  &amp;quot;mysql&amp;quot;,
  &amp;quot;mongodb&amp;quot;,
  &amp;quot;redis&amp;quot;,
];

interface CargoDependency {
  name: string;
  version: string;
  kind: &amp;quot;runtime&amp;quot; | &amp;quot;dev&amp;quot; | &amp;quot;build&amp;quot;;
}

interface CargoBinaryDefinition {
  name: string;
  path?: string;
}

interface CargoEvidenceData extends Record&amp;lt;string, unknown&amp;gt; {
  configType: &amp;quot;cargo-toml&amp;quot;;
  package?: {
    name?: string;
    version?: string;
    description?: string;
  };
  dependencies: Record&amp;lt;string, string&amp;gt;;
  devDependencies: Record&amp;lt;string, string&amp;gt;;
  buildDependencies: Record&amp;lt;string, string&amp;gt;;
  hasBinaries: boolean;
  hasLibrary: boolean;
  binaries: CargoBinaryDefinition[];
  fullCargo: Record&amp;lt;string, unknown&amp;gt;;
}

function isCargoEvidenceData(data: Record&amp;lt;string, unknown&amp;gt;): data is CargoEvidenceData {
  const configType &#x3D; data[&amp;quot;configType&amp;quot;];
  return typeof configType &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; &amp;amp;&amp;amp; configType &#x3D;&#x3D;&#x3D; &amp;quot;cargo-toml&amp;quot;;
}

export class RustPlugin implements ImporterPlugin {
  name(): string {
    return &amp;quot;rust&amp;quot;;
  }

  supports(filePath: string): boolean {
    const normalized &#x3D; filePath.replace(/\\/g, &amp;quot;/&amp;quot;);
    const fileName &#x3D; path.basename(normalized);

    if (fileName &#x3D;&#x3D;&#x3D; &amp;quot;Cargo.toml&amp;quot; || fileName &#x3D;&#x3D;&#x3D; &amp;quot;Cargo.lock&amp;quot;) {
      return true;
    }

    if (fileName.endsWith(&amp;quot;.rs&amp;quot;) &amp;amp;&amp;amp; normalized.includes(&amp;quot;/src/&amp;quot;)) {
      return true;
    }

    return false;
  }

  async parse(filePath: string, fileContent?: string, context?: ParseContext): Promise&amp;lt;Evidence[]&amp;gt; {
    if (!fileContent) return [];

    const normalized &#x3D; filePath.replace(/\\/g, &amp;quot;/&amp;quot;);
    const fileName &#x3D; path.basename(normalized);

    if (fileName &#x3D;&#x3D;&#x3D; &amp;quot;Cargo.toml&amp;quot;) {
      return this.parseCargoToml(normalized, fileContent, context);
    }

    if (fileName &#x3D;&#x3D;&#x3D; &amp;quot;Cargo.lock&amp;quot;) {
      return [
        {
          id: this.createEvidenceId(normalized, context),
          source: &amp;quot;rust&amp;quot;,
          type: &amp;quot;config&amp;quot;,
          filePath: normalized,
          data: { configType: &amp;quot;cargo-lock&amp;quot; },
          metadata: this.createMetadata(fileContent.length),
        },
      ];
    }

    if (normalized.includes(&amp;quot;/src/&amp;quot;) &amp;amp;&amp;amp; fileName.endsWith(&amp;quot;.rs&amp;quot;)) {
      return this.parseRustSource(normalized, fileContent, context);
    }

    return [];
  }

  async infer(evidence: Evidence[], context: InferenceContext): Promise&amp;lt;InferredArtifact[]&amp;gt; {
    const rustConfigs &#x3D; evidence.filter(
      (e) &#x3D;&amp;gt;
        e.source &#x3D;&#x3D;&#x3D; &amp;quot;rust&amp;quot; &amp;amp;&amp;amp; e.type &#x3D;&#x3D;&#x3D; &amp;quot;config&amp;quot; &amp;amp;&amp;amp; (e.data as any).configType &#x3D;&#x3D;&#x3D; &amp;quot;cargo-toml&amp;quot;,
    );

    if (rustConfigs.length &#x3D;&#x3D;&#x3D; 0) {
      return [];
    }

    const binaryDefinitions &#x3D; evidence.filter(
      (e) &#x3D;&amp;gt;
        e.source &#x3D;&#x3D;&#x3D; &amp;quot;rust&amp;quot; &amp;amp;&amp;amp;
        e.type &#x3D;&#x3D;&#x3D; &amp;quot;config&amp;quot; &amp;amp;&amp;amp;
        (e.data as any).configType &#x3D;&#x3D;&#x3D; &amp;quot;binary-definition&amp;quot;,
    );

    const artifacts: InferredArtifact[] &#x3D; [];

    for (const cargoEvidence of rustConfigs) {
      artifacts.push(...this.inferFromCargoToml(cargoEvidence, binaryDefinitions, context));
    }

    return artifacts;
  }

  // ---------------------------------------------------------------------------
  // Parsing helpers
  // ---------------------------------------------------------------------------
  private parseCargoToml(filePath: string, content: string, context?: ParseContext): Evidence[] {
    let cargo: Record&amp;lt;string, any&amp;gt;;

    try {
      cargo &#x3D; parse(content) as Record&amp;lt;string, any&amp;gt;;
    } catch (error) {
      console.warn(&amp;quot;Rust plugin: failed to parse Cargo.toml&amp;quot;, error);
      return [];
    }

    const runtimeDeps &#x3D; this.extractDependencies(cargo.dependencies, &amp;quot;runtime&amp;quot;);
    const devDeps &#x3D; this.extractDependencies(cargo[&amp;quot;dev-dependencies&amp;quot;], &amp;quot;dev&amp;quot;);
    const buildDeps &#x3D; this.extractDependencies(cargo[&amp;quot;build-dependencies&amp;quot;], &amp;quot;build&amp;quot;);
    const rawBin &#x3D; cargo.bin ?? cargo.binaries ?? cargo[&amp;quot;bin&amp;quot;];
    const binaries &#x3D; this.extractBinaries(rawBin);
    const hasBinaries &#x3D; Array.isArray(rawBin)
      ? rawBin.length &amp;gt; 0
      : Boolean(rawBin) || binaries.length &amp;gt; 0;

    const data: CargoEvidenceData &#x3D; {
      configType: &amp;quot;cargo-toml&amp;quot;,
      package: cargo.package ?? {},
      dependencies: this.dependenciesRecord(runtimeDeps),
      devDependencies: this.dependenciesRecord(devDeps),
      buildDependencies: this.dependenciesRecord(buildDeps),
      hasBinaries,
      hasLibrary: Boolean(cargo.lib),
      binaries,
      fullCargo: cargo,
    };

    const evidence: Evidence[] &#x3D; [
      {
        id: this.createEvidenceId(filePath, context),
        source: &amp;quot;rust&amp;quot;,
        type: &amp;quot;config&amp;quot;,
        filePath,
        data,
        metadata: this.createMetadata(content.length),
      },
    ];

    for (const dep of [...runtimeDeps, ...devDeps, ...buildDeps]) {
      evidence.push({
        id: &#x60;${this.createEvidenceId(filePath, context)}#${dep.kind}-${dep.name}&#x60;,
        source: &amp;quot;rust&amp;quot;,
        type: &amp;quot;dependency&amp;quot;,
        filePath,
        data: {
          dependencyType: dep.kind,
          name: dep.name,
          version: dep.version,
        },
        metadata: this.createMetadata(0),
      });
    }

    for (const bin of binaries) {
      evidence.push({
        id: &#x60;${this.createEvidenceId(filePath, context)}#bin-${bin.name}&#x60;,
        source: &amp;quot;rust&amp;quot;,
        type: &amp;quot;config&amp;quot;,
        filePath,
        data: {
          configType: &amp;quot;binary-definition&amp;quot;,
          binaryName: bin.name,
          binaryPath: bin.path,
        },
        metadata: this.createMetadata(0),
      });
    }

    return evidence;
  }

  private parseRustSource(filePath: string, content: string, context?: ParseContext): Evidence[] {
    const evidence: Evidence[] &#x3D; [];
    const baseId &#x3D; this.createEvidenceId(filePath, context);
    const metadata &#x3D; this.createMetadata(content.length);

    if (/fn\s+main\s*\(/.test(content)) {
      evidence.push({
        id: &#x60;${baseId}#main&#x60;,
        source: &amp;quot;rust&amp;quot;,
        type: &amp;quot;function&amp;quot;,
        filePath,
        data: {
          functionType: &amp;quot;main&amp;quot;,
          isEntryPoint: true,
        },
        metadata,
      });
    }

    if (/#\s*\[\s*tokio::main/.test(content)) {
      evidence.push({
        id: &#x60;${baseId}#async-main&#x60;,
        source: &amp;quot;rust&amp;quot;,
        type: &amp;quot;function&amp;quot;,
        filePath,
        data: {
          functionType: &amp;quot;async-main&amp;quot;,
          runtime: &amp;quot;tokio&amp;quot;,
        },
        metadata,
      });
    }

    const frameworkMatch &#x3D; this.findFirstMatch(content, RUST_WEB_FRAMEWORKS);
    if (frameworkMatch) {
      evidence.push({
        id: &#x60;${baseId}#framework-${frameworkMatch}&#x60;,
        source: &amp;quot;rust&amp;quot;,
        type: &amp;quot;config&amp;quot;,
        filePath,
        data: {
          configType: &amp;quot;source-framework&amp;quot;,
          framework: frameworkMatch,
        },
        metadata,
      });
    }

    return evidence;
  }

  // ---------------------------------------------------------------------------
  // Inference helpers
  // ---------------------------------------------------------------------------
  private inferFromCargoToml(
    cargoEvidence: Evidence,
    binaryEvidence: Evidence[],
    context: InferenceContext,
  ): InferredArtifact[] {
    const cargoData &#x3D; cargoEvidence.data;
    if (!isCargoEvidenceData(cargoData)) {
      return [];
    }
    const data &#x3D; cargoData;
    const packageName &#x3D; data.package?.name || path.basename(path.dirname(cargoEvidence.filePath));
    const description &#x3D; data.package?.description || &amp;quot;Rust project&amp;quot;;

    const mergedDeps: Record&amp;lt;string, string&amp;gt; &#x3D; {
      ...data.dependencies,
      ...data.devDependencies,
      ...data.buildDependencies,
    };
    const dependencyNames &#x3D; Object.keys(mergedDeps);

    const framework &#x3D; this.findFirstMatch(dependencyNames, RUST_WEB_FRAMEWORKS);
    const cliFramework &#x3D; this.findFirstMatch(dependencyNames, RUST_CLI_FRAMEWORKS);
    const jobFramework &#x3D; this.findFirstMatch(dependencyNames, RUST_JOB_FRAMEWORKS);
    const databaseDriver &#x3D; this.findFirstMatch(dependencyNames, RUST_DATABASE_DRIVERS);

    const binariesForCrate &#x3D; binaryEvidence.filter((e) &#x3D;&amp;gt; e.filePath &#x3D;&#x3D;&#x3D; cargoEvidence.filePath);
    const hasExplicitBinary &#x3D; data.hasBinaries || binariesForCrate.length &amp;gt; 0;

    let artifactType: ArtifactType &#x3D; &amp;quot;package&amp;quot;;
    if (framework) {
      artifactType &#x3D; &amp;quot;service&amp;quot;;
    } else if (jobFramework) {
      artifactType &#x3D; &amp;quot;job&amp;quot;;
    } else if (hasExplicitBinary) {
      artifactType &#x3D; &amp;quot;binary&amp;quot;;
    }

    // Prefer binary names when available to avoid generic package titles.
    const binaryMatch &#x3D; binariesForCrate.find((e) &#x3D;&amp;gt; {
      const data &#x3D; e.data as Record&amp;lt;string, unknown&amp;gt;;
      return typeof data[&amp;quot;binaryName&amp;quot;] &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;;
    });
    const binaryData &#x3D; binaryMatch?.data as Record&amp;lt;string, unknown&amp;gt; | undefined;
    const binaryNameValue &#x3D; binaryData?.binaryName;
    const artifactName &#x3D; typeof binaryNameValue &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; ? binaryNameValue : packageName;

    const metadata: Record&amp;lt;string, unknown&amp;gt; &#x3D; {
      sourceFile: cargoEvidence.filePath,
      root: path.dirname(cargoEvidence.filePath),
      manifest: &amp;quot;Cargo.toml&amp;quot;,
      language: &amp;quot;rust&amp;quot;,
      packageManager: &amp;quot;cargo&amp;quot;,
      dependencies: dependencyNames,
    };

    if (framework) metadata.framework &#x3D; framework;
    if (artifactType &#x3D;&#x3D;&#x3D; &amp;quot;binary&amp;quot; &amp;amp;&amp;amp; cliFramework) metadata.cliFramework &#x3D; cliFramework;
    if (jobFramework) metadata.jobFramework &#x3D; jobFramework;
    if (databaseDriver) metadata.databaseDriver &#x3D; databaseDriver;
    if (data.package?.version) metadata.version &#x3D; data.package.version;
    const binaryPath &#x3D; binaryData?.binaryPath;
    if (typeof binaryPath &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
      metadata.entryPoint &#x3D; binaryPath;
    }

    const tags &#x3D; new Set&amp;lt;string&amp;gt;([&amp;quot;rust&amp;quot;]);
    if (artifactType &#x3D;&#x3D;&#x3D; &amp;quot;binary&amp;quot;) tags.add(&amp;quot;tool&amp;quot;);
    if (artifactType &#x3D;&#x3D;&#x3D; &amp;quot;service&amp;quot;) tags.add(&amp;quot;service&amp;quot;);
    if (artifactType &#x3D;&#x3D;&#x3D; &amp;quot;package&amp;quot; || data.hasLibrary) tags.add(&amp;quot;package&amp;quot;);
    if (artifactType &#x3D;&#x3D;&#x3D; &amp;quot;job&amp;quot;) tags.add(&amp;quot;job&amp;quot;);

    const provenance: Provenance &#x3D; {
      evidence: [cargoEvidence.id],
      plugins: [&amp;quot;rust&amp;quot;],
      rules: [&amp;quot;cargo-heuristics&amp;quot;],
      timestamp: Date.now(),
      pipelineVersion: &amp;quot;1.0.0&amp;quot;,
    };

    const artifact &#x3D; {
      id: &#x60;rust-${artifactType}-${artifactName}&#x60;,
      type: artifactType,
      name: artifactName,
      description,
      tags: Array.from(tags),
      metadata,
    };

    return [
      {
        artifact,
        provenance,
        relationships: [],
      },
    ];
  }

  private extractDependencies(
    deps: Record&amp;lt;string, any&amp;gt; | undefined,
    kind: CargoDependency[&amp;quot;kind&amp;quot;],
  ): CargoDependency[] {
    if (!deps) return [];

    return Object.entries(deps).map(([name, value]) &#x3D;&amp;gt; {
      if (typeof value &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
        return { name, version: value, kind };
      }
      if (value &amp;amp;&amp;amp; typeof value &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot; &amp;amp;&amp;amp; typeof value.version &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
        return { name, version: value.version, kind };
      }
      return { name, version: &amp;quot;workspace&amp;quot;, kind };
    });
  }

  private extractBinaries(binSection: unknown): CargoBinaryDefinition[] {
    if (!binSection) return [];
    if (Array.isArray(binSection)) {
      return binSection
        .map((entry) &#x3D;&amp;gt; {
          if (typeof entry &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
            return { name: entry };
          }
          if (entry &amp;amp;&amp;amp; typeof entry &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot;) {
            const record &#x3D; entry as Record&amp;lt;string, unknown&amp;gt;;
            if (typeof record.name &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
              return {
                name: record.name,
                path: typeof record.path &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; ? record.path : undefined,
              };
            }
          }
          return null;
        })
        .filter((value): value is CargoBinaryDefinition &#x3D;&amp;gt; value !&#x3D;&#x3D; null);
    }
    if (typeof binSection &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot;) {
      const name &#x3D; (binSection as Record&amp;lt;string, any&amp;gt;).name;
      if (typeof name &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot;) {
        return [
          {
            name,
            path: (binSection as Record&amp;lt;string, any&amp;gt;).path as string | undefined,
          },
        ];
      }
    }
    return [];
  }

  private dependenciesRecord(deps: CargoDependency[]): Record&amp;lt;string, string&amp;gt; {
    return deps.reduce&amp;lt;Record&amp;lt;string, string&amp;gt;&amp;gt;((acc, dep) &#x3D;&amp;gt; {
      acc[dep.name] &#x3D; dep.version;
      return acc;
    }, {});
  }

  private findFirstMatch(source: string | string[], candidates: string[]): string | undefined {
    const haystack &#x3D; Array.isArray(source) ? source : [source];
    for (const item of haystack) {
      const lower &#x3D; item.toLowerCase();
      const match &#x3D; candidates.find((candidate) &#x3D;&amp;gt; lower.includes(candidate.toLowerCase()));
      if (match) return match;
    }
    return undefined;
  }

  private createEvidenceId(filePath: string, context?: { projectRoot?: string }): string {
    const root &#x3D; context?.projectRoot ?? process.cwd();
    const relative &#x3D; path.relative(root, filePath);
    return relative &#x3D;&#x3D;&#x3D; &amp;quot;&amp;quot; ? filePath : relative;
  }

  private createMetadata(size: number) {
    return {
      timestamp: Date.now(),
      fileSize: size,
    };
  }
}

export const rustPlugin &#x3D; new RustPlugin();
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(20)">
                    <span class="file-path">file-code src/plugins/terraform.ts</span>
                    <div class="file-meta">
                        <span>6.84 KB</span>
                        <span>1,451 tokens</span>
                        <span>Score: 0.26</span>
                    </div>
                </div>
                <div class="file-content" id="file-20">
                    <pre class="code-block"><code>import * as path from &amp;quot;path&amp;quot;;
import * as fs from &amp;quot;fs-extra&amp;quot;;
import type {
  ConfidenceScore,
  Evidence,
  ImporterPlugin,
  InferenceContext,
  InferredArtifact,
  ParseContext,
  Provenance,
} from &amp;quot;../types&amp;quot;;

export interface TerraformData {
  name?: string;
  type: string;
  provider?: string;
  filePath: string;
  [key: string]: unknown;
}

export class TerraformPlugin implements ImporterPlugin {
  name(): string {
    return &amp;quot;terraform&amp;quot;;
  }

  supports(filePath: string): boolean {
    const basename &#x3D; path.basename(filePath).toLowerCase();
    const relative &#x3D; path.relative(process.cwd(), filePath).toLowerCase();
    return (
      basename.endsWith(&amp;quot;.tf&amp;quot;) ||
      basename.endsWith(&amp;quot;.tf.json&amp;quot;) ||
      basename &#x3D;&#x3D;&#x3D; &amp;quot;.terraform.lock.hcl&amp;quot; ||
      relative.includes(&amp;quot;terraform&amp;quot;)
    );
  }

  async parse(filePath: string, fileContent?: string, context?: ParseContext): Promise&amp;lt;Evidence[]&amp;gt; {
    if (!fileContent) {
      throw new Error(&amp;quot;File content required for Terraform parsing&amp;quot;);
    }

    const evidence: Evidence[] &#x3D; [];
    const basename &#x3D; path.basename(filePath).toLowerCase();

    try {
      if (basename &#x3D;&#x3D;&#x3D; &amp;quot;.terraform.lock.hcl&amp;quot;) {
        // Parse lockfile for providers and modules
        const lockEvidence &#x3D; this.parseTerraformLock(
          fileContent,
          filePath,
          context?.projectRoot || &amp;quot;/&amp;quot;,
        );
        evidence.push(...lockEvidence);
      } else if (basename.endsWith(&amp;quot;.tf&amp;quot;)) {
        // Parse .tf files for resources, providers, etc.
        const tfEvidence &#x3D; this.parseTerraformFile(
          fileContent,
          filePath,
          context?.projectRoot || &amp;quot;/&amp;quot;,
        );
        evidence.push(...tfEvidence);
      }
    } catch (error) {
      console.warn(&#x60;Failed to parse Terraform file ${filePath}:&#x60;, error);
    }

    return evidence;
  }

  private parseTerraformLock(content: string, filePath: string, projectRoot: string): Evidence[] {
    const evidence: Evidence[] &#x3D; [];

    // Simple parsing for lockfile - look for provider blocks
    const providerMatches &#x3D; content.match(
      /provider\s+&amp;quot;([^&amp;quot;]+)&amp;quot;\s+\(\n\s+version\s+&#x3D;\s+&amp;quot;([^&amp;quot;]+)&amp;quot;\n\s+\)/g,
    );
    if (providerMatches) {
      providerMatches.forEach((match, index) &#x3D;&amp;gt; {
        const providerName &#x3D; match.match(/provider\s+&amp;quot;([^&amp;quot;]+)&amp;quot;/)?.[1];
        const data: TerraformData &#x3D; {
          name: &#x60;provider&#x60;,
          type: &amp;quot;provider&amp;quot;,
          provider: providerName,
          filePath,
        };

        const evidenceId &#x3D; &#x60;${path.relative(projectRoot, filePath)}&#x60;;
        evidence.push({
          id: evidenceId,
          source: this.name(),
          type: &amp;quot;infrastructure&amp;quot;,
          filePath,
          data,
          metadata: {
            timestamp: Date.now(),
            fileSize: content.length,
          },
        });
      });
    }

    return evidence;
  }

  private parseTerraformFile(content: string, filePath: string, projectRoot: string): Evidence[] {
    const evidence: Evidence[] &#x3D; [];

    // Parse for resource, data, provider blocks
    const resourceMatches &#x3D; content.match(/resource\s+&amp;quot;([^&amp;quot;]+)&amp;quot;\s+&amp;quot;([^&amp;quot;]+)&amp;quot;\s*\{/g);
    if (resourceMatches) {
      resourceMatches.forEach((match, index) &#x3D;&amp;gt; {
        const provider &#x3D; match.match(/resource\s+&amp;quot;([^&amp;quot;]+)&amp;quot;/)?.[1];
        const name &#x3D; match.match(/resource\s+&amp;quot;[^&amp;quot;]+&amp;quot;\s+&amp;quot;([^&amp;quot;]+)&amp;quot;/)?.[1];

        const data: TerraformData &#x3D; {
          name,
          type: &amp;quot;resource&amp;quot;,
          provider,
          filePath,
        };

        const evidenceId &#x3D; &#x60;${path.relative(projectRoot, filePath)}&#x60;;
        evidence.push({
          id: evidenceId,
          source: this.name(),
          type: &amp;quot;infrastructure&amp;quot;,
          filePath,
          data,
          metadata: {
            timestamp: Date.now(),
            fileSize: content.length,
          },
        });
      });
    }

    // Parse provider blocks
    const providerMatches &#x3D; content.match(/provider\s+&amp;quot;([^&amp;quot;]+)&amp;quot;\s*\{/g);
    if (providerMatches) {
      providerMatches.forEach((match, index) &#x3D;&amp;gt; {
        const providerName &#x3D; match.match(/provider\s+&amp;quot;([^&amp;quot;]+)&amp;quot;/)?.[1];

        const data: TerraformData &#x3D; {
          name: &#x60;${providerName}&#x60;,
          type: &amp;quot;provider&amp;quot;,
          provider: providerName,
          filePath,
        };

        const evidenceId &#x3D; &#x60;${path.relative(projectRoot, filePath)}&#x60;;
        evidence.push({
          id: evidenceId,
          source: this.name(),
          type: &amp;quot;infrastructure&amp;quot;,
          filePath,
          data,
          metadata: {
            timestamp: Date.now(),
            fileSize: content.length,
          },
        });
      });
    }

    return evidence;
  }

  async infer(evidence: Evidence[], context: InferenceContext): Promise&amp;lt;InferredArtifact[]&amp;gt; {
    const artifacts: InferredArtifact[] &#x3D; [];

    // Filter Terraform evidence
    const tfEvidence &#x3D; evidence.filter(
      (e) &#x3D;&amp;gt; e.source &#x3D;&#x3D;&#x3D; this.name() &amp;amp;&amp;amp; e.type &#x3D;&#x3D;&#x3D; &amp;quot;infrastructure&amp;quot;,
    );

    if (tfEvidence.length &#x3D;&#x3D;&#x3D; 0) return artifacts;

    // Find directories with .terraform.lock.hcl as root
    const lockFilePaths &#x3D; tfEvidence
      .filter((e) &#x3D;&amp;gt; e.filePath.endsWith(&amp;quot;.terraform.lock.hcl&amp;quot;))
      .map((e) &#x3D;&amp;gt; path.dirname(e.filePath));
    if (lockFilePaths.length &#x3D;&#x3D;&#x3D; 0) return artifacts;

    for (const lockDir of lockFilePaths) {
      // Collect all tf files in this directory tree
      const tfFilesInDir &#x3D; tfEvidence
        .filter((e) &#x3D;&amp;gt; e.filePath.startsWith(lockDir) &amp;amp;&amp;amp; e.filePath.endsWith(&amp;quot;.tf&amp;quot;))
        .map((e) &#x3D;&amp;gt; e.filePath);

      if (tfFilesInDir.length &#x3D;&#x3D;&#x3D; 0) continue;

      // Extract resources from evidence in this group
      const groupEvidence &#x3D; tfEvidence.filter((e) &#x3D;&amp;gt; e.filePath.startsWith(lockDir));
      const resources &#x3D; groupEvidence
        .filter((e) &#x3D;&amp;gt; e.data.type &#x3D;&#x3D;&#x3D; &amp;quot;resource&amp;quot;)
        .map((e) &#x3D;&amp;gt; {
          const data &#x3D; e.data as TerraformData;
          return { kind: data.type || &amp;quot;resource&amp;quot;, name: data.name, apiVersion: data.provider };
        });

      const artifact &#x3D; {
        id: &#x60;${path.basename(lockDir)}&#x60;,
        type: &amp;quot;infrastructure&amp;quot; as const,
        name: &#x60;Terraform Infrastructure (${path.basename(lockDir)})&#x60;,
        description: &#x60;Terraform configurations in ${lockDir}&#x60;,
        tags: [&amp;quot;terraform&amp;quot;, &amp;quot;infrastructure&amp;quot;],
        metadata: {
          root: lockDir,
          files: [...tfFilesInDir, path.join(lockDir, &amp;quot;.terraform.lock.hcl&amp;quot;)],
          kind: &amp;quot;terraform&amp;quot; as const,
          resources,
        },
      };

      artifacts.push({
        artifact,
        provenance: {
          evidence: groupEvidence.map((e) &#x3D;&amp;gt; e.id),
          plugins: [&amp;quot;terraform&amp;quot;],
          rules: [&amp;quot;tf-grouping&amp;quot;, &amp;quot;lockfile-detection&amp;quot;],
          timestamp: Date.now(),
          pipelineVersion: &amp;quot;1.0.0&amp;quot;,
        },
        relationships: [],
      });
    }

    return artifacts;
  }
}

export const terraformPlugin &#x3D; new TerraformPlugin();
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(21)">
                    <span class="file-path">file-code src/plugins/go.ts</span>
                    <div class="file-meta">
                        <span>5.06 KB</span>
                        <span>1,185 tokens</span>
                        <span>Score: 0.24</span>
                    </div>
                </div>
                <div class="file-content" id="file-21">
                    <pre class="code-block"><code>/**
 * Simplified Go Plugin for Package Detection
 *
 * Detects Go packages via go.mod and guesses artifact type based on structure and dependencies.
 */

import * as path from &amp;quot;path&amp;quot;;
import {
  Evidence,
  ImporterPlugin,
  InferenceContext,
  InferredArtifact,
  ParseContext,
  Provenance,
} from &amp;quot;../types&amp;quot;;

// Go framework detection lists
const GO_WEB_FRAMEWORKS &#x3D; [&amp;quot;gin&amp;quot;, &amp;quot;echo&amp;quot;, &amp;quot;fiber&amp;quot;, &amp;quot;chi&amp;quot;, &amp;quot;mux&amp;quot;, &amp;quot;goji&amp;quot;, &amp;quot;iris&amp;quot;, &amp;quot;revel&amp;quot;];

const GO_CLI_FRAMEWORKS &#x3D; [&amp;quot;cobra&amp;quot;, &amp;quot;cli&amp;quot;, &amp;quot;urfave/cli&amp;quot;, &amp;quot;mitchellh/cli&amp;quot;];

const GO_JOB_FRAMEWORKS &#x3D; [&amp;quot;cron&amp;quot;, &amp;quot;gocron&amp;quot;, &amp;quot;gronx&amp;quot;];

const GO_DATABASE_DRIVERS &#x3D; [
  &amp;quot;gorm&amp;quot;,
  &amp;quot;sqlx&amp;quot;,
  &amp;quot;go-sql-driver/mysql&amp;quot;,
  &amp;quot;lib/pq&amp;quot;,
  &amp;quot;redis/go-redis&amp;quot;,
  &amp;quot;mongo-driver/mongo&amp;quot;,
];

export interface GoData extends Record&amp;lt;string, unknown&amp;gt; {
  name: string;
  description: string;
  type: string;
  filePath: string;
}

export class GoPlugin implements ImporterPlugin {
  name(): string {
    return &amp;quot;go&amp;quot;;
  }

  supports(filePath: string, fileContent?: string): boolean {
    const fileName &#x3D; path.basename(filePath);
    const extension &#x3D; path.extname(filePath);

    // Focus on go.mod and basic Go sources
    if (fileName &#x3D;&#x3D;&#x3D; &amp;quot;go.mod&amp;quot;) {
      return true;
    }

    if (extension &#x3D;&#x3D;&#x3D; &amp;quot;.go&amp;quot;) {
      return fileName &#x3D;&#x3D;&#x3D; &amp;quot;main.go&amp;quot; || fileName &#x3D;&#x3D;&#x3D; &amp;quot;main_test.go&amp;quot;;
    }

    return false;
  }

  async parse(filePath: string, fileContent?: string, context?: ParseContext): Promise&amp;lt;Evidence[]&amp;gt; {
    if (!fileContent || path.basename(filePath) !&#x3D;&#x3D; &amp;quot;go.mod&amp;quot;) return [];

    const evidence: Evidence[] &#x3D; [];
    const baseId &#x3D; path.relative(context?.projectRoot ?? process.cwd(), filePath);

    try {
      return this.parseGoMod(filePath, fileContent, baseId);
    } catch (error) {
      console.warn(&#x60;Go plugin failed to parse ${filePath}:&#x60;, error);
    }

    return evidence;
  }

  async infer(evidence: Evidence[], context: InferenceContext): Promise&amp;lt;InferredArtifact[]&amp;gt; {
    const goEvidence &#x3D; evidence.filter((e) &#x3D;&amp;gt; e.source &#x3D;&#x3D;&#x3D; &amp;quot;go&amp;quot;);
    if (goEvidence.length &#x3D;&#x3D;&#x3D; 0) return [];

    const artifacts: InferredArtifact[] &#x3D; [];
    const goModEvidence &#x3D; goEvidence.filter((e) &#x3D;&amp;gt; e.type &#x3D;&#x3D;&#x3D; &amp;quot;config&amp;quot;);

    for (const goMod of goModEvidence) {
      artifacts.push(...this.inferFromGoMod(goMod, evidence, context));
    }

    return artifacts;
  }

  // Parse go.mod
  private parseGoMod(filePath: string, content: string, baseId: string): Evidence[] {
    const evidence: Evidence[] &#x3D; [];
    let goMod;

    try {
      // Simple parsing for go.mod
      const lines &#x3D; content.split(&amp;quot;\n&amp;quot;);
      const moduleLine &#x3D; lines.find((line) &#x3D;&amp;gt; line.startsWith(&amp;quot;module &amp;quot;));
      const goLine &#x3D; lines.find((line) &#x3D;&amp;gt; line.startsWith(&amp;quot;go &amp;quot;));
      const requireLines &#x3D; lines.filter((line) &#x3D;&amp;gt; line.startsWith(&amp;quot;\t&amp;quot;) &amp;amp;&amp;amp; line.includes(&amp;quot; &amp;quot;));

      const moduleName &#x3D; moduleLine
        ? moduleLine.replace(&amp;quot;module &amp;quot;, &amp;quot;&amp;quot;).trim()
        : path.basename(path.dirname(filePath));
      const goVersion &#x3D; goLine ? goLine.replace(&amp;quot;go &amp;quot;, &amp;quot;&amp;quot;).trim() : &amp;quot;1.0&amp;quot;;

      const deps &#x3D; requireLines.map((line) &#x3D;&amp;gt; {
        const parts &#x3D; line.trim().split(&amp;quot; &amp;quot;);
        return parts[0].replace(&amp;quot;\t&amp;quot;, &amp;quot;&amp;quot;);
      });

      const inferredType &#x3D; this.determineGoType(deps);

      const goData: GoData &#x3D; {
        name: moduleName,
        description: &amp;quot;Go package&amp;quot;,
        type: inferredType,
        filePath,
      };

      evidence.push({
        id: baseId,
        source: &amp;quot;go&amp;quot;,
        type: &amp;quot;config&amp;quot;,
        filePath,
        data: goData,
        metadata: { timestamp: Date.now(), fileSize: content.length },
      });
    } catch (error) {
      console.warn(&amp;quot;Failed to parse go.mod:&amp;quot;, error);
    }

    return evidence;
  }

  // Simplified inference
  private inferFromGoMod(
    goModEvidence: Evidence,
    allEvidence: Evidence[],
    context: InferenceContext,
  ): InferredArtifact[] {
    const goData &#x3D; goModEvidence.data as unknown as GoData;
    const name &#x3D; goData.name;
    const artifacts: InferredArtifact[] &#x3D; [];

    const artifact &#x3D; {
      id: &#x60;go-${goData.type}-${name}&#x60;,
      type: goData.type as any,
      name,
      description: goData.description,
      tags: [&amp;quot;go&amp;quot;, goData.type],
      metadata: {
        sourceFile: goData.filePath,
        root: path.dirname(goData.filePath),
        manifest: &amp;quot;go.mod&amp;quot;,
        language: &amp;quot;go&amp;quot;,
      },
    };

    artifacts.push({
      artifact,
      provenance: {
        evidence: [goModEvidence.id],
        plugins: [&amp;quot;go&amp;quot;],
        rules: [&amp;quot;go-mod-simplification&amp;quot;],
        timestamp: Date.now(),
        pipelineVersion: &amp;quot;1.0.0&amp;quot;,
      },
      relationships: [],
    });

    return artifacts;
  }

  private determineGoType(deps: string[]): string {
    const hasWeb &#x3D; deps.some((d) &#x3D;&amp;gt; GO_WEB_FRAMEWORKS.some((f) &#x3D;&amp;gt; d.includes(f)));
    const hasCli &#x3D; deps.some((d) &#x3D;&amp;gt; GO_CLI_FRAMEWORKS.some((f) &#x3D;&amp;gt; d.includes(f)));
    const hasJob &#x3D; deps.some((d) &#x3D;&amp;gt; GO_JOB_FRAMEWORKS.some((f) &#x3D;&amp;gt; d.includes(f)));

    if (hasWeb) return &amp;quot;service&amp;quot;;
    if (hasCli) return &amp;quot;binary&amp;quot;;
    if (hasJob) return &amp;quot;job&amp;quot;;
    return &amp;quot;package&amp;quot;;
  }
}

export const goPlugin &#x3D; new GoPlugin();
</code></pre>
                </div>
            </div>
            <div class="file-section">
                <div class="file-header" onclick="toggleFile(22)">
                    <span class="file-path">file-code src/plugins/python.ts</span>
                    <div class="file-meta">
                        <span>27.47 KB</span>
                        <span>5,801 tokens</span>
                        <span>Score: 0.24</span>
                    </div>
                </div>
                <div class="file-content" id="file-22">
                    <pre class="code-block"><code>/**
 * Python Plugin for Brownfield Detection
 *
 * Comprehensive plugin for detecting Python artifacts including web services,
 * CLI tools, data processing scripts, and libraries. Analyzes setup.py, pyproject.toml,
 * requirements.txt, and source files to infer application architecture.
 */

import * as path from &amp;quot;path&amp;quot;;
import {
  type ArtifactType,
  type Evidence,
  type ImporterPlugin,
  type InferenceContext,
  type InferredArtifact,
  type ParseContext,
  type Provenance,
} from &amp;quot;../types&amp;quot;;

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// Python Configuration Data Types
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

interface PythonPackageData extends Record&amp;lt;string, unknown&amp;gt; {
  configType: string;
  name: string;
  version?: string;
  description?: string;
  dependencies: string[];
  devDependencies: string[];
  scripts: Record&amp;lt;string, string&amp;gt;;
  entryPoints?: Record&amp;lt;string, string&amp;gt;;
  author?: string;
  license?: string;
  keywords?: string[];
  homepage?: string;
  repository?: string;
}

interface PythonSourceData extends Record&amp;lt;string, unknown&amp;gt; {
  configType: string;
  filePath: string;
  hasImports: boolean;
  hasIfMain: boolean;
  isPackageInit: boolean;
  imports: string[];
  webFrameworks: string[];
  cliPatterns: string[];
  dataProcessingPatterns: string[];
}

// Simplified heuristics to align with Node and Rust manifest classification
const PYTHON_WEB_FRAMEWORKS &#x3D; [
  &amp;quot;django&amp;quot;,
  &amp;quot;flask&amp;quot;,
  &amp;quot;fastapi&amp;quot;,
  &amp;quot;tornado&amp;quot;,
  &amp;quot;sanic&amp;quot;,
  &amp;quot;starlette&amp;quot;,
  &amp;quot;bottle&amp;quot;,
  &amp;quot;falcon&amp;quot;,
  &amp;quot;pyramid&amp;quot;,
];

const PYTHON_CLI_LIBRARIES &#x3D; [&amp;quot;click&amp;quot;, &amp;quot;typer&amp;quot;, &amp;quot;argparse&amp;quot;, &amp;quot;fire&amp;quot;, &amp;quot;docopt&amp;quot;];

const PYTHON_FRONTEND_LIBRARIES &#x3D; [&amp;quot;streamlit&amp;quot;, &amp;quot;dash&amp;quot;, &amp;quot;gradio&amp;quot;, &amp;quot;panel&amp;quot;];

function normalizeDependencyName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9_.-].*$/i, &amp;quot;&amp;quot;)
    .replace(/_/g, &amp;quot;-&amp;quot;);
}

function collectNormalizedDependencies(values: string[] | undefined): Set&amp;lt;string&amp;gt; {
  const set &#x3D; new Set&amp;lt;string&amp;gt;();
  if (!values) return set;
  for (const value of values) {
    if (!value) continue;
    const normalized &#x3D; normalizeDependencyName(String(value));
    if (normalized) {
      set.add(normalized);
    }
  }
  return set;
}

interface PythonClassification {
  artifactType: ArtifactType;
  detectedType: string;
  reason: string;
  framework?: string;
}

function classifyPythonPackage(packageData: PythonPackageData): PythonClassification {
  const dependencySet &#x3D; collectNormalizedDependencies(packageData.dependencies);
  const devDependencySet &#x3D; collectNormalizedDependencies(packageData.devDependencies);
  const combinedDeps &#x3D; new Set&amp;lt;string&amp;gt;([...dependencySet, ...devDependencySet]);

  const findDependency &#x3D; (candidates: string[]): string | undefined &#x3D;&amp;gt; {
    return candidates.find((candidate) &#x3D;&amp;gt; combinedDeps.has(candidate));
  };

  const matchedWebFramework &#x3D; findDependency(PYTHON_WEB_FRAMEWORKS);
  if (matchedWebFramework) {
    return {
      artifactType: &amp;quot;service&amp;quot;,
      detectedType: &amp;quot;service&amp;quot;,
      reason: &amp;quot;web-framework&amp;quot;,
      framework: matchedWebFramework,
    };
  }

  const hasScripts &#x3D; Object.keys(packageData.scripts || {}).length &amp;gt; 0;
  const hasConsoleEntry &#x3D; Boolean(
    packageData.entryPoints &amp;amp;&amp;amp;
      typeof packageData.entryPoints &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot; &amp;amp;&amp;amp;
      Object.keys((packageData.entryPoints as Record&amp;lt;string, unknown&amp;gt;).console_scripts ?? {})
        .length &amp;gt; 0,
  );
  const matchedCliLibrary &#x3D; findDependency(PYTHON_CLI_LIBRARIES);

  if (matchedCliLibrary || hasScripts || hasConsoleEntry) {
    return {
      artifactType: &amp;quot;binary&amp;quot;,
      detectedType: &amp;quot;cli&amp;quot;,
      reason: matchedCliLibrary ? &amp;quot;cli-library&amp;quot; : &amp;quot;console-script&amp;quot;,
      framework: matchedCliLibrary,
    };
  }

  const matchedFrontendLibrary &#x3D; findDependency(PYTHON_FRONTEND_LIBRARIES);
  if (matchedFrontendLibrary) {
    return {
      artifactType: &amp;quot;frontend&amp;quot;,
      detectedType: &amp;quot;frontend&amp;quot;,
      reason: &amp;quot;frontend-library&amp;quot;,
      framework: matchedFrontendLibrary,
    };
  }

  return {
    artifactType: &amp;quot;package&amp;quot;,
    detectedType: &amp;quot;package&amp;quot;,
    reason: &amp;quot;default-package&amp;quot;,
  };
}

function classifyPythonSource(evidence: PythonSourceData[]): PythonClassification {
  let matchedFramework: string | undefined;
  let hasCli &#x3D; false;

  for (const item of evidence) {
    if (!matchedFramework &amp;amp;&amp;amp; item.webFrameworks?.length) {
      matchedFramework &#x3D; item.webFrameworks[0];
    }
    if (item.cliPatterns?.length || item.hasIfMain) {
      hasCli &#x3D; true;
    }
  }

  if (matchedFramework) {
    return {
      artifactType: &amp;quot;service&amp;quot;,
      detectedType: &amp;quot;service&amp;quot;,
      reason: &amp;quot;source-web-framework&amp;quot;,
      framework: matchedFramework,
    };
  }

  if (hasCli) {
    return {
      artifactType: &amp;quot;binary&amp;quot;,
      detectedType: &amp;quot;cli&amp;quot;,
      reason: &amp;quot;source-cli-pattern&amp;quot;,
    };
  }

  return {
    artifactType: &amp;quot;package&amp;quot;,
    detectedType: &amp;quot;package&amp;quot;,
    reason: &amp;quot;source-default&amp;quot;,
  };
}

// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
// Main Plugin Implementation
// &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

export class PythonPlugin implements ImporterPlugin {
  name(): string {
    return &amp;quot;python&amp;quot;;
  }

  supports(filePath: string, fileContent?: string): boolean {
    const fileName &#x3D; path.basename(filePath);
    const extension &#x3D; path.extname(filePath);

    // Support Python configuration files
    if (
      [
        &amp;quot;setup.py&amp;quot;,
        &amp;quot;pyproject.toml&amp;quot;,
        &amp;quot;requirements.txt&amp;quot;,
        &amp;quot;Pipfile&amp;quot;,
        &amp;quot;poetry.lock&amp;quot;,
        &amp;quot;setup.cfg&amp;quot;,
        &amp;quot;environment.yml&amp;quot;,
        &amp;quot;conda.yml&amp;quot;,
      ].includes(fileName)
    ) {
      return true;
    }

    // Support Python source files
    if ([&amp;quot;.py&amp;quot;, &amp;quot;.pyx&amp;quot;, &amp;quot;.pyi&amp;quot;].includes(extension)) {
      return true;
    }

    return false;
  }

  async parse(filePath: string, fileContent?: string, context?: ParseContext): Promise&amp;lt;Evidence[]&amp;gt; {
    if (!fileContent) return [];

    const evidence: Evidence[] &#x3D; [];
    const fileName &#x3D; path.basename(filePath);
    const baseId &#x3D; path.relative(context?.projectRoot ?? process.cwd(), filePath);

    try {
      if (fileName &#x3D;&#x3D;&#x3D; &amp;quot;setup.py&amp;quot;) {
        evidence.push(...(await this.parseSetupPy(filePath, fileContent, baseId)));
      } else if (fileName &#x3D;&#x3D;&#x3D; &amp;quot;pyproject.toml&amp;quot;) {
        evidence.push(...(await this.parsePyprojectToml(filePath, fileContent, baseId)));
      } else if (fileName &#x3D;&#x3D;&#x3D; &amp;quot;requirements.txt&amp;quot;) {
        evidence.push(...(await this.parseRequirementsTxt(filePath, fileContent, baseId)));
      } else if (fileName &#x3D;&#x3D;&#x3D; &amp;quot;Pipfile&amp;quot;) {
        evidence.push(...(await this.parsePipfile(filePath, fileContent, baseId)));
      } else if (path.extname(filePath) &#x3D;&#x3D;&#x3D; &amp;quot;.py&amp;quot;) {
        evidence.push(...(await this.parsePythonSource(filePath, fileContent, baseId)));
      }
    } catch (error) {
      console.warn(&#x60;Python plugin failed to parse ${filePath}:&#x60;, error);
    }

    return evidence;
  }

  async infer(evidence: Evidence[], context: InferenceContext): Promise&amp;lt;InferredArtifact[]&amp;gt; {
    const pythonEvidence &#x3D; evidence.filter((e) &#x3D;&amp;gt; e.source &#x3D;&#x3D;&#x3D; &amp;quot;python&amp;quot;);
    if (pythonEvidence.length &#x3D;&#x3D;&#x3D; 0) return [];

    const artifacts: InferredArtifact[] &#x3D; [];

    try {
      // Infer from package configuration evidence
      const packageEvidence &#x3D; pythonEvidence.filter((e) &#x3D;&amp;gt; {
        if (e.type !&#x3D;&#x3D; &amp;quot;config&amp;quot;) return false;
        const configType &#x3D; typeof e.data?.configType &#x3D;&#x3D;&#x3D; &amp;quot;string&amp;quot; ? e.data.configType : &amp;quot;&amp;quot;;
        return [&amp;quot;setup&amp;quot;, &amp;quot;pyproject&amp;quot;, &amp;quot;package&amp;quot;, &amp;quot;requirements&amp;quot;, &amp;quot;pipfile&amp;quot;].some((token) &#x3D;&amp;gt;
          configType.includes(token),
        );
      });

      for (const pkg of packageEvidence) {
        artifacts.push(...(await this.inferFromPackageConfig(pkg, pythonEvidence, context)));
      }

      // If no package config found, try to infer from source files
      if (packageEvidence.length &#x3D;&#x3D;&#x3D; 0) {
        artifacts.push(...(await this.inferFromSourceOnly(pythonEvidence, context)));
      }
    } catch (error) {
      console.warn(&amp;quot;Python plugin inference failed:&amp;quot;, error);
    }

    return artifacts;
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // Private parsing methods
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  private async parseSetupPy(
    filePath: string,
    content: string,
    baseId: string,
  ): Promise&amp;lt;Evidence[]&amp;gt; {
    const evidence: Evidence[] &#x3D; [];

    try {
      // Extract setup() call parameters using regex (simplified)
      const setupMatch &#x3D; content.match(/setup\s*\(\s*([\s\S]*?)\s*\)/);
      if (!setupMatch) return evidence;

      const setupContent &#x3D; setupMatch[1];

      // Extract basic metadata
      const name &#x3D;
        this.extractPythonStringField(setupContent, &amp;quot;name&amp;quot;) ||
        path.basename(path.dirname(filePath));
      const version &#x3D; this.extractPythonStringField(setupContent, &amp;quot;version&amp;quot;);
      const description &#x3D; this.extractPythonStringField(setupContent, &amp;quot;description&amp;quot;);

      // Extract dependencies
      const installRequires &#x3D; this.extractPythonListField(setupContent, &amp;quot;install_requires&amp;quot;);
      const extraRequires &#x3D; this.extractPythonDictField(setupContent, &amp;quot;extras_require&amp;quot;);

      // Extract entry points
      const entryPoints &#x3D; this.extractPythonDictField(setupContent, &amp;quot;entry_points&amp;quot;);
      const scripts &#x3D; this.extractPythonListField(setupContent, &amp;quot;scripts&amp;quot;);

      const packageData: PythonPackageData &#x3D; {
        configType: &amp;quot;setup-py&amp;quot;,
        name,
        version,
        description,
        dependencies: installRequires,
        devDependencies: Object.values(extraRequires).flat(),
        scripts: this.convertToScripts(entryPoints as any, scripts),
        entryPoints: entryPoints as any,
        author: this.extractPythonStringField(setupContent, &amp;quot;author&amp;quot;),
        license: this.extractPythonStringField(setupContent, &amp;quot;license&amp;quot;),
        homepage: this.extractPythonStringField(setupContent, &amp;quot;url&amp;quot;),
      };

      evidence.push({
        id: baseId,
        source: &amp;quot;python&amp;quot;,
        type: &amp;quot;config&amp;quot;,
        filePath,
        data: packageData,
        metadata: {
          timestamp: Date.now(),
          fileSize: content.length,
        },
      });
    } catch (error) {
      console.warn(&amp;quot;Failed to parse setup.py:&amp;quot;, error);
    }

    return evidence;
  }

  private async parsePyprojectToml(
    filePath: string,
    content: string,
    baseId: string,
  ): Promise&amp;lt;Evidence[]&amp;gt; {
    const evidence: Evidence[] &#x3D; [];

    try {
      // Simple TOML parsing for common fields
      const projectMatch &#x3D; content.match(/\[project\]([\s\S]*?)(?&#x3D;\n\[|\n$)/);
      const poetryMatch &#x3D; content.match(/\[tool\.poetry\]([\s\S]*?)(?&#x3D;\n\[|\n$)/);

      let projectSection &#x3D; projectMatch?.[1];
      let poetrySection &#x3D; poetryMatch?.[1];

      // Extract from [project] section (PEP 621)
      const name &#x3D;
        this.extractTomlField(projectSection, &amp;quot;name&amp;quot;) ||
        this.extractTomlField(poetrySection, &amp;quot;name&amp;quot;) ||
        path.basename(path.dirname(filePath));
      const version &#x3D;
        this.extractTomlField(projectSection, &amp;quot;version&amp;quot;) ||
        this.extractTomlField(poetrySection, &amp;quot;version&amp;quot;);
      const description &#x3D;
        this.extractTomlField(projectSection, &amp;quot;description&amp;quot;) ||
        this.extractTomlField(poetrySection, &amp;quot;description&amp;quot;);

      // Extract dependencies
      const dependencies &#x3D;
        this.extractTomlArray(projectSection, &amp;quot;dependencies&amp;quot;) ||
        this.extractTomlDependencies(poetrySection);
      const devDependencies &#x3D; this.extractTomlDevDependencies(content);

      // Extract scripts
      const scripts &#x3D;
        this.extractTomlTable(projectSection, &amp;quot;scripts&amp;quot;) ||
        this.extractTomlTable(poetrySection, &amp;quot;scripts&amp;quot;) ||
        {};

      const packageData: PythonPackageData &#x3D; {
        configType: &amp;quot;pyproject-toml&amp;quot;,
        name,
        version,
        description,
        dependencies,
        devDependencies,
        scripts,
        author:
          this.extractTomlField(projectSection, &amp;quot;authors&amp;quot;) ||
          this.extractTomlField(poetrySection, &amp;quot;authors&amp;quot;),
        license:
          this.extractTomlField(projectSection, &amp;quot;license&amp;quot;) ||
          this.extractTomlField(poetrySection, &amp;quot;license&amp;quot;),
        homepage:
          this.extractTomlField(projectSection, &amp;quot;homepage&amp;quot;) ||
          this.extractTomlField(poetrySection, &amp;quot;homepage&amp;quot;),
      };

      evidence.push({
        id: baseId,
        source: &amp;quot;python&amp;quot;,
        type: &amp;quot;config&amp;quot;,
        filePath,
        data: packageData,
        metadata: {
          timestamp: Date.now(),
          fileSize: content.length,
        },
      });
    } catch (error) {
      console.warn(&amp;quot;Failed to parse pyproject.toml:&amp;quot;, error);
    }

    return evidence;
  }

  private async parseRequirementsTxt(
    filePath: string,
    content: string,
    baseId: string,
  ): Promise&amp;lt;Evidence[]&amp;gt; {
    const evidence: Evidence[] &#x3D; [];

    try {
      const dependencies &#x3D; content
        .split(&amp;quot;\n&amp;quot;)
        .map((line) &#x3D;&amp;gt; line.trim())
        .filter((line) &#x3D;&amp;gt; line &amp;amp;&amp;amp; !line.startsWith(&amp;quot;#&amp;quot;) &amp;amp;&amp;amp; !line.startsWith(&amp;quot;-&amp;quot;))
        .map((line) &#x3D;&amp;gt; line.split(/[&amp;gt;&#x3D;&amp;lt;~!]/)[0].trim());

      // Derive package name from the directory containing requirements.txt
      const packageName &#x3D; path.basename(path.dirname(filePath));

      const packageData: PythonPackageData &#x3D; {
        configType: &amp;quot;requirements-txt&amp;quot;,
        name: packageName,
        dependencies,
        devDependencies: [],
        scripts: {},
      };

      evidence.push({
        id: baseId,
        source: &amp;quot;python&amp;quot;,
        type: &amp;quot;config&amp;quot;,
        filePath,
        data: packageData,
        metadata: {
          timestamp: Date.now(),
          fileSize: content.length,
        },
      });
    } catch (error) {
      console.warn(&amp;quot;Failed to parse requirements.txt:&amp;quot;, error);
    }

    return evidence;
  }

  private async parsePipfile(
    filePath: string,
    content: string,
    baseId: string,
  ): Promise&amp;lt;Evidence[]&amp;gt; {
    const evidence: Evidence[] &#x3D; [];

    try {
      // Extract dependencies from [packages] and [dev-packages] sections
      const packagesMatch &#x3D; content.match(/\[packages\]([\s\S]*?)(?&#x3D;\n\[|\n$)/);
      const devPackagesMatch &#x3D; content.match(/\[dev-packages\]([\s\S]*?)(?&#x3D;\n\[|\n$)/);

      const dependencies &#x3D; this.extractTomlDependencies(packagesMatch?.[1]);
      const devDependencies &#x3D; this.extractTomlDependencies(devPackagesMatch?.[1]);

      evidence.push({
        id: baseId,
        source: &amp;quot;python&amp;quot;,
        type: &amp;quot;dependency&amp;quot;,
        filePath,
        data: {
          configType: &amp;quot;pipfile&amp;quot;,
          dependencies,
          devDependencies,
        },
        metadata: {
          timestamp: Date.now(),
          fileSize: content.length,
        },
      });
    } catch (error) {
      console.warn(&amp;quot;Failed to parse Pipfile:&amp;quot;, error);
    }

    return evidence;
  }

  private async parsePythonSource(
    filePath: string,
    content: string,
    baseId: string,
  ): Promise&amp;lt;Evidence[]&amp;gt; {
    const evidence: Evidence[] &#x3D; [];

    try {
      // Detect imports
      const imports &#x3D; this.extractImports(content);
      const hasImports &#x3D; imports.length &amp;gt; 0;

      // Check for if __name__ &#x3D;&#x3D; &amp;quot;__main__&amp;quot;:
      const hasIfMain &#x3D; /if\s+__name__\s*&#x3D;&#x3D;\s*[&amp;#39;&amp;quot;&amp;quot;]__main__[&amp;#39;&amp;quot;&amp;quot;]/.test(content);

      // Check if this is a package __init__.py
      const isPackageInit &#x3D; path.basename(filePath) &#x3D;&#x3D;&#x3D; &amp;quot;__init__.py&amp;quot;;

      // Detect web framework usage
      const webFrameworks &#x3D; this.detectWebFrameworks(content, imports);

      // Detect CLI patterns
      const cliPatterns &#x3D; this.detectCliPatterns(content, imports);

      // Detect data processing patterns
      const dataProcessingPatterns &#x3D; this.detectDataProcessingPatterns(content, imports);

      const sourceData: PythonSourceData &#x3D; {
        configType: &amp;quot;source-file&amp;quot;,
        filePath,
        hasImports,
        hasIfMain,
        isPackageInit,
        imports,
        webFrameworks,
        cliPatterns,
        dataProcessingPatterns,
      };

      evidence.push({
        id: baseId,
        source: &amp;quot;python&amp;quot;,
        type: hasIfMain ? &amp;quot;function&amp;quot; : hasImports ? &amp;quot;import&amp;quot; : &amp;quot;export&amp;quot;,
        filePath,
        data: sourceData,
        metadata: {
          timestamp: Date.now(),
          fileSize: content.length,
        },
      });
    } catch (error) {
      console.warn(&amp;quot;Failed to parse Python source:&amp;quot;, error);
    }

    return evidence;
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // Private inference methods
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  private async inferFromPackageConfig(
    packageEvidence: Evidence,
    allEvidence: Evidence[],
    context: InferenceContext,
  ): Promise&amp;lt;InferredArtifact[]&amp;gt; {
    const packageData &#x3D; packageEvidence.data as unknown as PythonPackageData;
    const classification &#x3D; classifyPythonPackage(packageData);
    const artifactName &#x3D; packageData.name || this.deriveNameFromPath(packageEvidence.filePath);
    const artifact &#x3D; this.buildArtifactFromClassification({
      artifactName,
      artifactType: classification.artifactType,
      detectedType: classification.detectedType,
      reason: classification.reason,
      framework: classification.framework,
      description: packageData.description,
      filePath: packageEvidence.filePath,
      metadataExtras: {
        dependencies: packageData.dependencies,
        devDependencies: packageData.devDependencies,
        scripts: packageData.scripts,
        entryPoints: packageData.entryPoints,
      },
    });

    return [
      {
        artifact,
        provenance: this.createProvenance([packageEvidence]),
        relationships: [],
      },
    ];
  }

  private async inferFromSourceOnly(
    allEvidence: Evidence[],
    context: InferenceContext,
  ): Promise&amp;lt;InferredArtifact[]&amp;gt; {
    const sourceEvidence &#x3D; allEvidence.filter((e) &#x3D;&amp;gt; e.data?.configType &#x3D;&#x3D;&#x3D; &amp;quot;source-file&amp;quot;);

    if (sourceEvidence.length &#x3D;&#x3D;&#x3D; 0) return [];

    const sourceData &#x3D; sourceEvidence.map((e) &#x3D;&amp;gt; e.data as unknown as PythonSourceData);
    const classification &#x3D; classifyPythonSource(sourceData);
    const projectName &#x3D; path.basename(context.projectRoot ?? process.cwd());
    const sourceFilePath &#x3D; sourceEvidence[0]?.filePath ?? context.projectRoot ?? process.cwd();

    const artifact &#x3D; this.buildArtifactFromClassification({
      artifactName: projectName,
      artifactType: classification.artifactType,
      detectedType: classification.detectedType,
      reason: classification.reason,
      framework: classification.framework,
      description: undefined,
      filePath: sourceFilePath,
      metadataExtras: {},
    });

    return [
      {
        artifact,
        provenance: this.createProvenance(sourceEvidence),
        relationships: [],
      },
    ];
  }

  private deriveNameFromPath(filePath: string): string {
    const basename &#x3D; path.basename(path.dirname(filePath));
    return basename || &amp;quot;python-project&amp;quot;;
  }

  private buildArtifactFromClassification(params: {
    artifactName: string;
    artifactType: ArtifactType;
    detectedType: string;
    reason: string;
    framework?: string;
    description?: string;
    filePath: string;
    metadataExtras: Record&amp;lt;string, unknown&amp;gt;;
  }) {
    const {
      artifactName,
      artifactType,
      detectedType,
      reason,
      framework,
      description,
      filePath,
      metadataExtras,
    } &#x3D; params;

    const tags &#x3D; new Set&amp;lt;string&amp;gt;([&amp;quot;python&amp;quot;]);
    if (artifactType &#x3D;&#x3D;&#x3D; &amp;quot;binary&amp;quot;) {
      tags.add(&amp;quot;tool&amp;quot;);
    } else if (artifactType &#x3D;&#x3D;&#x3D; &amp;quot;service&amp;quot;) {
      tags.add(&amp;quot;service&amp;quot;);
    } else if (artifactType &#x3D;&#x3D;&#x3D; &amp;quot;frontend&amp;quot;) {
      tags.add(&amp;quot;frontend&amp;quot;);
    } else {
      tags.add(&amp;quot;package&amp;quot;);
    }

    if (framework) {
      tags.add(framework);
    }

    const fallbackDescriptions: Record&amp;lt;ArtifactType, string&amp;gt; &#x3D; {
      service: &#x60;Python web service: ${artifactName}&#x60;,
      binary: &#x60;Python CLI tool: ${artifactName}&#x60;,
      tool: &#x60;Python tool: ${artifactName}&#x60;,
      package: &#x60;Python package: ${artifactName}&#x60;,
      job: &#x60;Python job: ${artifactName}&#x60;,
      schema: &#x60;Python schema: ${artifactName}&#x60;,
      config: &#x60;Python config: ${artifactName}&#x60;,
      deployment: &#x60;Python deployment: ${artifactName}&#x60;,
      test: &#x60;Python tests: ${artifactName}&#x60;,
      frontend: &#x60;Python frontend app: ${artifactName}&#x60;,
      database: &#x60;Python database service: ${artifactName}&#x60;,
      cache: &#x60;Python cache service: ${artifactName}&#x60;,
      queue: &#x60;Python queue service: ${artifactName}&#x60;,
      proxy: &#x60;Python proxy: ${artifactName}&#x60;,
      monitor: &#x60;Python monitor: ${artifactName}&#x60;,
      auth: &#x60;Python auth service: ${artifactName}&#x60;,
      docs: &#x60;Python docs: ${artifactName}&#x60;,
      infrastructure: &#x60;Python infrastructure: ${artifactName}&#x60;,
    };

    const artifactDescription &#x3D;
      description?.trim() ||
      fallbackDescriptions[artifactType] ||
      &#x60;Python component: ${artifactName}&#x60;;

    const fileName &#x3D; path.basename(filePath);
    let manifest: string | undefined;
    if (fileName &#x3D;&#x3D;&#x3D; &amp;quot;pyproject.toml&amp;quot;) {
      manifest &#x3D; &amp;quot;pyproject.toml&amp;quot;;
    } else if (fileName &#x3D;&#x3D;&#x3D; &amp;quot;setup.py&amp;quot;) {
      manifest &#x3D; &amp;quot;setup.py&amp;quot;;
    } else if (fileName &#x3D;&#x3D;&#x3D; &amp;quot;Pipfile&amp;quot;) {
      manifest &#x3D; &amp;quot;Pipfile&amp;quot;;
    } else if (fileName &#x3D;&#x3D;&#x3D; &amp;quot;requirements.txt&amp;quot;) {
      manifest &#x3D; &amp;quot;requirements.txt&amp;quot;;
    }

    return {
      id: &#x60;python-${artifactType}-${artifactName}&#x60;,
      type: artifactType,
      name: artifactName,
      description: artifactDescription,
      tags: Array.from(tags),
      metadata: {
        sourceFile: filePath,
        root: path.dirname(filePath),
        ...(manifest ? { manifest } : {}),
        language: &amp;quot;python&amp;quot;,
        framework,
        detectedType,
        classification: {
          source: &amp;quot;python-analysis&amp;quot;,
          reason,
        },
        ...metadataExtras,
      },
    };
  }

  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
  // Helper methods
  // &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

  private extractImports(content: string): string[] {
    const imports: string[] &#x3D; [];
    const lines &#x3D; content.split(&amp;quot;\n&amp;quot;);

    for (const line of lines) {
      const trimmed &#x3D; line.trim();

      // import module
      const importMatch &#x3D; trimmed.match(
        /^import\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)/,
      );
      if (importMatch) {
        imports.push(importMatch[1].split(&amp;quot;.&amp;quot;)[0]);
        continue;
      }

      // from module import ...
      const fromMatch &#x3D; trimmed.match(
        /^from\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)\s+import/,
      );
      if (fromMatch) {
        imports.push(fromMatch[1].split(&amp;quot;.&amp;quot;)[0]);
      }
    }

    return [...new Set(imports)];
  }

  private detectWebFrameworks(content: string, imports: string[]): string[] {
    const webFrameworks &#x3D; [
      &amp;quot;django&amp;quot;,
      &amp;quot;flask&amp;quot;,
      &amp;quot;fastapi&amp;quot;,
      &amp;quot;tornado&amp;quot;,
      &amp;quot;sanic&amp;quot;,
      &amp;quot;starlette&amp;quot;,
      &amp;quot;bottle&amp;quot;,
      &amp;quot;falcon&amp;quot;,
      &amp;quot;pyramid&amp;quot;,
    ];
    return imports.filter((imp) &#x3D;&amp;gt; webFrameworks.includes(imp));
  }

  private detectCliPatterns(content: string, imports: string[]): string[] {
    const cliLibraries &#x3D; [&amp;quot;click&amp;quot;, &amp;quot;argparse&amp;quot;, &amp;quot;typer&amp;quot;, &amp;quot;fire&amp;quot;, &amp;quot;docopt&amp;quot;];
    const patterns: string[] &#x3D; [];

    // Check for CLI library imports
    patterns.push(...imports.filter((imp) &#x3D;&amp;gt; cliLibraries.includes(imp)));

    // Check for CLI patterns in code
    if (/if\s+__name__\s*&#x3D;&#x3D;\s*[&amp;#39;&amp;quot;&amp;quot;]__main__[&amp;#39;&amp;quot;&amp;quot;]/.test(content)) {
      patterns.push(&amp;quot;main_guard&amp;quot;);
    }

    if (/sys\.argv/.test(content)) {
      patterns.push(&amp;quot;argv_usage&amp;quot;);
    }

    return patterns;
  }

  private detectDataProcessingPatterns(content: string, imports: string[]): string[] {
    const dataLibraries &#x3D; [
      &amp;quot;pandas&amp;quot;,
      &amp;quot;numpy&amp;quot;,
      &amp;quot;scipy&amp;quot;,
      &amp;quot;matplotlib&amp;quot;,
      &amp;quot;seaborn&amp;quot;,
      &amp;quot;plotly&amp;quot;,
      &amp;quot;dask&amp;quot;,
      &amp;quot;polars&amp;quot;,
    ];
    return imports.filter((imp) &#x3D;&amp;gt; dataLibraries.includes(imp));
  }

  // Utility methods for parsing Python/TOML content
  private extractPythonStringField(content: string, field: string): string | undefined {
    const regex &#x3D; new RegExp(&#x60;${field}\\s*&#x3D;\\s*[&amp;#39;&amp;quot;](.*?)[&amp;#39;&amp;quot;]&#x60;);
    const match &#x3D; content.match(regex);
    return match?.[1];
  }

  private extractPythonListField(content: string, field: string): string[] {
    const regex &#x3D; new RegExp(&#x60;${field}\\s*&#x3D;\\s*\\[(.*?)\\]&#x60;, &amp;quot;s&amp;quot;);
    const match &#x3D; content.match(regex);
    if (!match) return [];

    return match[1]
      .split(&amp;quot;,&amp;quot;)
      .map((item) &#x3D;&amp;gt; item.trim().replace(/[&amp;#39;&amp;quot;]/g, &amp;quot;&amp;quot;))
      .filter((item) &#x3D;&amp;gt; item.length &amp;gt; 0);
  }

  private extractPythonDictField(content: string, field: string): Record&amp;lt;string, string[]&amp;gt; {
    // Simplified dict parsing - would need more robust implementation
    return {};
  }

  private extractTomlField(content: string | undefined, field: string): string | undefined {
    if (!content) return undefined;
    const regex &#x3D; new RegExp(&#x60;${field}\\s*&#x3D;\\s*[&amp;#39;&amp;quot;](.*?)[&amp;#39;&amp;quot;]&#x60;);
    const match &#x3D; content.match(regex);
    return match?.[1];
  }

  private extractTomlArray(content: string | undefined, field: string): string[] {
    if (!content) return [];
    const regex &#x3D; new RegExp(&#x60;${field}\\s*&#x3D;\\s*\\[(.*?)\\]&#x60;, &amp;quot;s&amp;quot;);
    const match &#x3D; content.match(regex);
    if (!match) return [];

    return match[1]
      .split(&amp;quot;,&amp;quot;)
      .map((item) &#x3D;&amp;gt; item.trim().replace(/[&amp;#39;&amp;quot;]/g, &amp;quot;&amp;quot;))
      .filter((item) &#x3D;&amp;gt; item.length &amp;gt; 0);
  }

  private extractTomlTable(content: string | undefined, field: string): Record&amp;lt;string, string&amp;gt; {
    if (!content) return {};
    // Simplified table parsing
    return {};
  }

  private extractTomlDependencies(content: string | undefined): string[] {
    if (!content) return [];
    const dependencies: string[] &#x3D; [];
    const lines &#x3D; content.split(&amp;quot;\n&amp;quot;);

    for (const line of lines) {
      const trimmed &#x3D; line.trim();
      if (trimmed &amp;amp;&amp;amp; !trimmed.startsWith(&amp;quot;#&amp;quot;)) {
        const eqIndex &#x3D; trimmed.indexOf(&amp;quot;&#x3D;&amp;quot;);
        if (eqIndex &amp;gt; 0) {
          const depName &#x3D; trimmed.substring(0, eqIndex).trim();
          if (depName &amp;amp;&amp;amp; /^[a-zA-Z_-]+$/.test(depName)) {
            dependencies.push(depName);
          }
        }
      }
    }

    return dependencies;
  }

  private extractTomlDevDependencies(content: string): string[] {
    const devMatch &#x3D; content.match(
      /\[tool\.poetry\.group\.dev\.dependencies\]([\s\S]*?)(?&#x3D;\n\[|\n$)/,
    );
    if (devMatch) {
      return this.extractTomlDependencies(devMatch[1]);
    }
    return [];
  }

  private convertToScripts(
    entryPoints: Record&amp;lt;string, any&amp;gt;,
    scripts: string[],
  ): Record&amp;lt;string, string&amp;gt; {
    const result: Record&amp;lt;string, string&amp;gt; &#x3D; {};

    // Convert entry points
    if (entryPoints?.console_scripts) {
      Object.entries(entryPoints.console_scripts).forEach(([name, target]) &#x3D;&amp;gt; {
        result[name] &#x3D; target as string;
      });
    }

    // Convert scripts array
    scripts.forEach((script) &#x3D;&amp;gt; {
      const name &#x3D; path.basename(script, path.extname(script));
      result[name] &#x3D; script;
    });

    return result;
  }

  private createProvenance(evidence: Evidence[]): Provenance {
    return {
      evidence: evidence.map((e) &#x3D;&amp;gt; e.id),
      plugins: [&amp;quot;python&amp;quot;],
      rules: [&amp;quot;package-config-analysis&amp;quot;, &amp;quot;source-file-analysis&amp;quot;],
      timestamp: Date.now(),
      pipelineVersion: &amp;quot;1.0.0&amp;quot;,
    };
  }
}

// Export the plugin instance
export const pythonPlugin &#x3D; new PythonPlugin();
</code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- CDN JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <script>
        // Initialize syntax highlighting
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });

        // Toggle individual file
        function toggleFile(index) {
            const content = document.getElementById('file-' + index);
            content.classList.toggle('expanded');
        }

        // Toggle all files
        let allExpanded = false;
        function toggleAllFiles() {
            const contents = document.querySelectorAll('.file-content');
            const button = document.querySelector('.expand-all');

            if (allExpanded) {
                contents.forEach(c => c.classList.remove('expanded'));
                button.textContent = 'Expand All Files';
                allExpanded = false;
            } else {
                contents.forEach(c => c.classList.add('expanded'));
                button.textContent = 'Collapse All Files';
                allExpanded = true;
            }
        }
    </script>
</body>
</html>
