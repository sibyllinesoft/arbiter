import path from "node:path";
import fs from "fs-extra";
import { nanoid } from "nanoid";
import type {
  ProjectCompositionConfig,
  SRFFragmentEntry,
  IntegrationHistoryEntry,
  ComposedSpecification,
  ConflictEntry,
  ImportSrfOptions,
  ValidateCompositionOptions,
  RecoveryOptions,
} from "../types.js";
import { SRFValidator } from "./validator.js";
import { ConflictResolver } from "./conflict-resolver.js";
import { SpecificationComposer } from "./spec-composer.js";
import { RecoveryManager } from "./recovery-manager.js";

/**
 * Main project composition manager that coordinates all composition operations
 */
export class ProjectCompositionManager {
  private config: ProjectCompositionConfig | null = null;
  private readonly projectRoot: string;
  private readonly configPath: string;
  private readonly validator: SRFValidator;
  private readonly conflictResolver: ConflictResolver;
  private readonly specComposer: SpecificationComposer;
  private readonly recoveryManager: RecoveryManager;

  constructor(projectRoot: string) {
    this.projectRoot = projectRoot;
    this.configPath = path.join(projectRoot, ".arbiter", "project.json");
    this.validator = new SRFValidator();
    this.conflictResolver = new ConflictResolver();
    this.specComposer = new SpecificationComposer();
    this.recoveryManager = new RecoveryManager(projectRoot);
  }

  /**
   * Initialize project composition system
   */
  async initialize(options: {
    name: string;
    description: string;
    compositionTemplate?: "basic" | "advanced" | "enterprise";
    enableFragments?: boolean;
  }): Promise<void> {
    const arbiterDir = path.join(this.projectRoot, ".arbiter");
    await fs.ensureDir(arbiterDir);

    const template = options.compositionTemplate || "basic";
    const config: ProjectCompositionConfig = {
      metadata: {
        name: options.name,
        id: nanoid(),
        description: options.description,
        created_at: new Date().toISOString(),
        last_modified: new Date().toISOString(),
        version: "1.0.0",
      },
      composition: {
        composedSpecDir: ".arbiter/composed",
        fragmentsDir: ".arbiter/fragments",
        conflictResolutionDir: ".arbiter/conflicts",
        masterSpecFile: "master.cue",
        autoResolveConflicts: template === "basic",
        validationLevel: template === "enterprise" ? "strict" : "moderate",
      },
      fragments: [],
      integrationHistory: [],
    };

    // Create required directories
    const dirs = [
      config.composition.composedSpecDir,
      config.composition.fragmentsDir,
      config.composition.conflictResolutionDir,
    ].map((dir) => path.join(this.projectRoot, dir));

    for (const dir of dirs) {
      await fs.ensureDir(dir);
    }

    // Write configuration
    await fs.writeJson(this.configPath, config, { spaces: 2 });
    this.config = config;

    // Initialize master specification with basic structure
    const masterSpecPath = path.join(
      this.projectRoot,
      config.composition.composedSpecDir,
      config.composition.masterSpecFile,
    );

    const initialSpec = `// Master CUE Specification for ${options.name}
// Generated by Arbiter Project Composition System
// Version: ${config.metadata.version}

package ${options.name.replace(/[^a-zA-Z0-9]/g, "")}

// Project metadata
#ProjectMetadata: {
	name: "${options.name}"
	version: "${config.metadata.version}"
	description: "${options.description}"
	composedAt: "${config.metadata.created_at}"
}

// Composition configuration
#CompositionConfig: {
	fragments: [...]
	validationLevel: "${config.composition.validationLevel}"
	autoResolveConflicts: ${config.composition.autoResolveConflicts}
}

// Project specifications will be composed here
#ProjectSpec: {
	metadata: #ProjectMetadata
	composition: #CompositionConfig
	
	// Feature specifications from SRF fragments
	features: {...}
	
	// Global constraints and validations
	constraints: {...}
	
	// External dependencies
	dependencies: {...}
}

// Export the complete project specification
project: #ProjectSpec & {
	metadata: #ProjectMetadata
	composition: #CompositionConfig
}`;

    await fs.writeFile(masterSpecPath, initialSpec, "utf-8");

    // Create initial integration history entry
    const historyEntry: IntegrationHistoryEntry = {
      id: nanoid(),
      timestamp: new Date().toISOString(),
      operation: "import",
      fragments: [],
      specBefore: "",
      specAfter: initialSpec,
      success: true,
      recoveryData: {
        filesAffected: [masterSpecPath],
        backups: {},
      },
    };

    config.integrationHistory.push(historyEntry);
    await this.saveConfig();
  }

  /**
   * Load project composition configuration
   */
  async loadConfig(): Promise<ProjectCompositionConfig> {
    if (this.config) {
      return this.config;
    }

    if (!(await fs.pathExists(this.configPath))) {
      throw new Error(
        `Project composition not initialized. Run 'arbiter init --composition' first.`,
      );
    }

    this.config = await fs.readJson(this.configPath);
    return this.config!;
  }

  /**
   * Save current configuration to disk
   */
  private async saveConfig(): Promise<void> {
    if (!this.config) {
      throw new Error("No configuration to save");
    }

    this.config.metadata.last_modified = new Date().toISOString();
    await fs.writeJson(this.configPath, this.config, { spaces: 2 });
  }

  /**
   * Import an SRF fragment into the project
   */
  async importFragment(options: ImportSrfOptions): Promise<{
    success: boolean;
    fragmentId?: string;
    conflicts?: ConflictEntry[];
    error?: string;
  }> {
    const config = await this.loadConfig();

    try {
      // Validate the SRF fragment
      if (!options.skipValidation) {
        const validationResult = await this.validator.validateSRF(options.fragment);
        if (!validationResult.isValid) {
          return {
            success: false,
            error: `SRF validation failed: ${validationResult.errors.join(", ")}`,
          };
        }
      }

      // Read and parse the fragment
      const fragmentContent = await fs.readFile(options.fragment, "utf-8");
      const fragmentId = nanoid();
      const fragmentFilename = path.basename(options.fragment);

      // Copy fragment to project fragments directory
      const fragmentPath = path.join(
        this.projectRoot,
        config.composition.fragmentsDir,
        `${fragmentId}-${fragmentFilename}`,
      );
      await fs.copy(options.fragment, fragmentPath);

      // Check for conflicts with existing fragments
      const conflicts = await this.detectConflicts(fragmentContent, fragmentId);

      // Create fragment entry
      const fragmentEntry: SRFFragmentEntry = {
        id: fragmentId,
        filename: fragmentFilename,
        path: fragmentPath,
        description: options.description || `Imported from ${options.fragment}`,
        imported_at: new Date().toISOString(),
        version: await this.calculateFragmentVersion(fragmentContent),
        dependencies: options.dependencies || [],
        conflicts: conflicts,
        status: conflicts.length > 0 ? "conflict" : "integrated",
      };

      // If there are conflicts and auto-resolution is disabled, mark as pending
      if (conflicts.length > 0 && !config.composition.autoResolveConflicts) {
        fragmentEntry.status = "pending";
        config.fragments.push(fragmentEntry);
        await this.saveConfig();

        return {
          success: false,
          fragmentId,
          conflicts,
          error: "Conflicts detected. Use 'arbiter composition resolve' to resolve them.",
        };
      }

      // Attempt automatic conflict resolution if enabled
      if (conflicts.length > 0 && config.composition.autoResolveConflicts) {
        const resolutionResults = await this.conflictResolver.resolveConflicts(
          conflicts,
          fragmentContent,
          await this.getCurrentSpec(),
        );

        if (!resolutionResults.success) {
          fragmentEntry.status = "conflict";
          config.fragments.push(fragmentEntry);
          await this.saveConfig();

          return {
            success: false,
            fragmentId,
            conflicts,
            error: `Auto-resolution failed: ${resolutionResults.error}`,
          };
        }

        // Apply resolutions
        fragmentEntry.conflicts = conflicts.map((conflict) => ({
          ...conflict,
          resolution: resolutionResults.resolutions.find((r) => r.method !== "manual"),
        }));
      }

      // Integrate the fragment into the composed specification
      const currentSpec = await this.getCurrentSpec();
      const newSpec = await this.specComposer.integrateFragment(
        currentSpec,
        fragmentContent,
        fragmentEntry,
      );

      // Create integration history entry
      const historyEntry: IntegrationHistoryEntry = {
        id: nanoid(),
        timestamp: new Date().toISOString(),
        operation: "import",
        fragments: [fragmentId],
        specBefore: currentSpec,
        specAfter: newSpec,
        success: true,
        recoveryData: {
          filesAffected: [fragmentPath, await this.getMasterSpecPath()],
          backups: {},
        },
      };

      // Update composed specification
      await this.updateMasterSpec(newSpec);

      // Add fragment to configuration
      config.fragments.push(fragmentEntry);
      config.integrationHistory.push(historyEntry);
      await this.saveConfig();

      return {
        success: true,
        fragmentId,
        conflicts: conflicts.length > 0 ? conflicts : undefined,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Validate the current project composition
   */
  async validateComposition(options: ValidateCompositionOptions = {}): Promise<{
    success: boolean;
    conflicts: ConflictEntry[];
    errors: string[];
    warnings: string[];
    fragmentsStatus: Record<string, string>;
  }> {
    const config = await this.loadConfig();

    const result = {
      success: true,
      conflicts: [] as ConflictEntry[],
      errors: [] as string[],
      warnings: [] as string[],
      fragmentsStatus: {} as Record<string, string>,
    };

    try {
      // Validate each fragment individually
      const fragmentsToValidate = options.fragments
        ? config.fragments.filter((f) => options.fragments!.includes(f.id))
        : config.fragments;

      for (const fragment of fragmentsToValidate) {
        try {
          const fragmentContent = await fs.readFile(fragment.path, "utf-8");
          const validation = await this.validator.validateSRF(fragment.path);

          if (!validation.isValid) {
            result.success = false;
            result.errors.push(
              `Fragment ${fragment.id} (${fragment.filename}): ${validation.errors.join(", ")}`,
            );
            result.fragmentsStatus[fragment.id] = "invalid";
          } else {
            result.fragmentsStatus[fragment.id] = "valid";
          }

          // Add existing conflicts
          result.conflicts.push(...fragment.conflicts);
        } catch (error) {
          result.success = false;
          result.errors.push(
            `Failed to validate fragment ${fragment.id}: ${error instanceof Error ? error.message : String(error)}`,
          );
          result.fragmentsStatus[fragment.id] = "error";
        }
      }

      // Validate the composed specification
      const currentSpec = await this.getCurrentSpec();
      const specValidation = await this.validator.validateComposedSpec(currentSpec);

      if (!specValidation.isValid) {
        result.success = false;
        result.errors.push(...specValidation.errors);
      }

      result.warnings.push(...specValidation.warnings);

      // Check for dependency cycles
      const dependencyCycles = this.detectDependencyCycles(config.fragments);
      if (dependencyCycles.length > 0) {
        result.success = false;
        result.errors.push(`Dependency cycles detected: ${dependencyCycles.join(", ")}`);
      }
    } catch (error) {
      result.success = false;
      result.errors.push(
        `Composition validation failed: ${error instanceof Error ? error.message : String(error)}`,
      );
    }

    return result;
  }

  /**
   * Generate a complete composed specification for recovery
   */
  async generateComposedSpec(): Promise<ComposedSpecification> {
    const config = await this.loadConfig();
    const currentSpec = await this.getCurrentSpec();
    const validation = await this.validateComposition();

    const composedSpec: ComposedSpecification = {
      metadata: {
        composedAt: new Date().toISOString(),
        sourceFragments: config.fragments.map((f) => f.id),
        version: await this.calculateSpecVersion(currentSpec),
      },
      spec: currentSpec,
      validation: {
        valid: validation.success,
        errors: validation.errors.map((error) => ({
          message: error,
          path: "unknown",
          sourceFragment: "unknown",
          severity: "major" as const,
        })),
        warnings: validation.warnings.map((warning) => ({
          message: warning,
          path: "unknown",
          sourceFragment: "unknown",
          category: "compatibility" as const,
        })),
      },
      recovery: {
        regenerationCapable: validation.success,
        externalDependencies: this.extractExternalDependencies(config.fragments),
        fileStructure: await this.generateFileStructure(),
      },
    };

    // Save the composed specification
    const composedSpecPath = path.join(
      this.projectRoot,
      config.composition.composedSpecDir,
      "composed-spec.json",
    );

    await fs.writeJson(composedSpecPath, composedSpec, { spaces: 2 });

    return composedSpec;
  }

  /**
   * Recover project from composed specification
   */
  async recoverFromComposedSpec(options: RecoveryOptions): Promise<{
    success: boolean;
    recoveredFiles: string[];
    error?: string;
  }> {
    return this.recoveryManager.recoverProject(options);
  }

  /**
   * Detect conflicts between a new fragment and existing ones
   */
  private async detectConflicts(
    fragmentContent: string,
    fragmentId: string,
  ): Promise<ConflictEntry[]> {
    const config = await this.loadConfig();
    const conflicts: ConflictEntry[] = [];

    // Parse new fragment for comparison
    const newFragmentSpec = await this.specComposer.parseFragment(fragmentContent);

    // Compare with existing fragments
    for (const existingFragment of config.fragments) {
      try {
        const existingContent = await fs.readFile(existingFragment.path, "utf-8");
        const existingSpec = await this.specComposer.parseFragment(existingContent);

        const fragmentConflicts = await this.conflictResolver.detectConflicts(
          newFragmentSpec,
          existingSpec,
          fragmentId,
          existingFragment.id,
        );

        conflicts.push(...fragmentConflicts);
      } catch (error) {}
    }

    return conflicts;
  }

  /**
   * Get the current master specification
   */
  private async getCurrentSpec(): Promise<string> {
    const config = await this.loadConfig();
    const masterSpecPath = await this.getMasterSpecPath();

    try {
      return await fs.readFile(masterSpecPath, "utf-8");
    } catch {
      // Return empty spec if file doesn't exist
      return "";
    }
  }

  /**
   * Update the master specification file
   */
  private async updateMasterSpec(spec: string): Promise<void> {
    const masterSpecPath = await this.getMasterSpecPath();
    await fs.writeFile(masterSpecPath, spec, "utf-8");
  }

  /**
   * Get the path to the master specification file
   */
  private async getMasterSpecPath(): Promise<string> {
    const config = await this.loadConfig();
    return path.join(
      this.projectRoot,
      config.composition.composedSpecDir,
      config.composition.masterSpecFile,
    );
  }

  /**
   * Calculate a version hash for fragment content
   */
  private async calculateFragmentVersion(content: string): Promise<string> {
    // Simple hash calculation - in production, use crypto.createHash
    return Buffer.from(content).toString("base64").slice(0, 12);
  }

  /**
   * Calculate a version hash for the complete specification
   */
  private async calculateSpecVersion(spec: string): Promise<string> {
    return Buffer.from(spec).toString("base64").slice(0, 12);
  }

  /**
   * Detect dependency cycles in fragments
   */
  private detectDependencyCycles(fragments: SRFFragmentEntry[]): string[] {
    const cycles: string[] = [];
    const visited = new Set<string>();
    const recursionStack = new Set<string>();

    const dfs = (fragmentId: string, path: string[]): boolean => {
      if (recursionStack.has(fragmentId)) {
        cycles.push([...path, fragmentId].join(" -> "));
        return true;
      }

      if (visited.has(fragmentId)) {
        return false;
      }

      visited.add(fragmentId);
      recursionStack.add(fragmentId);

      const fragment = fragments.find((f) => f.id === fragmentId);
      if (fragment) {
        for (const dep of fragment.dependencies) {
          if (dfs(dep, [...path, fragmentId])) {
            return true;
          }
        }
      }

      recursionStack.delete(fragmentId);
      return false;
    };

    for (const fragment of fragments) {
      if (!visited.has(fragment.id)) {
        dfs(fragment.id, []);
      }
    }

    return cycles;
  }

  /**
   * Extract external dependencies from fragments
   */
  private extractExternalDependencies(fragments: SRFFragmentEntry[]): string[] {
    const deps = new Set<string>();

    for (const fragment of fragments) {
      // Add fragment dependencies that aren't other fragments
      const fragmentIds = new Set(fragments.map((f) => f.id));
      for (const dep of fragment.dependencies) {
        if (!fragmentIds.has(dep)) {
          deps.add(dep);
        }
      }
    }

    return Array.from(deps);
  }

  /**
   * Generate file structure template for recovery
   */
  private async generateFileStructure(): Promise<Record<string, string>> {
    const structure: Record<string, string> = {};

    // Add basic CUE project structure
    structure["cue.mod/module.cue"] = "module template";
    structure["schema.cue"] = "schema template";
    structure["values.cue"] = "values template";
    structure[".arbiter/project.json"] = "composition config";

    return structure;
  }
}
