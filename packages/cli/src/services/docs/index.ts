#!/usr/bin/env node
/**
 * @packageDocumentation
 * Docs command - Generate documentation from CUE specifications.
 *
 * Provides functionality to:
 * - Generate Markdown, HTML, or JSON documentation
 * - Extract schema and field documentation
 * - Support custom templates for output
 * - Include usage examples in generated docs
 */

import fs from "node:fs/promises";
import path from "node:path";
import { safeFileOperation } from "@/constraints/index.js";
import type { CLIConfig } from "@/types.js";
import chalk from "chalk";
import {
  CLI_EXAMPLE_TEMPLATE,
  type FieldDoc,
  LIBRARY_EXAMPLE_TEMPLATE,
  type SchemaDoc,
  generateCssStyles,
  generateHtmlDocs,
  generateMarkdownDocs,
} from "./templates.js";

/**
 * Options for docs command
 */
export interface DocsOptions {
  format?: "markdown" | "html" | "json";
  output?: string;
  outputDir?: string;
  template?: string;
  interactive?: boolean;
  examples?: boolean;
}

/**
 * Schema documentation generator from CUE definitions
 */
export async function docsCommand(
  subcommand: "schema" | "api" | "help",
  options: DocsOptions,
  config: CLIConfig,
): Promise<number> {
  try {
    switch (subcommand) {
      case "schema":
        return await generateSchemaDocumentation(options, config);
      case "api":
        return await generateApiDocumentation(options, config);
      case "help":
        showDocsHelp();
        return 0;
      default:
        console.error(chalk.red(`Unknown docs subcommand: ${subcommand}`));
        showDocsHelp();
        return 1;
    }
  } catch (error) {
    console.error(
      chalk.red("Documentation generation failed:"),
      error instanceof Error ? error.message : String(error),
    );
    return 2;
  }
}

/**
 * Generate CLI reference documentation (placeholder implementation for compatibility).
 */
export async function docsGenerateCommand(options: any, _config: CLIConfig): Promise<number> {
  const outputDir = options.output || "@/services/docs/docs";
  const formats = (options.formats || "markdown").split(",");
  const fileBase = path.join(outputDir, "cli-reference");

  await fs.mkdir(outputDir, { recursive: true });

  const markdown = `# Arbiter CLI Reference\n\nGenerated on ${new Date().toISOString()}\n\n(Placeholder reference generated by docsGenerateCommand)\n`;

  if (formats.includes("markdown")) {
    await safeFileOperation("write", `${fileBase}.md`, async (validatedPath) => {
      await fs.writeFile(validatedPath, markdown, "utf-8");
    });
  }

  if (formats.includes("json")) {
    await safeFileOperation("write", `${fileBase}.json`, async (validatedPath) => {
      await fs.writeFile(
        validatedPath,
        JSON.stringify({ generatedAt: new Date().toISOString() }, null, 2),
        "utf-8",
      );
    });
  }

  console.log(chalk.green(`‚úÖ Generated CLI reference in ${outputDir}`));
  return 0;
}

/**
 * Check for assembly file existence
 */
async function checkAssemblyFile(assemblyPath: string): Promise<boolean> {
  try {
    await fs.access(assemblyPath);
    console.log(chalk.green("‚úÖ Found arbiter.assembly.cue"));
    return true;
  } catch {
    console.log(chalk.red("‚ùå No arbiter.assembly.cue found in current directory"));
    console.log(chalk.dim("Run: arbiter init --preset <id> to create one"));
    return false;
  }
}

/**
 * Resolve output path based on options
 */
function resolveDocOutputPath(options: DocsOptions): string {
  const format = options.format || "markdown";
  const outputDir = options.outputDir || ".";
  const filename =
    options.output ||
    `schema-docs.${format === "json" ? "json" : format === "html" ? "html" : "md"}`;
  return path.isAbsolute(filename) ? filename : path.join(outputDir, filename);
}

/**
 * Render documentation content based on format
 */
function renderDocumentationContent(schemaInfo: SchemaDoc, format: string): string {
  switch (format) {
    case "markdown":
      return generateMarkdownDocs(schemaInfo);
    case "html":
      return generateHtmlDocs(schemaInfo);
    case "json":
      return JSON.stringify(schemaInfo, null, 2);
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
}

/**
 * Display next steps after documentation generation
 */
function showDocGenerationNextSteps(outputPath: string): void {
  console.log(chalk.blue("\nüéØ Next steps:"));
  console.log(chalk.dim(`  üìñ View documentation: ${outputPath}`));
  console.log(chalk.dim("  üîÑ Regenerate automatically: arbiter watch --docs"));
  console.log(chalk.dim("  üåê Serve docs: arbiter docs serve (coming soon)"));
}

/**
 * Generate schema documentation from arbiter.assembly.cue
 */
async function generateSchemaDocumentation(
  options: DocsOptions,
  _config: CLIConfig,
): Promise<number> {
  console.log(chalk.blue("üìö Generating schema documentation from CUE definitions..."));

  const assemblyPath = path.resolve("arbiter.assembly.cue");
  if (!(await checkAssemblyFile(assemblyPath))) {
    return 1;
  }

  const assemblyContent = await fs.readFile(assemblyPath, "utf-8");
  const schemaInfo = await parseCueSchema(assemblyContent);

  const format = options.format || "markdown";
  const outputPath = resolveDocOutputPath(options);
  const outputDirPath = path.dirname(outputPath);
  await fs.mkdir(outputDirPath, { recursive: true });

  console.log(chalk.blue(`üìù Generating ${format.toUpperCase()} documentation...`));
  console.log(chalk.dim(`Output: ${outputPath}`));

  const documentationContent = renderDocumentationContent(schemaInfo, format);

  await safeFileOperation("write", outputPath, async (validatedPath) => {
    await fs.writeFile(validatedPath, documentationContent, "utf-8");
  });
  console.log(chalk.green(`‚úÖ Generated documentation: ${outputPath}`));

  if (options.examples) {
    await generateExampleFiles(schemaInfo, outputDirPath);
  }

  showDocGenerationNextSteps(outputPath);
  return 0;
}

/**
 * Generate API documentation from surface.json
 */
async function generateApiDocumentation(options: DocsOptions, _config: CLIConfig): Promise<number> {
  console.log(chalk.blue("üîå Generating API documentation..."));

  const surfacePath = path.resolve("surface.json");

  try {
    await fs.access(surfacePath);
  } catch {
    console.log(chalk.yellow("‚ö†Ô∏è  No surface.json found"));
    console.log(chalk.dim("Run: arbiter surface <language> to generate API surface"));
    return 1;
  }

  const surfaceContent = await fs.readFile(surfacePath, "utf-8");
  const surfaceData = JSON.parse(surfaceContent);

  const format = options.format || "markdown";
  const outputDir = options.outputDir || ".";
  const filename = options.output || `api-docs.${format === "html" ? "html" : "md"}`;
  const outputPath = path.isAbsolute(filename) ? filename : path.join(outputDir, filename);

  // Ensure output directory exists
  const outputDirPath = path.dirname(outputPath);
  await fs.mkdir(outputDirPath, { recursive: true });

  console.log(chalk.blue(`üìù Generating API ${format.toUpperCase()} documentation...`));
  console.log(chalk.dim(`Output: ${outputPath}`));

  const apiDocs = generateApiDocs(surfaceData, format);

  await safeFileOperation("write", outputPath, async (validatedPath) => {
    await fs.writeFile(validatedPath, apiDocs, "utf-8");
  });
  console.log(chalk.green(`‚úÖ Generated API documentation: ${outputPath}`));

  // Show next steps
  console.log(chalk.blue("\nüéØ Next steps:"));
  console.log(chalk.dim(`  üìñ View API docs: ${outputPath}`));
  console.log(chalk.dim("  üîÑ Update surface: arbiter surface <language> --diff"));

  return 0;
}

// Export helpers for testing
export const __docsTesting = {
  generateMarkdownDocs,
  generateHtmlDocs,
  generateExampleFiles,
  parseCueSchema,
  generateApiDocs,
};

interface ParseContext {
  schemaDoc: SchemaDoc;
  commentBuffer: string[];
}

/**
 * Try to extract an import from a CUE line.
 */
function tryExtractImport(line: string, ctx: ParseContext): boolean {
  if (!line.startsWith("import ")) return false;
  const importMatch = line.match(/import\s+"([^"]+)"/);
  if (importMatch) {
    ctx.schemaDoc.imports.push(importMatch[1]);
  }
  return true;
}

/**
 * Try to extract a comment from a CUE line.
 */
function tryExtractComment(line: string, ctx: ParseContext): boolean {
  if (!line.startsWith("//")) return false;
  ctx.commentBuffer.push(line.replace(/^\/\/\s*/, ""));
  return true;
}

/**
 * Determine if a field is required based on its type definition.
 */
function isFieldRequired(fieldType: string, line: string): boolean {
  return !fieldType.includes("?") && !line.includes("default:");
}

/**
 * Extract default value from a line if present.
 */
function extractDefaultValue(line: string): string | undefined {
  if (!line.includes("default:")) return undefined;
  const defaultMatch = line.match(/default:\s*([^,}]+)/);
  return defaultMatch?.[1]?.trim();
}

/**
 * Create a field documentation entry.
 */
function createFieldDoc(
  fieldName: string,
  fieldType: string,
  line: string,
  commentBuffer: string[],
): FieldDoc {
  return {
    name: fieldName,
    type: fieldType,
    description: commentBuffer.join(" "),
    required: isFieldRequired(fieldType, line),
    constraints: [],
    default: extractDefaultValue(line),
  };
}

/**
 * Try to extract a field definition from a CUE line.
 */
function tryExtractField(line: string, ctx: ParseContext): boolean {
  if (!line.includes(":") || line.startsWith("//")) return false;

  const fieldMatch = line.match(/^([^:]+):\s*(.+)$/);
  if (!fieldMatch) return false;

  const fieldName = fieldMatch[1].trim();
  const fieldType = fieldMatch[2].trim();

  // Skip internal fields
  if (fieldName.startsWith("_")) return true;

  const field = createFieldDoc(fieldName, fieldType, line, ctx.commentBuffer);
  ctx.schemaDoc.fields.push(field);

  // Reset comment buffer after processing a field
  ctx.commentBuffer = [];
  return true;
}

/**
 * Process a single line from CUE content.
 */
function processCueLine(line: string, ctx: ParseContext): void {
  const trimmedLine = line.trim();

  if (tryExtractImport(trimmedLine, ctx)) return;
  if (tryExtractComment(trimmedLine, ctx)) return;

  // If we process a field (or try to), reset comment buffer
  if (tryExtractField(trimmedLine, ctx)) return;

  // Non-matching lines reset the comment buffer
  if (trimmedLine && !trimmedLine.startsWith("//")) {
    ctx.commentBuffer = [];
  }
}

/**
 * Parse CUE schema to extract documentation information
 */
async function parseCueSchema(content: string): Promise<SchemaDoc> {
  const ctx: ParseContext = {
    schemaDoc: {
      name: "Arbiter Assembly",
      description: "Arbiter project configuration schema",
      fields: [],
      examples: [],
      constraints: [],
      imports: [],
    },
    commentBuffer: [],
  };

  for (const line of content.split("\n")) {
    processCueLine(line, ctx);
  }

  return ctx.schemaDoc;
}

/**
 * Generate API documentation from surface data
 */
function generateApiDocs(surfaceData: any, format: string): string {
  if (format === "html") {
    return generateApiDocsHtml(surfaceData);
  }
  return generateApiDocsMarkdown(surfaceData);
}

/**
 * Generate markdown header for API docs.
 */
function generateApiDocsHeader(): string {
  return `# API Documentation

> ü§ñ Auto-generated from source code analysis
> Last updated: ${new Date().toISOString()}

`;
}

/**
 * Generate markdown for function parameters.
 */
function generateParametersMarkdown(
  parameters: Array<{ name: string; type: string; description?: string }>,
): string {
  if (!parameters || parameters.length === 0) return "";

  let md = "**Parameters:**\n\n";
  for (const param of parameters) {
    md += `- \`${param.name}\` (${param.type}): ${param.description || "No description"}\n`;
  }
  return md + "\n";
}

/**
 * Generate markdown for function return value.
 */
function generateReturnsMarkdown(
  returns: { type: string; description?: string } | undefined,
): string {
  if (!returns) return "";

  let md = `**Returns:** \`${returns.type}\`\n\n`;
  if (returns.description) {
    md += `${returns.description}\n\n`;
  }
  return md;
}

/**
 * Generate markdown for a single function.
 */
function generateFunctionMarkdown(func: any): string {
  let md = `### \`${func.name}\`\n\n`;

  if (func.description) {
    md += `${func.description}\n\n`;
  }

  md += generateParametersMarkdown(func.parameters);
  md += generateReturnsMarkdown(func.returns);

  if (func.example) {
    md += `**Example:**\n\n\`\`\`typescript\n${func.example}\`\`\`\n\n`;
  }

  md += "---\n\n";
  return md;
}

/**
 * Generate API documentation in Markdown format
 */
function generateApiDocsMarkdown(surfaceData: any): string {
  let md = generateApiDocsHeader();

  if (surfaceData.functions && surfaceData.functions.length > 0) {
    md += "## Functions\n\n";
    for (const func of surfaceData.functions) {
      md += generateFunctionMarkdown(func);
    }
  }

  return md;
}

/**
 * Generate HTML document header with styles
 */
function generateHtmlHeader(): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>API Documentation</title>
  <style>${generateCssStyles()}</style>
</head>
<body>
  <header>
    <h1>API Documentation</h1>
    <div class="meta">Auto-generated on ${new Date().toLocaleString()}</div>
  </header>

  <main>`;
}

/**
 * Generate HTML footer
 */
function generateHtmlFooter(): string {
  return `
  </main>

  <footer>
    <p>Generated by <strong>Arbiter CLI</strong></p>
  </footer>
</body>
</html>`;
}

/**
 * Generate HTML for function parameters
 */
function generateParametersHtml(
  parameters: Array<{ name: string; type: string; description?: string }>,
): string {
  if (!parameters || parameters.length === 0) return "";

  const paramItems = parameters
    .map(
      (param) =>
        `<li><code>${param.name}</code> (${param.type}): ${param.description || "No description"}</li>`,
    )
    .join("");

  return `
        <h4>Parameters</h4>
        <ul>${paramItems}</ul>`;
}

/**
 * Generate HTML for function return value
 */
function generateReturnsHtml(returns: { type: string; description?: string } | undefined): string {
  if (!returns) return "";

  let html = `<h4>Returns</h4><p><code>${returns.type}</code></p>`;
  if (returns.description) {
    html += `<p>${returns.description}</p>`;
  }
  return html;
}

/**
 * Generate HTML for a single function
 */
function generateFunctionHtml(func: any): string {
  const descriptionHtml = func.description ? `<p>${func.description}</p>` : "";
  const parametersHtml = generateParametersHtml(func.parameters);
  const returnsHtml = generateReturnsHtml(func.returns);

  return `
      <div class="function">
        <h3><code>${func.name}</code></h3>${descriptionHtml}${parametersHtml}${returnsHtml}</div>`;
}

/**
 * Generate HTML for functions section
 */
function generateFunctionsSectionHtml(functions: any[]): string {
  if (!functions || functions.length === 0) return "";

  const functionsHtml = functions.map(generateFunctionHtml).join("");
  return `
    <section id="functions">
      <h2>Functions</h2>${functionsHtml}</section>`;
}

/**
 * Generate API documentation in HTML format
 */
function generateApiDocsHtml(surfaceData: any): string {
  return (
    generateHtmlHeader() +
    generateFunctionsSectionHtml(surfaceData.functions) +
    generateHtmlFooter()
  );
}

/**
 * Generate example files alongside documentation
 */
async function generateExampleFiles(_schemaInfo: SchemaDoc, outputDir: string): Promise<void> {
  const examplesDir = path.join(outputDir, "examples");
  await fs.mkdir(examplesDir, { recursive: true });

  await safeFileOperation("write", path.join(examplesDir, "library.cue"), async (validatedPath) => {
    await fs.writeFile(validatedPath, LIBRARY_EXAMPLE_TEMPLATE);
  });

  await safeFileOperation("write", path.join(examplesDir, "cli.cue"), async (validatedPath) => {
    await fs.writeFile(validatedPath, CLI_EXAMPLE_TEMPLATE);
  });

  console.log(chalk.green(`‚úÖ Generated example files in ${examplesDir}`));
}

/**
 * Show help for docs command
 */
function showDocsHelp(): void {
  console.log(`
${chalk.bold("arbiter docs")} - Documentation generation

${chalk.bold("USAGE:")}
  arbiter docs schema [options]     Generate schema documentation from CUE
  arbiter docs api [options]        Generate API documentation from surface
  arbiter docs help                 Show this help

${chalk.bold("OPTIONS:")}
  --format <type>      Output format: markdown, html, json (default: markdown)
  --output <file>      Output file path (auto-named if not specified)
  --examples          Generate example files alongside documentation
  --interactive       Interactive documentation setup

${chalk.bold("EXAMPLES:")}
  arbiter docs schema                           # Generate Markdown schema docs
  arbiter docs schema --format html            # Generate HTML documentation
  arbiter docs schema --examples --format json # Generate JSON schema + examples
  arbiter docs api --format html               # Generate API docs from surface.json
`);
}
