/**
 * @packageDocumentation
 * Project and service structure generation.
 *
 * Handles service infrastructure artifacts, project scaffolding,
 * and language-specific file generation for different project types.
 */

import path from "node:path";
import type { ProjectConfig as LanguageProjectConfig } from "@/language-support/index.js";
import {
  generateGoFiles,
  generatePythonFiles,
  generateRustFiles,
  generateTypeScriptFiles,
} from "@/services/generate/api/language-generators.js";
import {
  determinePathOwnership,
  isTypeScriptServiceLanguage,
} from "@/services/generate/api/route-derivation.js";
import { type PathRouter, createRouter } from "@/services/generate/core/compose/router.js";
import {
  type TargetCreationOptions,
  createServiceTarget,
} from "@/services/generate/core/orchestration/targets.js";
import {
  configureTemplateOrchestrator,
  getConfiguredLanguagePlugin,
  initializeProject,
} from "@/services/generate/core/orchestration/template-orchestrator.js";
import { writeClientReadme, writeServiceReadme } from "@/services/generate/helpers/readme.js";
import type {
  ClientGenerationTarget,
  ServiceGenerationTarget,
} from "@/services/generate/io/contexts.js";
import {
  generateClientDockerArtifacts,
  generateServiceDockerArtifacts,
  getPrimaryServicePort,
} from "@/services/generate/util/docker/docker-generator.js";
import { ensureDirectory, writeFileWithHooks } from "@/services/generate/util/hook-executor.js";
import { joinRelativePath, slugify } from "@/services/generate/util/shared.js";
import type { GenerateOptions, GenerationReporter } from "@/services/generate/util/types.js";
import type { CLIConfig, ProjectStructureConfig } from "@/types.js";
import type { PackageManagerCommandSet } from "@/utils/io/package-manager.js";
import { type AppSpec, getBehaviorsArray, getPackages } from "@arbiter/specification";
import chalk from "chalk";
import fs from "fs-extra";

const reporter: GenerationReporter = {
  info: (...args: any[]) => console.info(...args),
  warn: (...args: any[]) => console.warn(...args),
  error: (...args: any[]) => console.error(...args),
};

/**
 * Generate README overview section
 */
function generateReadmeOverview(appSpec: AppSpec): string {
  return appSpec.product.goals
    ? appSpec.product.goals.map((goal) => `- ${goal}`).join("\n")
    : "No goals specified";
}

/**
 * Generate README constraints section (if any)
 */
function generateReadmeConstraints(appSpec: AppSpec): string {
  if (!appSpec.product.constraints) return "";
  return `
## Constraints

${appSpec.product.constraints.map((constraint) => `- ${constraint}`).join("\n")}
`;
}

/**
 * Generate README routes section
 */
function generateReadmeRoutes(appSpec: AppSpec): string {
  const routes = (appSpec as any).ui?.routes;
  return (
    routes
      ?.map(
        (route: any) =>
          `- **${route.path}** (${route.id}): ${route.capabilities?.join(", ") ?? "none"}`,
      )
      .join("\n") ?? "No routes defined"
  );
}

/**
 * Generate README behaviors section
 */
function generateReadmeBehaviors(appSpec: AppSpec): string {
  return (
    getBehaviorsArray(appSpec)
      ?.map((behavior: any) => `- **${behavior.id}**: ${behavior.steps?.length ?? 0} steps`)
      .join("\n") ?? "No behaviors defined"
  );
}

/**
 * Generate project README content
 */
function generateProjectReadme(appSpec: AppSpec, packageManager: PackageManagerCommandSet): string {
  const workflowCommands = [
    packageManager.install,
    `${packageManager.exec("playwright", "install --with-deps")}   # one-time Playwright browser install`,
    packageManager.run("lint"),
    packageManager.run("build"),
    packageManager.run("test"),
    packageManager.run("test:e2e"),
  ].join("\n");

  return `# ${appSpec.product.name}

Generated by Arbiter from app specification.

## Overview

${generateReadmeOverview(appSpec)}
${generateReadmeConstraints(appSpec)}

## Routes

${generateReadmeRoutes(appSpec)}

## Behaviors

${generateReadmeBehaviors(appSpec)}

## Development Workflow

\`\`\`bash
${workflowCommands}
\`\`\`

### Just Commands
\`\`\`bash
just test       # equivalent to ${packageManager.run("test")}
just test-e2e   # equivalent to ${packageManager.run("test:e2e")}
\`\`\`
`;
}

/**
 * Generate minimal package.json when no plugin available
 */
function generateMinimalPackageJson(appSpec: AppSpec, structure: ProjectStructureConfig): object {
  return {
    name: appSpec.product.name.toLowerCase().replace(/\s+/g, "-"),
    version: "1.0.0",
    description: appSpec.product.goals?.join("; ") || "Generated by Arbiter",
    arbiter: {
      projectStructure: {
        services: structure.servicesDirectory,
        packages: structure.packagesDirectory,
        tools: structure.toolsDirectory,
        docs: structure.docsDirectory,
        tests: structure.testsDirectory,
        infra: structure.infraDirectory,
      },
    },
  };
}

/**
 * Generate service infrastructure artifacts
 */
export async function generateServiceInfrastructureArtifacts(
  serviceTarget: ServiceGenerationTarget,
  serviceSpec: any,
  options: GenerateOptions,
): Promise<string[]> {
  const outputs: string[] = [];
  const readmePath = await writeServiceReadme(serviceTarget, serviceSpec, options);
  outputs.push(readmePath);
  return outputs;
}

/**
 * Build dev proxy config for Vite
 */
export function buildDevProxyConfig(
  appSpec: AppSpec,
  pathOwnership: Map<string, string>,
): Record<string, { target: string; changeOrigin: boolean }> {
  const proxies: Record<string, { target: string; changeOrigin: boolean }> = {};

  for (const [pathKey, ownerSlug] of pathOwnership.entries()) {
    const normalized = pathKey.replace(/^\/+/, "");
    if (!normalized) continue;
    const firstSegment = normalized.split("/")[0];
    if (!firstSegment) continue;
    const prefix = `/${firstSegment}`;
    if (proxies[prefix]) continue;

    const packageEntry = Object.entries(getPackages(appSpec) ?? {}).find(
      ([packageName]) => slugify(packageName, packageName) === ownerSlug,
    );
    if (!packageEntry) continue;
    const [, packageSpec] = packageEntry;
    if (!isTypeScriptServiceLanguage((packageSpec as any)?.language as string | undefined))
      continue;

    const port = getPrimaryServicePort(packageSpec, 3000);
    proxies[prefix] = {
      target: `http://127.0.0.1:${port}`,
      changeOrigin: true,
    };
  }

  return proxies;
}

/**
 * Enhance client dev server with proxy configuration
 */
export async function enhanceClientDevServer(
  appSpec: AppSpec,
  clientTarget: ClientGenerationTarget,
  options: GenerateOptions,
): Promise<void> {
  const viteConfigPath = path.join(clientTarget.context.root, "vite.config.ts");
  if (!fs.existsSync(viteConfigPath)) {
    return;
  }

  const pathOwnership = determinePathOwnership(appSpec);
  const proxies = buildDevProxyConfig(appSpec, pathOwnership);

  const proxyEntries = Object.entries(proxies)
    .map(
      ([prefix, proxy]) => `      '${prefix}': {
        target: '${proxy.target}',
        changeOrigin: ${proxy.changeOrigin ? "true" : "false"},
      },`,
    )
    .join("\n");

  const proxyBlock = Object.keys(proxies).length
    ? `    proxy: {
${proxyEntries}
    },
`
    : "";

  const viteConfig = `import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    host: '127.0.0.1',
    port: 5173,
    strictPort: true,
${proxyBlock}  },
  build: {
    target: 'es2022',
    sourcemap: true
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test-setup.ts'],
  },
});
`;

  await writeFileWithHooks(viteConfigPath, viteConfig, options);
}

/**
 * Build project configuration from app spec
 */
function buildProjectConfig(appSpec: AppSpec): LanguageProjectConfig {
  return {
    name: appSpec.product.name.toLowerCase().replace(/\s+/g, "-"),
    description: appSpec.product.goals?.join("; ") || "Generated by Arbiter",
    features: [],
    testing: true,
  };
}

/**
 * Write project files from initialization result
 */
async function writeProjectFiles(
  result: {
    files: Array<{ path: string; content: string; executable?: boolean }>;
    instructions?: string[];
  },
  context: { root: string },
  relativeRoot: string,
  options: GenerateOptions,
): Promise<string[]> {
  const files: string[] = [];

  for (const file of result.files) {
    const fullPath = path.join(context.root, file.path);
    await ensureDirectory(path.dirname(fullPath), options);
    await writeFileWithHooks(fullPath, file.content, options, file.executable ? 0o755 : undefined);
    files.push(joinRelativePath(relativeRoot, file.path));
  }

  if (result.instructions) {
    result.instructions.forEach((instruction) => console.log(chalk.green(`‚úÖ ${instruction}`)));
  }

  return files;
}

/**
 * Initialize project with language plugin
 */
async function initializeWithPlugin(
  language: string,
  appSpec: AppSpec,
  context: { root: string },
  relativeRoot: string,
  options: GenerateOptions,
  cliConfig: CLIConfig,
  plugin: ReturnType<typeof getConfiguredLanguagePlugin>,
): Promise<string[]> {
  console.log(chalk.blue(`üì¶ Initializing ${language} project using ${plugin!.name}...`));
  configureTemplateOrchestrator(language, cliConfig);

  try {
    const result = await initializeProject(language, buildProjectConfig(appSpec));
    return writeProjectFiles(result, context, relativeRoot, options);
  } catch (error: any) {
    console.error(chalk.red(`‚ùå Failed to initialize ${language} project:`), error.message);
    return [];
  }
}

/**
 * Initialize project with minimal structure (no plugin)
 */
async function initializeMinimalStructure(
  appSpec: AppSpec,
  structure: ProjectStructureConfig,
  context: { root: string },
  relativeRoot: string,
  options: GenerateOptions,
  language: string,
): Promise<string[]> {
  console.log(
    chalk.yellow(`‚ö†Ô∏è  No language plugin available for '${language}', using minimal structure`),
  );

  const packageJson = generateMinimalPackageJson(appSpec, structure);
  const packagePath = path.join(context.root, "package.json");
  await ensureDirectory(path.dirname(packagePath), options);
  await writeFileWithHooks(packagePath, JSON.stringify(packageJson, null, 2), options);

  return [joinRelativePath(relativeRoot, "package.json")];
}

/**
 * Generate project structure from app specification.
 */
export async function generateProjectStructure(
  appSpec: AppSpec,
  outputDir: string,
  options: GenerateOptions,
  structure: ProjectStructureConfig,
  clientTarget: ClientGenerationTarget,
  cliConfig: CLIConfig,
  packageManager: PackageManagerCommandSet,
): Promise<string[]> {
  const { context, relativeRoot } = clientTarget;
  const language = appSpec.config?.language || "typescript";
  const plugin = getConfiguredLanguagePlugin(language);

  const files: string[] = plugin
    ? await initializeWithPlugin(
        language,
        appSpec,
        context,
        relativeRoot,
        options,
        cliConfig,
        plugin,
      )
    : await initializeMinimalStructure(
        appSpec,
        structure,
        context,
        relativeRoot,
        options,
        language,
      );

  // Generate README
  const readmePath = path.join(context.root, "README.md");
  await writeFileWithHooks(readmePath, generateProjectReadme(appSpec, packageManager), options);
  files.push(joinRelativePath(relativeRoot, "README.md"));

  // Generate Docker artifacts
  const dockerArtifacts = await generateClientDockerArtifacts(
    clientTarget,
    appSpec,
    options,
    cliConfig,
    packageManager,
  );
  files.push(...dockerArtifacts.map((artifact) => joinRelativePath(relativeRoot, artifact)));

  await enhanceClientDevServer(appSpec, clientTarget, options);

  return files;
}

interface ServiceGenerationResult {
  files: string[];
  supportsCodeScaffold: boolean;
}

/**
 * Generate language-specific files for a service
 */
async function generateLanguageFiles(
  language: string,
  generationPayload: any,
  serviceContext: { root: string },
  options: GenerateOptions,
  structure: ProjectStructureConfig,
  serviceTarget: ServiceGenerationTarget,
  appSpec: AppSpec,
  pathOwnership: Map<string, string>,
): Promise<ServiceGenerationResult> {
  switch (language) {
    case "typescript":
      return {
        files: await generateTypeScriptFiles(
          generationPayload,
          serviceContext.root,
          options,
          structure,
          serviceTarget,
          appSpec,
          pathOwnership,
        ),
        supportsCodeScaffold: true,
      };
    case "python":
      return {
        files: await generatePythonFiles(
          generationPayload,
          serviceContext.root,
          options,
          structure,
          serviceTarget,
        ),
        supportsCodeScaffold: true,
      };
    case "go":
      return {
        files: await generateGoFiles(
          generationPayload,
          serviceContext.root,
          options,
          structure,
          serviceTarget,
        ),
        supportsCodeScaffold: true,
      };
    case "rust":
      return {
        files: await generateRustFiles(
          generationPayload,
          serviceContext.root,
          options,
          structure,
          serviceTarget,
        ),
        supportsCodeScaffold: true,
      };
    case "container":
    case "prebuilt":
    case "image":
      console.log(
        chalk.dim("    ‚ÑπÔ∏è  Using prebuilt/container workload; generating infrastructure only."),
      );
      return { files: [], supportsCodeScaffold: false };
    default:
      console.log(
        chalk.yellow(
          `    ‚ö†Ô∏è  Service language '${language}' not supported for automated scaffolding.`,
        ),
      );
      return { files: [], supportsCodeScaffold: false };
  }
}

/**
 * Process a single service and generate its artifacts
 */
async function processService(
  serviceName: string,
  serviceConfig: any,
  appSpec: AppSpec,
  outputDir: string,
  options: GenerateOptions,
  structure: ProjectStructureConfig,
  cliConfig: CLIConfig,
  packageManager: PackageManagerCommandSet,
  pathOwnership: Map<string, string>,
  targetOptions?: TargetCreationOptions,
): Promise<string[]> {
  const serviceTarget = createServiceTarget(
    serviceName,
    serviceConfig,
    structure,
    outputDir,
    targetOptions,
  );
  const { context: serviceContext } = serviceTarget;
  await ensureDirectory(serviceContext.root, options);

  const language = serviceTarget.language;
  const relativePrefix = serviceTarget.relativeRoot.split("/");

  console.log(
    chalk.dim(`  ‚Ä¢ ${serviceName} (${language}) -> ${joinRelativePath(...relativePrefix)}`),
  );

  const generationPayload = {
    name: serviceTarget.slug,
    originalName: serviceTarget.key,
    version: "1.0.0",
    service: serviceConfig,
    routesDir: serviceContext.routesDir,
  };

  const files: string[] = [];

  // Generate language-specific files
  const { files: generated, supportsCodeScaffold } = await generateLanguageFiles(
    language,
    generationPayload,
    serviceContext,
    options,
    structure,
    serviceTarget,
    appSpec,
    pathOwnership,
  );

  if (generated.length > 0) {
    files.push(
      ...generated.map((file) => joinRelativePath(...relativePrefix, file.replace(/^\.\//, ""))),
    );
  }

  // Generate Docker artifacts for supported languages
  if (supportsCodeScaffold) {
    const dockerArtifacts = await generateServiceDockerArtifacts(
      serviceTarget,
      serviceConfig,
      options,
      cliConfig,
      structure,
      packageManager,
    );
    files.push(...dockerArtifacts.map((artifact) => joinRelativePath(...relativePrefix, artifact)));
  }

  // Generate infrastructure artifacts for all services
  const infraArtifacts = await generateServiceInfrastructureArtifacts(
    serviceTarget,
    serviceConfig,
    options,
  );
  files.push(
    ...infraArtifacts.map((artifact) =>
      joinRelativePath(...relativePrefix, artifact.replace(/^\.\//, "")),
    ),
  );

  return files;
}

/**
 * Generate service structures from app specification packages.
 */
export async function generateServiceStructures(
  appSpec: AppSpec,
  outputDir: string,
  options: GenerateOptions,
  structure: ProjectStructureConfig,
  cliConfig: CLIConfig,
  packageManager: PackageManagerCommandSet,
): Promise<string[]> {
  // Get services from both appSpec.services (markdown parser) and packages (CUE parser)
  const servicesFromMarkdown = (appSpec as any).services as Record<string, any> | undefined;
  const packagesFromCue = getPackages(appSpec) ?? {};

  // Merge both sources, with markdown services taking precedence
  const allServices: Record<string, any> = {
    ...packagesFromCue,
    ...(servicesFromMarkdown ?? {}),
  };

  // Filter to only include service/worker subtypes (not frontends)
  const serviceEntries = Object.entries(allServices).filter(([, config]) => {
    if (!config || typeof config !== "object") return false;
    const subtype = config.subtype;
    // Include services with subtype service/worker, or any with a port (backend services)
    // Exclude frontends
    if (subtype === "frontend") return false;
    return subtype === "service" || subtype === "worker" || config.port;
  });

  if (serviceEntries.length === 0) {
    return [];
  }

  console.log(chalk.blue("üîß Generating service structures..."));

  const files: string[] = [];
  const pathOwnership = determinePathOwnership(appSpec);

  // Create router from config for path resolution
  const router = await createRouter(cliConfig.generator?.routing, outputDir);
  const groups = (appSpec as any).groups ?? {};
  const targetOptions: TargetCreationOptions = {
    router,
    groups,
    defaultConfig: cliConfig.default,
  };

  for (const [packageName, packageConfig] of serviceEntries) {
    const packageFiles = await processService(
      packageName,
      packageConfig,
      appSpec,
      outputDir,
      options,
      structure,
      cliConfig,
      packageManager,
      pathOwnership,
      targetOptions,
    );
    files.push(...packageFiles);
  }

  return files;
}
