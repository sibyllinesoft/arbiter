/**
 * @packageDocumentation
 * README and documentation generation helpers.
 *
 * Provides utilities for generating project documentation including
 * README files, environment variable references, and command documentation.
 */

import path from "node:path";
import type { ClientGenerationTarget } from "@/services/generate/io/contexts.js";
import { ensureDirectory, writeFileWithHooks } from "@/services/generate/util/hook-executor.js";
import { joinRelativePath } from "@/services/generate/util/shared.js";
import type { GenerateOptions } from "@/services/generate/util/types.js";
import type { ProjectStructureConfig } from "@/types.js";
import type { PackageManagerCommandSet } from "@/utils/io/package-manager.js";
import type { AppSpec } from "@arbiter/shared";
import {
  getBuildCommand,
  getInstallCommand,
  getLintCommand,
  getRunCommand,
  getTestCommand,
} from "./commands.js";

export async function writeClientReadme(
  appSpec: AppSpec,
  clientTarget: ClientGenerationTarget,
  packageManager: PackageManagerCommandSet,
  options: GenerateOptions,
): Promise<string> {
  const workflowCommands = [
    packageManager.install,
    `${packageManager.exec("playwright", "install --with-deps")}   # one-time Playwright browser install`,
    packageManager.run("lint"),
    packageManager.run("build"),
    packageManager.run("test"),
    packageManager.run("test:e2e"),
  ].join("\n");

  const makeTestEquivalent = packageManager.run("test");
  const makeE2eEquivalent = packageManager.run("test:e2e");

  const readmeContent = `# ${appSpec.product.name}

Generated by Arbiter from app specification.

## Overview

${appSpec.product.goals ? appSpec.product.goals.map((goal) => `- ${goal}`).join("\n") : "No goals specified"}

${
  appSpec.product.constraints
    ? `
## Constraints

${appSpec.product.constraints.map((constraint) => `- ${constraint}`).join("\n")}
`
    : ""
}

## Routes

${((appSpec as any).ui?.routes ?? []).map((route: any) => `- **${route.path}** (${route.id}): ${(route.capabilities ?? []).join(", ")}`).join("\n") || "No routes defined"}

## Flows

${appSpec.behaviors.map((flow) => `- **${flow.id}**: ${flow.steps.length} steps`).join("\n")}

## Development Workflow

\`\`\`bash
${workflowCommands}
\`\`\`

### Make Targets
\`\`\`bash
make test       # equivalent to ${makeTestEquivalent}
make test-e2e   # equivalent to ${makeE2eEquivalent}
\`\`\`
`;

  const readmePath = path.join(clientTarget.context.root, "README.md");
  await writeFileWithHooks(readmePath, readmeContent, options);
  return joinRelativePath(clientTarget.relativeRoot, "README.md");
}

export function formatPortsSection(ports: any[]): string[] {
  if (ports.length === 0) {
    return ["- None declared (update the spec to expose health or admin ports)."];
  }
  return ports.map(
    (port) =>
      `- ${port.name || "port"}: ${port.port}${port.targetPort ? ` â†’ ${port.targetPort}` : ""}`,
  );
}

export function formatEnvSection(envBlock: Record<string, string>): string[] {
  if (Object.keys(envBlock).length === 0) {
    return ["- No environment variables declared."];
  }
  return Object.entries(envBlock).map(([key, value]) => `- ${key}=${value}`);
}

export function formatDependenciesSection(dependencies: string[] | undefined): string[] {
  if (!Array.isArray(dependencies) || dependencies.length === 0) {
    return [];
  }
  return ["", "## Dependencies", "", ...dependencies.map((dep) => `- ${dep}`)];
}

export async function writeServiceReadme(
  serviceTarget: { context: { root: string }; slug: string; key: string },
  serviceSpec: any,
  options: GenerateOptions,
): Promise<string> {
  const serviceSlug = serviceTarget.slug;
  const displayName = serviceTarget.key;
  const envBlock = collectServiceEnvironmentVariables(serviceSpec);
  const artifactType =
    serviceSpec?.type ?? serviceSpec?.artifactType ?? serviceSpec?.workload ?? "deployment";

  const ports = Array.isArray(serviceSpec?.ports) ? serviceSpec.ports : [];

  const readmeLines = [
    `# ${displayName}`,
    "",
    "This directory contains application code and infrastructure references generated by Arbiter.",
    "",
    "## Runtime Image",
    "",
    `- **Image:** ${serviceSpec?.image ?? `ghcr.io/your-org/${serviceSlug}:latest`}`,
    artifactType ? `- **Artifact Type:** ${artifactType}` : "",
    "",
    "## Ports",
    "",
    ...formatPortsSection(ports),
    "",
    "## Environment",
    "",
    ...formatEnvSection(envBlock),
    ...formatDependenciesSection(serviceSpec?.dependencies),
  ];

  const readmeContent = readmeLines.join("\n");
  const readmePath = path.join(serviceTarget.context.root, "README.md");
  await writeFileWithHooks(readmePath, readmeContent, options);
  // Return just the filename - caller adds the service prefix
  return "README.md";
}

export function collectServiceEnvironmentVariables(serviceSpec: any): Record<string, string> {
  const env: Record<string, string> = {};
  if (serviceSpec?.env && typeof serviceSpec.env === "object") {
    Object.assign(env, serviceSpec.env);
  }
  if (serviceSpec?.database?.url) {
    env["DATABASE_URL"] = serviceSpec.database.url;
  }
  return env;
}
