import { readFile, writeFile } from "node:fs/promises";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import { safeFileOperation } from "@/constraints/index.js";
import {
  API_VERSION,
  type ExecutionReport,
  type JUnitTestSuite,
  type NDJSONEvent,
  type PhaseEvent,
  type PlanOutput,
  type StandardizedOutput,
  type SurfaceOutput,
  type TraceOutput,
} from "@/types/output.js";
import chalk from "chalk";

/**
 * Output utility class for managing standardized outputs
 */
export class StandardizedOutputManager {
  private agentMode: boolean;
  private command: string;

  constructor(command: string, agentMode = false) {
    this.command = command;
    this.agentMode = agentMode;
  }

  /**
   * Create standardized output base with apiVersion stamping
   */
  private createBaseOutput(): StandardizedOutput {
    return {
      apiVersion: API_VERSION,
      timestamp: Date.now(),
      command: this.command,
      version: this.getPackageVersion(),
    };
  }

  private tryReadPackageVersion(packagePath: string): string | null {
    try {
      const fs = require("fs");
      const packageJson = JSON.parse(fs.readFileSync(packagePath, "utf8"));
      return packageJson.version || null;
    } catch {
      return null;
    }
  }

  /**
   * Get version from package.json
   */
  private getPackageVersion(): string {
    try {
      const currentDir = dirname(fileURLToPath(import.meta.url));
      const packagePaths = [
        join(currentDir, "../../package.json"),
        join(currentDir, "../../../package.json"),
      ];

      for (const packagePath of packagePaths) {
        const version = this.tryReadPackageVersion(packagePath);
        if (version) {
          return version;
        }
      }
    } catch {
      // Fallback if version detection fails
    }

    return "0.1.0";
  }

  /**
   * Write plan.json file
   */
  async writePlanFile(
    plan: PlanOutput["plan"],
    guards: PlanOutput["guards"],
    diff: PlanOutput["diff"],
    outputPath = "plan.json",
    metadata?: Record<string, unknown>,
  ): Promise<void> {
    const output: PlanOutput = {
      ...this.createBaseOutput(),
      kind: "Plan",
      plan,
      guards,
      diff,
      metadata,
    };

    await this.writeFileSafely(outputPath, JSON.stringify(output, null, 2));

    if (!this.agentMode) {
      console.log(chalk.green(`✅ Plan written to ${outputPath}`));
    }
  }

  /**
   * Write diff.txt file
   */
  async writeDiffFile(diff: string, outputPath = "diff.txt"): Promise<void> {
    const header = `# Diff Report\n# Generated by Arbiter CLI v${API_VERSION}\n# Timestamp: ${new Date().toISOString()}\n# Command: ${this.command}\n\n`;

    await this.writeFileSafely(outputPath, header + diff);

    if (!this.agentMode) {
      console.log(chalk.green(`✅ Diff written to ${outputPath}`));
    }
  }

  /**
   * Write junit.xml file
   */
  async writeJUnitFile(testSuite: JUnitTestSuite, outputPath = "junit.xml"): Promise<void> {
    const xml = this.generateJUnitXML(testSuite);
    await this.writeFileSafely(outputPath, xml);

    if (!this.agentMode) {
      console.log(chalk.green(`✅ JUnit report written to ${outputPath}`));
    }
  }

  /**
   * Write report.json file
   */
  async writeReportFile(report: ExecutionReport, outputPath = "report.json"): Promise<void> {
    await this.writeFileSafely(outputPath, JSON.stringify(report, null, 2));

    if (!this.agentMode) {
      console.log(chalk.green(`✅ Execution report written to ${outputPath}`));
    }
  }

  /**
   * Write TRACE.json file
   */
  async writeTraceFile(trace: TraceOutput, outputPath = "TRACE.json"): Promise<void> {
    await this.writeFileSafely(outputPath, JSON.stringify(trace, null, 2));

    if (!this.agentMode) {
      console.log(chalk.green(`✅ Trace report written to ${outputPath}`));
    }
  }

  /**
   * Write surface.json file
   */
  async writeSurfaceFile(surface: SurfaceOutput, outputPath = "surface.json"): Promise<void> {
    await this.writeFileSafely(outputPath, JSON.stringify(surface, null, 2));

    if (!this.agentMode) {
      console.log(chalk.green(`✅ Surface analysis written to ${outputPath}`));
    }
  }

  /**
   * Event hook (NDJSON streaming removed)
   */
  emitEvent(_event: PhaseEvent & { timestamp?: number }): void {
    // NDJSON streaming removed; events are no longer emitted
  }

  close(): void {
    // No stream to close when NDJSON file output is disabled
  }

  private async writeFileSafely(outputPath: string, content: string): Promise<void> {
    await safeFileOperation("write", outputPath, async (validatedPath) => {
      await writeFile(validatedPath, content);
    });
  }

  /**
   * Generate JUnit XML format
   */
  private generateJUnitXML(testSuite: JUnitTestSuite): string {
    const testCasesXml = testSuite.testcases
      .map((testcase) => {
        let testCaseContent = "";

        if (testcase.failure) {
          testCaseContent += `    <failure message="${this.escapeXml(testcase.failure.message)}" type="${this.escapeXml(testcase.failure.type)}">${this.escapeXml(testcase.failure.content)}</failure>\n`;
        }

        if (testcase.error) {
          testCaseContent += `    <error message="${this.escapeXml(testcase.error.message)}" type="${this.escapeXml(testcase.error.type)}">${this.escapeXml(testcase.error.content)}</error>\n`;
        }

        return `  <testcase classname="${this.escapeXml(testcase.classname)}" name="${this.escapeXml(testcase.name)}" time="${testcase.time}">
${testCaseContent}  </testcase>`;
      })
      .join("\n");

    return `<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by Arbiter CLI ${API_VERSION} -->
<testsuite name="${this.escapeXml(testSuite.name)}" tests="${testSuite.tests}" failures="${testSuite.failures}" errors="${testSuite.errors}" time="${testSuite.time}" timestamp="${new Date().toISOString()}">
${testCasesXml}
</testsuite>`;
  }

  /**
   * Escape XML special characters
   */
  private escapeXml(text: string): string {
    return text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#x27;");
  }
}

/**
 * Helper function to create output manager for commands
 */
export function createOutputManager(command: string, agentMode = false): StandardizedOutputManager {
  return new StandardizedOutputManager(command, agentMode);
}

/**
 * Helper function to add --agent-mode flag to commands
 */
export function addAgentModeOption(command: any): void {
  command.option("--agent-mode", "deprecated; no-op");
}

export { API_VERSION } from "@/types/output.js";
export type {
  ExecutionReport,
  JUnitTestSuite,
  NDJSONEvent,
  PhaseEvent,
  PlanOutput,
  StandardizedOutput,
  SurfaceOutput,
  TraceOutput,
} from "@/types/output.js";
