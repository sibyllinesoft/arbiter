import { createWriteStream } from "node:fs";
import { readFile, writeFile } from "node:fs/promises";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import chalk from "chalk";
import { safeFileOperation } from "../constraints/index.js";
import {
  API_VERSION,
  type ExecutionReport,
  type JUnitTestSuite,
  type NDJSONEvent,
  type PhaseEvent,
  type PlanOutput,
  type StandardizedOutput,
  type SurfaceOutput,
  type TraceOutput,
} from "../types/output.js";

/**
 * Output utility class for managing standardized outputs
 */
export class StandardizedOutputManager {
  private agentMode: boolean;
  private command: string;
  private ndjsonStream?: NodeJS.WritableStream;

  constructor(command: string, agentMode = false, ndjsonOutput?: string) {
    this.command = command;
    this.agentMode = agentMode;

    if (agentMode && ndjsonOutput) {
      this.ndjsonStream = createWriteStream(ndjsonOutput);
    }
  }

  /**
   * Create standardized output base with apiVersion stamping
   */
  private createBaseOutput(): StandardizedOutput {
    return {
      apiVersion: API_VERSION,
      timestamp: Date.now(),
      command: this.command,
      version: this.getPackageVersion(),
    };
  }

  /**
   * Get version from package.json
   */
  private getPackageVersion(): string {
    try {
      // Try to find package.json by walking up from current file
      const currentDir = dirname(fileURLToPath(import.meta.url));
      const packagePaths = [
        join(currentDir, "../../package.json"), // cli package
        join(currentDir, "../../../package.json"), // root package
      ];

      for (const packagePath of packagePaths) {
        try {
          const fs = require("fs");
          const packageJson = JSON.parse(fs.readFileSync(packagePath, "utf8"));
          if (packageJson.version) {
            return packageJson.version;
          }
        } catch {
          // Continue to next path
        }
      }
    } catch {
      // Fallback if version detection fails
    }

    return "0.1.0"; // Fallback version
  }

  /**
   * Write plan.json file
   */
  async writePlanFile(
    plan: PlanOutput["plan"],
    guards: PlanOutput["guards"],
    diff: PlanOutput["diff"],
    outputPath = "plan.json",
    metadata?: Record<string, unknown>,
  ): Promise<void> {
    const output: PlanOutput = {
      ...this.createBaseOutput(),
      kind: "Plan",
      plan,
      guards,
      diff,
      metadata,
    };

    await this.writeFileSafely(outputPath, JSON.stringify(output, null, 2));

    if (!this.agentMode) {
      console.log(chalk.green(`✅ Plan written to ${outputPath}`));
    }
  }

  /**
   * Write diff.txt file
   */
  async writeDiffFile(diff: string, outputPath = "diff.txt"): Promise<void> {
    const header = `# Diff Report\n# Generated by Arbiter CLI v${API_VERSION}\n# Timestamp: ${new Date().toISOString()}\n# Command: ${this.command}\n\n`;

    await this.writeFileSafely(outputPath, header + diff);

    if (!this.agentMode) {
      console.log(chalk.green(`✅ Diff written to ${outputPath}`));
    }
  }

  /**
   * Write junit.xml file
   */
  async writeJUnitFile(testSuite: JUnitTestSuite, outputPath = "junit.xml"): Promise<void> {
    const xml = this.generateJUnitXML(testSuite);
    await this.writeFileSafely(outputPath, xml);

    if (!this.agentMode) {
      console.log(chalk.green(`✅ JUnit report written to ${outputPath}`));
    }
  }

  /**
   * Write report.json file
   */
  async writeReportFile(report: ExecutionReport, outputPath = "report.json"): Promise<void> {
    await this.writeFileSafely(outputPath, JSON.stringify(report, null, 2));

    if (!this.agentMode) {
      console.log(chalk.green(`✅ Execution report written to ${outputPath}`));
    }
  }

  /**
   * Write TRACE.json file
   */
  async writeTraceFile(trace: TraceOutput, outputPath = "TRACE.json"): Promise<void> {
    await this.writeFileSafely(outputPath, JSON.stringify(trace, null, 2));

    if (!this.agentMode) {
      console.log(chalk.green(`✅ Trace report written to ${outputPath}`));
    }
  }

  /**
   * Write surface.json file
   */
  async writeSurfaceFile(surface: SurfaceOutput, outputPath = "surface.json"): Promise<void> {
    await this.writeFileSafely(outputPath, JSON.stringify(surface, null, 2));

    if (!this.agentMode) {
      console.log(chalk.green(`✅ Surface analysis written to ${outputPath}`));
    }
  }

  /**
   * Emit NDJSON event for agent consumption
   */
  emitEvent(event: PhaseEvent & { timestamp?: number }): void {
    if (!this.agentMode) return;

    const ndjsonEvent: NDJSONEvent = {
      ...event,
      timestamp: event.timestamp || Date.now(),
    };

    const line = `${JSON.stringify(ndjsonEvent)}\n`;

    if (this.ndjsonStream) {
      this.ndjsonStream.write(line);
    } else {
      // Write to stdout for agent consumption
      process.stdout.write(line);
    }
  }

  /**
   * Close NDJSON stream
   */
  close(): void {
    if (this.ndjsonStream) {
      this.ndjsonStream.end();
    }
  }

  private async writeFileSafely(outputPath: string, content: string): Promise<void> {
    await safeFileOperation("write", outputPath, async (validatedPath) => {
      await writeFile(validatedPath, content);
    });
  }

  /**
   * Generate JUnit XML format
   */
  private generateJUnitXML(testSuite: JUnitTestSuite): string {
    const testCasesXml = testSuite.testcases
      .map((testcase) => {
        let testCaseContent = "";

        if (testcase.failure) {
          testCaseContent += `    <failure message="${this.escapeXml(testcase.failure.message)}" type="${this.escapeXml(testcase.failure.type)}">${this.escapeXml(testcase.failure.content)}</failure>\n`;
        }

        if (testcase.error) {
          testCaseContent += `    <error message="${this.escapeXml(testcase.error.message)}" type="${this.escapeXml(testcase.error.type)}">${this.escapeXml(testcase.error.content)}</error>\n`;
        }

        return `  <testcase classname="${this.escapeXml(testcase.classname)}" name="${this.escapeXml(testcase.name)}" time="${testcase.time}">
${testCaseContent}  </testcase>`;
      })
      .join("\n");

    return `<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by Arbiter CLI ${API_VERSION} -->
<testsuite name="${this.escapeXml(testSuite.name)}" tests="${testSuite.tests}" failures="${testSuite.failures}" errors="${testSuite.errors}" time="${testSuite.time}" timestamp="${new Date().toISOString()}">
${testCasesXml}
</testsuite>`;
  }

  /**
   * Escape XML special characters
   */
  private escapeXml(text: string): string {
    return text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#x27;");
  }
}

/**
 * Helper function to create output manager for commands
 */
export function createOutputManager(
  command: string,
  agentMode = false,
  ndjsonOutput?: string,
): StandardizedOutputManager {
  return new StandardizedOutputManager(command, agentMode, ndjsonOutput);
}

/**
 * Helper function to add --agent-mode flag to commands
 */
export function addAgentModeOption(command: any): void {
  command.option("--agent-mode", "output NDJSON events for agent consumption");
  command.option("--ndjson-output <file>", "write NDJSON events to file instead of stdout");
}

/**
 * Helper function to detect if we should use agent mode
 */
export function shouldUseAgentMode(options: any): boolean {
  return !!options.agentMode || !!options.ndjsonOutput;
}

export { API_VERSION } from "../types/output.js";
export type {
  ExecutionReport,
  JUnitTestSuite,
  NDJSONEvent,
  PhaseEvent,
  PlanOutput,
  StandardizedOutput,
  SurfaceOutput,
  TraceOutput,
} from "../types/output.js";
