/**
 * TypeScript API Surface Extractor
 * 
 * Extracts public API surface from TypeScript libraries by:
 * 1. Analyzing .d.ts files generated by tsc
 * 2. Parsing TypeScript AST to find exported declarations
 * 3. Converting to standardized surface.json format for semver analysis
 */

import fs from 'fs/promises';
import path from 'path';
import { spawn } from 'child_process';
import { glob } from 'glob';

export interface TypeScriptApiSurface {
  version: string;
  extractedAt: string;
  extractor: 'typescript-surface';
  sourceFiles: string[];
  exports: {
    functions: FunctionSignature[];
    classes: ClassSignature[];
    interfaces: InterfaceSignature[];
    types: TypeAliasSignature[];
    constants: ConstantSignature[];
    enums: EnumSignature[];
  };
  dependencies: {
    external: string[];
    internal: string[];
  };
  metadata: {
    totalExports: number;
    complexityScore: number;
    stability: 'stable' | 'beta' | 'alpha';
  };
}

export interface FunctionSignature {
  name: string;
  parameters: Parameter[];
  returnType: string;
  generics?: string[];
  overloads?: FunctionSignature[];
  deprecated?: boolean;
  since?: string;
  visibility: 'public' | 'protected' | 'private';
}

export interface ClassSignature {
  name: string;
  constructor?: FunctionSignature;
  methods: FunctionSignature[];
  properties: PropertySignature[];
  staticMethods: FunctionSignature[];
  staticProperties: PropertySignature[];
  extends?: string;
  implements?: string[];
  generics?: string[];
  abstract?: boolean;
  deprecated?: boolean;
  since?: string;
}

export interface InterfaceSignature {
  name: string;
  properties: PropertySignature[];
  methods: FunctionSignature[];
  extends?: string[];
  generics?: string[];
  deprecated?: boolean;
  since?: string;
}

export interface TypeAliasSignature {
  name: string;
  type: string;
  generics?: string[];
  deprecated?: boolean;
  since?: string;
}

export interface ConstantSignature {
  name: string;
  type: string;
  value?: any;
  deprecated?: boolean;
  since?: string;
}

export interface EnumSignature {
  name: string;
  members: Array<{
    name: string;
    value: string | number;
  }>;
  deprecated?: boolean;
  since?: string;
}

export interface PropertySignature {
  name: string;
  type: string;
  optional?: boolean;
  readonly?: boolean;
  static?: boolean;
  deprecated?: boolean;
  since?: string;
}

export interface Parameter {
  name: string;
  type: string;
  optional?: boolean;
  defaultValue?: any;
  rest?: boolean;
}

export class TypeScriptSurfaceExtractor {
  constructor(
    private repoPath: string,
    private options: {
      includePrivate?: boolean;
      includeInternal?: boolean;
      outputPath?: string;
    } = {}
  ) {}

  /**
   * Extract API surface from TypeScript project
   */
  async extract(): Promise<TypeScriptApiSurface> {
    const startTime = new Date().toISOString();
    
    // Step 1: Find TypeScript configuration
    const tsConfig = await this.findTsConfig();
    if (!tsConfig) {
      throw new Error('No tsconfig.json found - cannot extract TypeScript API surface');
    }

    // Step 2: Generate declaration files
    const declarationFiles = await this.generateDeclarationFiles(tsConfig);
    if (declarationFiles.length === 0) {
      throw new Error('No declaration files generated - check TypeScript compilation');
    }

    // Step 3: Parse declaration files
    const surface = await this.parseDeclarationFiles(declarationFiles);

    // Step 4: Enhance with metadata
    const enhancedSurface: TypeScriptApiSurface = {
      ...surface,
      version: await this.getPackageVersion(),
      extractedAt: startTime,
      extractor: 'typescript-surface',
      sourceFiles: declarationFiles,
      metadata: {
        totalExports: this.countTotalExports(surface.exports),
        complexityScore: this.calculateComplexityScore(surface.exports),
        stability: await this.determineStability(),
      },
    };

    // Step 5: Save to file if requested
    if (this.options.outputPath) {
      await fs.writeFile(
        this.options.outputPath,
        JSON.stringify(enhancedSurface, null, 2)
      );
    }

    return enhancedSurface;
  }

  private async findTsConfig(): Promise<string | null> {
    const possibleConfigs = [
      'tsconfig.json',
      'tsconfig.build.json',
      'packages/*/tsconfig.json',
    ];

    for (const pattern of possibleConfigs) {
      try {
        const configs = await glob(pattern, { cwd: this.repoPath });
        if (configs.length > 0) {
          return path.join(this.repoPath, configs[0]);
        }
      } catch {
        continue;
      }
    }

    return null;
  }

  private async generateDeclarationFiles(tsConfigPath: string): Promise<string[]> {
    // Run TypeScript compiler to generate .d.ts files
    const outDir = path.join(this.repoPath, 'dist');
    
    try {
      await this.runCommand('npx', [
        'tsc',
        '-p', tsConfigPath,
        '--declaration',
        '--emitDeclarationOnly',
        '--outDir', outDir
      ], { cwd: this.repoPath });

      // Find generated .d.ts files
      const declarationFiles = await glob('**/*.d.ts', {
        cwd: outDir,
        ignore: ['**/node_modules/**'],
      });

      return declarationFiles.map(file => path.join(outDir, file));
    } catch (error) {
      throw new Error(`Failed to generate TypeScript declarations: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private async parseDeclarationFiles(declarationFiles: string[]): Promise<Omit<TypeScriptApiSurface, 'version' | 'extractedAt' | 'extractor' | 'sourceFiles' | 'metadata'>> {
    const exports: TypeScriptApiSurface['exports'] = {
      functions: [],
      classes: [],
      interfaces: [],
      types: [],
      constants: [],
      enums: [],
    };

    const dependencies = {
      external: new Set<string>(),
      internal: new Set<string>(),
    };

    for (const filePath of declarationFiles) {
      try {
        const content = await fs.readFile(filePath, 'utf-8');
        const fileExports = await this.parseDeclarationFile(content, filePath);
        
        // Merge exports
        exports.functions.push(...fileExports.functions);
        exports.classes.push(...fileExports.classes);
        exports.interfaces.push(...fileExports.interfaces);
        exports.types.push(...fileExports.types);
        exports.constants.push(...fileExports.constants);
        exports.enums.push(...fileExports.enums);

        // Collect dependencies
        fileExports.dependencies.external.forEach(dep => dependencies.external.add(dep));
        fileExports.dependencies.internal.forEach(dep => dependencies.internal.add(dep));
      } catch (error) {
        console.warn(`Warning: Failed to parse ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
      }
    }

    return {
      exports,
      dependencies: {
        external: Array.from(dependencies.external),
        internal: Array.from(dependencies.internal),
      },
    };
  }

  private async parseDeclarationFile(content: string, filePath: string): Promise<{
    functions: FunctionSignature[];
    classes: ClassSignature[];
    interfaces: InterfaceSignature[];
    types: TypeAliasSignature[];
    constants: ConstantSignature[];
    enums: EnumSignature[];
    dependencies: { external: string[]; internal: string[] };
  }> {
    // Simple regex-based parsing for TypeScript declarations
    // In production, this should use the TypeScript compiler API for proper AST parsing
    
    const result = {
      functions: [] as FunctionSignature[],
      classes: [] as ClassSignature[],
      interfaces: [] as InterfaceSignature[],
      types: [] as TypeAliasSignature[],
      constants: [] as ConstantSignature[],
      enums: [] as EnumSignature[],
      dependencies: { external: [] as string[], internal: [] as string[] },
    };

    const lines = content.split('\n');

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Parse export statements
      if (line.startsWith('export ') || line.includes('declare ')) {
        if (line.includes('function ')) {
          const func = this.parseFunctionDeclaration(line);
          if (func) result.functions.push(func);
        } else if (line.includes('class ')) {
          const cls = this.parseClassDeclaration(lines, i);
          if (cls.class) result.classes.push(cls.class);
          i = cls.nextIndex;
        } else if (line.includes('interface ')) {
          const iface = this.parseInterfaceDeclaration(lines, i);
          if (iface.interface) result.interfaces.push(iface.interface);
          i = iface.nextIndex;
        } else if (line.includes('type ') && line.includes('=')) {
          const type = this.parseTypeAliasDeclaration(line);
          if (type) result.types.push(type);
        } else if (line.includes('const ') || line.includes('let ') || line.includes('var ')) {
          const constant = this.parseConstantDeclaration(line);
          if (constant) result.constants.push(constant);
        } else if (line.includes('enum ')) {
          const enumDecl = this.parseEnumDeclaration(lines, i);
          if (enumDecl.enum) result.enums.push(enumDecl.enum);
          i = enumDecl.nextIndex;
        }
      }

      // Parse import statements for dependencies
      if (line.startsWith('import ')) {
        const dep = this.parseImportDeclaration(line);
        if (dep) {
          if (dep.startsWith('.') || dep.startsWith('/')) {
            result.dependencies.internal.push(dep);
          } else {
            result.dependencies.external.push(dep);
          }
        }
      }
    }

    return result;
  }

  private parseFunctionDeclaration(line: string): FunctionSignature | null {
    // Simple regex for function parsing
    const match = line.match(/export\s+(?:declare\s+)?function\s+(\w+)\s*(<[^>]*>)?\s*\(([^)]*)\)\s*:\s*([^;{]+)/);
    if (!match) return null;

    const [, name, generics, params, returnType] = match;
    
    return {
      name,
      parameters: this.parseParameters(params),
      returnType: returnType.trim(),
      generics: generics ? [generics.slice(1, -1)] : undefined,
      visibility: 'public',
    };
  }

  private parseClassDeclaration(lines: string[], startIndex: number): { class: ClassSignature | null; nextIndex: number } {
    const line = lines[startIndex].trim();
    const match = line.match(/export\s+(?:declare\s+)?(?:abstract\s+)?class\s+(\w+)(?:<[^>]*>)?(?:\s+extends\s+(\w+))?(?:\s+implements\s+([^{]+))?/);
    if (!match) return { class: null, nextIndex: startIndex };

    const [, name, extendsClass, implementsList] = match;
    
    const classSignature: ClassSignature = {
      name,
      methods: [],
      properties: [],
      staticMethods: [],
      staticProperties: [],
      extends: extendsClass,
      implements: implementsList ? implementsList.split(',').map(s => s.trim()) : undefined,
      abstract: line.includes('abstract'),
      visibility: 'public',
    };

    // Parse class body (simplified)
    let i = startIndex + 1;
    let braceLevel = 0;
    let foundOpenBrace = false;

    while (i < lines.length) {
      const bodyLine = lines[i].trim();
      
      if (bodyLine.includes('{')) {
        braceLevel++;
        foundOpenBrace = true;
      }
      if (bodyLine.includes('}')) {
        braceLevel--;
        if (braceLevel === 0 && foundOpenBrace) break;
      }

      // Parse methods and properties (simplified)
      if (foundOpenBrace && braceLevel > 0 && bodyLine.length > 0 && !bodyLine.startsWith('//') && !bodyLine.startsWith('/*')) {
        if (bodyLine.includes('(') && bodyLine.includes(')')) {
          // Likely a method
          const method = this.parseMethodDeclaration(bodyLine);
          if (method) {
            if (method.name === 'constructor') {
              classSignature.constructor = method;
            } else if (bodyLine.includes('static ')) {
              classSignature.staticMethods.push(method);
            } else {
              classSignature.methods.push(method);
            }
          }
        } else if (bodyLine.includes(':')) {
          // Likely a property
          const property = this.parsePropertyDeclaration(bodyLine);
          if (property) {
            if (bodyLine.includes('static ')) {
              classSignature.staticProperties.push(property);
            } else {
              classSignature.properties.push(property);
            }
          }
        }
      }

      i++;
    }

    return { class: classSignature, nextIndex: i };
  }

  private parseInterfaceDeclaration(lines: string[], startIndex: number): { interface: InterfaceSignature | null; nextIndex: number } {
    const line = lines[startIndex].trim();
    const match = line.match(/export\s+(?:declare\s+)?interface\s+(\w+)(?:<[^>]*>)?(?:\s+extends\s+([^{]+))?/);
    if (!match) return { interface: null, nextIndex: startIndex };

    const [, name, extendsList] = match;
    
    const interfaceSignature: InterfaceSignature = {
      name,
      properties: [],
      methods: [],
      extends: extendsList ? extendsList.split(',').map(s => s.trim()) : undefined,
    };

    // Parse interface body (simplified)
    let i = startIndex + 1;
    let braceLevel = 0;
    let foundOpenBrace = false;

    while (i < lines.length) {
      const bodyLine = lines[i].trim();
      
      if (bodyLine.includes('{')) {
        braceLevel++;
        foundOpenBrace = true;
      }
      if (bodyLine.includes('}')) {
        braceLevel--;
        if (braceLevel === 0 && foundOpenBrace) break;
      }

      if (foundOpenBrace && braceLevel > 0 && bodyLine.length > 0 && !bodyLine.startsWith('//')) {
        if (bodyLine.includes('(') && bodyLine.includes(')')) {
          // Method signature
          const method = this.parseMethodDeclaration(bodyLine);
          if (method) interfaceSignature.methods.push(method);
        } else if (bodyLine.includes(':')) {
          // Property signature
          const property = this.parsePropertyDeclaration(bodyLine);
          if (property) interfaceSignature.properties.push(property);
        }
      }

      i++;
    }

    return { interface: interfaceSignature, nextIndex: i };
  }

  private parseTypeAliasDeclaration(line: string): TypeAliasSignature | null {
    const match = line.match(/export\s+(?:declare\s+)?type\s+(\w+)(?:<[^>]*>)?\s*=\s*([^;]+)/);
    if (!match) return null;

    const [, name, type] = match;
    
    return {
      name,
      type: type.trim(),
    };
  }

  private parseConstantDeclaration(line: string): ConstantSignature | null {
    const match = line.match(/export\s+(?:declare\s+)?(?:const|let|var)\s+(\w+)\s*:\s*([^;=]+)(?:\s*=\s*([^;]+))?/);
    if (!match) return null;

    const [, name, type, value] = match;
    
    return {
      name,
      type: type.trim(),
      value: value ? value.trim() : undefined,
    };
  }

  private parseEnumDeclaration(lines: string[], startIndex: number): { enum: EnumSignature | null; nextIndex: number } {
    const line = lines[startIndex].trim();
    const match = line.match(/export\s+(?:declare\s+)?enum\s+(\w+)/);
    if (!match) return { enum: null, nextIndex: startIndex };

    const [, name] = match;
    const members: Array<{ name: string; value: string | number }> = [];

    let i = startIndex + 1;
    let braceLevel = 0;
    let foundOpenBrace = false;

    while (i < lines.length) {
      const bodyLine = lines[i].trim();
      
      if (bodyLine.includes('{')) {
        braceLevel++;
        foundOpenBrace = true;
      }
      if (bodyLine.includes('}')) {
        braceLevel--;
        if (braceLevel === 0 && foundOpenBrace) break;
      }

      if (foundOpenBrace && braceLevel > 0 && bodyLine.length > 0 && !bodyLine.startsWith('//')) {
        const memberMatch = bodyLine.match(/(\w+)\s*(?:=\s*([^,}]+))?/);
        if (memberMatch) {
          const [, memberName, memberValue] = memberMatch;
          members.push({
            name: memberName,
            value: memberValue ? memberValue.trim().replace(/[",]/g, '') : memberName,
          });
        }
      }

      i++;
    }

    return {
      enum: {
        name,
        members,
      },
      nextIndex: i,
    };
  }

  private parseMethodDeclaration(line: string): FunctionSignature | null {
    // Simplified method parsing
    const match = line.match(/(?:static\s+)?(\w+)\s*\(([^)]*)\)\s*:\s*([^;{]+)/);
    if (!match) return null;

    const [, name, params, returnType] = match;
    
    return {
      name,
      parameters: this.parseParameters(params),
      returnType: returnType.trim(),
      visibility: 'public',
    };
  }

  private parsePropertyDeclaration(line: string): PropertySignature | null {
    const match = line.match(/(?:(static|readonly)\s+)?(\w+)\??\s*:\s*([^;]+)/);
    if (!match) return null;

    const [, modifier, name, type] = match;
    
    return {
      name,
      type: type.trim(),
      optional: line.includes('?:'),
      readonly: modifier === 'readonly',
      static: modifier === 'static',
    };
  }

  private parseParameters(paramStr: string): Parameter[] {
    if (!paramStr.trim()) return [];

    return paramStr.split(',').map(param => {
      const trimmed = param.trim();
      const match = trimmed.match(/(?:\.\.\.)?(\w+)\??\s*:\s*([^=]+)(?:\s*=\s*(.+))?/);
      
      if (match) {
        const [, name, type, defaultValue] = match;
        return {
          name,
          type: type.trim(),
          optional: trimmed.includes('?:'),
          defaultValue: defaultValue ? defaultValue.trim() : undefined,
          rest: trimmed.startsWith('...'),
        };
      }

      return {
        name: trimmed.split(':')[0] || 'unknown',
        type: 'unknown',
      };
    });
  }

  private parseImportDeclaration(line: string): string | null {
    const match = line.match(/import\s+[^'"]*['"]([^'"]+)['"]/);
    return match ? match[1] : null;
  }

  private async getPackageVersion(): Promise<string> {
    try {
      const packageJsonPath = path.join(this.repoPath, 'package.json');
      const content = await fs.readFile(packageJsonPath, 'utf-8');
      const packageJson = JSON.parse(content);
      return packageJson.version || '0.0.0';
    } catch {
      return '0.0.0';
    }
  }

  private countTotalExports(exports: TypeScriptApiSurface['exports']): number {
    return exports.functions.length +
           exports.classes.length +
           exports.interfaces.length +
           exports.types.length +
           exports.constants.length +
           exports.enums.length;
  }

  private calculateComplexityScore(exports: TypeScriptApiSurface['exports']): number {
    // Simple complexity scoring
    let score = 0;
    
    // Functions contribute to complexity
    score += exports.functions.length * 2;
    
    // Classes are more complex
    exports.classes.forEach(cls => {
      score += 5; // Base class complexity
      score += cls.methods.length * 2;
      score += cls.properties.length;
      score += cls.staticMethods.length * 2;
      score += cls.staticProperties.length;
    });
    
    // Interfaces contribute less
    exports.interfaces.forEach(iface => {
      score += 3; // Base interface complexity
      score += iface.methods.length;
      score += iface.properties.length;
    });
    
    // Types and enums
    score += exports.types.length;
    score += exports.enums.length * 2;
    score += exports.constants.length;
    
    return score;
  }

  private async determineStability(): Promise<'stable' | 'beta' | 'alpha'> {
    try {
      const version = await this.getPackageVersion();
      if (version.startsWith('0.')) return 'alpha';
      if (version.includes('beta') || version.includes('rc')) return 'beta';
      return 'stable';
    } catch {
      return 'alpha';
    }
  }

  private async runCommand(
    command: string,
    args: string[],
    options: { cwd?: string } = {}
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const child = spawn(command, args, {
        cwd: options.cwd || this.repoPath,
        stdio: 'pipe',
      });

      let stderr = '';
      child.stderr?.on('data', (data) => {
        stderr += data.toString();
      });

      child.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`Command failed with exit code ${code}: ${stderr}`));
        }
      });

      child.on('error', reject);
    });
  }
}

/**
 * Convenience function to extract TypeScript API surface
 */
export async function extractTypeScriptApiSurface(
  repoPath: string,
  options?: {
    includePrivate?: boolean;
    includeInternal?: boolean;
    outputPath?: string;
  }
): Promise<TypeScriptApiSurface> {
  const extractor = new TypeScriptSurfaceExtractor(repoPath, options);
  return extractor.extract();
}