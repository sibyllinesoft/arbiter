<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Repository Analysis: Scribe Analysis</title>
    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2a2a2a;
            --bg-tertiary: #3a3a3a;
            --text-primary: #e5e5e5;
            --text-secondary: #b5b5b5;
            --text-muted: #888;
            --accent-primary: #4f9cf9;
            --accent-secondary: #7c3aed;
            --border-color: #404040;
            --hover-color: #333333;
            --code-bg: #252525;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .header {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-bottom: 1px solid rgba(255, 255, 255, 0.02);
            color: white;
            padding: 32px;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.02) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 255, 255, 0.01) 0%, transparent 50%);
            pointer-events: none;
        }
        
        .header::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3e%3cg fill='none' fill-rule='evenodd'%3e%3cg fill='%23ffffff' fill-opacity='0.02'%3e%3ccircle cx='20' cy='20' r='1'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e");
            pointer-events: none;
        }
        
        .header h1 {
            margin: 0;
            font-size: 32px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
            z-index: 1;
        }
        
        .header .meta {
            margin-top: 20px;
            opacity: 0.9;
            font-size: 13px;
            position: relative;
            z-index: 1;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 16px;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255, 255, 255, 0.08);
            padding: 8px 12px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .meta-item:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-1px);
        }
        
        .stats {
            background: var(--bg-tertiary);
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 24px;
        }
        
        .stat {
            text-align: center;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }
        
        .stat:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .stat-label {
            font-size: 12px;
            text-transform: uppercase;
            color: var(--text-muted);
            letter-spacing: 0.5px;
            font-weight: 500;
        }
        
        .toc {
            background: var(--bg-tertiary);
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .toc h3 {
            margin: 0 0 20px 0;
            font-size: 18px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }
        
        .file-list {
            max-height: 400px;
            overflow-y: auto;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }
        
        .file-item {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }
        
        .file-item:hover {
            background-color: var(--hover-color);
        }
        
        .file-item:last-child {
            border-bottom: none;
        }
        
        .file-name {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-meta {
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .content {
            padding: 24px;
            background: var(--bg-secondary);
        }
        
        .file-section {
            margin-bottom: 32px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-primary);
        }
        
        .file-header {
            background: var(--bg-tertiary);
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-content {
            max-height: 600px;
            overflow-y: auto;
            position: relative;
        }
        
        .file-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .file-content::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        
        .file-content::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        .file-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        pre {
            margin: 0;
            padding: 24px;
            background: var(--code-bg);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: var(--text-primary);
        }
        
        .icon {
            width: 16px;
            height: 16px;
        }
        
        .icon-lg {
            width: 20px;
            height: 20px;
        }

        /* React Tree Component Styles */
        .tree-container {
            height: 400px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow-y: auto;
            padding: 8px;
        }

        .tree-node {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            cursor: pointer;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            color: var(--text-secondary);
            transition: all 0.2s ease;
            user-select: none;
            border-radius: 4px;
            margin: 1px 0;
        }

        .tree-node:hover {
            background: var(--hover-color);
            color: var(--accent-primary);
        }

        .tree-node.selected {
            background: var(--accent-primary);
            color: white;
        }

        .tree-node-content {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            width: 100%;
        }

        .tree-arrow {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 4px;
            transition: transform 0.2s ease;
            flex-shrink: 0;
            opacity: 0.6;
        }

        .tree-arrow.expanded {
            transform: rotate(90deg);
        }

        .tree-arrow.hidden {
            opacity: 0;
        }

        .tree-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        .tree-label {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .folder-icon {
            color: var(--accent-secondary);
        }

        .file-icon {
            color: var(--text-secondary);
        }

        /* Scrollbar styling for tree */
        .tree-container::-webkit-scrollbar {
            width: 8px;
        }

        .tree-container::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        .tree-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .tree-container::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        @media (max-width: 768px) {
            body {
                padding: 12px;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 24px;
            }
            
            .header .meta {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .meta-item {
                justify-content: center;
            }
            
            .stats {
                grid-template-columns: 1fr;
                gap: 16px;
                padding: 16px;
            }
            
            .content {
                padding: 16px;
            }
        }
        
        .control-bar {
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 16px 32px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }
        
        .control-buttons {
            display: flex;
            gap: 12px;
        }
        
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-primary {
            background: var(--accent-primary);
            color: white;
        }
        
        .btn-primary:hover {
            background: #3d8bfd;
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover {
            background: var(--hover-color);
            transform: translateY(-1px);
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .status-dot.online {
            background: #10b981;
        }
        
        .status-dot.offline {
            background: #ef4444;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @media (max-width: 768px) {
            .control-bar {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
                padding: 16px;
            }
            
            .control-buttons {
                justify-content: center;
            }
            
            .status-indicator {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                🔍 Repository Analysis
            </h1>
            <div class="meta">
                <div class="meta-item">
                    <span>📊 <strong>Algorithm:</strong> v5-integrated</span>
                </div>
                <div class="meta-item">
                    <span>🕒 <strong>Generated:</strong> 2025-09-20 21:14:45 UTC</span>
                </div>
                <div class="meta-item">
                    <span>⚡ <strong>Selection Time:</strong> 153ms</span>
                </div>
            </div>
        </div>
        
        <div class="control-bar">
            <div class="control-buttons">
                <button id="save-btn" class="btn btn-primary">
                    💾 Save Bundle
                </button>
                <button id="shutdown-btn" class="btn btn-secondary">
                    🛑 Shutdown Server
                </button>
            </div>
            <div class="status-indicator">
                <span id="connection-status" class="status-dot online"></span>
                <span id="status-text">Connected</span>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-value">
                    📄 29
                </div>
                <div class="stat-label">Files Selected</div>
            </div>
            <div class="stat">
                <div class="stat-value">
                    🔢 70,967
                </div>
                <div class="stat-label">Estimated Tokens</div>
            </div>
            <div class="stat">
                <div class="stat-value">
                    💾 341.40 KB
                </div>
                <div class="stat-label">Total Size</div>
            </div>
            <div class="stat">
                <div class="stat-value">
                    🎯 93.5%
                </div>
                <div class="stat-label">Coverage</div>
            </div>
        </div>
        
        <div class="toc">
            <h3>
                📁 File Explorer
            </h3>
            <div id="file-tree-container" class="tree-container"></div>
        </div>
        
        <div class="file-list">
            <div class="file-item">
                <span class="file-name">📄 DIRECTORY_MAP.txt</span>
                <span class="file-meta">4.76 KB • ~1,609 tokens • Score: 1.00</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/types.ts</span>
                <span class="file-meta">6.93 KB • ~1,602 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/db.ts</span>
                <span class="file-meta">20.43 KB • ~4,463 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/utils.ts</span>
                <span class="file-meta">8.85 KB • ~1,987 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/events.ts</span>
                <span class="file-meta">14.14 KB • ~2,849 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/auth.ts</span>
                <span class="file-meta">17.18 KB • ~3,485 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/handlers/discovery.ts</span>
                <span class="file-meta">11.30 KB • ~2,275 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/handlers/services.ts</span>
                <span class="file-meta">17.18 KB • ~3,751 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/nats.ts</span>
                <span class="file-meta">6.97 KB • ~1,453 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/handlers/manager.ts</span>
                <span class="file-meta">16.36 KB • ~3,377 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/mcp.ts</span>
                <span class="file-meta">13.81 KB • ~2,685 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/handlers/executor.ts</span>
                <span class="file-meta">17.51 KB • ~3,482 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/webhooks.ts</span>
                <span class="file-meta">13.22 KB • ~2,629 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/ir.ts</span>
                <span class="file-meta">21.12 KB • ~4,356 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/handlers/sandbox.ts</span>
                <span class="file-meta">2.52 KB • ~579 tokens • Score: 0.73</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/handlers/loader.ts</span>
                <span class="file-meta">1.52 KB • ~311 tokens • Score: 0.68</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/server.ts</span>
                <span class="file-meta">18.02 KB • ~3,799 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/handlers/types.ts</span>
                <span class="file-meta">5.69 KB • ~1,227 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/routes/index.ts</span>
                <span class="file-meta">40.45 KB • ~8,206 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/handlers/examples/slack-notification.ts</span>
                <span class="file-meta">8.53 KB • ~1,701 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/migrations/run.ts</span>
                <span class="file-meta">8.41 KB • ~1,751 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/websocket/index.ts</span>
                <span class="file-meta">14.71 KB • ~2,829 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/handlers/api.ts</span>
                <span class="file-meta">10.49 KB • ~2,185 tokens • Score: 0.85</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/handlers/examples/push-handler.ts</span>
                <span class="file-meta">3.94 KB • ~808 tokens • Score: 0.80</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/mcp-cli-integration.ts</span>
                <span class="file-meta">3.03 KB • ~642 tokens • Score: 0.75</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/config.ts</span>
                <span class="file-meta">843.00 B • ~207 tokens • Score: 0.64</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/static/index.ts</span>
                <span class="file-meta">300.00 B • ~70 tokens • Score: 0.61</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/specEngine.ts</span>
                <span class="file-meta">26.92 KB • ~5,404 tokens • Score: 0.17</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 src/handlers/examples/spec-validator.ts</span>
                <span class="file-meta">6.23 KB • ~1,245 tokens • Score: 0.17</span>
            </div>
        </div>
        
        <div class="content">
            <div class="file-section" id="file-1">
                <div class="file-header">📄 DIRECTORY_MAP.txt</div>
                <div class="file-content">
                    <pre>Repository Inventory
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
Path                                                         Type       Size Modified
------------------------------------------------------------ ---- ---------- -------------------
.                                                            dir   352.66 KB 2025-09-20 17:08:02
/                                                            dir     4.10 KB 2025-09-07 18:08:55
/home                                                        dir     32.00 B 2025-07-05 13:25:42
/home/nathan                                                 dir     1.88 KB 2025-09-20 17:13:07
/home/nathan/Projects                                        dir    822.00 B 2025-09-20 12:06:36
/home/nathan/Projects/arbiter                                dir    734.00 B 2025-09-20 15:56:16
/home/nathan/Projects/arbiter/apps                           dir     12.00 B 2025-09-20 17:14:36
/home/nathan/Projects/arbiter/apps/api                       dir    268.00 B 2025-09-20 16:51:40
/home/nathan/Projects/arbiter/apps/api/package.json          file    2.43 KB 2025-09-20 02:10:06
/home/nathan/Projects/arbiter/apps/api/src                   dir    400.00 B 2025-09-20 16:49:43
/home/nathan/Projects/arbiter/apps/api/src/auth.ts           file   17.18 KB 2025-09-20 16:05:30
/home/nathan/Projects/arbiter/apps/api/src/config.ts         file   843.00 B 2025-09-20 14:02:13
/home/nathan/Projects/arbiter/apps/api/src/db.ts             file   20.43 KB 2025-09-20 16:49:43
/home/nathan/Projects/arbiter/apps/api/src/events.ts         file   14.14 KB 2025-09-19 19:12:23
/home/nathan/Projects/arbiter/apps/api/src/handlers          dir    188.00 B 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/handlers/README.md file   12.73 KB 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/handlers/api.ts   file   10.49 KB 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/handlers/discovery.ts file   11.30 KB 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/handlers/examples dir    106.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/api/src/handlers/examples/push-handler.ts file    3.94 KB 2025-09-19 19:12:23
/home/nathan/Projects/arbiter/apps/api/src/handlers/examples/slack-notification.ts file    8.53 KB 2025-09-19 19:12:24
/home/nathan/Projects/arbiter/apps/api/src/handlers/examples/spec-validator.ts file    6.23 KB 2025-09-19 19:12:24
/home/nathan/Projects/arbiter/apps/api/src/handlers/executor.ts file   17.51 KB 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/handlers/loader.ts file    1.52 KB 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/handlers/manager.ts file   16.36 KB 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/handlers/sandbox.ts file    2.52 KB 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/handlers/services.ts file   17.18 KB 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/handlers/types.ts file    5.69 KB 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/ir.ts             file   21.12 KB 2025-09-20 00:42:25
/home/nathan/Projects/arbiter/apps/api/src/mcp-cli-integration.ts file    3.03 KB 2025-09-20 02:22:23
/home/nathan/Projects/arbiter/apps/api/src/mcp.ts            file   13.81 KB 2025-09-20 15:51:19
/home/nathan/Projects/arbiter/apps/api/src/migrations        dir     12.00 B 2025-09-19 19:01:59
/home/nathan/Projects/arbiter/apps/api/src/migrations/run.ts file    8.41 KB 2025-09-19 19:12:24
/home/nathan/Projects/arbiter/apps/api/src/nats.ts           file    6.97 KB 2025-09-19 19:12:24
/home/nathan/Projects/arbiter/apps/api/src/routes            dir     16.00 B 2025-09-20 17:08:02
/home/nathan/Projects/arbiter/apps/api/src/routes/index.ts   file   40.45 KB 2025-09-20 17:08:02
/home/nathan/Projects/arbiter/apps/api/src/server.ts         file   18.02 KB 2025-09-20 12:00:31
/home/nathan/Projects/arbiter/apps/api/src/specEngine.ts     file   26.92 KB 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/static            dir     16.00 B 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/static/index.ts   file   300.00 B 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/types.ts          file    6.93 KB 2025-09-20 00:05:44
/home/nathan/Projects/arbiter/apps/api/src/utils.ts          file    8.85 KB 2025-09-19 19:12:24
/home/nathan/Projects/arbiter/apps/api/src/webhooks.ts       file   13.22 KB 2025-09-19 19:12:24
/home/nathan/Projects/arbiter/apps/api/src/websocket         dir     16.00 B 2025-09-20 11:15:22
/home/nathan/Projects/arbiter/apps/api/src/websocket/index.ts file   14.71 KB 2025-09-20 12:00:31
/home/nathan/Projects/arbiter/apps/api/tsconfig.json         file   860.00 B 2025-09-20 00:05:44
</pre>
                </div>
            </div>
            <div class="file-section" id="file-2">
                <div class="file-header">📄 src/types.ts</div>
                <div class="file-content">
                    <pre>/**
 * Core domain types for Spec Workbench backend
 */

// Database entity types
export interface Project {
  id: string;
  name: string;
  created_at: string;
  updated_at: string;
}

export interface Fragment {
  id: string;
  project_id: string;
  path: string;
  content: string;
  created_at: string;
  updated_at: string;
  head_revision_id?: string;
}

export interface FragmentRevision {
  id: string;
  fragment_id: string;
  revision_number: number;
  content: string;
  content_hash: string;
  author?: string;
  message?: string;
  created_at: string;
}

export interface Version {
  id: string;
  project_id: string;
  spec_hash: string;
  resolved_json: string;
  created_at: string;
}

export interface Event {
  id: string;
  project_id: string;
  event_type: EventType;
  data: Record&amp;lt;string, unknown&amp;gt;;
  created_at: string;
}

// Event types for real-time collaboration
export type EventType &#x3D;
  | &amp;quot;fragment_created&amp;quot;
  | &amp;quot;fragment_updated&amp;quot;
  | &amp;quot;fragment_deleted&amp;quot;
  | &amp;quot;fragment_revision_created&amp;quot;
  | &amp;quot;validation_started&amp;quot;
  | &amp;quot;validation_completed&amp;quot;
  | &amp;quot;validation_failed&amp;quot;
  | &amp;quot;version_frozen&amp;quot;
  | &amp;quot;webhook_received&amp;quot;
  | &amp;quot;git_push_processed&amp;quot;
  | &amp;quot;git_merge_processed&amp;quot;;

// API request/response types
export interface CreateFragmentRequest {
  path: string;
  content: string;
}

export interface CreateFragmentResponse {
  id: string;
  path: string;
  created_at: string;
}

export interface ResolvedSpecResponse {
  spec_hash: string;
  resolved: Record&amp;lt;string, unknown&amp;gt;;
  last_updated: string;
}

export interface ValidationRequest {
  force?: boolean;
}

export interface ValidationResponse {
  success: boolean;
  spec_hash: string;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

export interface ValidationError {
  type: &amp;quot;schema&amp;quot; | &amp;quot;assertion&amp;quot; | &amp;quot;custom&amp;quot;;
  message: string;
  location?: string;
  details?: Record&amp;lt;string, unknown&amp;gt;;
}

export interface ValidationWarning {
  type: &amp;quot;orphan_token&amp;quot; | &amp;quot;coverage&amp;quot; | &amp;quot;duplicate&amp;quot;;
  message: string;
  location?: string;
}

// Gap analysis types
export interface GapSet {
  missing_capabilities: string[];
  orphaned_tokens: TokenReference[];
  coverage_gaps: CoverageGap[];
  duplicates: Duplicate[];
}

export interface TokenReference {
  token: string;
  defined_in: string[];
  referenced_in: string[];
}

export interface CoverageGap {
  capability: string;
  expected_coverage: number;
  actual_coverage: number;
  missing_scenarios: string[];
}

export interface Duplicate {
  type: &amp;quot;capability&amp;quot; | &amp;quot;requirement&amp;quot; | &amp;quot;test_case&amp;quot;;
  name: string;
  locations: string[];
}

// IR (Intermediate Representation) types for diagrams
export type IRKind &#x3D;
  | &amp;quot;flow&amp;quot;
  | &amp;quot;fsm&amp;quot;
  | &amp;quot;view&amp;quot;
  | &amp;quot;site&amp;quot;
  | &amp;quot;capabilities&amp;quot;
  | &amp;quot;flows&amp;quot;
  | &amp;quot;dependencies&amp;quot;
  | &amp;quot;coverage&amp;quot;;

export interface IRResponse {
  kind: IRKind;
  data: Record&amp;lt;string, unknown&amp;gt;;
  generated_at: string;
}

// Version freezing
export interface FreezeRequest {
  version_name: string;
  description?: string;
}

export interface FreezeResponse {
  version_id: string;
  spec_hash: string;
  frozen_at: string;
}

// Authentication
export interface AuthContext {
  token: string;
  user_id?: string;
  project_access: string[];
  oauth_token?: any; // OAuth JWT token for scope checking
}

// External tool execution results
export interface ExternalToolResult {
  success: boolean;
  stdout: string;
  stderr: string;
  exit_code: number;
  duration_ms: number;
}

// Rate limiting
export interface RateLimitBucket {
  tokens: number;
  last_refill: number;
  max_tokens: number;
  refill_rate: number;
}

// WebSocket message types
export interface WebSocketMessage {
  type: &amp;quot;event&amp;quot; | &amp;quot;error&amp;quot; | &amp;quot;ping&amp;quot; | &amp;quot;pong&amp;quot;;
  project_id?: string;
  data: Record&amp;lt;string, unknown&amp;gt;;
}

// NATS integration types
export interface NatsSpecEvent {
  topic: string;
  projectId: string;
  event: Omit&amp;lt;Event, &amp;quot;id&amp;quot; | &amp;quot;created_at&amp;quot;&amp;gt;;
  metadata: {
    timestamp: string;
    specHash?: string;
    sequence: number;
  };
}

export interface NatsConfig {
  url?: string;
  enabled: boolean;
  reconnectTimeWait: number;
  maxReconnectAttempts: number;
  topicPrefix: string;
}

// Error response structure (RFC 7807 Problem Details)
export interface ProblemDetails {
  type: string;
  title: string;
  status: number;
  detail?: string;
  instance?: string;
  [key: string]: unknown;
}

// Webhook types
export interface WebhookPayload {
  repository: {
    full_name: string;
    clone_url: string;
    default_branch?: string;
  };
  commits?: Array&amp;lt;{
    id: string;
    message: string;
    author: {
      name: string;
      email: string;
    };
    modified?: string[];
    added?: string[];
    removed?: string[];
  }&amp;gt;;
  ref?: string;
  before?: string;
  after?: string;
  action?: string;
  merge_request?: {
    id: number;
    state: string;
    target_branch: string;
    source_branch: string;
  };
  pull_request?: {
    id: number;
    state: string;
    base: { ref: string };
    head: { ref: string };
  };
}

export interface WebhookConfig {
  id: string;
  project_id: string;
  provider: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;;
  repository_url: string;
  secret_hash?: string;
  enabled: boolean;
  events: WebhookEventType[];
  created_at: string;
  updated_at: string;
}

export type WebhookEventType &#x3D; &amp;quot;push&amp;quot; | &amp;quot;merge_request&amp;quot; | &amp;quot;pull_request&amp;quot; | &amp;quot;tag&amp;quot;;

export interface WebhookRequest {
  provider: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;;
  event: string;
  signature?: string;
  payload: WebhookPayload;
  timestamp: string;
}

export interface WebhookResponse {
  success: boolean;
  message: string;
  actions_taken?: string[];
  project_id?: string;
}

// Configuration
export interface ServerConfig {
  port: number;
  host: string;
  database_path: string;
  spec_workdir: string;
  cue_binary_path: string;
  jq_binary_path: string;
  auth_required: boolean;
  rate_limit: {
    max_tokens: number;
    refill_rate: number; // tokens per second
    window_ms: number;
  };
  external_tool_timeout_ms: number;
  websocket: {
    max_connections: number;
    ping_interval_ms: number;
  };
  nats?: NatsConfig;
  webhooks?: {
    enabled: boolean;
    secret?: string;
    github_secret?: string;
    gitlab_secret?: string;
    allowed_repos?: string[];
    sync_on_push: boolean;
    validate_on_merge: boolean;
  };
  handlers?: {
    enableAutoReload: boolean;
    maxConcurrentExecutions: number;
    defaultTimeout: number;
    defaultRetries: number;
    sandboxEnabled: boolean;
    allowedModules: string[];
    enableMetrics: boolean;
    notifications?: {
      email?: {
        mode?: &amp;quot;disabled&amp;quot; | &amp;quot;log&amp;quot; | &amp;quot;smtp&amp;quot;;
        from?: string;
        smtp?: {
          host?: string;
          port?: number;
          secure?: boolean;
          user?: string;
          pass?: string;
        };
      };
    };
  };
  oauth?: {
    enabled: boolean;
    mcpBaseUrl: string;
    authServerUrl: string;
    authServerPort: number;
    enableAuthServer: boolean;
    requiredScopes?: string[];
  };
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-3">
                <div class="file-header">📄 src/db.ts</div>
                <div class="file-content">
                    <pre>/**
 * SQLite database layer using Bun&amp;#39;s native sqlite driver
 */
import { Database } from &amp;#39;bun:sqlite&amp;#39;;
import { createHash, randomUUID } from &amp;#39;node:crypto&amp;#39;;
import type {
  Event,
  EventType,
  Fragment,
  FragmentRevision,
  Project,
  ServerConfig,
  Version,
} from &amp;#39;./types.ts&amp;#39;;

export class SpecWorkbenchDB {
  private db: Database;

  constructor(config: ServerConfig) {
    this.db &#x3D; new Database(config.database_path, { create: true });
    this.initializeSchema();
  }

  /**
   * Configure SQLite pragmas for optimal performance
   */
  private configurePragmas(): void {
    // Enable foreign key constraints
    this.db.exec(&amp;#39;PRAGMA foreign_keys &#x3D; ON&amp;#39;);
    // Enable WAL mode for better concurrent access
    this.db.exec(&amp;#39;PRAGMA journal_mode &#x3D; WAL&amp;#39;);
    this.db.exec(&amp;#39;PRAGMA synchronous &#x3D; NORMAL&amp;#39;);
    this.db.exec(&amp;#39;PRAGMA cache_size &#x3D; 1000&amp;#39;);
    this.db.exec(&amp;#39;PRAGMA temp_store &#x3D; memory&amp;#39;);
  }

  /**
   * Handle schema migrations (add columns if needed)
   */
  private handleSchemaMigrations(): void {
    // Schema migration - add head_revision_id column if it doesn&amp;#39;t exist
    try {
      this.db.exec(&amp;#39;ALTER TABLE fragments ADD COLUMN head_revision_id TEXT&amp;#39;);
    } catch (error) {
      // Column already exists or table doesn&amp;#39;t exist yet, ignore
    }

    // Schema migration - add service_count and database_count columns to projects table
    try {
      this.db.exec(&amp;#39;ALTER TABLE projects ADD COLUMN service_count INTEGER DEFAULT 0&amp;#39;);
    } catch (error) {
      // Column already exists or table doesn&amp;#39;t exist yet, ignore
    }
    
    try {
      this.db.exec(&amp;#39;ALTER TABLE projects ADD COLUMN database_count INTEGER DEFAULT 0&amp;#39;);
    } catch (error) {
      // Column already exists or table doesn&amp;#39;t exist yet, ignore
    }
  }

  /**
   * Create the projects table
   */
  private createProjectsTable(): void {
    this.db.exec(&#x60;
      CREATE TABLE IF NOT EXISTS projects (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (strftime(&amp;#39;%Y-%m-%d %H:%M:%f&amp;#39;, &amp;#39;now&amp;#39;)),
        updated_at TEXT NOT NULL DEFAULT (strftime(&amp;#39;%Y-%m-%d %H:%M:%f&amp;#39;, &amp;#39;now&amp;#39;))
      )
    &#x60;);
  }

  /**
   * Create the fragments table
   */
  private createFragmentsTable(): void {
    this.db.exec(&#x60;
      CREATE TABLE IF NOT EXISTS fragments (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        path TEXT NOT NULL,
        content TEXT NOT NULL,
        head_revision_id TEXT,
        created_at TEXT NOT NULL DEFAULT (strftime(&amp;#39;%Y-%m-%d %H:%M:%f&amp;#39;, &amp;#39;now&amp;#39;)),
        updated_at TEXT NOT NULL DEFAULT (strftime(&amp;#39;%Y-%m-%d %H:%M:%f&amp;#39;, &amp;#39;now&amp;#39;)),
        FOREIGN KEY (project_id) REFERENCES projects (id) ON DELETE CASCADE,
        UNIQUE (project_id, path)
      )
    &#x60;);
  }

  /**
   * Create the fragment_revisions table
   */
  private createFragmentRevisionsTable(): void {
    this.db.exec(&#x60;
      CREATE TABLE IF NOT EXISTS fragment_revisions (
        id TEXT PRIMARY KEY,
        fragment_id TEXT NOT NULL,
        revision_number INTEGER NOT NULL,
        content TEXT NOT NULL,
        content_hash TEXT NOT NULL,
        author TEXT,
        message TEXT,
        created_at TEXT NOT NULL DEFAULT (strftime(&amp;#39;%Y-%m-%d %H:%M:%f&amp;#39;, &amp;#39;now&amp;#39;)),
        FOREIGN KEY (fragment_id) REFERENCES fragments (id) ON DELETE CASCADE,
        UNIQUE (fragment_id, revision_number)
      )
    &#x60;);
  }

  /**
   * Create the versions table
   */
  private createVersionsTable(): void {
    this.db.exec(&#x60;
      CREATE TABLE IF NOT EXISTS versions (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        spec_hash TEXT NOT NULL,
        resolved_json TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (strftime(&amp;#39;%Y-%m-%d %H:%M:%f&amp;#39;, &amp;#39;now&amp;#39;)),
        FOREIGN KEY (project_id) REFERENCES projects (id) ON DELETE CASCADE,
        UNIQUE (project_id, spec_hash)
      )
    &#x60;);
  }

  /**
   * Create the events table
   */
  private createEventsTable(): void {
    this.db.exec(&#x60;
      CREATE TABLE IF NOT EXISTS events (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        event_type TEXT NOT NULL,
        data TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (strftime(&amp;#39;%Y-%m-%d %H:%M:%f&amp;#39;, &amp;#39;now&amp;#39;)),
        FOREIGN KEY (project_id) REFERENCES projects (id) ON DELETE CASCADE
      )
    &#x60;);
  }

  /**
   * Create the artifacts table for storing brownfield detection results
   */
  private createArtifactsTable(): void {
    this.db.exec(&#x60;
      CREATE TABLE IF NOT EXISTS artifacts (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        name TEXT NOT NULL,
        type TEXT NOT NULL,
        language TEXT,
        framework TEXT,
        metadata TEXT,
        file_path TEXT,
        confidence REAL DEFAULT 1.0,
        created_at TEXT NOT NULL DEFAULT (strftime(&amp;#39;%Y-%m-%d %H:%M:%f&amp;#39;, &amp;#39;now&amp;#39;)),
        FOREIGN KEY (project_id) REFERENCES projects (id) ON DELETE CASCADE
      )
    &#x60;);
  }

  /**
   * Create all database tables
   */
  private createTables(): void {
    this.createProjectsTable();
    this.createFragmentsTable();
    this.createFragmentRevisionsTable();
    this.createVersionsTable();
    this.createEventsTable();
    this.createArtifactsTable();
  }

  /**
   * Create performance indices for tables
   */
  private createIndices(): void {
    // Fragment indices
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_fragments_project_id ON fragments (project_id)&amp;#39;);
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_fragments_path ON fragments (project_id, path)&amp;#39;);

    // Fragment revision indices
    this.db.exec(
      &amp;#39;CREATE INDEX IF NOT EXISTS idx_fragment_revisions_fragment_id ON fragment_revisions (fragment_id)&amp;#39;
    );
    this.db.exec(
      &amp;#39;CREATE INDEX IF NOT EXISTS idx_fragment_revisions_revision_number ON fragment_revisions (fragment_id, revision_number)&amp;#39;
    );
    this.db.exec(
      &amp;#39;CREATE INDEX IF NOT EXISTS idx_fragment_revisions_content_hash ON fragment_revisions (content_hash)&amp;#39;
    );

    // Version indices
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_versions_project_id ON versions (project_id)&amp;#39;);
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_versions_hash ON versions (spec_hash)&amp;#39;);

    // Event indices
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_events_project_id ON events (project_id)&amp;#39;);
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_events_created_at ON events (created_at DESC)&amp;#39;);

    // Artifact indices
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_artifacts_project_id ON artifacts (project_id)&amp;#39;);
    this.db.exec(&amp;#39;CREATE INDEX IF NOT EXISTS idx_artifacts_type ON artifacts (project_id, type)&amp;#39;);
  }

  /**
   * Create database triggers for automatic timestamp updates
   */
  private createTriggers(): void {
    // Trigger to update updated_at on projects
    this.db.exec(&#x60;
      CREATE TRIGGER IF NOT EXISTS update_projects_updated_at
      AFTER UPDATE ON projects
      FOR EACH ROW
      BEGIN
        UPDATE projects SET updated_at &#x3D; datetime(&amp;#39;now&amp;#39;) WHERE id &#x3D; NEW.id;
      END
    &#x60;);

    // Trigger to update updated_at on fragments
    this.db.exec(&#x60;
      CREATE TRIGGER IF NOT EXISTS update_fragments_updated_at
      AFTER UPDATE ON fragments
      FOR EACH ROW
      BEGIN
        UPDATE fragments SET updated_at &#x3D; strftime(&amp;#39;%Y-%m-%d %H:%M:%f&amp;#39;, &amp;#39;now&amp;#39;) WHERE id &#x3D; NEW.id;
      END
    &#x60;);
  }

  /**
   * Initialize database schema with proper indices
   */
  private initializeSchema(): void {
    this.configurePragmas();
    this.handleSchemaMigrations();
    this.createTables();
    this.createIndices();
    this.createTriggers();
  }

  // Project operations
  async createProject(id: string, name: string, serviceCount &#x3D; 0, databaseCount &#x3D; 0): Promise&amp;lt;Project&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      INSERT INTO projects (id, name, service_count, database_count) VALUES (?, ?, ?, ?)
      RETURNING id, name, service_count, database_count, created_at, updated_at
    &#x60;);

    const result &#x3D; stmt.get(id, name, serviceCount, databaseCount) as Project;
    if (!result) {
      throw new Error(&amp;#39;Failed to create project&amp;#39;);
    }
    return result;
  }

  async getProject(id: string): Promise&amp;lt;Project | null&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM projects WHERE id &#x3D; ?&amp;#39;);
    return stmt.get(id) as Project | null;
  }

  async listProjects(): Promise&amp;lt;Project[]&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM projects ORDER BY created_at DESC&amp;#39;);
    return stmt.all() as Project[];
  }

  async deleteProject(id: string): Promise&amp;lt;void&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;DELETE FROM projects WHERE id &#x3D; ?&amp;#39;);
    const result &#x3D; stmt.run(id);
    if (result.changes &#x3D;&#x3D;&#x3D; 0) {
      throw new Error(&amp;#39;Project not found&amp;#39;);
    }
  }

  // Fragment operations
  async createFragment(
    id: string,
    projectId: string,
    path: string,
    content: string,
    author?: string,
    message?: string
  ): Promise&amp;lt;Fragment&amp;gt; {
    return this.transaction(() &#x3D;&amp;gt; {
      // Create fragment
      const stmt &#x3D; this.db.prepare(&#x60;
        INSERT INTO fragments (id, project_id, path, content) 
        VALUES (?, ?, ?, ?)
        RETURNING id, project_id, path, content, head_revision_id, created_at, updated_at
      &#x60;);

      const fragment &#x3D; stmt.get(id, projectId, path, content) as Fragment;
      if (!fragment) {
        throw new Error(&amp;#39;Failed to create fragment&amp;#39;);
      }

      // Create initial revision
      const revisionId &#x3D; this.generateId();
      const contentHash &#x3D; createHash(&amp;#39;sha256&amp;#39;).update(content).digest(&amp;#39;hex&amp;#39;);

      this.createFragmentRevision(
        revisionId,
        id,
        1, // Initial revision number
        content,
        contentHash,
        author,
        message || &amp;#39;Initial fragment creation&amp;#39;
      );

      // Update fragment with head revision pointer
      const updateStmt &#x3D; this.db.prepare(&#x60;
        UPDATE fragments SET head_revision_id &#x3D; ? WHERE id &#x3D; ?
      &#x60;);
      updateStmt.run(revisionId, id);

      // Return updated fragment
      const getStmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM fragments WHERE id &#x3D; ?&amp;#39;);
      return getStmt.get(id) as Fragment;
    });
  }

  async updateFragment(
    projectId: string,
    path: string,
    content: string,
    author?: string,
    message?: string
  ): Promise&amp;lt;Fragment&amp;gt; {
    return this.transaction(() &#x3D;&amp;gt; {
      // Get existing fragment
      const existingFragment &#x3D; this.getFragment(projectId, path);
      if (!existingFragment) {
        throw new Error(&amp;#39;Fragment not found&amp;#39;);
      }

      // Create content hash for deduplication
      const contentHash &#x3D; createHash(&amp;#39;sha256&amp;#39;).update(content).digest(&amp;#39;hex&amp;#39;);

      // Check if content has actually changed
      if (existingFragment.content &#x3D;&#x3D;&#x3D; content) {
        return existingFragment; // No change, return existing
      }

      // Get next revision number
      const nextRevisionNumber &#x3D; this.getNextRevisionNumber(existingFragment.id);

      // Create new revision
      const revisionId &#x3D; this.generateId();
      const revision &#x3D; this.createFragmentRevision(
        revisionId,
        existingFragment.id,
        nextRevisionNumber,
        content,
        contentHash,
        author,
        message
      );

      // Update fragment with new content and head revision pointer
      const stmt &#x3D; this.db.prepare(&#x60;
        UPDATE fragments 
        SET content &#x3D; ?, head_revision_id &#x3D; ?
        WHERE project_id &#x3D; ? AND path &#x3D; ?
        RETURNING id, project_id, path, content, head_revision_id, created_at, updated_at
      &#x60;);

      const result &#x3D; stmt.get(content, revisionId, projectId, path) as Fragment | undefined;
      if (!result) {
        throw new Error(&amp;#39;Failed to update fragment&amp;#39;);
      }
      return result;
    });
  }

  getFragment(projectId: string, path: string): Fragment | null {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM fragments WHERE project_id &#x3D; ? AND path &#x3D; ?&amp;#39;);
    return stmt.get(projectId, path) as Fragment | null;
  }

  async getFragmentById(id: string): Promise&amp;lt;Fragment | null&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM fragments WHERE id &#x3D; ?&amp;#39;);
    return stmt.get(id) as Fragment | null;
  }

  async listFragments(projectId: string): Promise&amp;lt;Fragment[]&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM fragments WHERE project_id &#x3D; ? ORDER BY path&amp;#39;);
    return stmt.all(projectId) as Fragment[];
  }

  async deleteFragment(projectId: string, path: string): Promise&amp;lt;void&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;DELETE FROM fragments WHERE project_id &#x3D; ? AND path &#x3D; ?&amp;#39;);
    const result &#x3D; stmt.run(projectId, path);
    if (result.changes &#x3D;&#x3D;&#x3D; 0) {
      throw new Error(&amp;#39;Fragment not found&amp;#39;);
    }
  }

  // Fragment revision operations
  private generateId(): string {
    return randomUUID();
  }

  private getNextRevisionNumber(fragmentId: string): number {
    const stmt &#x3D; this.db.prepare(&#x60;
      SELECT COALESCE(MAX(revision_number), 0) + 1 as next_revision
      FROM fragment_revisions 
      WHERE fragment_id &#x3D; ?
    &#x60;);
    const result &#x3D; stmt.get(fragmentId) as { next_revision: number };
    return result.next_revision;
  }

  async createFragmentRevision(
    id: string,
    fragmentId: string,
    revisionNumber: number,
    content: string,
    contentHash: string,
    author?: string,
    message?: string
  ): Promise&amp;lt;FragmentRevision&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      INSERT INTO fragment_revisions (id, fragment_id, revision_number, content, content_hash, author, message)
      VALUES (?, ?, ?, ?, ?, ?, ?)
      RETURNING id, fragment_id, revision_number, content, content_hash, author, message, created_at
    &#x60;);

    const result &#x3D; stmt.get(
      id,
      fragmentId,
      revisionNumber,
      content,
      contentHash,
      author,
      message
    ) as FragmentRevision;
    if (!result) {
      throw new Error(&amp;#39;Failed to create fragment revision&amp;#39;);
    }
    return result;
  }

  async getFragmentRevision(
    fragmentId: string,
    revisionNumber: number
  ): Promise&amp;lt;FragmentRevision | null&amp;gt; {
    const stmt &#x3D; this.db.prepare(
      &amp;#39;SELECT * FROM fragment_revisions WHERE fragment_id &#x3D; ? AND revision_number &#x3D; ?&amp;#39;
    );
    return stmt.get(fragmentId, revisionNumber) as FragmentRevision | null;
  }

  async listFragmentRevisions(fragmentId: string): Promise&amp;lt;FragmentRevision[]&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      SELECT * FROM fragment_revisions 
      WHERE fragment_id &#x3D; ? 
      ORDER BY revision_number DESC
    &#x60;);
    return stmt.all(fragmentId) as FragmentRevision[];
  }

  async getLatestFragmentRevision(fragmentId: string): Promise&amp;lt;FragmentRevision | null&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      SELECT * FROM fragment_revisions 
      WHERE fragment_id &#x3D; ? 
      ORDER BY revision_number DESC 
      LIMIT 1
    &#x60;);
    return stmt.get(fragmentId) as FragmentRevision | null;
  }

  // Version operations
  async createVersion(
    id: string,
    projectId: string,
    specHash: string,
    resolvedJson: string
  ): Promise&amp;lt;Version&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      INSERT INTO versions (id, project_id, spec_hash, resolved_json)
      VALUES (?, ?, ?, ?)
      RETURNING id, project_id, spec_hash, resolved_json, created_at
    &#x60;);

    const result &#x3D; stmt.get(id, projectId, specHash, resolvedJson) as Version;
    if (!result) {
      throw new Error(&amp;#39;Failed to create version&amp;#39;);
    }
    return result;
  }

  async getVersionByHash(projectId: string, specHash: string): Promise&amp;lt;Version | null&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM versions WHERE project_id &#x3D; ? AND spec_hash &#x3D; ?&amp;#39;);
    return stmt.get(projectId, specHash) as Version | null;
  }

  async getLatestVersion(projectId: string): Promise&amp;lt;Version | null&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      SELECT * FROM versions 
      WHERE project_id &#x3D; ? 
      ORDER BY created_at DESC 
      LIMIT 1
    &#x60;);
    return stmt.get(projectId) as Version | null;
  }

  async listVersions(projectId: string): Promise&amp;lt;Version[]&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      SELECT * FROM versions 
      WHERE project_id &#x3D; ? 
      ORDER BY created_at DESC
    &#x60;);
    return stmt.all(projectId) as Version[];
  }

  // Event operations
  async createEvent(
    id: string,
    projectId: string,
    eventType: EventType,
    data: Record&amp;lt;string, unknown&amp;gt;
  ): Promise&amp;lt;Event&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      INSERT INTO events (id, project_id, event_type, data)
      VALUES (?, ?, ?, ?)
      RETURNING id, project_id, event_type, data, created_at
    &#x60;);

    const result &#x3D; stmt.get(id, projectId, eventType, JSON.stringify(data)) as Event &amp;amp; {
      data: string;
    };

    if (!result) {
      throw new Error(&amp;#39;Failed to create event&amp;#39;);
    }

    return {
      ...result,
      data: JSON.parse(result.data),
    };
  }

  async getEvents(projectId: string, limit &#x3D; 100, since?: string): Promise&amp;lt;Event[]&amp;gt; {
    let query &#x3D; &#x60;
      SELECT * FROM events 
      WHERE project_id &#x3D; ?
    &#x60;;
    const params: any[] &#x3D; [projectId];

    if (since) {
      query +&#x3D; &amp;#39; AND created_at &amp;gt; ?&amp;#39;;
      // Convert ISO timestamp to SQLite datetime format
      const sqliteTimestamp &#x3D; new Date(since)
        .toISOString()
        .replace(&amp;#39;T&amp;#39;, &amp;#39; &amp;#39;)
        .replace(&amp;#39;Z&amp;#39;, &amp;#39;&amp;#39;)
        .split(&amp;#39;.&amp;#39;)[0];
      params.push(sqliteTimestamp);
    }

    query +&#x3D; &amp;#39; ORDER BY created_at DESC LIMIT ?&amp;#39;;
    params.push(limit);

    const stmt &#x3D; this.db.prepare(query);
    const results &#x3D; stmt.all(...params) as (Event &amp;amp; { data: string })[];

    return results.map(event &#x3D;&amp;gt; ({
      ...event,
      data: JSON.parse(event.data),
    }));
  }

  // Alias method for compatibility with tests
  async listEvents(projectId: string, limit &#x3D; 100): Promise&amp;lt;Event[]&amp;gt; {
    return this.getEvents(projectId, limit);
  }

  async listEventsByType(projectId: string, eventType: EventType): Promise&amp;lt;Event[]&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      SELECT * FROM events 
      WHERE project_id &#x3D; ? AND event_type &#x3D; ?
      ORDER BY created_at DESC
    &#x60;);
    const results &#x3D; stmt.all(projectId, eventType) as (Event &amp;amp; { data: string })[];

    return results.map(event &#x3D;&amp;gt; ({
      ...event,
      data: JSON.parse(event.data),
    }));
  }

  // Artifact operations
  async createArtifact(
    id: string,
    projectId: string,
    name: string,
    type: string,
    language?: string,
    framework?: string,
    metadata?: any,
    filePath?: string,
    confidence &#x3D; 1.0
  ): Promise&amp;lt;any&amp;gt; {
    const stmt &#x3D; this.db.prepare(&#x60;
      INSERT INTO artifacts (id, project_id, name, type, language, framework, metadata, file_path, confidence)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      RETURNING id, project_id, name, type, language, framework, metadata, file_path, confidence, created_at
    &#x60;);

    const result &#x3D; stmt.get(
      id,
      projectId,
      name,
      type,
      language,
      framework,
      metadata ? JSON.stringify(metadata) : null,
      filePath,
      confidence
    ) as any;

    if (!result) {
      throw new Error(&amp;#39;Failed to create artifact&amp;#39;);
    }

    return {
      ...result,
      metadata: result.metadata ? JSON.parse(result.metadata) : null,
    };
  }

  async getArtifacts(projectId: string): Promise&amp;lt;any[]&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM artifacts WHERE project_id &#x3D; ? ORDER BY created_at&amp;#39;);
    const results &#x3D; stmt.all(projectId) as any[];

    return results.map(artifact &#x3D;&amp;gt; ({
      ...artifact,
      metadata: artifact.metadata ? JSON.parse(artifact.metadata) : null,
    }));
  }

  async getArtifactsByType(projectId: string, type: string): Promise&amp;lt;any[]&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT * FROM artifacts WHERE project_id &#x3D; ? AND type &#x3D; ? ORDER BY created_at&amp;#39;);
    const results &#x3D; stmt.all(projectId, type) as any[];

    return results.map(artifact &#x3D;&amp;gt; ({
      ...artifact,
      metadata: artifact.metadata ? JSON.parse(artifact.metadata) : null,
    }));
  }

  async deleteArtifacts(projectId: string): Promise&amp;lt;void&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;DELETE FROM artifacts WHERE project_id &#x3D; ?&amp;#39;);
    stmt.run(projectId);
  }

  // Transaction support
  transaction&amp;lt;T&amp;gt;(fn: () &#x3D;&amp;gt; T): T {
    return this.db.transaction(fn)();
  }

  // Cleanup and maintenance
  async vacuum(): Promise&amp;lt;void&amp;gt; {
    this.db.exec(&amp;#39;VACUUM&amp;#39;);
  }

  close(): void {
    this.db.close();
  }

  // Health check
  async healthCheck(): Promise&amp;lt;boolean&amp;gt; {
    try {
      const result &#x3D; this.db.prepare(&amp;#39;SELECT 1 as ok&amp;#39;).get();
      return (result as any)?.ok &#x3D;&#x3D;&#x3D; 1;
    } catch {
      return false;
    }
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-4">
                <div class="file-header">📄 src/utils.ts</div>
                <div class="file-content">
                    <pre>/**
 * Utility functions for Spec Workbench backend
 */
import { createHash } from &amp;#39;node:crypto&amp;#39;;
import { isAbsolute, normalize, resolve, sep } from &amp;#39;node:path&amp;#39;;
import type { ExternalToolResult, ProblemDetails, RateLimitBucket } from &amp;#39;./types.ts&amp;#39;;

/**
 * Generate a unique ID using crypto.randomUUID()
 */
export function generateId(): string {
  return crypto.randomUUID();
}

/**
 * Compute SHA256 hash of a string
 */
export function computeSpecHash(content: string): string {
  return createHash(&amp;#39;sha256&amp;#39;).update(content).digest(&amp;#39;hex&amp;#39;);
}

/**
 * Execute external command with timeout and proper error handling
 */
export async function executeCommand(
  command: string,
  args: string[],
  options: {
    cwd?: string;
    timeout?: number;
    env?: Record&amp;lt;string, string&amp;gt;;
  } &#x3D; {}
): Promise&amp;lt;ExternalToolResult&amp;gt; {
  const startTime &#x3D; Date.now();
  const timeoutMs &#x3D; options.timeout ?? 10000; // 10s default

  try {
    const proc &#x3D; Bun.spawn([command, ...args], {
      cwd: options.cwd,
      env: { ...process.env, ...options.env },
      stdout: &amp;#39;pipe&amp;#39;,
      stderr: &amp;#39;pipe&amp;#39;,
    });

    // Set up timeout
    const timeoutPromise &#x3D; new Promise&amp;lt;never&amp;gt;((_, reject) &#x3D;&amp;gt; {
      setTimeout(() &#x3D;&amp;gt; {
        proc.kill();
        reject(new Error(&#x60;Command timed out after ${timeoutMs}ms&#x60;));
      }, timeoutMs);
    });

    // Wait for process to complete or timeout
    const _result &#x3D; await Promise.race([proc.exited, timeoutPromise]);

    const stdout &#x3D; await new Response(proc.stdout).text();
    const stderr &#x3D; await new Response(proc.stderr).text();
    const exitCode &#x3D; proc.exitCode ?? 1;
    const duration &#x3D; Date.now() - startTime;

    return {
      success: exitCode &#x3D;&#x3D;&#x3D; 0,
      stdout: stdout.trim(),
      stderr: stderr.trim(),
      exit_code: exitCode,
      duration_ms: duration,
    };
  } catch (error) {
    const duration &#x3D; Date.now() - startTime;
    return {
      success: false,
      stdout: &amp;#39;&amp;#39;,
      stderr: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
      exit_code: -1,
      duration_ms: duration,
    };
  }
}

/**
 * Format CUE content using cue fmt command
 */
export async function formatCUE(
  content: string,
  cueBinaryPath &#x3D; &amp;#39;cue&amp;#39;
): Promise&amp;lt;{ formatted: string; success: boolean; error?: string }&amp;gt; {
  // Write content to temporary file
  const tempFile &#x3D; &#x60;/tmp/temp_${generateId()}.cue&#x60;;

  try {
    await Bun.write(tempFile, content);

    const result &#x3D; await executeCommand(cueBinaryPath, [&amp;#39;fmt&amp;#39;, tempFile], {
      timeout: 5000,
    });

    if (result.success) {
      const formatted &#x3D; await Bun.file(tempFile).text();
      return { formatted, success: true };
    }
    return {
      formatted: content,
      success: false,
      error: result.stderr || &amp;#39;Failed to format CUE content&amp;#39;,
    };
  } catch (error) {
    return {
      formatted: content,
      success: false,
      error: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
    };
  } finally {
    // Clean up temp file
    try {
      (await Bun.file(tempFile).exists()) &amp;amp;&amp;amp; (await Bun.write(tempFile, &amp;#39;&amp;#39;));
    } catch {
      // Ignore cleanup errors
    }
  }
}

/**
 * Create RFC 7807 Problem Details error response
 */
export function createProblemDetails(
  status: number,
  title: string,
  detail?: string,
  type?: string,
  instance?: string,
  extensions?: Record&amp;lt;string, unknown&amp;gt;
): ProblemDetails {
  return {
    type: type ?? &#x60;https://httpstatuses.com/${status}&#x60;,
    title,
    status,
    ...(detail &amp;amp;&amp;amp; { detail }),
    ...(instance &amp;amp;&amp;amp; { instance }),
    ...extensions,
  };
}

/**
 * Token bucket rate limiter implementation
 */
export class TokenBucket {
  private buckets &#x3D; new Map&amp;lt;string, RateLimitBucket&amp;gt;();

  constructor(
    private maxTokens &#x3D; 10,
    private refillRate &#x3D; 1, // tokens per second
    private windowMs &#x3D; 10000 // 10 seconds
  ) {}

  /**
   * Check if request is allowed and consume a token
   */
  consume(identifier: string): boolean {
    const now &#x3D; Date.now();
    let bucket &#x3D; this.buckets.get(identifier);

    if (!bucket) {
      bucket &#x3D; {
        tokens: this.maxTokens - 1, // consume one token
        last_refill: now,
        max_tokens: this.maxTokens,
        refill_rate: this.refillRate,
      };
      this.buckets.set(identifier, bucket);
      return true;
    }

    // Calculate tokens to add based on time passed
    const timePassed &#x3D; now - bucket.last_refill;
    const tokensToAdd &#x3D; Math.floor((timePassed / 1000) * this.refillRate);

    if (tokensToAdd &amp;gt; 0) {
      bucket.tokens &#x3D; Math.min(bucket.max_tokens, bucket.tokens + tokensToAdd);
      bucket.last_refill &#x3D; now;
    }

    // Check if we have tokens available
    if (bucket.tokens &amp;gt; 0) {
      bucket.tokens--;
      return true;
    }

    return false;
  }

  /**
   * Get current token count for identifier
   */
  getTokenCount(identifier: string): number {
    const bucket &#x3D; this.buckets.get(identifier);
    if (!bucket) return this.maxTokens;

    // Calculate current tokens
    const now &#x3D; Date.now();
    const timePassed &#x3D; now - bucket.last_refill;
    const tokensToAdd &#x3D; Math.floor((timePassed / 1000) * this.refillRate);

    return Math.min(bucket.max_tokens, bucket.tokens + tokensToAdd);
  }

  /**
   * Clean up old buckets to prevent memory leaks
   */
  cleanup(): void {
    const now &#x3D; Date.now();
    const cutoff &#x3D; now - this.windowMs * 2; // Keep buckets for 2x window size

    for (const [key, bucket] of this.buckets.entries()) {
      if (bucket.last_refill &amp;lt; cutoff) {
        this.buckets.delete(key);
      }
    }
  }
}

/**
 * Ensure directory exists, create if it doesn&amp;#39;t
 */
export async function ensureDir(path: string): Promise&amp;lt;void&amp;gt; {
  try {
    const stat &#x3D; await Bun.file(path).exists();
    if (!stat) {
      await Bun.spawn([&amp;#39;mkdir&amp;#39;, &amp;#39;-p&amp;#39;, path]).exited;
    }
  } catch (error) {
    throw new Error(&#x60;Failed to create directory ${path}: ${error}&#x60;);
  }
}

/**
 * Safe JSON parsing with error handling
 */
export function safeJsonParse&amp;lt;T &#x3D; any&amp;gt;(
  json: string
): { success: true; data: T } | { success: false; error: string } {
  try {
    const data &#x3D; JSON.parse(json);
    return { success: true, data };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : &amp;#39;Invalid JSON&amp;#39;,
    };
  }
}

/**
 * Validate that a string is a valid file path (security check)
 */
export function validatePath(targetPath: string, baseDir: string &#x3D; process.cwd()): boolean {
  if (!targetPath) {
    return false;
  }

  if (targetPath.includes(&amp;#39;\0&amp;#39;)) {
    return false;
  }

  const sanitised &#x3D; targetPath.replace(/\\+/g, &amp;#39;/&amp;#39;);
  const normalisedInput &#x3D; normalize(sanitised).replace(/\\+/g, &amp;#39;/&amp;#39;);

  // Reject absolute paths or attempts to traverse up the directory tree
  if (
    isAbsolute(normalisedInput) ||
    normalisedInput.startsWith(&amp;#39;..&amp;#39;) ||
    normalisedInput.includes(&amp;#39;/../&amp;#39;)
  ) {
    return false;
  }

  // Only allow a conservative character set
  const pathRegex &#x3D; /^[a-zA-Z0-9._/\-]+$/;
  if (!pathRegex.test(normalisedInput)) {
    return false;
  }

  const resolvedBase &#x3D; resolve(baseDir);
  const resolvedTarget &#x3D; resolve(resolvedBase, normalisedInput);
  const baseWithSep &#x3D; resolvedBase.endsWith(sep) ? resolvedBase : &#x60;${resolvedBase}${sep}&#x60;;

  return resolvedTarget &#x3D;&#x3D;&#x3D; resolvedBase || resolvedTarget.startsWith(baseWithSep);
}

/**
 * Get current timestamp in ISO format
 */
export function getCurrentTimestamp(): string {
  return new Date().toISOString();
}

/**
 * Simple logger with structured output
 */
export const logger &#x3D; {
  info: (message: string, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
    console.log(
      JSON.stringify({
        level: &amp;#39;info&amp;#39;,
        message,
        timestamp: getCurrentTimestamp(),
        ...meta,
      })
    );
  },

  warn: (message: string, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
    console.warn(
      JSON.stringify({
        level: &amp;#39;warn&amp;#39;,
        message,
        timestamp: getCurrentTimestamp(),
        ...meta,
      })
    );
  },

  error: (message: string, error?: Error, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
    console.error(
      JSON.stringify({
        level: &amp;#39;error&amp;#39;,
        message,
        error: error?.message,
        stack: error?.stack,
        timestamp: getCurrentTimestamp(),
        ...meta,
      })
    );
  },

  debug: (message: string, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
    if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &amp;#39;development&amp;#39;) {
      console.debug(
        JSON.stringify({
          level: &amp;#39;debug&amp;#39;,
          message,
          timestamp: getCurrentTimestamp(),
          ...meta,
        })
      );
    }
  },
};

/**
 * Parse bearer token from Authorization header
 */
export function parseBearerToken(authHeader: string | undefined): string | null {
  if (!authHeader || !authHeader.startsWith(&amp;#39;Bearer &amp;#39;)) {
    return null;
  }
  return authHeader.slice(7).trim();
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-5">
                <div class="file-header">📄 src/events.ts</div>
                <div class="file-content">
                    <pre>/**
 * Real-time events and WebSocket management
 */
import type { ServerWebSocket } from &amp;#39;bun&amp;#39;;
import { NatsService } from &amp;#39;./nats.ts&amp;#39;;
import type { AuthContext, Event, ServerConfig, WebSocketMessage } from &amp;#39;./types.ts&amp;#39;;
import { generateId, getCurrentTimestamp, logger } from &amp;#39;./utils.ts&amp;#39;;

interface WebSocketConnection {
  id: string;
  ws: ServerWebSocket&amp;lt;{ connectionId: string; authContext: AuthContext }&amp;gt;;
  authContext: AuthContext;
  projectSubscriptions: Set&amp;lt;string&amp;gt;;
  lastPing: number;
}

export class EventService {
  private connections &#x3D; new Map&amp;lt;string, WebSocketConnection&amp;gt;();
  private projectSubscriptions &#x3D; new Map&amp;lt;string, Set&amp;lt;string&amp;gt;&amp;gt;(); // projectId -&amp;gt; Set&amp;lt;connectionId&amp;gt;
  private pingInterval?: Timer;
  private nats: NatsService;

  constructor(private config: ServerConfig) {
    this.nats &#x3D; new NatsService(config.nats);
    this.startPingInterval();
  }

  /**
   * Start WebSocket ping interval to keep connections alive
   */
  private startPingInterval(): void {
    this.pingInterval &#x3D; setInterval(() &#x3D;&amp;gt; {
      this.pingAllConnections();
    }, this.config.websocket.ping_interval_ms);
  }

  /**
   * Handle new WebSocket connection
   */
  handleConnection(
    ws: ServerWebSocket&amp;lt;{ connectionId: string; authContext: AuthContext }&amp;gt;,
    authContext: AuthContext
  ): string {
    const connectionId &#x3D; generateId();

    const connection: WebSocketConnection &#x3D; {
      id: connectionId,
      ws,
      authContext,
      projectSubscriptions: new Set(),
      lastPing: Date.now(),
    };

    this.connections.set(connectionId, connection);

    // Set connection data for WebSocket
    ws.data &#x3D; { connectionId, authContext };

    // Reduced logging - only log if debug level enabled
    // logger.info(&amp;quot;WebSocket connection established&amp;quot;, {
    //   connectionId,
    //   userId: authContext.user_id,
    //   totalConnections: this.connections.size,
    // });

    // Send welcome message
    this.sendToConnection(connectionId, {
      type: &amp;#39;event&amp;#39;,
      data: {
        event_type: &amp;#39;connection_established&amp;#39;,
        connection_id: connectionId,
        timestamp: getCurrentTimestamp(),
      },
    });

    return connectionId;
  }

  /**
   * Handle WebSocket disconnection
   */
  handleDisconnection(connectionId: string): void {
    const connection &#x3D; this.connections.get(connectionId);

    if (connection) {
      // Remove from all project subscriptions
      for (const projectId of connection.projectSubscriptions) {
        this.unsubscribeFromProject(connectionId, projectId);
      }

      this.connections.delete(connectionId);

      // Reduced logging - only log if debug level enabled
      // logger.info(&amp;quot;WebSocket connection closed&amp;quot;, {
      //   connectionId,
      //   userId: connection.authContext.user_id,
      //   totalConnections: this.connections.size,
      // });
    }
  }

  /**
   * Handle incoming WebSocket message
   */
  async handleMessage(connectionId: string, message: WebSocketMessage): Promise&amp;lt;void&amp;gt; {
    const connection &#x3D; this.connections.get(connectionId);

    if (!connection) {
      logger.warn(&amp;#39;Message from unknown connection&amp;#39;, { connectionId });
      return;
    }

    try {
      switch (message.type) {
        case &amp;#39;ping&amp;#39;:
          this.handlePing(connectionId);
          break;

        case &amp;#39;event&amp;#39;:
          await this.handleEventMessage(connectionId, message);
          break;

        default:
          logger.warn(&amp;#39;Unknown message type&amp;#39;, {
            connectionId,
            messageType: message.type,
          });
      }
    } catch (error) {
      logger.error(&amp;#39;Error handling WebSocket message&amp;#39;, error instanceof Error ? error : undefined, {
        connectionId,
        messageType: message.type,
      });

      this.sendToConnection(connectionId, {
        type: &amp;#39;error&amp;#39;,
        data: {
          error: &amp;#39;Failed to process message&amp;#39;,
          originalMessage: message,
        },
      });
    }
  }

  /**
   * Handle ping message
   */
  private handlePing(connectionId: string): void {
    const connection &#x3D; this.connections.get(connectionId);

    if (connection) {
      connection.lastPing &#x3D; Date.now();

      this.sendToConnection(connectionId, {
        type: &amp;#39;pong&amp;#39;,
        data: { timestamp: getCurrentTimestamp() },
      });
    }
  }

  /**
   * Handle event-type message (subscribe/unsubscribe)
   */
  private async handleEventMessage(connectionId: string, message: WebSocketMessage): Promise&amp;lt;void&amp;gt; {
    const connection &#x3D; this.connections.get(connectionId);
    if (!connection) return;

    const { data } &#x3D; message;
    const action &#x3D; data.action as string;
    const projectId &#x3D; data.project_id as string;

    switch (action) {
      case &amp;#39;subscribe&amp;#39;:
        if (projectId) {
          await this.subscribeToProject(connectionId, projectId);
        }
        break;

      case &amp;#39;unsubscribe&amp;#39;:
        if (projectId) {
          this.unsubscribeFromProject(connectionId, projectId);
        }
        break;

      default:
        logger.warn(&amp;#39;Unknown event action&amp;#39;, { connectionId, action });
    }
  }

  /**
   * Subscribe connection to project events
   */
  private async subscribeToProject(connectionId: string, projectId: string): Promise&amp;lt;void&amp;gt; {
    const connection &#x3D; this.connections.get(connectionId);

    if (!connection) {
      return;
    }

    // Check if user has access to project
    if (
      !connection.authContext.project_access.includes(&amp;#39;*&amp;#39;) &amp;amp;&amp;amp;
      !connection.authContext.project_access.includes(projectId)
    ) {
      this.sendToConnection(connectionId, {
        type: &amp;#39;error&amp;#39;,
        data: {
          error: &amp;#39;Access denied&amp;#39;,
          project_id: projectId,
        },
      });
      return;
    }

    // Add to project subscriptions
    connection.projectSubscriptions.add(projectId);

    if (!this.projectSubscriptions.has(projectId)) {
      this.projectSubscriptions.set(projectId, new Set());
    }
    this.projectSubscriptions.get(projectId)?.add(connectionId);

    logger.info(&amp;#39;Subscribed to project&amp;#39;, {
      connectionId,
      projectId,
      userId: connection.authContext.user_id,
    });

    // Acknowledge subscription
    this.sendToConnection(connectionId, {
      type: &amp;#39;event&amp;#39;,
      project_id: projectId,
      data: {
        event_type: &amp;#39;subscription_confirmed&amp;#39;,
        project_id: projectId,
        timestamp: getCurrentTimestamp(),
      },
    });
  }

  /**
   * Unsubscribe connection from project events
   */
  private unsubscribeFromProject(connectionId: string, projectId: string): void {
    const connection &#x3D; this.connections.get(connectionId);

    if (connection) {
      connection.projectSubscriptions.delete(projectId);
    }

    const projectConnections &#x3D; this.projectSubscriptions.get(projectId);
    if (projectConnections) {
      projectConnections.delete(connectionId);

      // Clean up empty project subscriptions
      if (projectConnections.size &#x3D;&#x3D;&#x3D; 0) {
        this.projectSubscriptions.delete(projectId);
      }
    }

    logger.debug(&amp;#39;Unsubscribed from project&amp;#39;, { connectionId, projectId });
  }

  /**
   * Broadcast event to all subscribers of a project
   */
  /**
   * Create WebSocket message from event
   */
  private createWebSocketMessage(
    projectId: string,
    event: Omit&amp;lt;Event, &amp;#39;id&amp;#39; | &amp;#39;created_at&amp;#39;&amp;gt;
  ): WebSocketMessage {
    return {
      type: &amp;#39;event&amp;#39;,
      project_id: projectId,
      data: {
        ...event,
        id: generateId(),
        created_at: getCurrentTimestamp(),
      },
    };
  }

  /**
   * Publish event to NATS (non-blocking)
   */
  private async publishToNats(
    projectId: string,
    event: Omit&amp;lt;Event, &amp;#39;id&amp;#39; | &amp;#39;created_at&amp;#39;&amp;gt;,
    specHash?: string
  ): Promise&amp;lt;void&amp;gt; {
    this.nats.publishEvent(projectId, event, specHash).catch(_error &#x3D;&amp;gt; {
      // Already logged in NatsService, but ensure it doesn&amp;#39;t affect WebSocket flow
      logger.debug(&amp;#39;NATS publish completed with potential error&amp;#39;, {
        projectId,
        eventType: event.event_type,
      });
    });
  }

  /**
   * Check if there are subscribers for the project
   */
  private hasProjectSubscribers(projectId: string): boolean {
    const subscribers &#x3D; this.projectSubscriptions.get(projectId);
    return !!(subscribers &amp;amp;&amp;amp; subscribers.size &amp;gt; 0);
  }

  /**
   * Get project subscribers
   */
  private getProjectSubscribers(projectId: string): Set&amp;lt;string&amp;gt; | undefined {
    return this.projectSubscriptions.get(projectId);
  }

  /**
   * Send message to individual connection with error handling
   */
  private async sendToConnectionSafe(
    connectionId: string,
    message: WebSocketMessage,
    projectId: string
  ): Promise&amp;lt;{ success: boolean }&amp;gt; {
    try {
      await this.sendToConnection(connectionId, message);
      return { success: true };
    } catch (error) {
      logger.error(
        &amp;#39;Failed to send message to connection&amp;#39;,
        error instanceof Error ? error : undefined,
        {
          connectionId,
          projectId,
        }
      );
      return { success: false };
    }
  }

  /**
   * Broadcast message to all WebSocket subscribers
   */
  private async broadcastToSubscribers(
    subscribers: Set&amp;lt;string&amp;gt;,
    message: WebSocketMessage,
    projectId: string
  ): Promise&amp;lt;{ successCount: number; errorCount: number }&amp;gt; {
    const promises &#x3D; Array.from(subscribers).map(connectionId &#x3D;&amp;gt;
      this.sendToConnectionSafe(connectionId, message, projectId)
    );

    const results &#x3D; await Promise.all(promises);
    const successCount &#x3D; results.filter(r &#x3D;&amp;gt; r.success).length;
    const errorCount &#x3D; results.length - successCount;

    return { successCount, errorCount };
  }

  /**
   * Log broadcast results and performance
   */
  private logBroadcastResults(
    projectId: string,
    event: Omit&amp;lt;Event, &amp;#39;id&amp;#39; | &amp;#39;created_at&amp;#39;&amp;gt;,
    subscriberCount: number,
    successCount: number,
    errorCount: number,
    duration: number
  ): void {
    logger.info(&amp;#39;Broadcasted event to project&amp;#39;, {
      projectId,
      eventType: event.event_type,
      subscriberCount,
      successCount,
      errorCount,
      duration,
    });
  }

  /**
   * Check and warn about broadcast performance
   */
  private checkBroadcastPerformance(projectId: string, duration: number, targetMs &#x3D; 100): void {
    if (duration &amp;gt; targetMs) {
      logger.warn(&amp;#39;Broadcast exceeded target time&amp;#39;, {
        projectId,
        duration,
        target: targetMs,
      });
    }
  }

  async broadcastToProject(
    projectId: string,
    event: Omit&amp;lt;Event, &amp;#39;id&amp;#39; | &amp;#39;created_at&amp;#39;&amp;gt;,
    specHash?: string
  ): Promise&amp;lt;void&amp;gt; {
    const startTime &#x3D; Date.now();

    // Create WebSocket message
    const message &#x3D; this.createWebSocketMessage(projectId, event);

    // Publish to NATS (async, non-blocking)
    await this.publishToNats(projectId, event, specHash);

    // Check for WebSocket subscribers
    if (!this.hasProjectSubscribers(projectId)) {
      logger.debug(&amp;#39;No WebSocket subscribers for project&amp;#39;, { projectId });
      return;
    }

    const subscribers &#x3D; this.getProjectSubscribers(projectId)!;

    // Broadcast to all WebSocket subscribers
    const { successCount, errorCount } &#x3D; await this.broadcastToSubscribers(
      subscribers,
      message,
      projectId
    );

    // Log results and check performance
    const duration &#x3D; Date.now() - startTime;
    this.logBroadcastResults(
      projectId,
      event,
      subscribers.size,
      successCount,
      errorCount,
      duration
    );
    this.checkBroadcastPerformance(projectId, duration);
  }

  /**
   * Send message to specific connection
   */
  private async sendToConnection(connectionId: string, message: WebSocketMessage): Promise&amp;lt;void&amp;gt; {
    const connection &#x3D; this.connections.get(connectionId);

    if (!connection) {
      throw new Error(&#x60;Connection ${connectionId} not found&#x60;);
    }

    try {
      const messageStr &#x3D; JSON.stringify(message);
      connection.ws.send(messageStr);
    } catch (error) {
      // Connection might be closed, remove it
      this.handleDisconnection(connectionId);
      throw error;
    }
  }

  /**
   * Ping all connections to keep them alive
   */
  private pingAllConnections(): void {
    const now &#x3D; Date.now();
    const timeout &#x3D; this.config.websocket.ping_interval_ms * 2;
    const staleConnections: string[] &#x3D; [];

    for (const [connectionId, connection] of this.connections.entries()) {
      if (now - connection.lastPing &amp;gt; timeout) {
        staleConnections.push(connectionId);
      } else {
        this.sendToConnection(connectionId, {
          type: &amp;#39;ping&amp;#39;,
          data: { timestamp: getCurrentTimestamp() },
        }).catch(() &#x3D;&amp;gt; {
          // Connection error, mark for removal
          staleConnections.push(connectionId);
        });
      }
    }

    // Clean up stale connections
    staleConnections.forEach(connectionId &#x3D;&amp;gt; {
      logger.info(&amp;#39;Removing stale connection&amp;#39;, { connectionId });
      this.handleDisconnection(connectionId);
    });
  }

  /**
   * Get connection statistics
   */
  getStats(): {
    totalConnections: number;
    totalProjects: number;
    connectionsByProject: Record&amp;lt;string, number&amp;gt;;
    nats: {
      enabled: boolean;
      connected: boolean;
      eventsPublished: number;
    };
  } {
    const connectionsByProject: Record&amp;lt;string, number&amp;gt; &#x3D; {};

    for (const [projectId, connections] of this.projectSubscriptions.entries()) {
      connectionsByProject[projectId] &#x3D; connections.size;
    }

    return {
      totalConnections: this.connections.size,
      totalProjects: this.projectSubscriptions.size,
      connectionsByProject,
      nats: this.nats.getStats(),
    };
  }

  /**
   * Close all connections and cleanup
   */
  async cleanup(): Promise&amp;lt;void&amp;gt; {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
    }

    // Close all connections
    for (const connection of this.connections.values()) {
      try {
        connection.ws.close();
      } catch {
        // Ignore close errors
      }
    }

    this.connections.clear();
    this.projectSubscriptions.clear();

    // Cleanup NATS connection
    await this.nats.cleanup();

    logger.info(&amp;#39;EventService cleanup completed&amp;#39;);
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-6">
                <div class="file-header">📄 src/auth.ts</div>
                <div class="file-content">
                    <pre>/**
 * Authentication and authorization module
 */
import type { AuthContext, ServerConfig } from &amp;#39;./types.ts&amp;#39;;
import { logger, parseBearerToken } from &amp;#39;./utils.ts&amp;#39;;

// OAuth-related interfaces
export interface OAuthToken {
  access_token: string;
  token_type: string;
  expires_in: number;
  scope: string;
  user_id?: string;
}

export interface OAuthService {
  validateToken(token: string): Promise&amp;lt;OAuthToken | null&amp;gt;;
  introspectToken(token: string): Promise&amp;lt;any&amp;gt;;
  getTokenInfo(token: string): Promise&amp;lt;any&amp;gt;;
}

export interface ProtectedResourceMetadata {
  issuer: string;
  authorization_endpoint: string;
  token_endpoint: string;
  scopes_supported: string[];
  response_types_supported: string[];
  grant_types_supported: string[];
}

export interface AuthorizationServer {
  issueToken(clientId: string, scope: string): Promise&amp;lt;OAuthToken&amp;gt;;
  validateClient(clientId: string, clientSecret: string): Promise&amp;lt;boolean&amp;gt;;
  revokeToken(token: string): Promise&amp;lt;boolean&amp;gt;;
}

export interface OAuthProvider {
  authorize(params: any): Promise&amp;lt;string&amp;gt;;
  getTokenFromCode(code: string, clientId: string, clientSecret: string): Promise&amp;lt;OAuthToken&amp;gt;;
  refreshToken(refreshToken: string): Promise&amp;lt;OAuthToken&amp;gt;;
}

export class AuthService {
  private validTokens: Set&amp;lt;string&amp;gt; &#x3D; new Set();
  private tokenToUserMap: Map&amp;lt;string, string&amp;gt; &#x3D; new Map();
  private userProjectAccess: Map&amp;lt;string, string[]&amp;gt; &#x3D; new Map();
  private oauthService: OAuthService | null &#x3D; null;
  private authorizationServer: AuthorizationServer | null &#x3D; null;
  private oauthProvider: OAuthProvider | null &#x3D; null;

  constructor(private config: ServerConfig) {
    // Initialize with development tokens only in development mode
    if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &amp;#39;development&amp;#39;) {
      const devToken &#x3D; process.env.DEV_AUTH_TOKEN || &amp;#39;dev-token&amp;#39;;
      const devUser &#x3D; process.env.DEV_AUTH_USER || &amp;#39;dev-user&amp;#39;;
      
      this.addToken(devToken, devUser, [&amp;#39;*&amp;#39;]);
      
      logger.warn(&amp;#39;DEVELOPMENT MODE: Authentication tokens configured!&amp;#39;, {
        devToken: &#x60;${devToken.substring(0, 4)}...&#x60;,
        devUser,
        warning: &amp;#39;This should NEVER be enabled in production!&amp;#39;
      });
    }
    
    // Fail-safe: Ensure no dev tokens in production
    if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &amp;#39;production&amp;#39; &amp;amp;&amp;amp; this.validTokens.has(&amp;#39;dev-token&amp;#39;)) {
      throw new Error(&amp;#39;SECURITY ERROR: Development tokens detected in production environment!&amp;#39;);
    }
  }

  /**
   * Add a valid token with user and project access
   */
  addToken(token: string, userId: string, projectAccess: string[] &#x3D; []): void {
    this.validTokens.add(token);
    this.tokenToUserMap.set(token, userId);
    this.userProjectAccess.set(userId, projectAccess);

    logger.info(&amp;#39;Token added for user&amp;#39;, {
      userId,
      projectCount: projectAccess.length,
    });
  }

  /**
   * Remove a token
   */
  removeToken(token: string): void {
    const userId &#x3D; this.tokenToUserMap.get(token);

    this.validTokens.delete(token);
    this.tokenToUserMap.delete(token);

    if (userId) {
      this.userProjectAccess.delete(userId);
      logger.info(&amp;#39;Token removed for user&amp;#39;, { userId });
    }
  }

  /**
   * Validate token and return auth context
   */
  validateToken(token: string): AuthContext | null {
    if (!this.validTokens.has(token)) {
      return null;
    }

    const userId &#x3D; this.tokenToUserMap.get(token);
    const projectAccess &#x3D; userId ? (this.userProjectAccess.get(userId) ?? []) : [];

    return {
      token,
      user_id: userId,
      project_access: projectAccess,
    };
  }

  /**
   * Check if user has access to a specific project
   */
  hasProjectAccess(authContext: AuthContext, projectId: string): boolean {
    // Wildcard access
    if (authContext.project_access.includes(&amp;#39;*&amp;#39;)) {
      return true;
    }

    // Specific project access
    return authContext.project_access.includes(projectId);
  }

  /**
   * Extract and validate auth context from request headers
   */
  async authenticateRequest(headers: Headers): Promise&amp;lt;AuthContext | null&amp;gt; {
    if (!this.config.auth_required) {
      // Return a default context when auth is disabled
      return {
        token: &amp;#39;no-auth&amp;#39;,
        user_id: &amp;#39;anonymous&amp;#39;,
        project_access: [&amp;#39;*&amp;#39;],
      };
    }

    const authHeader &#x3D; headers.get(&amp;#39;authorization&amp;#39;);
    const token &#x3D; parseBearerToken(authHeader ?? undefined);

    if (!token) {
      return null;
    }

    return this.validateToken(token);
  }

  /**
   * Create auth middleware for HTTP requests
   */
  createAuthMiddleware() {
    return async (
      request: Request
    ): Promise&amp;lt;{
      authorized: boolean;
      authContext?: AuthContext;
      response?: Response;
    }&amp;gt; &#x3D;&amp;gt; {
      try {
        const authContext &#x3D; await this.authenticateRequest(request.headers);

        if (!authContext) {
          return {
            authorized: false,
            response: new Response(
              JSON.stringify({
                type: &amp;#39;https://httpstatuses.com/401&amp;#39;,
                title: &amp;#39;Unauthorized&amp;#39;,
                status: 401,
                detail: &amp;#39;Valid bearer token required&amp;#39;,
              }),
              {
                status: 401,
                headers: {
                  &amp;#39;Content-Type&amp;#39;: &amp;#39;application/problem+json&amp;#39;,
                  &amp;#39;WWW-Authenticate&amp;#39;: &amp;#39;Bearer&amp;#39;,
                },
              }
            ),
          };
        }

        return { authorized: true, authContext };
      } catch (error) {
        logger.error(&amp;#39;Auth middleware error&amp;#39;, error instanceof Error ? error : undefined);

        return {
          authorized: false,
          response: new Response(
            JSON.stringify({
              type: &amp;#39;https://httpstatuses.com/500&amp;#39;,
              title: &amp;#39;Internal Server Error&amp;#39;,
              status: 500,
              detail: &amp;#39;Authentication service error&amp;#39;,
            }),
            {
              status: 500,
              headers: { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/problem+json&amp;#39; },
            }
          ),
        };
      }
    };
  }

  /**
   * Create project access middleware
   */
  createProjectAccessMiddleware() {
    return (
      authContext: AuthContext,
      projectId: string
    ): {
      authorized: boolean;
      response?: Response;
    } &#x3D;&amp;gt; {
      if (!this.hasProjectAccess(authContext, projectId)) {
        return {
          authorized: false,
          response: new Response(
            JSON.stringify({
              type: &amp;#39;https://httpstatuses.com/403&amp;#39;,
              title: &amp;#39;Forbidden&amp;#39;,
              status: 403,
              detail: &#x60;Access denied to project: ${projectId}&#x60;,
            }),
            {
              status: 403,
              headers: { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/problem+json&amp;#39; },
            }
          ),
        };
      }

      return { authorized: true };
    };
  }

  /**
   * Get user info for a token
   */
  getUserInfo(token: string): { userId?: string; projectAccess: string[] } | null {
    const userId &#x3D; this.tokenToUserMap.get(token);
    if (!userId) {
      return null;
    }

    return {
      userId,
      projectAccess: this.userProjectAccess.get(userId) ?? [],
    };
  }

  /**
   * List all active tokens (for admin purposes)
   */
  listTokens(): Array&amp;lt;{
    token: string;
    userId?: string;
    projectCount: number;
  }&amp;gt; {
    return Array.from(this.validTokens).map(token &#x3D;&amp;gt; {
      const userId &#x3D; this.tokenToUserMap.get(token);
      const projectAccess &#x3D; userId ? (this.userProjectAccess.get(userId) ?? []) : [];

      return {
        token: &#x60;${token.substring(0, 8)}...&#x60;, // Partial token for security
        userId,
        projectCount: projectAccess.length,
      };
    });
  }

  /**
   * Start OAuth service if enabled
   */
  async startOAuthService(): Promise&amp;lt;void&amp;gt; {
    if (!this.config.oauth?.enabled) {
      logger.info(&amp;#39;OAuth service disabled, skipping startup&amp;#39;);
      return;
    }

    try {
      // Initialize OAuth service components
      this.oauthService &#x3D; this.createOAuthServiceInstance();
      
      if (this.config.oauth.enableAuthServer) {
        this.authorizationServer &#x3D; this.createAuthorizationServerInstance();
        logger.info(&amp;#39;OAuth Authorization Server started&amp;#39;, {
          url: this.config.oauth.authServerUrl,
          port: this.config.oauth.authServerPort
        });
      }

      this.oauthProvider &#x3D; this.createOAuthProviderInstance();
      
      logger.info(&amp;#39;OAuth service started successfully&amp;#39;, {
        authServerEnabled: this.config.oauth.enableAuthServer,
        mcpBaseUrl: this.config.oauth.mcpBaseUrl,
        requiredScopes: this.config.oauth.requiredScopes || []
      });
    } catch (error) {
      logger.error(&amp;#39;Failed to start OAuth service&amp;#39;, { error });
      throw new Error(&#x60;OAuth service startup failed: ${error instanceof Error ? error.message : String(error)}&#x60;);
    }
  }

  /**
   * Stop OAuth service if enabled
   */
  async stopOAuthService(): Promise&amp;lt;void&amp;gt; {
    if (!this.config.oauth?.enabled) {
      return;
    }

    try {
      this.oauthService &#x3D; null;
      this.authorizationServer &#x3D; null;
      this.oauthProvider &#x3D; null;
      
      logger.info(&amp;#39;OAuth service stopped successfully&amp;#39;);
    } catch (error) {
      logger.error(&amp;#39;Error stopping OAuth service&amp;#39;, { error });
    }
  }

  /**
   * Get OAuth service instance
   */
  getOAuthService(): OAuthService | null {
    return this.oauthService;
  }

  /**
   * Get protected resource metadata for OAuth
   */
  getProtectedResourceMetadata(): ProtectedResourceMetadata | null {
    if (!this.config.oauth?.enabled) {
      return null;
    }

    return {
      issuer: this.config.oauth.authServerUrl,
      authorization_endpoint: &#x60;${this.config.oauth.authServerUrl}/oauth/authorize&#x60;,
      token_endpoint: &#x60;${this.config.oauth.authServerUrl}/oauth/token&#x60;,
      scopes_supported: this.config.oauth.requiredScopes || [&amp;#39;read&amp;#39;, &amp;#39;write&amp;#39;],
      response_types_supported: [&amp;#39;code&amp;#39;, &amp;#39;token&amp;#39;],
      grant_types_supported: [&amp;#39;authorization_code&amp;#39;, &amp;#39;client_credentials&amp;#39;, &amp;#39;refresh_token&amp;#39;]
    };
  }

  /**
   * Get OAuth authorization server instance
   */
  getAuthorizationServer(): AuthorizationServer | null {
    return this.authorizationServer;
  }

  /**
   * Get OAuth provider instance
   */
  getOAuthProvider(): OAuthProvider | null {
    return this.oauthProvider;
  }

  /**
   * Create OAuth-aware auth middleware
   */
  createOAuthAwareAuthMiddleware() {
    if (!this.config.oauth?.enabled) {
      // When OAuth is disabled, fall back to regular auth middleware
      return this.createAuthMiddleware();
    }

    return async (req: any, res: any, next: any) &#x3D;&amp;gt; {
      try {
        const token &#x3D; parseBearerToken(req.headers.authorization || &amp;#39;&amp;#39;);
        
        if (!token) {
          return res.status(401).json({ error: &amp;#39;Authorization token required&amp;#39; });
        }

        // Try OAuth validation first
        if (this.oauthService) {
          const oauthToken &#x3D; await this.oauthService.validateToken(token);
          if (oauthToken) {
            // Set OAuth context
            req.auth &#x3D; {
              token,
              user_id: oauthToken.user_id,
              project_access: this.extractProjectAccessFromScope(oauthToken.scope),
              oauth_token: oauthToken
            } as AuthContext;
            return next();
          }
        }

        // Fall back to regular token validation
        const regularAuthMiddleware &#x3D; this.createAuthMiddleware();
        return regularAuthMiddleware(req, res, next);
      } catch (error) {
        logger.error(&amp;#39;OAuth-aware auth middleware error&amp;#39;, { error });
        return res.status(500).json({ error: &amp;#39;Authentication error&amp;#39; });
      }
    };
  }

  /**
   * Validate OAuth token and extract user context
   */
  async validateOAuthToken(token: string): Promise&amp;lt;AuthContext | null&amp;gt; {
    if (!this.oauthService) {
      return null;
    }

    try {
      const oauthToken &#x3D; await this.oauthService.validateToken(token);
      if (!oauthToken) {
        return null;
      }

      return {
        token,
        user_id: oauthToken.user_id,
        project_access: this.extractProjectAccessFromScope(oauthToken.scope),
        oauth_token: oauthToken
      };
    } catch (error) {
      logger.error(&amp;#39;OAuth token validation failed&amp;#39;, { error });
      return null;
    }
  }

  /**
   * Extract project access from OAuth scope
   */
  private extractProjectAccessFromScope(scope: string): string[] {
    // Parse scope string to extract project access
    // Format: &amp;quot;read:project:proj1 write:project:proj2&amp;quot; etc.
    const scopes &#x3D; scope.split(&amp;#39; &amp;#39;);
    const projectAccess &#x3D; new Set&amp;lt;string&amp;gt;();

    for (const scopeItem of scopes) {
      const match &#x3D; scopeItem.match(/^(read|write):project:(.+)$/);
      if (match) {
        projectAccess.add(match[2]);
      }
    }

    return Array.from(projectAccess);
  }

  /**
   * Create OAuth service instance (stub implementation)
   */
  private createOAuthServiceInstance(): OAuthService {
    return {
      async validateToken(token: string): Promise&amp;lt;OAuthToken | null&amp;gt; {
        // Stub implementation for OAuth token validation
        // In production, this would validate against OAuth server
        logger.debug(&amp;#39;OAuth token validation (stub)&amp;#39;, { tokenPrefix: token.substring(0, 8) });
        
        // For development, accept tokens that start with &amp;#39;oauth_&amp;#39;
        if (token.startsWith(&amp;#39;oauth_&amp;#39;)) {
          return {
            access_token: token,
            token_type: &amp;#39;Bearer&amp;#39;,
            expires_in: 3600,
            scope: &amp;#39;read write&amp;#39;,
            user_id: &amp;#39;oauth-user&amp;#39;
          };
        }
        
        return null;
      },

      async introspectToken(token: string): Promise&amp;lt;any&amp;gt; {
        // Stub implementation for token introspection
        logger.debug(&amp;#39;OAuth token introspection (stub)&amp;#39;, { tokenPrefix: token.substring(0, 8) });
        return {
          active: token.startsWith(&amp;#39;oauth_&amp;#39;),
          client_id: &amp;#39;arbiter-client&amp;#39;,
          username: &amp;#39;oauth-user&amp;#39;,
          scope: &amp;#39;read write&amp;#39;
        };
      },

      async getTokenInfo(token: string): Promise&amp;lt;any&amp;gt; {
        // Stub implementation for token info
        logger.debug(&amp;#39;OAuth token info (stub)&amp;#39;, { tokenPrefix: token.substring(0, 8) });
        return {
          sub: &amp;#39;oauth-user&amp;#39;,
          aud: &amp;#39;arbiter-api&amp;#39;,
          iss: &amp;#39;arbiter-oauth-server&amp;#39;,
          exp: Math.floor(Date.now() / 1000) + 3600
        };
      }
    };
  }

  /**
   * Create authorization server instance (stub implementation)
   */
  private createAuthorizationServerInstance(): AuthorizationServer {
    return {
      async issueToken(clientId: string, scope: string): Promise&amp;lt;OAuthToken&amp;gt; {
        // Stub implementation for token issuance
        logger.debug(&amp;#39;OAuth token issuance (stub)&amp;#39;, { clientId, scope });
        
        const token &#x3D; &#x60;oauth_${Date.now()}_${Math.random().toString(36).substring(2)}&#x60;;
        return {
          access_token: token,
          token_type: &amp;#39;Bearer&amp;#39;,
          expires_in: 3600,
          scope,
          user_id: &#x60;user_${clientId}&#x60;
        };
      },

      async validateClient(clientId: string, clientSecret: string): Promise&amp;lt;boolean&amp;gt; {
        // Stub implementation for client validation
        logger.debug(&amp;#39;OAuth client validation (stub)&amp;#39;, { clientId });
        
        // For development, accept any client with &amp;#39;arbiter&amp;#39; in the ID
        return clientId.includes(&amp;#39;arbiter&amp;#39;) &amp;amp;&amp;amp; clientSecret.length &amp;gt; 8;
      },

      async revokeToken(token: string): Promise&amp;lt;boolean&amp;gt; {
        // Stub implementation for token revocation
        logger.debug(&amp;#39;OAuth token revocation (stub)&amp;#39;, { tokenPrefix: token.substring(0, 8) });
        return true;
      }
    };
  }

  /**
   * Create OAuth provider instance (stub implementation)
   */
  private createOAuthProviderInstance(): OAuthProvider {
    return {
      async authorize(params: any): Promise&amp;lt;string&amp;gt; {
        // Stub implementation for OAuth authorization
        logger.debug(&amp;#39;OAuth authorization (stub)&amp;#39;, { params });
        
        const code &#x3D; &#x60;auth_code_${Date.now()}_${Math.random().toString(36).substring(2)}&#x60;;
        return code;
      },

      async getTokenFromCode(code: string, clientId: string, clientSecret: string): Promise&amp;lt;OAuthToken&amp;gt; {
        // Stub implementation for authorization code exchange
        logger.debug(&amp;#39;OAuth code exchange (stub)&amp;#39;, { code, clientId });
        
        const token &#x3D; &#x60;oauth_${Date.now()}_${Math.random().toString(36).substring(2)}&#x60;;
        return {
          access_token: token,
          token_type: &amp;#39;Bearer&amp;#39;,
          expires_in: 3600,
          scope: &amp;#39;read write&amp;#39;,
          user_id: &#x60;user_${clientId}&#x60;
        };
      },

      async refreshToken(refreshToken: string): Promise&amp;lt;OAuthToken&amp;gt; {
        // Stub implementation for token refresh
        logger.debug(&amp;#39;OAuth token refresh (stub)&amp;#39;, { refreshTokenPrefix: refreshToken.substring(0, 8) });
        
        const token &#x3D; &#x60;oauth_${Date.now()}_${Math.random().toString(36).substring(2)}&#x60;;
        return {
          access_token: token,
          token_type: &amp;#39;Bearer&amp;#39;,
          expires_in: 3600,
          scope: &amp;#39;read write&amp;#39;,
          user_id: &amp;#39;refreshed-user&amp;#39;
        };
      }
    };
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-7">
                <div class="file-header">📄 src/handlers/discovery.ts</div>
                <div class="file-content">
                    <pre>/**
 * Handler discovery and loading system
 * Dynamically discovers and loads custom webhook handlers
 */

import { access, readdir, stat } from &amp;quot;node:fs/promises&amp;quot;;
import { basename, extname, join, relative } from &amp;quot;node:path&amp;quot;;
import { logger as defaultLogger } from &amp;quot;../utils.js&amp;quot;;
import { HandlerLoader } from &amp;quot;./loader.js&amp;quot;;
import type { HandlerDiscoveryConfig, HandlerModule, Logger, RegisteredHandler } from &amp;quot;./types.js&amp;quot;;

export class HandlerDiscovery {
  private handlers &#x3D; new Map&amp;lt;string, RegisteredHandler&amp;gt;();
  private watchers &#x3D; new Map&amp;lt;string, AbortController&amp;gt;();
  private loader: HandlerLoader;

  constructor(
    private config: HandlerDiscoveryConfig,
    private logger: Logger &#x3D; defaultLogger,
  ) {
    this.loader &#x3D; new HandlerLoader(this.logger);
  }

  /**
   * Discover all handlers in the configured directory
   */
  async discoverHandlers(): Promise&amp;lt;RegisteredHandler[]&amp;gt; {
    const handlersDir &#x3D; this.config.handlersDirectory;

    try {
      await access(handlersDir);
    } catch {
      this.logger.warn(&amp;quot;Handlers directory not found&amp;quot;, { path: handlersDir });
      return [];
    }

    this.logger.info(&amp;quot;Starting handler discovery&amp;quot;, { directory: handlersDir });

    const handlers: RegisteredHandler[] &#x3D; [];
    const discoveredHandlers &#x3D; new Map&amp;lt;string, RegisteredHandler&amp;gt;();

    // Discover GitHub handlers
    const githubHandlers &#x3D; await this.discoverProviderHandlers(
      join(handlersDir, &amp;quot;github&amp;quot;),
      &amp;quot;github&amp;quot;,
    );
    handlers.push(...githubHandlers);

    // Discover GitLab handlers
    const gitlabHandlers &#x3D; await this.discoverProviderHandlers(
      join(handlersDir, &amp;quot;gitlab&amp;quot;),
      &amp;quot;gitlab&amp;quot;,
    );
    handlers.push(...gitlabHandlers);

    // Cache discovered handlers
    for (const handler of handlers) {
      discoveredHandlers.set(handler.id, handler);
    }

    this.handlers &#x3D; discoveredHandlers;

    // Set up file watchers if enabled
    if (this.config.enableAutoReload) {
      await this.setupFileWatchers(handlersDir);
    }

    this.logger.info(&amp;quot;Handler discovery completed&amp;quot;, {
      totalHandlers: handlers.length,
      githubHandlers: githubHandlers.length,
      gitlabHandlers: gitlabHandlers.length,
    });

    return handlers;
  }

  /**
   * Discover handlers for a specific provider
   */
  private async discoverProviderHandlers(
    providerDir: string,
    provider: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;,
  ): Promise&amp;lt;RegisteredHandler[]&amp;gt; {
    try {
      await access(providerDir);
    } catch {
      this.logger.debug(&amp;quot;Provider directory not found&amp;quot;, { provider, path: providerDir });
      return [];
    }

    const handlers: RegisteredHandler[] &#x3D; [];
    const entries &#x3D; await readdir(providerDir, { withFileTypes: true });

    for (const entry of entries) {
      if (!entry.isFile()) continue;

      const ext &#x3D; extname(entry.name);
      if (![&amp;quot;.ts&amp;quot;, &amp;quot;.js&amp;quot;, &amp;quot;.mts&amp;quot;, &amp;quot;.mjs&amp;quot;].includes(ext)) continue;

      const handlerPath &#x3D; join(providerDir, entry.name);
      const eventName &#x3D; basename(entry.name, ext);

      try {
        const handlerId &#x3D; this.createHandlerId(provider, eventName, handlerPath);
        const handler &#x3D; await this.loadHandler(handlerPath, provider, eventName, handlerId);
        if (handler) {
          handlers.push(handler);
        }
      } catch (error) {
        this.logger.error(&amp;quot;Failed to load handler&amp;quot;, error as Error, {
          path: handlerPath,
          provider,
          event: eventName,
        });
      }
    }

    return handlers;
  }

  /**
   * Load a single handler file
   */
  private async loadHandler(
    handlerPath: string,
    provider: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;,
    eventName: string,
    handlerId?: string,
  ): Promise&amp;lt;RegisteredHandler | null&amp;gt; {
    try {
      this.logger.debug(&amp;quot;Loading handler&amp;quot;, { path: handlerPath, provider, event: eventName });

      // Security check: validate file path is within handlers directory
      if (!handlerPath.startsWith(this.config.handlersDirectory)) {
        throw new Error(&amp;quot;Handler path outside allowed directory&amp;quot;);
      }

      const handlerModule &#x3D; await this.loader.load({
        id: handlerId ?? this.createHandlerId(provider, eventName, handlerPath),
        provider,
        event: eventName,
        handlerPath,
        enabled: true,
        config: {
          enabled: true,
          timeout: this.config.defaultTimeout,
          retries: this.config.defaultRetries,
          environment: {},
          secrets: {},
        },
        executionCount: 0,
        errorCount: 0,
      } as RegisteredHandler);

      // Validate handler metadata
      this.validateHandlerModule(handlerModule, eventName);

      const registeredHandler: RegisteredHandler &#x3D; {
        id: handlerId ?? this.createHandlerId(provider, eventName, handlerPath),
        provider,
        event: eventName,
        handlerPath,
        enabled: handlerModule.config?.enabled ?? true,
        config: {
          enabled: true,
          timeout: this.config.defaultTimeout,
          retries: this.config.defaultRetries,
          environment: {},
          secrets: {},
          ...handlerModule.config,
        },
        executionCount: 0,
        errorCount: 0,
        metadata: handlerModule.metadata || {
          name: &#x60;${provider} ${eventName} handler&#x60;,
          description: &#x60;Handler for ${provider} ${eventName} events&#x60;,
          version: &amp;quot;1.0.0&amp;quot;,
          supportedEvents: [eventName],
          requiredPermissions: [],
        },
      };

      this.logger.info(&amp;quot;Handler loaded successfully&amp;quot;, {
        id: registeredHandler.id,
        provider,
        event: eventName,
        name: registeredHandler.metadata?.name,
      });

      return registeredHandler;
    } catch (error) {
      this.logger.error(&amp;quot;Handler loading failed&amp;quot;, error as Error, {
        path: handlerPath,
        provider,
        event: eventName,
      });
      return null;
    }
  }

  private createHandlerId(
    provider: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;,
    eventName: string,
    handlerPath: string,
  ): string {
    const relativePath &#x3D; relative(this.config.handlersDirectory, handlerPath);
    return &#x60;${provider}:${eventName}:${relativePath}&#x60;;
  }

  /**
   * Validate handler module structure
   */
  private validateHandlerModule(module: HandlerModule, eventName: string): void {
    if (!module.handler) {
      throw new Error(&amp;quot;Handler module must export a handler function&amp;quot;);
    }

    if (typeof module.handler !&#x3D;&#x3D; &amp;quot;function&amp;quot;) {
      throw new Error(&amp;quot;Handler must be a function&amp;quot;);
    }

    // Validate supported events if specified
    if (module.metadata?.supportedEvents) {
      const supportedEvents &#x3D; module.metadata.supportedEvents;
      if (!supportedEvents.includes(eventName)) {
        this.logger.warn(&amp;quot;Handler event name not in supported events list&amp;quot;, {
          eventName,
          supportedEvents,
        });
      }
    }

    // Validate required permissions format
    if (module.metadata?.requiredPermissions) {
      for (const permission of module.metadata.requiredPermissions) {
        if (typeof permission !&#x3D;&#x3D; &amp;quot;string&amp;quot; || !permission.includes(&amp;quot;:&amp;quot;)) {
          this.logger.warn(&amp;quot;Invalid permission format&amp;quot;, { permission });
        }
      }
    }
  }

  async registerHandlerFromFile(
    handlerPath: string,
    provider: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;,
    eventName: string,
  ): Promise&amp;lt;RegisteredHandler&amp;gt; {
    const handlerId &#x3D; this.createHandlerId(provider, eventName, handlerPath);
    const handler &#x3D; await this.loadHandler(handlerPath, provider, eventName, handlerId);

    if (!handler) {
      throw new Error(&amp;quot;Failed to load handler after creation&amp;quot;);
    }

    this.handlers.set(handler.id, handler);
    return handler;
  }

  /**
   * Set up file watchers for auto-reload
   */
  private async setupFileWatchers(handlersDir: string): Promise&amp;lt;void&amp;gt; {
    try {
      // Note: In a real implementation, you&amp;#39;d use fs.watch or a library like chokidar
      this.logger.info(&amp;quot;File watching not implemented in this example&amp;quot;);

      // Example implementation outline:
      // const watcher &#x3D; fs.watch(handlersDir, { recursive: true });
      // watcher.on(&amp;#39;change&amp;#39;, (eventType, filename) &#x3D;&amp;gt; {
      //   if (filename &amp;amp;&amp;amp; this.isHandlerFile(filename)) {
      //     this.reloadHandler(filename);
      //   }
      // });
    } catch (error) {
      this.logger.error(&amp;quot;Failed to setup file watchers&amp;quot;, error as Error);
    }
  }

  /**
   * Get all registered handlers
   */
  getHandlers(): RegisteredHandler[] {
    return Array.from(this.handlers.values());
  }

  /**
   * Get handlers for a specific provider and event
   */
  getHandlersForEvent(provider: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;, event: string): RegisteredHandler[] {
    return this.getHandlers().filter(
      (h) &#x3D;&amp;gt; h.provider &#x3D;&#x3D;&#x3D; provider &amp;amp;&amp;amp; h.event &#x3D;&#x3D;&#x3D; event &amp;amp;&amp;amp; h.enabled,
    );
  }

  /**
   * Get a specific handler by ID
   */
  getHandler(id: string): RegisteredHandler | undefined {
    return this.handlers.get(id);
  }

  /**
   * Update handler configuration
   */
  updateHandlerConfig(id: string, updates: Partial&amp;lt;RegisteredHandler&amp;gt;): boolean {
    const handler &#x3D; this.handlers.get(id);
    if (!handler) return false;

    // Merge updates
    Object.assign(handler, updates);
    this.handlers.set(id, handler);

    this.logger.info(&amp;quot;Handler configuration updated&amp;quot;, { id, updates: Object.keys(updates) });
    return true;
  }

  /**
   * Enable or disable a handler
   */
  setHandlerEnabled(id: string, enabled: boolean): boolean {
    const handler &#x3D; this.handlers.get(id);
    if (!handler) return false;

    handler.enabled &#x3D; enabled;
    handler.config.enabled &#x3D; enabled;
    this.handlers.set(id, handler);

    this.logger.info(&amp;quot;Handler state changed&amp;quot;, { id, enabled });
    return true;
  }

  /**
   * Remove a handler from registry
   */
  removeHandler(id: string): boolean {
    const removed &#x3D; this.handlers.delete(id);
    if (removed) {
      this.logger.info(&amp;quot;Handler removed&amp;quot;, { id });
    }
    return removed;
  }

  /**
   * Reload handler from file
   */
  async reloadHandler(id: string): Promise&amp;lt;boolean&amp;gt; {
    const existingHandler &#x3D; this.handlers.get(id);
    if (!existingHandler) return false;

    try {
      // Reload handler
      const reloadedHandler &#x3D; await this.loadHandler(
        existingHandler.handlerPath,
        existingHandler.provider,
        existingHandler.event,
        existingHandler.id,
      );

      if (reloadedHandler) {
        // Preserve runtime state
        reloadedHandler.id &#x3D; existingHandler.id;
        reloadedHandler.executionCount &#x3D; existingHandler.executionCount;
        reloadedHandler.errorCount &#x3D; existingHandler.errorCount;
        reloadedHandler.lastExecuted &#x3D; existingHandler.lastExecuted;

        this.handlers.set(id, reloadedHandler);
        this.logger.info(&amp;quot;Handler reloaded&amp;quot;, { id });
        return true;
      }
    } catch (error) {
      this.logger.error(&amp;quot;Handler reload failed&amp;quot;, error as Error, { id });
    }

    return false;
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    // Stop all file watchers
    for (const [path, controller] of this.watchers) {
      controller.abort();
      this.logger.debug(&amp;quot;Stopped file watcher&amp;quot;, { path });
    }
    this.watchers.clear();

    // Clear handler cache
    this.handlers.clear();

    this.logger.info(&amp;quot;Handler discovery disposed&amp;quot;);
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-8">
                <div class="file-header">📄 src/handlers/services.ts</div>
                <div class="file-content">
                    <pre>/**
 * Handler Services - Provide secure, sandboxed services for custom handlers
 */

import { mkdir } from &amp;quot;node:fs/promises&amp;quot;;
import path from &amp;quot;node:path&amp;quot;;
import nodemailer from &amp;quot;nodemailer&amp;quot;;
import type { Transporter } from &amp;quot;nodemailer&amp;quot;;
import { logger as defaultLogger } from &amp;quot;../utils.js&amp;quot;;
import { HandlerSandbox } from &amp;quot;./sandbox.js&amp;quot;;
import type {
  FileDiff,
  GitService,
  HttpClient,
  HttpResponse,
  Logger,
  NotificationService,
  RequestOptions,
  SlackMessage,
} from &amp;quot;./types.js&amp;quot;;

type EmailMode &#x3D; &amp;quot;disabled&amp;quot; | &amp;quot;log&amp;quot; | &amp;quot;smtp&amp;quot;;

export interface HandlerEmailConfig {
  mode?: EmailMode;
  from?: string;
  smtp?: {
    host?: string;
    port?: number;
    secure?: boolean;
    user?: string;
    pass?: string;
  };
}

/**
 * HTTP Client for handlers with built-in security and rate limiting
 */
export class HandlerHttpClient implements HttpClient {
  private requestCounts &#x3D; new Map&amp;lt;string, { count: number; resetTime: number }&amp;gt;();
  private readonly maxRequestsPerMinute &#x3D; 60;
  private readonly allowedDomains &#x3D; new Set([
    &amp;quot;api.github.com&amp;quot;,
    &amp;quot;gitlab.com&amp;quot;,
    &amp;quot;hooks.slack.com&amp;quot;,
    &amp;quot;api.slack.com&amp;quot;,
    &amp;quot;discord.com&amp;quot;,
    &amp;quot;api.trello.com&amp;quot;,
    &amp;quot;api.atlassian.com&amp;quot;,
  ]);

  constructor(private logger: Logger) {}

  async get(url: string, options: RequestOptions &#x3D; {}): Promise&amp;lt;HttpResponse&amp;gt; {
    return this.makeRequest(&amp;quot;GET&amp;quot;, url, undefined, options);
  }

  async post(url: string, data?: unknown, options: RequestOptions &#x3D; {}): Promise&amp;lt;HttpResponse&amp;gt; {
    return this.makeRequest(&amp;quot;POST&amp;quot;, url, data, options);
  }

  async put(url: string, data?: unknown, options: RequestOptions &#x3D; {}): Promise&amp;lt;HttpResponse&amp;gt; {
    return this.makeRequest(&amp;quot;PUT&amp;quot;, url, data, options);
  }

  async delete(url: string, options: RequestOptions &#x3D; {}): Promise&amp;lt;HttpResponse&amp;gt; {
    return this.makeRequest(&amp;quot;DELETE&amp;quot;, url, undefined, options);
  }

  private async makeRequest(
    method: string,
    url: string,
    data?: unknown,
    options: RequestOptions &#x3D; {},
  ): Promise&amp;lt;HttpResponse&amp;gt; {
    // Validate URL
    this.validateUrl(url);

    // Rate limiting
    this.checkRateLimit();

    const { timeout &#x3D; 10000, retries &#x3D; 0 } &#x3D; options;
    let lastError: Error | undefined;

    for (let attempt &#x3D; 0; attempt &amp;lt;&#x3D; retries; attempt++) {
      try {
        const controller &#x3D; new AbortController();
        const timeoutId &#x3D; setTimeout(() &#x3D;&amp;gt; controller.abort(), timeout);

        const requestOptions: RequestInit &#x3D; {
          method,
          headers: {
            &amp;quot;Content-Type&amp;quot;: &amp;quot;application/json&amp;quot;,
            &amp;quot;User-Agent&amp;quot;: &amp;quot;Arbiter-Webhook-Handler/1.0&amp;quot;,
            ...options.headers,
          },
          signal: controller.signal,
        };

        if (data &amp;amp;&amp;amp; (method &#x3D;&#x3D;&#x3D; &amp;quot;POST&amp;quot; || method &#x3D;&#x3D;&#x3D; &amp;quot;PUT&amp;quot;)) {
          requestOptions.body &#x3D; JSON.stringify(data);
        }

        this.logger.debug(&amp;quot;Making HTTP request&amp;quot;, { method, url, attempt });

        const response &#x3D; await fetch(url, requestOptions);
        clearTimeout(timeoutId);

        let responseData: unknown;
        const contentType &#x3D; response.headers.get(&amp;quot;content-type&amp;quot;) || &amp;quot;&amp;quot;;

        if (contentType.includes(&amp;quot;application/json&amp;quot;)) {
          responseData &#x3D; await response.json();
        } else {
          responseData &#x3D; await response.text();
        }

        const result: HttpResponse &#x3D; {
          status: response.status,
          statusText: response.statusText,
          data: responseData,
          headers: Object.fromEntries(response.headers.entries()),
        };

        // Log result
        this.logger.info(&amp;quot;HTTP request completed&amp;quot;, {
          method,
          url: this.sanitizeUrl(url),
          status: response.status,
          attempt,
        });

        return result;
      } catch (error) {
        lastError &#x3D; error as Error;

        if (attempt &#x3D;&#x3D;&#x3D; retries) {
          this.logger.error(&amp;quot;HTTP request failed&amp;quot;, lastError, {
            method,
            url: this.sanitizeUrl(url),
            attempt,
          });
          throw lastError;
        }

        // Exponential backoff for retries
        const delay &#x3D; Math.min(1000 * 2 ** attempt, 5000);
        await new Promise((resolve) &#x3D;&amp;gt; setTimeout(resolve, delay));
      }
    }

    throw lastError || new Error(&amp;quot;HTTP request failed&amp;quot;);
  }

  private validateUrl(url: string): void {
    try {
      const parsedUrl &#x3D; new URL(url);

      // Only allow HTTPS (except localhost for development)
      if (parsedUrl.protocol !&#x3D;&#x3D; &amp;quot;https:&amp;quot; &amp;amp;&amp;amp; !parsedUrl.hostname.includes(&amp;quot;localhost&amp;quot;)) {
        throw new Error(&amp;quot;Only HTTPS URLs are allowed&amp;quot;);
      }

      // Check allowed domains
      if (
        !this.allowedDomains.has(parsedUrl.hostname) &amp;amp;&amp;amp;
        !parsedUrl.hostname.includes(&amp;quot;localhost&amp;quot;)
      ) {
        throw new Error(&#x60;Domain not allowed: ${parsedUrl.hostname}&#x60;);
      }

      // Prevent SSRF attacks
      if (parsedUrl.hostname.includes(&amp;quot;metadata&amp;quot;) || parsedUrl.hostname.includes(&amp;quot;169.254&amp;quot;)) {
        throw new Error(&amp;quot;Blocked URL pattern detected&amp;quot;);
      }
    } catch (error) {
      throw new Error(&#x60;Invalid URL: ${error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;}&#x60;);
    }
  }

  private checkRateLimit(): void {
    const now &#x3D; Date.now();
    const minute &#x3D; Math.floor(now / 60000);

    const current &#x3D; this.requestCounts.get(String(minute)) || { count: 0, resetTime: minute };

    if (current.count &amp;gt;&#x3D; this.maxRequestsPerMinute) {
      throw new Error(&amp;quot;Rate limit exceeded: too many HTTP requests&amp;quot;);
    }

    current.count++;
    this.requestCounts.set(String(minute), current);

    // Clean up old entries
    for (const [key, value] of this.requestCounts) {
      if (value.resetTime &amp;lt; minute - 5) {
        // Keep last 5 minutes
        this.requestCounts.delete(key);
      }
    }
  }

  private sanitizeUrl(url: string): string {
    try {
      const parsedUrl &#x3D; new URL(url);
      return &#x60;${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}&#x60;;
    } catch {
      return &amp;quot;[invalid-url]&amp;quot;;
    }
  }
}

/**
 * Notification service for handlers
 */
export class HandlerNotificationService implements NotificationService {
  private emailMode: EmailMode;
  private emailFrom?: string;
  private transporter?: Transporter;

  constructor(
    private logger: Logger,
    private emailConfig: HandlerEmailConfig &#x3D; {},
  ) {
    this.emailMode &#x3D; this.resolveEmailMode(emailConfig.mode);
    this.emailFrom &#x3D; emailConfig.from ?? process.env.HANDLER_EMAIL_FROM;

    if (this.emailMode &#x3D;&#x3D;&#x3D; &amp;quot;smtp&amp;quot;) {
      this.configureSmtpTransport(emailConfig.smtp);
    }
  }

  async sendSlack(webhookUrl: string, message: SlackMessage): Promise&amp;lt;void&amp;gt; {
    if (!webhookUrl.includes(&amp;quot;hooks.slack.com&amp;quot;)) {
      throw new Error(&amp;quot;Invalid Slack webhook URL&amp;quot;);
    }

    const payload &#x3D; {
      text: message.text,
      blocks: message.blocks,
      channel: message.channel,
      username: message.username || &amp;quot;Arbiter Webhook&amp;quot;,
      icon_emoji: message.iconEmoji || &amp;quot;:robot_face:&amp;quot;,
    };

    try {
      const response &#x3D; await fetch(webhookUrl, {
        method: &amp;quot;POST&amp;quot;,
        headers: {
          &amp;quot;Content-Type&amp;quot;: &amp;quot;application/json&amp;quot;,
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(&#x60;Slack webhook failed: ${response.status} ${response.statusText}&#x60;);
      }

      this.logger.info(&amp;quot;Slack notification sent successfully&amp;quot;);
    } catch (error) {
      this.logger.error(&amp;quot;Failed to send Slack notification&amp;quot;, error as Error);
      throw error;
    }
  }

  async sendEmail(to: string, subject: string, body: string): Promise&amp;lt;void&amp;gt; {
    const sanitizedTo &#x3D; this.sanitizeEmail(to);

    if (this.emailMode &#x3D;&#x3D;&#x3D; &amp;quot;disabled&amp;quot;) {
      const message &#x3D;
        &amp;quot;Email notifications are disabled. Set HANDLER_EMAIL_MODE&#x3D;log or smtp to enable.&amp;quot;;
      this.logger.warn(message, { to: sanitizedTo });
      throw new Error(message);
    }

    if (this.emailMode &#x3D;&#x3D;&#x3D; &amp;quot;log&amp;quot;) {
      this.logger.info(&amp;quot;Email notification logged (log mode)&amp;quot;, {
        to: sanitizedTo,
        subject,
      });
      return;
    }

    if (!this.transporter || !this.emailFrom) {
      const message &#x3D; &amp;quot;Email transporter not configured. Check SMTP credentials and from address.&amp;quot;;
      this.logger.error(message, undefined, { to: sanitizedTo });
      throw new Error(message);
    }

    try {
      await this.transporter.sendMail({
        from: this.emailFrom,
        to,
        subject,
        text: body,
        html: this.renderEmailHtml(subject, body),
      });

      this.logger.info(&amp;quot;Email notification sent successfully&amp;quot;, { to: sanitizedTo, subject });
    } catch (error) {
      this.logger.error(&amp;quot;Failed to send email notification&amp;quot;, error as Error, {
        to: sanitizedTo,
      });
      throw error;
    }
  }

  async sendWebhook(url: string, payload: unknown): Promise&amp;lt;void&amp;gt; {
    try {
      const response &#x3D; await fetch(url, {
        method: &amp;quot;POST&amp;quot;,
        headers: {
          &amp;quot;Content-Type&amp;quot;: &amp;quot;application/json&amp;quot;,
          &amp;quot;User-Agent&amp;quot;: &amp;quot;Arbiter-Webhook-Handler/1.0&amp;quot;,
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(&#x60;Webhook failed: ${response.status} ${response.statusText}&#x60;);
      }

      this.logger.info(&amp;quot;Webhook notification sent successfully&amp;quot;, {
        url: this.sanitizeUrl(url),
      });
    } catch (error) {
      this.logger.error(&amp;quot;Failed to send webhook notification&amp;quot;, error as Error, {
        url: this.sanitizeUrl(url),
      });
      throw error;
    }
  }

  private resolveEmailMode(override?: EmailMode): EmailMode {
    if (override) return override;

    const fromEnv &#x3D; (process.env.HANDLER_EMAIL_MODE || &amp;quot;&amp;quot;).toLowerCase();
    if (fromEnv &#x3D;&#x3D;&#x3D; &amp;quot;smtp&amp;quot; || fromEnv &#x3D;&#x3D;&#x3D; &amp;quot;log&amp;quot;) {
      return fromEnv;
    }
    return &amp;quot;disabled&amp;quot;;
  }

  private configureSmtpTransport(smtpConfig?: HandlerEmailConfig[&amp;quot;smtp&amp;quot;]): void {
    const host &#x3D; smtpConfig?.host ?? process.env.HANDLER_EMAIL_SMTP_HOST;
    const port &#x3D; smtpConfig?.port ?? Number(process.env.HANDLER_EMAIL_SMTP_PORT || 587);
    const secure &#x3D; smtpConfig?.secure ?? process.env.HANDLER_EMAIL_SMTP_SECURE &#x3D;&#x3D;&#x3D; &amp;quot;true&amp;quot;;
    const user &#x3D; smtpConfig?.user ?? process.env.HANDLER_EMAIL_SMTP_USER;
    const pass &#x3D; smtpConfig?.pass ?? process.env.HANDLER_EMAIL_SMTP_PASS;

    if (!host || !user || !pass) {
      this.logger.error(&amp;quot;SMTP email mode enabled but configuration is incomplete&amp;quot;, undefined, {
        missing: {
          host: !host,
          user: !user,
          pass: !pass,
        },
      });
      this.emailMode &#x3D; &amp;quot;disabled&amp;quot;;
      return;
    }

    if (!this.emailFrom) {
      this.logger.warn(&amp;quot;SMTP email mode enabled but HANDLER_EMAIL_FROM is not set. Using user.&amp;quot;);
      this.emailFrom &#x3D; user;
    }

    this.transporter &#x3D; nodemailer.createTransport({
      host,
      port,
      secure: secure ?? port &#x3D;&#x3D;&#x3D; 465,
      auth: {
        user,
        pass,
      },
    });
  }

  private renderEmailHtml(subject: string, body: string): string {
    const safeSubject &#x3D; this.escapeHtml(subject);
    const safeBody &#x3D; this.escapeHtml(body);
    return &#x60;&amp;lt;!doctype html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta charset&#x3D;&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;title&amp;gt;${safeSubject}&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;pre style&#x3D;&amp;quot;font-family: monospace; white-space: pre-wrap;&amp;quot;&amp;gt;${safeBody}&amp;lt;/pre&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#x60;;
  }

  private sanitizeEmail(email: string): string {
    const parts &#x3D; email.split(&amp;quot;@&amp;quot;);
    if (parts.length !&#x3D;&#x3D; 2) return &amp;quot;[invalid-email]&amp;quot;;
    return &#x60;${parts[0].substring(0, 2)}***@${parts[1]}&#x60;;
  }

  private sanitizeUrl(url: string): string {
    try {
      const parsedUrl &#x3D; new URL(url);
      return &#x60;${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}&#x60;;
    } catch {
      return &amp;quot;[invalid-url]&amp;quot;;
    }
  }

  private escapeHtml(value: string): string {
    return value.replace(/&amp;amp;/g, &amp;quot;&amp;amp;amp;&amp;quot;).replace(/&amp;lt;/g, &amp;quot;&amp;amp;lt;&amp;quot;).replace(/&amp;gt;/g, &amp;quot;&amp;amp;gt;&amp;quot;);
  }
}

/**
 * Git service for handlers (limited read-only operations)
 */
export class HandlerGitService implements GitService {
  private readonly baseDir: string;

  constructor(private logger: Logger) {
    this.baseDir &#x3D; process.env.HANDLER_GIT_ROOT ?? &amp;quot;/tmp/arbiter-handler-git&amp;quot;;
  }

  async cloneRepository(url: string, target: string): Promise&amp;lt;void&amp;gt; {
    const validatedUrl &#x3D; this.validateRepoUrl(url);
    const targetPath &#x3D; await this.resolveTargetPath(target);

    await this.runGit([&amp;quot;clone&amp;quot;, &amp;quot;--depth&amp;quot;, &amp;quot;1&amp;quot;, validatedUrl, targetPath], process.cwd());
    this.logger.info(&amp;quot;Repository cloned for handler&amp;quot;, {
      url: this.sanitizeUrl(validatedUrl),
      target: targetPath,
    });
  }

  async getCommitDiff(sha: string): Promise&amp;lt;FileDiff[]&amp;gt; {
    const repoPath &#x3D; this.resolveRepoPath();
    const output &#x3D; await this.runGitOutput(
      [&amp;quot;diff&amp;quot;, &#x60;${sha}^&#x60;, sha, &amp;quot;--name-status&amp;quot;, &amp;quot;--stat&amp;quot;],
      repoPath,
    );

    return this.parseDiff(output.stdout);
  }

  async getFileContent(path: string, ref &#x3D; &amp;quot;HEAD&amp;quot;): Promise&amp;lt;string&amp;gt; {
    const repoPath &#x3D; this.resolveRepoPath();
    const result &#x3D; await this.runGitOutput([&amp;quot;show&amp;quot;, &#x60;${ref}:${path}&#x60;], repoPath);
    return result.stdout;
  }

  async createBranch(name: string, from &#x3D; &amp;quot;HEAD&amp;quot;): Promise&amp;lt;void&amp;gt; {
    const repoPath &#x3D; this.resolveRepoPath();
    await this.runGit([&amp;quot;branch&amp;quot;, name, from], repoPath);
    this.logger.info(&amp;quot;Created branch for handler&amp;quot;, { name, from });
  }

  async createPullRequest(): Promise&amp;lt;unknown&amp;gt; {
    throw new Error(&amp;quot;Pull request creation requires provider integration&amp;quot;);
  }

  private resolveRepoPath(): string {
    return process.env.HANDLER_GIT_REPO_PATH ?? process.cwd();
  }

  private async resolveTargetPath(target: string): Promise&amp;lt;string&amp;gt; {
    const absolute &#x3D; path.isAbsolute(target) ? target : path.join(this.baseDir, target);
    if (!absolute.startsWith(this.baseDir)) {
      throw new Error(&amp;quot;Target path outside allowed git directory&amp;quot;);
    }
    await mkdir(path.dirname(absolute), { recursive: true });
    return absolute;
  }

  private validateRepoUrl(url: string): string {
    try {
      const parsed &#x3D; new URL(url);
      if (![&amp;quot;https:&amp;quot;, &amp;quot;git:&amp;quot;].includes(parsed.protocol)) {
        throw new Error(&amp;quot;Only HTTPS/GIT URLs are allowed&amp;quot;);
      }
      return parsed.toString();
    } catch (error) {
      throw new Error(
        &#x60;Invalid repository URL: ${error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;}&#x60;,
      );
    }
  }

  private async runGit(args: string[], cwd: string): Promise&amp;lt;void&amp;gt; {
    const result &#x3D; Bun.spawnSync([&amp;quot;git&amp;quot;, ...args], { cwd, stderr: &amp;quot;pipe&amp;quot;, stdout: &amp;quot;pipe&amp;quot; });
    if (result.exitCode !&#x3D;&#x3D; 0) {
      const error &#x3D; new TextDecoder().decode(result.stderr);
      throw new Error(error || &#x60;git ${args.join(&amp;quot; &amp;quot;)} failed&#x60;);
    }
  }

  private async runGitOutput(
    args: string[],
    cwd: string,
  ): Promise&amp;lt;{ stdout: string; stderr: string }&amp;gt; {
    const result &#x3D; Bun.spawnSync([&amp;quot;git&amp;quot;, ...args], { cwd, stderr: &amp;quot;pipe&amp;quot;, stdout: &amp;quot;pipe&amp;quot; });
    const stdout &#x3D; new TextDecoder().decode(result.stdout).trim();
    const stderr &#x3D; new TextDecoder().decode(result.stderr).trim();
    if (result.exitCode !&#x3D;&#x3D; 0) {
      throw new Error(stderr || &#x60;git ${args.join(&amp;quot; &amp;quot;)} failed&#x60;);
    }
    return { stdout, stderr };
  }

  private parseDiff(output: string): FileDiff[] {
    const diffs: FileDiff[] &#x3D; [];
    const lines &#x3D; output.split(&amp;quot;\n&amp;quot;);

    for (const line of lines) {
      if (!line || !/^[AMDCRTU]/.test(line)) continue;
      const [status, filePath] &#x3D; line.split(/\s+/);
      diffs.push({
        path: filePath,
        status: this.mapStatus(status),
        additions: 0,
        deletions: 0,
      });
    }

    return diffs;
  }

  private mapStatus(status: string): FileDiff[&amp;quot;status&amp;quot;] {
    switch (status[0]) {
      case &amp;quot;A&amp;quot;:
        return &amp;quot;added&amp;quot;;
      case &amp;quot;D&amp;quot;:
        return &amp;quot;deleted&amp;quot;;
      case &amp;quot;R&amp;quot;:
        return &amp;quot;renamed&amp;quot;;
      default:
        return &amp;quot;modified&amp;quot;;
    }
  }

  private sanitizeUrl(url: string): string {
    try {
      const parsedUrl &#x3D; new URL(url);
      return &#x60;${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}&#x60;;
    } catch {
      return &amp;quot;[invalid-url]&amp;quot;;
    }
  }
}

/**
 * Security validator for handler services
 */
export class HandlerSecurityValidator {
  static validateHandlerCode(
    code: string,
    logger: Logger &#x3D; defaultLogger,
  ): {
    safe: boolean;
    violations: string[];
  } {
    const sandbox &#x3D; new HandlerSandbox(logger);
    return sandbox.validate(code);
  }

  static sanitizeEnvironment(env: Record&amp;lt;string, string&amp;gt;): Record&amp;lt;string, string&amp;gt; {
    const sanitized: Record&amp;lt;string, string&amp;gt; &#x3D; {};
    const allowedKeys &#x3D; [&amp;quot;NODE_ENV&amp;quot;, &amp;quot;LOG_LEVEL&amp;quot;];

    for (const [key, value] of Object.entries(env)) {
      if (allowedKeys.includes(key) || key.startsWith(&amp;quot;HANDLER_&amp;quot;)) {
        sanitized[key] &#x3D; value;
      }
    }

    return sanitized;
  }

  static validateSecrets(secrets: Record&amp;lt;string, string&amp;gt;): { valid: boolean; errors: string[] } {
    const errors: string[] &#x3D; [];

    for (const [key, value] of Object.entries(secrets)) {
      if (!key.startsWith(&amp;quot;HANDLER_&amp;quot;)) {
        errors.push(&#x60;Secret key must start with &amp;#39;HANDLER_&amp;#39;: ${key}&#x60;);
      }

      if (value.length &amp;lt; 10) {
        errors.push(&#x60;Secret value too short: ${key}&#x60;);
      }
    }

    return {
      valid: errors.length &#x3D;&#x3D;&#x3D; 0,
      errors,
    };
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-9">
                <div class="file-header">📄 src/nats.ts</div>
                <div class="file-content">
                    <pre>/**
 * NATS integration service for external agent communication
 * Publishes spec events to NATS topics for external AI agents to consume
 */
import { type ConnectionOptions, type NatsConnection, connect } from &amp;#39;nats&amp;#39;;
import type { Event, NatsConfig, NatsSpecEvent } from &amp;#39;./types.ts&amp;#39;;
import { getCurrentTimestamp, logger } from &amp;#39;./utils.ts&amp;#39;;

export class NatsService {
  private connection: NatsConnection | null &#x3D; null;
  private config: NatsConfig;
  private isConnected &#x3D; false;
  private reconnectAttempts &#x3D; 0;
  private eventSequence &#x3D; 0;
  private reconnectTimer?: Timer;

  constructor(config?: NatsConfig) {
    this.config &#x3D; {
      url: process.env.NATS_URL || &amp;#39;nats://localhost:4222&amp;#39;,
      enabled: !!process.env.NATS_URL || false,
      reconnectTimeWait: 2000, // Start with 2 seconds
      maxReconnectAttempts: 10,
      topicPrefix: &amp;#39;spec&amp;#39;,
      ...config,
    };

    if (this.config.enabled) {
      this.initialize();
    } else {
      logger.info(&amp;#39;NATS integration disabled - no NATS_URL configured&amp;#39;);
    }
  }

  /**
   * Initialize NATS connection
   */
  private async initialize(): Promise&amp;lt;void&amp;gt; {
    if (!this.config.enabled) {
      return;
    }

    try {
      const connectionOptions: ConnectionOptions &#x3D; {
        servers: [this.config.url!],
        reconnectTimeWait: this.config.reconnectTimeWait,
        maxReconnectAttempts: this.config.maxReconnectAttempts,
        pingInterval: 60000, // 60 seconds
        maxPingOut: 2,
      };

      logger.info(&amp;#39;Connecting to NATS server&amp;#39;, {
        url: this.config.url,
        options: connectionOptions,
      });

      this.connection &#x3D; await connect(connectionOptions);
      this.isConnected &#x3D; true;
      this.reconnectAttempts &#x3D; 0;

      logger.info(&amp;#39;Successfully connected to NATS server&amp;#39;, {
        server: this.connection.getServer(),
      });

      // Set up event listeners
      this.setupConnectionListeners();
    } catch (error) {
      this.isConnected &#x3D; false;

      logger.error(&amp;#39;Failed to connect to NATS server&amp;#39;, error instanceof Error ? error : undefined, {
        url: this.config.url,
        attempts: this.reconnectAttempts,
      });

      this.scheduleReconnect();
    }
  }

  /**
   * Setup connection event listeners
   */
  private setupConnectionListeners(): void {
    if (!this.connection) return;

    // Monitor connection state
    this.connection.closed().then(error &#x3D;&amp;gt; {
      this.isConnected &#x3D; false;

      if (error) {
        logger.error(
          &amp;#39;NATS connection closed with error&amp;#39;,
          error instanceof Error ? error : undefined
        );
        this.scheduleReconnect();
      } else {
        logger.info(&amp;#39;NATS connection closed normally&amp;#39;);
      }
    });
  }

  /**
   * Schedule a reconnection attempt with exponential backoff
   */
  private scheduleReconnect(): void {
    if (this.reconnectAttempts &amp;gt;&#x3D; this.config.maxReconnectAttempts) {
      logger.error(&amp;#39;Max NATS reconnect attempts reached, giving up&amp;#39;, undefined, {
        maxAttempts: this.config.maxReconnectAttempts,
      });
      return;
    }

    const delay &#x3D; Math.min(
      this.config.reconnectTimeWait * 2 ** this.reconnectAttempts,
      30000 // Max 30 seconds
    );

    this.reconnectAttempts++;

    logger.info(&amp;#39;Scheduling NATS reconnect&amp;#39;, {
      attempt: this.reconnectAttempts,
      delay,
      maxAttempts: this.config.maxReconnectAttempts,
    });

    this.reconnectTimer &#x3D; setTimeout(() &#x3D;&amp;gt; {
      this.initialize();
    }, delay);
  }

  /**
   * Publish event to NATS topic for external agents
   */
  async publishEvent(
    projectId: string,
    event: Omit&amp;lt;Event, &amp;#39;id&amp;#39; | &amp;#39;created_at&amp;#39;&amp;gt;,
    specHash?: string
  ): Promise&amp;lt;void&amp;gt; {
    // Always return early if NATS is disabled - no impact on core functionality
    if (!this.config.enabled || !this.connection || !this.isConnected) {
      return;
    }

    try {
      // Map event type to topic suffix
      const topicSuffix &#x3D; this.getTopicSuffix(event.event_type);
      const topic &#x3D; &#x60;${this.config.topicPrefix}.${projectId}.${topicSuffix}.updated&#x60;;

      const natsEvent: NatsSpecEvent &#x3D; {
        topic,
        projectId,
        event,
        metadata: {
          timestamp: getCurrentTimestamp(),
          specHash,
          sequence: ++this.eventSequence,
        },
      };

      // Publish to NATS (fire and forget for performance)
      this.connection.publish(topic, JSON.stringify(natsEvent));

      logger.debug(&amp;#39;Published event to NATS&amp;#39;, {
        topic,
        projectId,
        eventType: event.event_type,
        sequence: this.eventSequence,
      });
    } catch (error) {
      // Log error but don&amp;#39;t throw - NATS failures should never break core functionality
      logger.error(&amp;#39;Failed to publish event to NATS&amp;#39;, error instanceof Error ? error : undefined, {
        projectId,
        eventType: event.event_type,
      });
    }
  }

  /**
   * Map event types to NATS topic suffixes
   */
  private getTopicSuffix(eventType: string): string {
    switch (eventType) {
      case &amp;#39;fragment_created&amp;#39;:
      case &amp;#39;fragment_updated&amp;#39;:
      case &amp;#39;fragment_deleted&amp;#39;:
        return &amp;#39;fragment&amp;#39;;

      case &amp;#39;validation_started&amp;#39;:
      case &amp;#39;validation_completed&amp;#39;:
      case &amp;#39;validation_failed&amp;#39;:
        return &amp;#39;validation&amp;#39;;

      case &amp;#39;version_frozen&amp;#39;:
        return &amp;#39;version&amp;#39;;

      default:
        return &amp;#39;general&amp;#39;;
    }
  }

  /**
   * Health check for NATS connection
   */
  getHealthStatus(): {
    enabled: boolean;
    connected: boolean;
    server?: string;
    reconnectAttempts: number;
    eventsPublished: number;
  } {
    return {
      enabled: this.config.enabled,
      connected: this.isConnected,
      server: this.connection?.getServer(),
      reconnectAttempts: this.reconnectAttempts,
      eventsPublished: this.eventSequence,
    };
  }

  /**
   * Get connection statistics
   */
  getStats(): {
    enabled: boolean;
    connected: boolean;
    eventsPublished: number;
    config: NatsConfig;
  } {
    return {
      enabled: this.config.enabled,
      connected: this.isConnected,
      eventsPublished: this.eventSequence,
      config: this.config,
    };
  }

  /**
   * Manually trigger reconnection (for testing/admin)
   */
  async reconnect(): Promise&amp;lt;void&amp;gt; {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer &#x3D; undefined;
    }

    this.reconnectAttempts &#x3D; 0;
    await this.initialize();
  }

  /**
   * Close NATS connection and cleanup
   */
  async cleanup(): Promise&amp;lt;void&amp;gt; {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer &#x3D; undefined;
    }

    if (this.connection) {
      try {
        await this.connection.close();
        logger.info(&amp;#39;NATS connection closed successfully&amp;#39;);
      } catch (error) {
        logger.error(&amp;#39;Error closing NATS connection&amp;#39;, error instanceof Error ? error : undefined);
      }

      this.connection &#x3D; null;
      this.isConnected &#x3D; false;
    }
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-10">
                <div class="file-header">📄 src/handlers/manager.ts</div>
                <div class="file-content">
                    <pre>/**
 * Handler Manager - Integrates custom handlers with existing webhook system
 * This is the main integration point that extends the WebhookService
 */

import { access, mkdir, writeFile } from &amp;quot;node:fs/promises&amp;quot;;
import { join } from &amp;quot;node:path&amp;quot;;
import type { SpecWorkbenchDB } from &amp;quot;../db.js&amp;quot;;
import type { EventService } from &amp;quot;../events.js&amp;quot;;
import type { ServerConfig } from &amp;quot;../types.js&amp;quot;;
import { logger as defaultLogger } from &amp;quot;../utils.js&amp;quot;;
import { HandlerDiscovery } from &amp;quot;./discovery.js&amp;quot;;
import { HandlerExecutor } from &amp;quot;./executor.js&amp;quot;;
import {
  type HandlerEmailConfig,
  HandlerGitService,
  HandlerHttpClient,
  HandlerNotificationService,
} from &amp;quot;./services.js&amp;quot;;
import type {
  HandlerCreationOptions,
  HandlerDiscoveryConfig,
  HandlerExecution,
  HandlerResult,
  HandlerServices,
  Logger,
  RegisteredHandler,
  WebhookRequest,
} from &amp;quot;./types.js&amp;quot;;

export class CustomHandlerManager {
  private discovery: HandlerDiscovery;
  private executor: HandlerExecutor;
  private services: HandlerServices;
  private initialized &#x3D; false;

  constructor(
    private config: ServerConfig,
    private events: EventService,
    private db: SpecWorkbenchDB,
    private logger: Logger &#x3D; defaultLogger,
  ) {
    // Initialize handler services
    const emailConfig &#x3D; this.config.handlers?.notifications?.email as
      | HandlerEmailConfig
      | undefined;

    this.services &#x3D; {
      events: this.events,
      db: this.db,
      http: new HandlerHttpClient(this.logger),
      notifications: new HandlerNotificationService(this.logger, emailConfig),
      git: new HandlerGitService(this.logger),
    };

    // Configure discovery
    const discoveryConfig: HandlerDiscoveryConfig &#x3D; {
      handlersDirectory: join(process.cwd(), &amp;quot;arbiter&amp;quot;, &amp;quot;handlers&amp;quot;),
      enableAutoReload: this.config.handlers?.enableAutoReload ?? false,
      maxConcurrentExecutions: this.config.handlers?.maxConcurrentExecutions ?? 10,
      defaultTimeout: this.config.handlers?.defaultTimeout ?? 30000,
      defaultRetries: this.config.handlers?.defaultRetries ?? 2,
      sandboxEnabled: this.config.handlers?.sandboxEnabled ?? true,
      allowedModules: this.config.handlers?.allowedModules ?? [
        &amp;quot;node:crypto&amp;quot;,
        &amp;quot;node:util&amp;quot;,
        &amp;quot;node:url&amp;quot;,
        &amp;quot;node:path&amp;quot;,
      ],
      enableMetrics: this.config.handlers?.enableMetrics ?? true,
    };

    this.discovery &#x3D; new HandlerDiscovery(discoveryConfig, this.logger);
    this.executor &#x3D; new HandlerExecutor(this.discovery, this.services, this.logger);
  }

  /**
   * Initialize the handler system
   */
  async initialize(): Promise&amp;lt;void&amp;gt; {
    if (this.initialized) return;

    this.logger.info(&amp;quot;Initializing custom handler manager&amp;quot;);

    try {
      // Discover and load all handlers
      const handlers &#x3D; await this.discovery.discoverHandlers();

      this.logger.info(&amp;quot;Custom handler manager initialized&amp;quot;, {
        handlersCount: handlers.length,
        enabledHandlers: handlers.filter((h) &#x3D;&amp;gt; h.enabled).length,
      });

      this.initialized &#x3D; true;
    } catch (error) {
      this.logger.error(&amp;quot;Failed to initialize custom handler manager&amp;quot;, error as Error);
      throw error;
    }
  }

  /**
   * Process webhook with custom handlers (integrates with existing WebhookService)
   */
  async processWebhookWithCustomHandlers(
    projectId: string,
    request: WebhookRequest,
  ): Promise&amp;lt;string[]&amp;gt; {
    if (!this.initialized) {
      await this.initialize();
    }

    const actions: string[] &#x3D; [];

    try {
      this.logger.info(&amp;quot;Processing webhook with custom handlers&amp;quot;, {
        projectId,
        provider: request.provider,
        event: request.event,
      });

      // Execute custom handlers
      const handlerResults &#x3D; await this.executor.executeHandlers(projectId, request);

      // Process results and extract actions
      for (const result of handlerResults) {
        if (result.success &amp;amp;&amp;amp; result.actions) {
          actions.push(...result.actions);
        } else if (!result.success) {
          actions.push(&#x60;Custom handler failed: ${result.message}&#x60;);

          // Log handler errors
          if (result.errors) {
            for (const error of result.errors) {
              this.logger.error(&amp;quot;Custom handler error&amp;quot;, new Error(error.message), {
                projectId,
                errorCode: error.code,
                errorDetails: error.details,
              });
            }
          }
        }
      }

      // Broadcast custom handler events
      if (handlerResults.length &amp;gt; 0) {
        await this.events.broadcastToProject(projectId, {
          project_id: projectId,
          event_type: &amp;quot;webhook_received&amp;quot;,
          data: {
            provider: request.provider,
            event: request.event,
            customHandlersExecuted: handlerResults.length,
            successfulHandlers: handlerResults.filter((r) &#x3D;&amp;gt; r.success).length,
            failedHandlers: handlerResults.filter((r) &#x3D;&amp;gt; !r.success).length,
            totalActions: actions.length,
          },
        });
      }
    } catch (error) {
      this.logger.error(&amp;quot;Custom handler processing failed&amp;quot;, error as Error, {
        projectId,
        provider: request.provider,
        event: request.event,
      });

      actions.push(&amp;quot;Custom handler processing failed&amp;quot;);
    }

    return actions;
  }

  /**
   * Create and register a new handler on disk
   */
  async createHandler(options: HandlerCreationOptions): Promise&amp;lt;RegisteredHandler&amp;gt; {
    if (!options.code || options.code.trim().length &#x3D;&#x3D;&#x3D; 0) {
      throw new Error(&amp;quot;Handler code must not be empty&amp;quot;);
    }

    if (options.provider !&#x3D;&#x3D; &amp;quot;github&amp;quot; &amp;amp;&amp;amp; options.provider !&#x3D;&#x3D; &amp;quot;gitlab&amp;quot;) {
      throw new Error(&#x60;Unsupported provider: ${options.provider}&#x60;);
    }

    if (!this.initialized) {
      await this.initialize();
    }

    const normalizedEvent &#x3D; this.normalizeEventName(options.event);
    const handlersRoot &#x3D; join(process.cwd(), &amp;quot;arbiter&amp;quot;, &amp;quot;handlers&amp;quot;, options.provider);
    await mkdir(handlersRoot, { recursive: true });

    const extension &#x3D; this.detectFileExtension(options.code);
    let fileName &#x3D; &#x60;${normalizedEvent}${extension}&#x60;;
    let handlerPath &#x3D; join(handlersRoot, fileName);
    let counter &#x3D; 1;

    while (await this.pathExists(handlerPath)) {
      fileName &#x3D; &#x60;${normalizedEvent}-${counter++}${extension}&#x60;;
      handlerPath &#x3D; join(handlersRoot, fileName);
    }

    const source &#x3D; this.buildHandlerModuleSource(options, normalizedEvent);
    await writeFile(handlerPath, source, &amp;quot;utf-8&amp;quot;);

    const handler &#x3D; await this.discovery.registerHandlerFromFile(
      handlerPath,
      options.provider,
      normalizedEvent,
    );

    this.logger.info(&amp;quot;Custom handler created&amp;quot;, {
      id: handler.id,
      provider: handler.provider,
      event: handler.event,
      path: handler.handlerPath,
    });

    return handler;
  }

  /**
   * Get all registered handlers
   */
  getHandlers(): RegisteredHandler[] {
    return this.discovery.getHandlers();
  }

  /**
   * Get handlers for specific provider/event
   */
  getHandlersForEvent(provider: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;, event: string): RegisteredHandler[] {
    return this.discovery.getHandlersForEvent(provider, event);
  }

  /**
   * Get handler by ID
   */
  getHandler(id: string): RegisteredHandler | undefined {
    return this.discovery.getHandler(id);
  }

  /**
   * Update handler configuration
   */
  updateHandlerConfig(id: string, updates: Partial&amp;lt;RegisteredHandler&amp;gt;): boolean {
    return this.discovery.updateHandlerConfig(id, updates);
  }

  /**
   * Enable/disable handler
   */
  setHandlerEnabled(id: string, enabled: boolean): boolean {
    return this.discovery.setHandlerEnabled(id, enabled);
  }

  /**
   * Remove handler
   */
  removeHandler(id: string): boolean {
    return this.discovery.removeHandler(id);
  }

  /**
   * Reload handler from file
   */
  async reloadHandler(id: string): Promise&amp;lt;boolean&amp;gt; {
    return await this.discovery.reloadHandler(id);
  }

  /**
   * Get execution history
   */
  getExecutionHistory(limit &#x3D; 100): HandlerExecution[] {
    return this.executor.getExecutionHistory(limit);
  }

  /**
   * Get handler statistics
   */
  getHandlerStats(): {
    totalHandlers: number;
    enabledHandlers: number;
    activeExecutions: number;
    totalExecutions: number;
    failedExecutions: number;
  } {
    const handlers &#x3D; this.discovery.getHandlers();
    const executions &#x3D; this.executor.getExecutionHistory();

    return {
      totalHandlers: handlers.length,
      enabledHandlers: handlers.filter((h) &#x3D;&amp;gt; h.enabled).length,
      activeExecutions: this.executor.getActiveExecutionCount(),
      totalExecutions: executions.length,
      failedExecutions: executions.filter((e) &#x3D;&amp;gt; !e.result.success).length,
    };
  }

  private normalizeEventName(event: string): string {
    const trimmed &#x3D; event.trim().toLowerCase();
    if (trimmed.length &#x3D;&#x3D;&#x3D; 0) {
      throw new Error(&amp;quot;Event name is required&amp;quot;);
    }

    if (trimmed.includes(&amp;quot;/&amp;quot;) || trimmed.includes(&amp;quot;\\&amp;quot;)) {
      throw new Error(&amp;quot;Event name cannot contain path separators&amp;quot;);
    }

    return trimmed.replace(/[^a-z0-9._-]/g, &amp;quot;-&amp;quot;);
  }

  private detectFileExtension(code: string): &amp;quot;.ts&amp;quot; | &amp;quot;.js&amp;quot; {
    const trimmed &#x3D; code.trim();
    if (trimmed.includes(&amp;quot;module.exports&amp;quot;) || trimmed.includes(&amp;quot;require(&amp;quot;)) {
      return &amp;quot;.js&amp;quot;;
    }

    if (trimmed.includes(&amp;quot;export &amp;quot;) || trimmed.includes(&amp;quot;import &amp;quot;)) {
      return &amp;quot;.ts&amp;quot;;
    }

    return &amp;quot;.ts&amp;quot;;
  }

  private async pathExists(target: string): Promise&amp;lt;boolean&amp;gt; {
    try {
      await access(target);
      return true;
    } catch {
      return false;
    }
  }

  private buildHandlerModuleSource(
    options: HandlerCreationOptions,
    normalizedEvent: string,
  ): string {
    const trimmed &#x3D; options.code.trim();

    if (trimmed.includes(&amp;quot;export default&amp;quot;)) {
      const transformed &#x3D; trimmed.replace(/export\s+default/, &amp;quot;module.exports &#x3D;&amp;quot;);
      return transformed.endsWith(&amp;quot;\n&amp;quot;) ? transformed : &#x60;${transformed}\n&#x60;;
    }

    if (trimmed.includes(&amp;quot;module.exports&amp;quot;) || trimmed.includes(&amp;quot;exports.&amp;quot;)) {
      return trimmed.endsWith(&amp;quot;\n&amp;quot;) ? trimmed : &#x60;${trimmed}\n&#x60;;
    }

    const defaultTimeout &#x3D; this.config.handlers?.defaultTimeout ?? 30000;
    const defaultRetries &#x3D; this.config.handlers?.defaultRetries ?? 2;

    const config &#x3D; {
      enabled: options.config?.enabled ?? true,
      timeout: options.config?.timeout ?? defaultTimeout,
      retries: options.config?.retries ?? defaultRetries,
      environment: options.config?.environment ?? {},
      secrets: options.config?.secrets ?? {},
    };

    const metadata &#x3D; {
      name: options.metadata?.name ?? &#x60;${options.provider} ${normalizedEvent} handler&#x60;,
      description: options.metadata?.description ?? &amp;quot;Custom webhook handler generated by Arbiter&amp;quot;,
      version: options.metadata?.version ?? &amp;quot;1.0.0&amp;quot;,
      author: options.metadata?.author ?? &amp;quot;Arbiter&amp;quot;,
      supportedEvents: [normalizedEvent],
      requiredPermissions: [],
    };

    const defaultBody &#x3D; [
      &amp;quot;return {&amp;quot;,
      &amp;quot;  success: true,&amp;quot;,
      &amp;quot;  message: &amp;#39;Handler executed successfully&amp;#39;,&amp;quot;,
      &amp;quot;  actions: [],&amp;quot;,
      &amp;quot;};&amp;quot;,
    ].join(&amp;quot;\n&amp;quot;);

    const body &#x3D; trimmed.length &amp;gt; 0 ? this.indentSnippet(trimmed) : this.indentSnippet(defaultBody);

    return &#x60;module.exports &#x3D; {
  config: ${this.formatObjectLiteral(config, 4)},
  metadata: ${this.formatObjectLiteral(metadata, 4)},
  handler: async (payload, context) &#x3D;&amp;gt; {
${body}
  },
};
&#x60;;
  }

  private formatObjectLiteral(value: unknown, indent: number): string {
    const json &#x3D; JSON.stringify(value, null, 2);
    const lines &#x3D; json.split(&amp;quot;\n&amp;quot;);
    return lines
      .map((line, index) &#x3D;&amp;gt; {
        if (index &#x3D;&#x3D;&#x3D; 0 || index &#x3D;&#x3D;&#x3D; lines.length - 1) {
          return line;
        }
        return &#x60;${&amp;quot; &amp;quot;.repeat(indent)}${line.trimStart()}&#x60;;
      })
      .join(&amp;quot;\n&amp;quot;);
  }

  private indentSnippet(snippet: string, indentSize &#x3D; 4): string {
    const indent &#x3D; &amp;quot; &amp;quot;.repeat(indentSize);
    return snippet
      .split(&amp;quot;\n&amp;quot;)
      .map((line) &#x3D;&amp;gt; &#x60;${indent}${line.trimEnd()}&#x60;)
      .join(&amp;quot;\n&amp;quot;);
  }

  /**
   * Create a new handler directory structure
   */
  async createHandlerStructure(): Promise&amp;lt;void&amp;gt; {
    const { promises: fs } &#x3D; await import(&amp;quot;node:fs&amp;quot;);
    const path &#x3D; await import(&amp;quot;node:path&amp;quot;);

    const handlersDir &#x3D; path.join(process.cwd(), &amp;quot;arbiter&amp;quot;, &amp;quot;handlers&amp;quot;);

    try {
      // Create directory structure
      await fs.mkdir(path.join(handlersDir, &amp;quot;github&amp;quot;), { recursive: true });
      await fs.mkdir(path.join(handlersDir, &amp;quot;gitlab&amp;quot;), { recursive: true });
      await fs.mkdir(path.join(handlersDir, &amp;quot;shared&amp;quot;), { recursive: true });
      await fs.mkdir(path.join(handlersDir, &amp;quot;examples&amp;quot;), { recursive: true });

      // Create example configuration
      const configExample &#x3D; {
        $schema: &amp;quot;./handler-config.schema.json&amp;quot;,
        defaults: {
          timeout: 30000,
          retries: 2,
          enabled: true,
        },
        handlers: {
          &amp;quot;github/push&amp;quot;: {
            enabled: true,
            timeout: 15000,
            environment: {
              NODE_ENV: &amp;quot;production&amp;quot;,
            },
            secrets: {
              SLACK_WEBHOOK: &amp;quot;${HANDLER_SLACK_WEBHOOK}&amp;quot;,
              JIRA_TOKEN: &amp;quot;${HANDLER_JIRA_TOKEN}&amp;quot;,
            },
          },
        },
      };

      await fs.writeFile(
        path.join(handlersDir, &amp;quot;.handlers-config.json&amp;quot;),
        JSON.stringify(configExample, null, 2),
      );

      // Create shared utilities example
      const utilsExample &#x3D; &#x60;/**
 * Shared utilities for webhook handlers
 */

export function formatSlackMessage(title: string, details: Record&amp;lt;string, unknown&amp;gt;) {
  return {
    blocks: [
      {
        type: &amp;#39;section&amp;#39;,
        text: {
          type: &amp;#39;mrkdwn&amp;#39;,
          text: \&#x60;*\${title}*\&#x60;
        }
      },
      {
        type: &amp;#39;section&amp;#39;,
        fields: Object.entries(details).map(([key, value]) &#x3D;&amp;gt; ({
          type: &amp;#39;mrkdwn&amp;#39;,
          text: \&#x60;*\${key}:* \${value}\&#x60;
        }))
      }
    ]
  };
}

export function extractSpecFiles(filePaths: string[]): string[] {
  return filePaths.filter(path &#x3D;&amp;gt; path.endsWith(&amp;#39;.cue&amp;#39;) || path.endsWith(&amp;#39;.spec.ts&amp;#39;));
}

export function shouldNotify(branch: string, defaultBranch: string): boolean {
  return branch &#x3D;&#x3D;&#x3D; \&#x60;refs/heads/\${defaultBranch}\&#x60; || branch.includes(&amp;#39;release&amp;#39;);
}
&#x60;;

      await fs.writeFile(path.join(handlersDir, &amp;quot;shared&amp;quot;, &amp;quot;utils.ts&amp;quot;), utilsExample);

      this.logger.info(&amp;quot;Handler directory structure created&amp;quot;, { path: handlersDir });
    } catch (error) {
      this.logger.error(&amp;quot;Failed to create handler structure&amp;quot;, error as Error);
      throw error;
    }
  }

  /**
   * Validate handler file
   */
  async validateHandler(filePath: string): Promise&amp;lt;{
    valid: boolean;
    errors: string[];
    warnings: string[];
  }&amp;gt; {
    const result &#x3D; {
      valid: true,
      errors: [] as string[],
      warnings: [] as string[],
    };

    try {
      // Basic file validation
      const { promises: fs } &#x3D; await import(&amp;quot;node:fs&amp;quot;);
      const content &#x3D; await fs.readFile(filePath, &amp;quot;utf-8&amp;quot;);

      // Check for required exports
      if (!content.includes(&amp;quot;export default&amp;quot;) &amp;amp;&amp;amp; !content.includes(&amp;quot;exports.handler&amp;quot;)) {
        result.errors.push(&amp;quot;Handler must export a default handler module&amp;quot;);
        result.valid &#x3D; false;
      }

      // Check for async handler function
      if (!content.includes(&amp;quot;async&amp;quot;) || !content.includes(&amp;quot;Promise&amp;quot;)) {
        result.warnings.push(&amp;quot;Handler should be async and return a Promise&amp;lt;HandlerResult&amp;gt;&amp;quot;);
      }

      // Check for proper error handling
      if (!content.includes(&amp;quot;try&amp;quot;) || !content.includes(&amp;quot;catch&amp;quot;)) {
        result.warnings.push(&amp;quot;Handler should include proper error handling (try/catch)&amp;quot;);
      }

      // Check for context usage
      if (!content.includes(&amp;quot;context.logger&amp;quot;) &amp;amp;&amp;amp; !content.includes(&amp;quot;logger&amp;quot;)) {
        result.warnings.push(&amp;quot;Handler should use context.logger for logging&amp;quot;);
      }
    } catch (error) {
      result.errors.push(
        &#x60;Failed to read handler file: ${error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;}&#x60;,
      );
      result.valid &#x3D; false;
    }

    return result;
  }

  /**
   * Shutdown handler manager
   */
  async dispose(): Promise&amp;lt;void&amp;gt; {
    this.logger.info(&amp;quot;Shutting down custom handler manager&amp;quot;);

    this.executor.dispose();
    this.discovery.dispose();

    this.initialized &#x3D; false;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-11">
                <div class="file-header">📄 src/mcp.ts</div>
                <div class="file-content">
                    <pre>import { StreamableHTTPTransport } from &amp;#39;@hono/mcp&amp;#39;;
import { McpServer } from &amp;#39;@modelcontextprotocol/sdk/server/mcp.js&amp;#39;;
import { Hono } from &amp;#39;hono&amp;#39;;
import { z } from &amp;#39;zod&amp;#39;;

const API_BASE_URL &#x3D; process.env.API_BASE_URL || &amp;#39;http://localhost:5050&amp;#39;;

function createMcpServer() {
  const server &#x3D; new McpServer(
    {
      name: &amp;#39;arbiter-api&amp;#39;,
      version: &amp;#39;1.0.0&amp;#39;,
    },
    {
      capabilities: {
        tools: {},
      },
    }
  );

  // Register health check tool
  server.registerTool(
    &amp;#39;check_health&amp;#39;,
    {
      title: &amp;#39;Health Check&amp;#39;,
      description: &amp;#39;Check the health status of the Arbiter API server&amp;#39;,
      inputSchema: {},
    },
    async () &#x3D;&amp;gt; ({
      content: [
        {
          type: &amp;#39;text&amp;#39;,
          text: JSON.stringify(
            {
              status: &amp;#39;healthy&amp;#39;,
              timestamp: new Date().toISOString(),
              server: &amp;#39;Arbiter API&amp;#39;,
              version: &amp;#39;1.0.0&amp;#39;,
              public_url: &amp;#39;https://arbiter-dev.sibylline.dev&amp;#39;,
            },
            null,
            2
          ),
        },
      ],
    })
  );

  // Register spec validation tool
  server.registerTool(
    &amp;#39;validate_spec&amp;#39;,
    {
      title: &amp;#39;Validate Specification&amp;#39;,
      description: &amp;#39;Validate a CUE specification using the Arbiter API&amp;#39;,
      inputSchema: {
        spec_content: z.string().describe(&amp;#39;The CUE specification content to validate&amp;#39;),
        spec_type: z
          .enum([&amp;#39;v1&amp;#39;, &amp;#39;v2&amp;#39;, &amp;#39;auto&amp;#39;])
          .optional()
          .describe(&amp;#39;The type of specification (optional)&amp;#39;),
      },
    },
    async ({ spec_content, spec_type }) &#x3D;&amp;gt; {
      try {
        const validationResult &#x3D; await fetch(&#x60;${API_BASE_URL}/api/validate&#x60;, {
          method: &amp;#39;POST&amp;#39;,
          headers: { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39; },
          body: JSON.stringify({
            spec_content,
            spec_type: spec_type || &amp;#39;auto&amp;#39;,
          }),
        }).then(r &#x3D;&amp;gt; r.json());

        return {
          content: [
            {
              type: &amp;#39;text&amp;#39;,
              text: JSON.stringify(
                {
                  success: true,
                  validation_result: validationResult,
                  message: &amp;#39;Validation completed successfully&amp;#39;,
                },
                null,
                2
              ),
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: &amp;#39;text&amp;#39;,
              text: &#x60;Validation failed: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;,
            },
          ],
          isError: true,
        };
      }
    }
  );

  // Register server info tool
  server.registerTool(
    &amp;#39;get_server_info&amp;#39;,
    {
      title: &amp;#39;Server Information&amp;#39;,
      description: &amp;#39;Get comprehensive server information and capabilities&amp;#39;,
      inputSchema: {
        include_metrics: z.boolean().optional().describe(&amp;#39;Whether to include performance metrics&amp;#39;),
      },
    },
    async ({ include_metrics &#x3D; false }) &#x3D;&amp;gt; ({
      content: [
        {
          type: &amp;#39;text&amp;#39;,
          text: JSON.stringify(
            {
              server: &amp;#39;Arbiter API&amp;#39;,
              version: &amp;#39;1.0.0&amp;#39;,
              capabilities: [&amp;#39;spec_validation&amp;#39;, &amp;#39;webhook_handling&amp;#39;, &amp;#39;mcp_integration&amp;#39;],
              endpoints: [&amp;#39;/health&amp;#39;, &amp;#39;/api/validate&amp;#39;, &amp;#39;/mcp&amp;#39;, &amp;#39;/webhooks/*&amp;#39;],
              public_url: &amp;#39;https://arbiter-dev.sibylline.dev&amp;#39;,
              timestamp: new Date().toISOString(),
              mcp_tools: [
                &amp;#39;check_health&amp;#39;,
                &amp;#39;validate_spec&amp;#39;,
                &amp;#39;get_server_info&amp;#39;,
                &amp;#39;search&amp;#39;,
                &amp;#39;fetch&amp;#39;,
                &amp;#39;create_project&amp;#39;,
                &amp;#39;add_service&amp;#39;,
                &amp;#39;add_endpoint&amp;#39;,
                &amp;#39;add_route&amp;#39;,
                &amp;#39;add_flow&amp;#39;,
                &amp;#39;add_load-balancer&amp;#39;,
                &amp;#39;add_database&amp;#39;,
                &amp;#39;add_cache&amp;#39;,
                &amp;#39;add_locator&amp;#39;,
                &amp;#39;add_schema&amp;#39;,
                &amp;#39;add_package&amp;#39;,
                &amp;#39;add_component&amp;#39;,
                &amp;#39;add_module&amp;#39;,
              ],
              include_metrics,
            },
            null,
            2
          ),
        },
      ],
    })
  );

  // Register search action (required by ChatGPT)
  server.registerTool(
    &amp;#39;search&amp;#39;,
    {
      title: &amp;#39;Search Arbiter Resources&amp;#39;,
      description:
        &amp;#39;Search through Arbiter specifications, documentation, handlers, and project resources&amp;#39;,
      inputSchema: {
        query: z.string().describe(&amp;#39;The search query to find relevant information&amp;#39;),
      },
    },
    async ({ query }) &#x3D;&amp;gt; {
      try {
        const searchResult &#x3D; await fetch(&#x60;${API_BASE_URL}/api/search&#x60;, {
          method: &amp;#39;POST&amp;#39;,
          headers: { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39; },
          body: JSON.stringify({
            query,
            type: &amp;#39;all&amp;#39;,
            limit: 10,
          }),
        }).then(r &#x3D;&amp;gt; r.json());

        // Transform results to match ChatGPT&amp;#39;s expected format
        const results &#x3D; (searchResult.results || []).map((result: any, index: number) &#x3D;&amp;gt; ({
          id: &#x60;${result.path}-${index}&#x60;,
          title: result.title,
          url: &#x60;file://${result.path}&#x60;,
        }));

        return {
          content: [
            {
              type: &amp;#39;text&amp;#39;,
              text: JSON.stringify({ results }),
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: &amp;#39;text&amp;#39;,
              text: &#x60;Search failed: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;,
            },
          ],
          isError: true,
        };
      }
    }
  );

  // Register fetch action (required by ChatGPT)
  server.registerTool(
    &amp;#39;fetch&amp;#39;,
    {
      title: &amp;#39;Fetch File Content&amp;#39;,
      description: &amp;#39;Fetch the complete content of a specific file from the Arbiter project&amp;#39;,
      inputSchema: {
        id: z.string().describe(&amp;#39;The unique identifier for the document to fetch&amp;#39;),
      },
    },
    async ({ id }) &#x3D;&amp;gt; {
      try {
        // Extract path from the id (format: &amp;quot;path-index&amp;quot;)
        const path &#x3D; id.split(&amp;#39;-&amp;#39;).slice(0, -1).join(&amp;#39;-&amp;#39;);

        const fetchResult &#x3D; await fetch(&#x60;${API_BASE_URL}/api/fetch&#x60;, {
          method: &amp;#39;POST&amp;#39;,
          headers: { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39; },
          body: JSON.stringify({
            path,
            encoding: &amp;#39;utf-8&amp;#39;,
          }),
        }).then(r &#x3D;&amp;gt; r.json());

        if (!fetchResult.success) {
          return {
            content: [
              {
                type: &amp;#39;text&amp;#39;,
                text: &#x60;Fetch failed: ${fetchResult.error || &amp;#39;Unknown error&amp;#39;}&#x60;,
              },
            ],
            isError: true,
          };
        }

        // Transform result to match ChatGPT&amp;#39;s expected format
        const result &#x3D; {
          id,
          title: fetchResult.path.split(&amp;#39;/&amp;#39;).pop() || &amp;#39;Unknown&amp;#39;,
          text: fetchResult.content,
          url: &#x60;file://${fetchResult.path}&#x60;,
          metadata: {
            size: fetchResult.size,
            type: fetchResult.type,
            lastModified: fetchResult.lastModified,
            source: &amp;#39;arbiter_project&amp;#39;,
          },
        };

        return {
          content: [
            {
              type: &amp;#39;text&amp;#39;,
              text: JSON.stringify(result),
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: &amp;#39;text&amp;#39;,
              text: &#x60;Fetch failed: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;,
            },
          ],
          isError: true,
        };
      }
    }
  );

  // Register create project tool
  server.registerTool(
    &amp;#39;create_project&amp;#39;,
    {
      title: &amp;#39;Create Project&amp;#39;,
      description: &amp;#39;Create a new Arbiter project with basic structure and templates&amp;#39;,
      inputSchema: {
        name: z.string().describe(&amp;#39;Name of the project to create&amp;#39;),
        options: z
          .object({
            template: z
              .enum([&amp;#39;basic&amp;#39;, &amp;#39;kubernetes&amp;#39;, &amp;#39;api&amp;#39;])
              .optional()
              .describe(&amp;#39;Project template to use (default: basic)&amp;#39;),
            directory: z
              .string()
              .optional()
              .describe(&amp;#39;Target directory for the project (default: current directory)&amp;#39;),
            force: z.boolean().optional().describe(&amp;#39;Overwrite existing directory if it exists&amp;#39;),
          })
          .optional()
          .describe(&amp;#39;Additional options for project creation&amp;#39;),
      },
    },
    async ({ name, options &#x3D; {} }) &#x3D;&amp;gt; {
      try {
        const response &#x3D; await fetch(&#x60;${API_BASE_URL}/api/create&#x60;, {
          method: &amp;#39;POST&amp;#39;,
          headers: { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39; },
          body: JSON.stringify({
            name,
            options: {
              template: options.template || &amp;#39;basic&amp;#39;,
              directory: options.directory,
              force: options.force || false,
              ...options,
            },
          }),
        }).then(r &#x3D;&amp;gt; r.json());

        if (!response.success) {
          return {
            content: [
              {
                type: &amp;#39;text&amp;#39;,
                text: &#x60;Failed to create project: ${response.error || &amp;#39;Unknown error&amp;#39;}&#x60;,
              },
            ],
            isError: true,
          };
        }

        return {
          content: [
            {
              type: &amp;#39;text&amp;#39;,
              text: JSON.stringify({
                success: true,
                action: &amp;#39;create_project&amp;#39;,
                name,
                message: response.message || &#x60;Successfully created project: ${name}&#x60;,
                template: options.template || &amp;#39;basic&amp;#39;,
                directory: response.directory,
                next_steps: [
                  &#x60;cd ${response.directory || name}&#x60;,
                  &amp;#39;arbiter add &amp;lt;component-type&amp;gt; &amp;lt;name&amp;gt;  # Add models, endpoints, configs, etc.&amp;#39;,
                  &amp;#39;arbiter generate  # Creates the actual CUE files&amp;#39;,
                  &amp;#39;arbiter check  # Validate the generated CUE&amp;#39;,
                ],
              }),
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: &amp;#39;text&amp;#39;,
              text: &#x60;Failed to create project: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;,
            },
          ],
          isError: true,
        };
      }
    }
  );

  // Register add commands for building specifications
  const addCommands &#x3D; [
    { name: &amp;#39;service&amp;#39;, description: &amp;#39;Add a service to the specification&amp;#39; },
    { name: &amp;#39;endpoint&amp;#39;, description: &amp;#39;Add an API endpoint to a service&amp;#39; },
    { name: &amp;#39;route&amp;#39;, description: &amp;#39;Add a UI route for frontend applications&amp;#39; },
    { name: &amp;#39;flow&amp;#39;, description: &amp;#39;Add a user flow for testing and validation&amp;#39; },
    { name: &amp;#39;load-balancer&amp;#39;, description: &amp;#39;Add a load balancer with health check invariants&amp;#39; },
    { name: &amp;#39;database&amp;#39;, description: &amp;#39;Add a database with automatic service attachment&amp;#39; },
    { name: &amp;#39;cache&amp;#39;, description: &amp;#39;Add a cache service with automatic attachment&amp;#39; },
    { name: &amp;#39;locator&amp;#39;, description: &amp;#39;Add a UI locator for testing&amp;#39; },
    { name: &amp;#39;schema&amp;#39;, description: &amp;#39;Add a schema for API documentation&amp;#39; },
    { name: &amp;#39;package&amp;#39;, description: &amp;#39;Add a reusable package/library&amp;#39; },
    { name: &amp;#39;component&amp;#39;, description: &amp;#39;Add a UI component&amp;#39; },
    { name: &amp;#39;module&amp;#39;, description: &amp;#39;Add a standalone module&amp;#39; },
  ];

  for (const cmd of addCommands) {
    server.registerTool(
      &#x60;add_${cmd.name}&#x60;,
      {
        title: &#x60;Add ${cmd.name.charAt(0).toUpperCase() + cmd.name.slice(1)}&#x60;,
        description: cmd.description,
        inputSchema: {
          name: z.string().describe(&amp;#39;Name of the component to add&amp;#39;),
          options: z.record(z.any()).optional().describe(&amp;#39;Additional options for the component&amp;#39;),
        },
      },
      async ({ name, options &#x3D; {} }) &#x3D;&amp;gt; {
        try {
          const response &#x3D; await fetch(&#x60;${API_BASE_URL}/api/add&#x60;, {
            method: &amp;#39;POST&amp;#39;,
            headers: { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39; },
            body: JSON.stringify({
              subcommand: cmd.name,
              name,
              options: {
                ...options,
                dryRun: false,
                verbose: true,
              },
            }),
          }).then(r &#x3D;&amp;gt; r.json());

          if (!response.success) {
            return {
              content: [
                {
                  type: &amp;#39;text&amp;#39;,
                  text: &#x60;Failed to add ${cmd.name}: ${response.error || &amp;#39;Unknown error&amp;#39;}&#x60;,
                },
              ],
              isError: true,
            };
          }

          return {
            content: [
              {
                type: &amp;#39;text&amp;#39;,
                text: JSON.stringify({
                  success: true,
                  action: &#x60;add_${cmd.name}&#x60;,
                  name,
                  message: response.message || &#x60;Successfully added ${cmd.name}: ${name}&#x60;,
                  details: response.details,
                }),
              },
            ],
          };
        } catch (error) {
          return {
            content: [
              {
                type: &amp;#39;text&amp;#39;,
                text: &#x60;Failed to add ${cmd.name}: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;,
              },
            ],
            isError: true,
          };
        }
      }
    );
  }

  return server;
}

export function createMcpApp() {
  const app &#x3D; new Hono();

  app.all(&amp;#39;/mcp&amp;#39;, async c &#x3D;&amp;gt; {
    try {
      const server &#x3D; createMcpServer();
      const transport &#x3D; new StreamableHTTPTransport();

      await server.connect(transport);

      return await transport.handleRequest(c);
    } catch (error) {
      console.error(&amp;#39;MCP Server Error:&amp;#39;, error);
      return c.json({ error: &amp;#39;Internal server error&amp;#39; }, 500);
    }
  });

  return app;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-12">
                <div class="file-header">📄 src/handlers/executor.ts</div>
                <div class="file-content">
                    <pre>/**
 * Handler execution pipeline
 * Executes custom webhook handlers with sandboxing and error handling
 */

import { setTimeout } from &amp;quot;node:timers/promises&amp;quot;;
import type { SpecWorkbenchDB } from &amp;quot;../db.js&amp;quot;;
import type { EventService } from &amp;quot;../events.js&amp;quot;;
import { logger as defaultLogger, generateId, getCurrentTimestamp } from &amp;quot;../utils.js&amp;quot;;
import type { HandlerDiscovery } from &amp;quot;./discovery.js&amp;quot;;
import { HandlerLoader } from &amp;quot;./loader.js&amp;quot;;
import { HandlerSecurityValidator } from &amp;quot;./services.js&amp;quot;;
import type {
  EnhancedWebhookPayload,
  HandlerContext,
  HandlerExecution,
  HandlerResult,
  HandlerServices,
  Logger,
  RegisteredHandler,
  WebhookHandler,
  WebhookPayload,
  WebhookRequest,
} from &amp;quot;./types.js&amp;quot;;

export class HandlerExecutor {
  private activeExecutions &#x3D; new Map&amp;lt;string, AbortController&amp;gt;();
  private executionHistory: HandlerExecution[] &#x3D; [];
  private loader: HandlerLoader;

  constructor(
    private discovery: HandlerDiscovery,
    private services: HandlerServices,
    private logger: Logger &#x3D; defaultLogger,
  ) {
    this.loader &#x3D; new HandlerLoader(this.logger);
  }

  /**
   * Execute handlers for a webhook event
   */
  async executeHandlers(projectId: string, request: WebhookRequest): Promise&amp;lt;HandlerResult[]&amp;gt; {
    const { provider, event } &#x3D; request;

    // Get handlers for this event
    const handlers &#x3D; this.discovery.getHandlersForEvent(provider, event);

    if (handlers.length &#x3D;&#x3D;&#x3D; 0) {
      this.logger.debug(&amp;quot;No handlers found for event&amp;quot;, { provider, event });
      return [];
    }

    this.logger.info(&amp;quot;Executing handlers for webhook event&amp;quot;, {
      projectId,
      provider,
      event,
      handlerCount: handlers.length,
    });

    // Enhance payload with parsed data
    const enhancedPayload &#x3D; await this.enhancePayload(request);

    // Execute handlers in parallel
    const executions &#x3D; handlers.map((handler) &#x3D;&amp;gt;
      this.executeHandler(projectId, handler, enhancedPayload),
    );

    const results &#x3D; await Promise.allSettled(executions);

    // Process results
    const handlerResults: HandlerResult[] &#x3D; [];
    for (let i &#x3D; 0; i &amp;lt; results.length; i++) {
      const result &#x3D; results[i];
      const handler &#x3D; handlers[i];

      if (result.status &#x3D;&#x3D;&#x3D; &amp;quot;fulfilled&amp;quot;) {
        handlerResults.push(result.value.result);
        this.updateHandlerStats(handler.id, result.value.result);
      } else {
        const errorResult: HandlerResult &#x3D; {
          success: false,
          message: &#x60;Handler execution failed: ${result.reason}&#x60;,
          errors: [
            {
              code: &amp;quot;EXECUTION_FAILED&amp;quot;,
              message: result.reason?.message || &amp;quot;Unknown error&amp;quot;,
              stack: result.reason?.stack,
            },
          ],
        };
        handlerResults.push(errorResult);
        this.updateHandlerStats(handler.id, errorResult);
      }
    }

    return handlerResults;
  }

  /**
   * Execute a single handler with timeout and error handling
   */
  private async executeHandler(
    projectId: string,
    handler: RegisteredHandler,
    payload: EnhancedWebhookPayload,
  ): Promise&amp;lt;{ result: HandlerResult; execution: HandlerExecution }&amp;gt; {
    const executionId &#x3D; generateId();
    const startTime &#x3D; Date.now();
    const startedAt &#x3D; getCurrentTimestamp();

    this.logger.debug(&amp;quot;Starting handler execution&amp;quot;, {
      executionId,
      handlerId: handler.id,
      handlerName: handler.metadata?.name,
      projectId,
    });

    // Create abort controller for timeout
    const abortController &#x3D; new AbortController();
    this.activeExecutions.set(executionId, abortController);

    let result: HandlerResult;
    let completedAt: string;
    let duration: number;

    try {
      // Load handler module
      const handlerModule &#x3D; await this.loadHandlerModule(handler);

      // Create execution context
      const context &#x3D; await this.createHandlerContext(
        projectId,
        handler,
        executionId,
        abortController.signal,
      );

      // Execute with timeout
      const timeoutPromise &#x3D; setTimeout(handler.config.timeout, null, {
        signal: abortController.signal,
      });

      const executionPromise &#x3D; this.executeWithRetries(
        handlerModule.handler,
        payload,
        context,
        handler.config.retries,
      );

      const raceResult &#x3D; await Promise.race([executionPromise, timeoutPromise]);

      if (raceResult &#x3D;&#x3D;&#x3D; null) {
        throw new Error(&#x60;Handler execution timed out after ${handler.config.timeout}ms&#x60;);
      }

      result &#x3D; raceResult as HandlerResult;

      // Add timing information
      const endTime &#x3D; Date.now();
      duration &#x3D; endTime - startTime;
      completedAt &#x3D; getCurrentTimestamp();
      result.duration &#x3D; duration;

      this.logger.info(&amp;quot;Handler execution completed&amp;quot;, {
        executionId,
        handlerId: handler.id,
        success: result.success,
        duration,
        actionsCount: result.actions?.length || 0,
      });
    } catch (error) {
      const endTime &#x3D; Date.now();
      duration &#x3D; endTime - startTime;
      completedAt &#x3D; getCurrentTimestamp();

      this.logger.error(&amp;quot;Handler execution failed&amp;quot;, error as Error, {
        executionId,
        handlerId: handler.id,
        projectId,
        duration,
      });

      result &#x3D; {
        success: false,
        message: error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;,
        duration,
        errors: [
          {
            code: &amp;quot;HANDLER_EXECUTION_ERROR&amp;quot;,
            message: error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;,
            stack: error instanceof Error ? error.stack : undefined,
          },
        ],
      };
    } finally {
      // Clean up
      this.activeExecutions.delete(executionId);
      abortController.abort();
    }

    // Record execution
    const execution: HandlerExecution &#x3D; {
      id: executionId,
      handlerId: handler.id,
      projectId,
      provider: payload.repository.full_name.includes(&amp;quot;gitlab&amp;quot;) ? &amp;quot;gitlab&amp;quot; : &amp;quot;github&amp;quot;,
      event: payload.parsed.eventType,
      payload,
      result,
      startedAt,
      completedAt,
      duration,
    };

    this.executionHistory.push(execution);

    // Trim history to prevent memory leaks (keep last 1000 executions)
    if (this.executionHistory.length &amp;gt; 1000) {
      this.executionHistory &#x3D; this.executionHistory.slice(-1000);
    }

    return { result, execution };
  }

  /**
   * Execute handler with retry logic
   */
  private async executeWithRetries(
    handler: WebhookHandler,
    payload: EnhancedWebhookPayload,
    context: HandlerContext,
    retries: number,
  ): Promise&amp;lt;HandlerResult&amp;gt; {
    let lastError: Error | undefined;

    for (let attempt &#x3D; 0; attempt &amp;lt;&#x3D; retries; attempt++) {
      try {
        if (attempt &amp;gt; 0) {
          const delay &#x3D; Math.min(1000 * 2 ** (attempt - 1), 5000); // Exponential backoff
          await setTimeout(delay);

          this.logger.info(&amp;quot;Retrying handler execution&amp;quot;, {
            attempt,
            maxRetries: retries,
            delay,
          });
        }

        const result &#x3D; await handler(payload, context);

        // If successful or explicitly non-retryable, return immediately
        if (result.success || !this.isRetryableError(result)) {
          return result;
        }

        lastError &#x3D; new Error(result.message);
      } catch (error) {
        lastError &#x3D; error as Error;

        // If not retryable, fail immediately
        if (!this.isRetryableError(error)) {
          throw error;
        }
      }
    }

    // All retries exhausted
    throw new Error(&#x60;Handler failed after ${retries + 1} attempts: ${lastError?.message}&#x60;);
  }

  /**
   * Check if an error is retryable
   */
  private isRetryableError(error: unknown): boolean {
    if (error instanceof Error) {
      const message &#x3D; error.message.toLowerCase();

      // Network/timeout errors are retryable
      if (
        message.includes(&amp;quot;timeout&amp;quot;) ||
        message.includes(&amp;quot;network&amp;quot;) ||
        message.includes(&amp;quot;connection&amp;quot;) ||
        message.includes(&amp;quot;econnreset&amp;quot;) ||
        message.includes(&amp;quot;enotfound&amp;quot;)
      ) {
        return true;
      }

      // HTTP 5xx errors are retryable
      if (message.includes(&amp;quot;5&amp;quot;) &amp;amp;&amp;amp; message.includes(&amp;quot;error&amp;quot;)) {
        return true;
      }
    }

    if (typeof error &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot; &amp;amp;&amp;amp; error !&#x3D;&#x3D; null) {
      const result &#x3D; error as HandlerResult;
      if (result.errors) {
        return result.errors.some((e) &#x3D;&amp;gt;
          [&amp;quot;TIMEOUT&amp;quot;, &amp;quot;NETWORK_ERROR&amp;quot;, &amp;quot;SERVICE_UNAVAILABLE&amp;quot;].includes(e.code),
        );
      }
    }

    return false;
  }

  /**
   * Load handler module dynamically
   */
  private async loadHandlerModule(handler: RegisteredHandler): Promise&amp;lt;any&amp;gt; {
    return this.loader.load(handler);
  }

  /**
   * Create handler execution context
   */
  private async createHandlerContext(
    projectId: string,
    handler: RegisteredHandler,
    executionId: string,
    abortSignal: AbortSignal,
  ): Promise&amp;lt;HandlerContext&amp;gt; {
    const sanitizedEnvironment &#x3D; HandlerSecurityValidator.sanitizeEnvironment(
      handler.config.environment,
    );

    const secretsValidation &#x3D; HandlerSecurityValidator.validateSecrets(handler.config.secrets);
    if (!secretsValidation.valid) {
      throw new Error(
        &#x60;Handler secrets configuration invalid: ${secretsValidation.errors.join(&amp;quot;, &amp;quot;)}&#x60;,
      );
    }

    const sanitizedConfig &#x3D; {
      ...handler.config,
      environment: sanitizedEnvironment,
      secrets: { ...handler.config.secrets },
    } as HandlerContext[&amp;quot;config&amp;quot;];

    return {
      projectId,
      config: sanitizedConfig,
      logger: this.createHandlerLogger(handler.id, executionId),
      services: this.services,
      metadata: {
        handlerPath: handler.handlerPath,
        version: handler.metadata?.version || &amp;quot;1.0.0&amp;quot;,
        executionId,
        timestamp: getCurrentTimestamp(),
      },
    };
  }

  /**
   * Create scoped logger for handler
   */
  private createHandlerLogger(handlerId: string, executionId: string): Logger {
    return {
      info: (message: string, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
        this.logger.info(message, { ...meta, handlerId, executionId });
      },
      warn: (message: string, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
        this.logger.warn(message, { ...meta, handlerId, executionId });
      },
      error: (message: string, error?: Error, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
        this.logger.error(message, error, { ...meta, handlerId, executionId });
      },
      debug: (message: string, meta?: Record&amp;lt;string, unknown&amp;gt;) &#x3D;&amp;gt; {
        this.logger.debug(message, { ...meta, handlerId, executionId });
      },
    };
  }

  /**
   * Enhance webhook payload with parsed data
   */
  private async enhancePayload(request: WebhookRequest): Promise&amp;lt;EnhancedWebhookPayload&amp;gt; {
    const { provider, event, payload } &#x3D; request;

    // Parse payload based on provider and event type
    const parsed &#x3D; await this.parsePayload(provider, event, payload);

    return {
      ...payload,
      parsed,
    };
  }

  /**
   * Parse webhook payload into standardized format
   */
  private async parsePayload(
    provider: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;,
    event: string,
    payload: WebhookPayload,
  ): Promise&amp;lt;EnhancedWebhookPayload[&amp;quot;parsed&amp;quot;]&amp;gt; {
    const parsed: EnhancedWebhookPayload[&amp;quot;parsed&amp;quot;] &#x3D; {
      eventType: event,
      author: {
        name: &amp;quot;Unknown&amp;quot;,
        email: undefined,
        username: undefined,
      },
      repository: {
        name: payload.repository?.full_name?.split(&amp;quot;/&amp;quot;).pop() || &amp;quot;unknown&amp;quot;,
        fullName: payload.repository?.full_name || &amp;quot;unknown&amp;quot;,
        owner: payload.repository?.full_name?.split(&amp;quot;/&amp;quot;)[0] || &amp;quot;unknown&amp;quot;,
        url: payload.repository?.clone_url || &amp;quot;&amp;quot;,
        defaultBranch: payload.repository?.default_branch || &amp;quot;main&amp;quot;,
        isPrivate: false,
      },
    };

    // Provider-specific parsing
    if (provider &#x3D;&#x3D;&#x3D; &amp;quot;github&amp;quot;) {
      await this.parseGitHubPayload(event, payload, parsed);
    } else if (provider &#x3D;&#x3D;&#x3D; &amp;quot;gitlab&amp;quot;) {
      await this.parseGitLabPayload(event, payload, parsed);
    }

    return parsed;
  }

  /**
   * Parse GitHub webhook payload
   */
  private async parseGitHubPayload(
    event: string,
    payload: any,
    parsed: EnhancedWebhookPayload[&amp;quot;parsed&amp;quot;],
  ): Promise&amp;lt;void&amp;gt; {
    // Common GitHub fields
    if (payload.sender) {
      parsed.author.username &#x3D; payload.sender.login;
      parsed.author.name &#x3D; payload.sender.login;
    }

    if (payload.repository) {
      parsed.repository.isPrivate &#x3D; payload.repository.private;
      parsed.repository.url &#x3D; payload.repository.html_url;
    }

    // Event-specific parsing
    switch (event) {
      case &amp;quot;push&amp;quot;:
        if (payload.commits) {
          parsed.commits &#x3D; payload.commits.map((commit: any) &#x3D;&amp;gt; ({
            sha: commit.id,
            message: commit.message,
            author: commit.author.name,
            url: commit.url,
            timestamp: commit.timestamp,
            added: commit.added || [],
            modified: commit.modified || [],
            removed: commit.removed || [],
          }));
        }
        break;

      case &amp;quot;pull_request&amp;quot;:
        if (payload.pull_request) {
          parsed.action &#x3D; payload.action;
          parsed.pullRequest &#x3D; {
            id: payload.pull_request.number,
            title: payload.pull_request.title,
            body: payload.pull_request.body || &amp;quot;&amp;quot;,
            state: payload.pull_request.state,
            baseBranch: payload.pull_request.base.ref,
            headBranch: payload.pull_request.head.ref,
            url: payload.pull_request.html_url,
            merged: payload.pull_request.merged,
            mergeable: payload.pull_request.mergeable,
          };
        }
        break;

      case &amp;quot;issues&amp;quot;:
        if (payload.issue) {
          parsed.action &#x3D; payload.action;
          parsed.issue &#x3D; {
            id: payload.issue.number,
            title: payload.issue.title,
            body: payload.issue.body || &amp;quot;&amp;quot;,
            state: payload.issue.state,
            labels: payload.issue.labels?.map((l: any) &#x3D;&amp;gt; l.name) || [],
            assignees: payload.issue.assignees?.map((a: any) &#x3D;&amp;gt; a.login) || [],
            url: payload.issue.html_url,
          };
        }
        break;
    }
  }

  /**
   * Parse GitLab webhook payload
   */
  private async parseGitLabPayload(
    event: string,
    payload: any,
    parsed: EnhancedWebhookPayload[&amp;quot;parsed&amp;quot;],
  ): Promise&amp;lt;void&amp;gt; {
    // Common GitLab fields
    if (payload.user) {
      parsed.author.username &#x3D; payload.user.username;
      parsed.author.name &#x3D; payload.user.name;
      parsed.author.email &#x3D; payload.user.email;
    }

    if (payload.project) {
      parsed.repository.name &#x3D; payload.project.name;
      parsed.repository.fullName &#x3D; payload.project.path_with_namespace;
      parsed.repository.url &#x3D; payload.project.web_url;
      parsed.repository.isPrivate &#x3D; payload.project.visibility_level &amp;lt; 20;
      parsed.repository.defaultBranch &#x3D; payload.project.default_branch;
    }

    // Event-specific parsing
    switch (event) {
      case &amp;quot;Push Hook&amp;quot;:
        if (payload.commits) {
          parsed.commits &#x3D; payload.commits.map((commit: any) &#x3D;&amp;gt; ({
            sha: commit.id,
            message: commit.message,
            author: commit.author.name,
            url: commit.url,
            timestamp: commit.timestamp,
            added: commit.added || [],
            modified: commit.modified || [],
            removed: commit.removed || [],
          }));
        }
        break;

      case &amp;quot;Merge Request Hook&amp;quot;:
        if (payload.merge_request) {
          parsed.action &#x3D; payload.action;
          parsed.pullRequest &#x3D; {
            id: payload.merge_request.iid,
            title: payload.merge_request.title,
            body: payload.merge_request.description || &amp;quot;&amp;quot;,
            state: payload.merge_request.state,
            baseBranch: payload.merge_request.target_branch,
            headBranch: payload.merge_request.source_branch,
            url: payload.merge_request.url,
            merged: payload.merge_request.state &#x3D;&#x3D;&#x3D; &amp;quot;merged&amp;quot;,
            mergeable: payload.merge_request.merge_status &#x3D;&#x3D;&#x3D; &amp;quot;can_be_merged&amp;quot;,
          };
        }
        break;
    }
  }

  /**
   * Update handler statistics
   */
  private updateHandlerStats(handlerId: string, result: HandlerResult): void {
    const handler &#x3D; this.discovery.getHandler(handlerId);
    if (handler) {
      handler.executionCount++;
      handler.lastExecuted &#x3D; getCurrentTimestamp();

      if (!result.success) {
        handler.errorCount++;
      }

      this.discovery.updateHandlerConfig(handlerId, {
        executionCount: handler.executionCount,
        errorCount: handler.errorCount,
        lastExecuted: handler.lastExecuted,
      });
    }
  }

  /**
   * Get execution history
   */
  getExecutionHistory(limit &#x3D; 100): HandlerExecution[] {
    return this.executionHistory.slice(-limit);
  }

  /**
   * Get active executions count
   */
  getActiveExecutionCount(): number {
    return this.activeExecutions.size;
  }

  /**
   * Cancel all active executions
   */
  cancelAllExecutions(): void {
    for (const [executionId, controller] of this.activeExecutions) {
      controller.abort();
      this.logger.info(&amp;quot;Cancelled handler execution&amp;quot;, { executionId });
    }
    this.activeExecutions.clear();
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    this.cancelAllExecutions();
    this.executionHistory.length &#x3D; 0;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-13">
                <div class="file-header">📄 src/webhooks.ts</div>
                <div class="file-content">
                    <pre>/**
 * Webhook service for handling GitLab and GitHub webhooks
 */
import { createHash, createHmac, timingSafeEqual } from &amp;#39;node:crypto&amp;#39;;
import type { SpecWorkbenchDB } from &amp;#39;./db.ts&amp;#39;;
import type { EventService } from &amp;#39;./events.ts&amp;#39;;
import { CustomHandlerManager } from &amp;#39;./handlers/manager.js&amp;#39;;
import type {
  EventType,
  ServerConfig,
  WebhookConfig,
  WebhookEventType,
  WebhookPayload,
  WebhookRequest,
  WebhookResponse,
} from &amp;#39;./types.ts&amp;#39;;
import { generateId, getCurrentTimestamp, logger } from &amp;#39;./utils.ts&amp;#39;;

export class WebhookService {
  private handlerManager: CustomHandlerManager;

  constructor(
    private config: ServerConfig,
    private events: EventService,
    private db: SpecWorkbenchDB
  ) {
    this.handlerManager &#x3D; new CustomHandlerManager(this.config, this.events, this.db, logger);
  }

  /**
   * Process incoming webhook from GitLab or GitHub
   */
  async processWebhook(
    provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;,
    event: string,
    signature: string | undefined,
    payload: WebhookPayload,
    headers: Record&amp;lt;string, string&amp;gt;
  ): Promise&amp;lt;WebhookResponse&amp;gt; {
    try {
      logger.info(&amp;#39;Processing webhook&amp;#39;, {
        provider,
        event,
        repository: payload.repository?.full_name,
        ref: payload.ref,
      });

      // Verify webhook signature
      const verification &#x3D; await this.verifySignature(provider, signature, JSON.stringify(payload));
      if (!verification.valid) {
        logger.warn(&amp;#39;Webhook signature verification failed&amp;#39;, {
          provider,
          repository: payload.repository?.full_name,
        });
        return {
          success: false,
          message: &amp;#39;Invalid signature&amp;#39;,
        };
      }

      // Find matching project configuration
      const projectId &#x3D; await this.findProjectForRepository(payload.repository.full_name);
      if (!projectId) {
        logger.info(&amp;#39;No project found for repository&amp;#39;, {
          repository: payload.repository.full_name,
        });
        return {
          success: false,
          message: &amp;#39;No project configured for this repository&amp;#39;,
        };
      }

      // Process the webhook event
      const webhookRequest: WebhookRequest &#x3D; {
        provider,
        event,
        signature,
        payload,
        timestamp: getCurrentTimestamp(),
      };

      // Process with both built-in and custom handlers
      const builtInActions &#x3D; await this.handleWebhookEvent(projectId, webhookRequest);
      const customActions &#x3D; await this.handlerManager.processWebhookWithCustomHandlers(
        projectId,
        webhookRequest
      );

      const actions &#x3D; [...builtInActions, ...customActions];

      // Broadcast webhook received event
      await this.events.broadcastToProject(projectId, {
        project_id: projectId,
        event_type: &amp;#39;webhook_received&amp;#39;,
        data: {
          provider,
          event,
          repository: payload.repository.full_name,
          ref: payload.ref,
          actions_taken: actions,
        },
      });

      return {
        success: true,
        message: &amp;#39;Webhook processed successfully&amp;#39;,
        actions_taken: actions,
        project_id: projectId,
      };
    } catch (error) {
      logger.error(&amp;#39;Webhook processing error&amp;#39;, error instanceof Error ? error : undefined, {
        provider,
        event,
      });
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
      };
    }
  }

  /**
   * Verify webhook signature based on provider
   */
  private async verifySignature(
    provider: &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39;,
    signature: string | undefined,
    payload: string
  ): Promise&amp;lt;{ valid: boolean; reason?: string }&amp;gt; {
    if (!this.config.webhooks?.enabled) {
      return { valid: true }; // Allow if webhooks not configured
    }

    if (!signature) {
      return { valid: false, reason: &amp;#39;No signature provided&amp;#39; };
    }

    try {
      if (provider &#x3D;&#x3D;&#x3D; &amp;#39;github&amp;#39;) {
        return this.verifyGitHubSignature(signature, payload);
      }
      if (provider &#x3D;&#x3D;&#x3D; &amp;#39;gitlab&amp;#39;) {
        return this.verifyGitLabSignature(signature, payload);
      }

      return { valid: false, reason: &amp;#39;Unknown provider&amp;#39; };
    } catch (error) {
      logger.error(&amp;#39;Signature verification error&amp;#39;, error instanceof Error ? error : undefined);
      return { valid: false, reason: &amp;#39;Verification failed&amp;#39; };
    }
  }

  /**
   * Verify GitHub webhook signature (HMAC SHA-256)
   */
  private verifyGitHubSignature(
    signature: string,
    payload: string
  ): { valid: boolean; reason?: string } {
    const secret &#x3D; this.config.webhooks?.github_secret || this.config.webhooks?.secret;

    if (!secret) {
      return { valid: false, reason: &amp;#39;No GitHub secret configured&amp;#39; };
    }

    // GitHub signature format: sha256&#x3D;&amp;lt;hex&amp;gt;
    if (!signature.startsWith(&amp;#39;sha256&#x3D;&amp;#39;)) {
      return { valid: false, reason: &amp;#39;Invalid signature format&amp;#39; };
    }

    const expectedSignature &#x3D; createHmac(&amp;#39;sha256&amp;#39;, secret).update(payload, &amp;#39;utf8&amp;#39;).digest(&amp;#39;hex&amp;#39;);

    const providedSignature &#x3D; signature.replace(&amp;#39;sha256&#x3D;&amp;#39;, &amp;#39;&amp;#39;);

    const valid &#x3D; timingSafeEqual(
      Buffer.from(expectedSignature, &amp;#39;hex&amp;#39;),
      Buffer.from(providedSignature, &amp;#39;hex&amp;#39;)
    );

    return { valid };
  }

  /**
   * Verify GitLab webhook signature (HMAC SHA-256)
   */
  private verifyGitLabSignature(
    signature: string,
    payload: string
  ): { valid: boolean; reason?: string } {
    const secret &#x3D; this.config.webhooks?.gitlab_secret || this.config.webhooks?.secret;

    if (!secret) {
      return { valid: false, reason: &amp;#39;No GitLab secret configured&amp;#39; };
    }

    const expectedSignature &#x3D; createHmac(&amp;#39;sha256&amp;#39;, secret).update(payload, &amp;#39;utf8&amp;#39;).digest(&amp;#39;base64&amp;#39;);

    const valid &#x3D; timingSafeEqual(Buffer.from(expectedSignature), Buffer.from(signature));

    return { valid };
  }

  /**
   * Find project ID for a given repository
   */
  private async findProjectForRepository(repositoryFullName: string): Promise&amp;lt;string | null&amp;gt; {
    try {
      // For now, we&amp;#39;ll use a simple naming convention
      // In a real implementation, this would query the database for webhook configs
      const projects &#x3D; await this.db.listProjects();

      // Look for project with matching name or check if repository is in allowed list
      const allowedRepos &#x3D; this.config.webhooks?.allowed_repos || [];

      if (allowedRepos.length &amp;gt; 0 &amp;amp;&amp;amp; !allowedRepos.includes(repositoryFullName)) {
        return null;
      }

      // Simple heuristic: find project by repository name
      const repoName &#x3D; repositoryFullName.split(&amp;#39;/&amp;#39;).pop()?.toLowerCase() || &amp;#39;&amp;#39;;
      const matchingProject &#x3D; projects.find(
        p &#x3D;&amp;gt; p.name.toLowerCase().includes(repoName) || repoName.includes(p.name.toLowerCase())
      );

      return matchingProject?.id || projects[0]?.id || null;
    } catch (error) {
      logger.error(
        &amp;#39;Error finding project for repository&amp;#39;,
        error instanceof Error ? error : undefined
      );
      return null;
    }
  }

  /**
   * Handle specific webhook events
   */
  private async handleWebhookEvent(projectId: string, request: WebhookRequest): Promise&amp;lt;string[]&amp;gt; {
    const actions: string[] &#x3D; [];

    try {
      if (request.provider &#x3D;&#x3D;&#x3D; &amp;#39;github&amp;#39;) {
        actions.push(...(await this.handleGitHubEvent(projectId, request)));
      } else if (request.provider &#x3D;&#x3D;&#x3D; &amp;#39;gitlab&amp;#39;) {
        actions.push(...(await this.handleGitLabEvent(projectId, request)));
      }
    } catch (error) {
      logger.error(&amp;#39;Error handling webhook event&amp;#39;, error instanceof Error ? error : undefined);
      actions.push(&amp;#39;Error processing event&amp;#39;);
    }

    return actions;
  }

  /**
   * Handle GitHub webhook events
   */
  private async handleGitHubEvent(projectId: string, request: WebhookRequest): Promise&amp;lt;string[]&amp;gt; {
    const actions: string[] &#x3D; [];
    const { event, payload } &#x3D; request;

    switch (event) {
      case &amp;#39;push&amp;#39;:
        if (payload.ref &amp;amp;&amp;amp; payload.commits) {
          actions.push(&#x60;Received ${payload.commits.length} commits on ${payload.ref}&#x60;);

          if (this.config.webhooks?.sync_on_push) {
            // TODO: Implement sync logic
            actions.push(&amp;#39;Triggered spec sync&amp;#39;);
          }

          // Broadcast git push event
          await this.events.broadcastToProject(projectId, {
            project_id: projectId,
            event_type: &amp;#39;git_push_processed&amp;#39;,
            data: {
              provider: &amp;#39;github&amp;#39;,
              ref: payload.ref,
              commits: payload.commits.length,
              repository: payload.repository.full_name,
            },
          });
        }
        break;

      case &amp;#39;pull_request&amp;#39;:
        if (payload.pull_request &amp;amp;&amp;amp; payload.action) {
          actions.push(&#x60;Pull request ${payload.action}: #${payload.pull_request.id}&#x60;);

          if (payload.action &#x3D;&#x3D;&#x3D; &amp;#39;closed&amp;#39; &amp;amp;&amp;amp; this.config.webhooks?.validate_on_merge) {
            // TODO: Implement validation logic
            actions.push(&amp;#39;Triggered spec validation&amp;#39;);
          }

          await this.events.broadcastToProject(projectId, {
            project_id: projectId,
            event_type: &amp;#39;git_merge_processed&amp;#39;,
            data: {
              provider: &amp;#39;github&amp;#39;,
              action: payload.action,
              pr_id: payload.pull_request.id,
              base_branch: payload.pull_request.base.ref,
              head_branch: payload.pull_request.head.ref,
            },
          });
        }
        break;

      default:
        actions.push(&#x60;Unhandled GitHub event: ${event}&#x60;);
    }

    return actions;
  }

  /**
   * Handle GitLab webhook events
   */
  private async handleGitLabEvent(projectId: string, request: WebhookRequest): Promise&amp;lt;string[]&amp;gt; {
    const actions: string[] &#x3D; [];
    const { event, payload } &#x3D; request;

    switch (event) {
      case &amp;#39;Push Hook&amp;#39;:
        if (payload.ref &amp;amp;&amp;amp; payload.commits) {
          actions.push(&#x60;Received ${payload.commits.length} commits on ${payload.ref}&#x60;);

          if (this.config.webhooks?.sync_on_push) {
            // TODO: Implement sync logic
            actions.push(&amp;#39;Triggered spec sync&amp;#39;);
          }

          await this.events.broadcastToProject(projectId, {
            project_id: projectId,
            event_type: &amp;#39;git_push_processed&amp;#39;,
            data: {
              provider: &amp;#39;gitlab&amp;#39;,
              ref: payload.ref,
              commits: payload.commits.length,
              repository: payload.repository.full_name,
            },
          });
        }
        break;

      case &amp;#39;Merge Request Hook&amp;#39;:
        if (payload.merge_request &amp;amp;&amp;amp; payload.action) {
          actions.push(&#x60;Merge request ${payload.action}: !${payload.merge_request.id}&#x60;);

          if (payload.action &#x3D;&#x3D;&#x3D; &amp;#39;merge&amp;#39; &amp;amp;&amp;amp; this.config.webhooks?.validate_on_merge) {
            // TODO: Implement validation logic
            actions.push(&amp;#39;Triggered spec validation&amp;#39;);
          }

          await this.events.broadcastToProject(projectId, {
            project_id: projectId,
            event_type: &amp;#39;git_merge_processed&amp;#39;,
            data: {
              provider: &amp;#39;gitlab&amp;#39;,
              action: payload.action,
              mr_id: payload.merge_request.id,
              target_branch: payload.merge_request.target_branch,
              source_branch: payload.merge_request.source_branch,
            },
          });
        }
        break;

      default:
        actions.push(&#x60;Unhandled GitLab event: ${event}&#x60;);
    }

    return actions;
  }

  /**
   * Get webhook configuration for a project
   */
  async getWebhookConfig(projectId: string): Promise&amp;lt;WebhookConfig | null&amp;gt; {
    // TODO: Implement database storage for webhook configs
    // For now, return a basic config based on server settings
    if (!this.config.webhooks?.enabled) {
      return null;
    }

    return {
      id: generateId(),
      project_id: projectId,
      provider: &amp;#39;github&amp;#39;, // Default
      repository_url: &amp;#39;&amp;#39;,
      enabled: true,
      events: [&amp;#39;push&amp;#39;, &amp;#39;pull_request&amp;#39;],
      created_at: getCurrentTimestamp(),
      updated_at: getCurrentTimestamp(),
    };
  }

  /**
   * Create or update webhook configuration
   */
  async updateWebhookConfig(
    config: Partial&amp;lt;WebhookConfig&amp;gt; &amp;amp; { project_id: string }
  ): Promise&amp;lt;WebhookConfig&amp;gt; {
    // TODO: Implement database storage
    const webhookConfig: WebhookConfig &#x3D; {
      id: config.id || generateId(),
      project_id: config.project_id,
      provider: config.provider || &amp;#39;github&amp;#39;,
      repository_url: config.repository_url || &amp;#39;&amp;#39;,
      secret_hash: config.secret_hash,
      enabled: config.enabled ?? true,
      events: config.events || [&amp;#39;push&amp;#39;],
      created_at: config.created_at || getCurrentTimestamp(),
      updated_at: getCurrentTimestamp(),
    };

    logger.info(&amp;#39;Updated webhook config&amp;#39;, {
      projectId: config.project_id,
      provider: webhookConfig.provider,
    });

    return webhookConfig;
  }

  /**
   * Delete webhook configuration
   */
  async deleteWebhookConfig(projectId: string): Promise&amp;lt;boolean&amp;gt; {
    // TODO: Implement database deletion
    logger.info(&amp;#39;Deleted webhook config&amp;#39;, { projectId });
    return true;
  }

  /**
   * Get custom handler manager for API endpoints
   */
  getHandlerManager(): CustomHandlerManager {
    return this.handlerManager;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-14">
                <div class="file-header">📄 src/ir.ts</div>
                <div class="file-content">
                    <pre>/**
 * Intermediate Representation (IR) generator for diagrams and visualizations
 */
import type { IRKind, IRResponse } from &amp;#39;./types.ts&amp;#39;;
import { getCurrentTimestamp, logger } from &amp;#39;./utils.ts&amp;#39;;

export class IRGenerator {
  /**
   * Generate IR for different diagram types
   */
  async generateIR(kind: IRKind, resolved: Record&amp;lt;string, unknown&amp;gt;): Promise&amp;lt;IRResponse&amp;gt; {
    const startTime &#x3D; Date.now();

    try {
      let data: Record&amp;lt;string, unknown&amp;gt;;

      switch (kind) {
        case &amp;#39;flow&amp;#39;:
          data &#x3D; this.generateFlowIR(resolved);
          break;
        case &amp;#39;fsm&amp;#39;:
          data &#x3D; this.generateFsmIR(resolved);
          break;
        case &amp;#39;view&amp;#39;:
          data &#x3D; this.generateViewIR(resolved);
          break;
        case &amp;#39;site&amp;#39;:
          data &#x3D; this.generateSiteIR(resolved);
          break;
        case &amp;#39;capabilities&amp;#39;:
          data &#x3D; this.generateCapabilitiesIR(resolved);
          break;
        case &amp;#39;flows&amp;#39;:
          data &#x3D; this.generateFlowsIR(resolved);
          break;
        case &amp;#39;dependencies&amp;#39;:
          data &#x3D; this.generateDependenciesIR(resolved);
          break;
        case &amp;#39;coverage&amp;#39;:
          data &#x3D; this.generateCoverageIR(resolved);
          break;
        default:
          throw new Error(&#x60;Unknown IR kind: ${kind}&#x60;);
      }

      const duration &#x3D; Date.now() - startTime;

      // Reduced logging - only log for debug level when enabled
      // logger.debug(&amp;quot;Generated IR&amp;quot;, {
      //   kind,
      //   nodeCount: this.getNodeCount(data),
      //   duration,
      // });

      return {
        kind,
        data,
        generated_at: getCurrentTimestamp(),
      };
    } catch (error) {
      logger.error(&amp;#39;IR generation failed&amp;#39;, error instanceof Error ? error : undefined, { kind });

      throw new Error(
        &#x60;Failed to generate ${kind} IR: ${error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;}&#x60;
      );
    }
  }

  /**
   * Generate flow IR for Mermaid (flowchart/sequence) - from TODO.md specification
   */
  private generateFlowIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    const flows &#x3D; this.extractFlows(resolved);
    const flowIRs: any[] &#x3D; [];

    Object.entries(flows).forEach(([flowId, flow]) &#x3D;&amp;gt; {
      const nodes: any[] &#x3D; [];
      const edges: any[] &#x3D; [];

      if (Array.isArray(flow.steps)) {
        flow.steps.forEach((step: any, index: number) &#x3D;&amp;gt; {
          const nodeId &#x3D; step.id || &#x60;${index}&#x60;;
          const kind &#x3D; this.getFlowStepKind(step);
          const label &#x3D; this.getFlowStepLabel(step, index);

          nodes.push({
            id: nodeId,
            kind,
            label,
          });

          // Create edges based on dependsOn relationships
          if (step.dependsOn &amp;amp;&amp;amp; Array.isArray(step.dependsOn)) {
            step.dependsOn.forEach((depId: string) &#x3D;&amp;gt; {
              edges.push({
                from: depId,
                to: nodeId,
                label: step.transition || &amp;#39;&amp;#39;,
              });
            });
          }
        });
      }

      flowIRs.push({
        id: flowId,
        nodes,
        edges,
      });
    });

    return {
      specHash: this.computeSpecHash(resolved),
      flows: flowIRs,
    };
  }

  /**
   * Generate FSM IR for XState - from TODO.md specification
   */
  private generateFsmIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    // Handle both CUE format (states) and legacy format (stateModels)
    const stateModels &#x3D;
      (resolved.states as Record&amp;lt;string, any&amp;gt;) ||
      (resolved.stateModels as Record&amp;lt;string, any&amp;gt;) ||
      {};
    const fsms: any[] &#x3D; [];

    Object.entries(stateModels).forEach(([fsmId, model]) &#x3D;&amp;gt; {
      const states: Record&amp;lt;string, any&amp;gt; &#x3D; {};

      if (model.states &amp;amp;&amp;amp; typeof model.states &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39;) {
        Object.entries(model.states).forEach(([stateId, state]: [string, any]) &#x3D;&amp;gt; {
          states[stateId] &#x3D; {
            actions: state.actions || [],
            transitions: state.transitions || state.on || {},
          };
        });
      }

      fsms.push({
        id: fsmId,
        name: model.name || fsmId,
        initial: model.initialState || model.initial || &amp;#39;idle&amp;#39;,
        states,
      });
    });

    return {
      specHash: this.computeSpecHash(resolved),
      fsms,
    };
  }

  /**
   * Generate view IR for wireframes - from TODO.md specification
   */
  private generateViewIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    // Handle both CUE format (routes) and legacy format (ui.routes)
    const routes &#x3D; (resolved.routes as Record&amp;lt;string, any&amp;gt;) || (resolved.ui as any)?.routes || {};
    const locators &#x3D; (resolved.locators as Record&amp;lt;string, string&amp;gt;) || {};
    const views: any[] &#x3D; [];

    Object.entries(routes).forEach(([path, route]: [string, any]) &#x3D;&amp;gt; {
      const widgets: any[] &#x3D; [];

      // Extract widgets from route components and map with locators
      if (route.components &amp;amp;&amp;amp; Array.isArray(route.components)) {
        route.components.forEach((component: any) &#x3D;&amp;gt; {
          if (component.type &#x3D;&#x3D;&#x3D; &amp;#39;button&amp;#39; &amp;amp;&amp;amp; component.token) {
            widgets.push({
              type: &amp;#39;button&amp;#39;,
              token: component.token,
              text: component.text || component.token,
            });
          } else if (component.type &#x3D;&#x3D;&#x3D; &amp;#39;input&amp;#39; &amp;amp;&amp;amp; component.token) {
            widgets.push({
              type: &amp;#39;input&amp;#39;,
              token: component.token,
              label: component.label || component.token,
            });
          } else if (component.type &#x3D;&#x3D;&#x3D; &amp;#39;table&amp;#39; &amp;amp;&amp;amp; component.token) {
            widgets.push({
              type: &amp;#39;table&amp;#39;,
              token: component.token,
              columns: component.columns || [],
            });
          }
        });
      }

      // Also extract widgets from referenced locators
      Object.entries(locators).forEach(([token, _selector]) &#x3D;&amp;gt; {
        if (token.startsWith(&amp;#39;btn:&amp;#39;)) {
          widgets.push({
            type: &amp;#39;button&amp;#39;,
            token,
            text: token.replace(&amp;#39;btn:&amp;#39;, &amp;#39;&amp;#39;),
          });
        } else if (token.startsWith(&amp;#39;input:&amp;#39;)) {
          widgets.push({
            type: &amp;#39;input&amp;#39;,
            token,
            label: token.replace(&amp;#39;input:&amp;#39;, &amp;#39;&amp;#39;),
          });
        }
      });

      // Create view for each route (even without widgets for navigation structure)
      views.push({
        id: path,
        name: route.name || path,
        component: route.component,
        layout: route.layout,
        requiresAuth: route.requiresAuth || false,
        widgets,
      });
    });

    return {
      specHash: this.computeSpecHash(resolved),
      views,
    };
  }

  /**
   * Generate site IR (DAG of routes) for Graphviz - from TODO.md specification
   */
  private generateSiteIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    const routes &#x3D; (resolved.ui as any)?.routes || [];
    const nodes: any[] &#x3D; [];
    const edges: any[] &#x3D; [];

    // Create nodes for each route
    routes.forEach((route: any) &#x3D;&amp;gt; {
      nodes.push({
        id: route.id || route.path,
        label: route.name || route.path,
        path: route.path,
        capabilities: route.capabilities || [],
      });
    });

    // Create edges based on route relationships and navigation patterns
    routes.forEach((route: any, index: number) &#x3D;&amp;gt; {
      const routeId &#x3D; route.id || route.path;

      // Connect routes that share capabilities (simplified relationship detection)
      routes.forEach((otherRoute: any, otherIndex: number) &#x3D;&amp;gt; {
        if (index !&#x3D;&#x3D; otherIndex &amp;amp;&amp;amp; route.capabilities &amp;amp;&amp;amp; otherRoute.capabilities) {
          const sharedCaps &#x3D; route.capabilities.filter((cap: string) &#x3D;&amp;gt;
            otherRoute.capabilities.includes(cap)
          );

          if (sharedCaps.length &amp;gt; 0) {
            const otherRouteId &#x3D; otherRoute.id || otherRoute.path;
            edges.push({
              from: routeId,
              to: otherRouteId,
              label: sharedCaps.join(&amp;#39;, &amp;#39;),
              type: &amp;#39;capability&amp;#39;,
            });
          }
        }
      });
    });

    return {
      specHash: this.computeSpecHash(resolved),
      routes: {
        nodes,
        edges,
      },
    };
  }

  private extractFlows(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, any&amp;gt; {
    return (resolved.flows as Record&amp;lt;string, any&amp;gt;) || {};
  }

  private getNodeCount(data: Record&amp;lt;string, unknown&amp;gt;): number {
    const nodes &#x3D; data.nodes;
    return Array.isArray(nodes) ? nodes.length : 0;
  }

  // New helper methods for TODO.md specification compliance
  private getFlowStepKind(step: any): string {
    // Handle CUE specification format
    if (step.type) return step.type;

    // Fallback to legacy test format
    if (step.visit) return &amp;#39;visit&amp;#39;;
    if (step.click) return &amp;#39;click&amp;#39;;
    if (step.fill) return &amp;#39;fill&amp;#39;;
    if (step.expect) return &amp;#39;expect&amp;#39;;
    if (step.expect_api) return &amp;#39;expect_api&amp;#39;;
    return &amp;#39;process&amp;#39;;
  }

  private getFlowStepLabel(step: any, index: number): string {
    // Handle CUE specification format
    if (step.name) return step.name;

    // Fallback to legacy test format
    if (step.visit) return &#x60;Visit: ${step.visit}&#x60;;
    if (step.click) return &#x60;Click: ${step.click}&#x60;;
    if (step.fill) return &#x60;Fill: ${step.fill}&#x60;;
    if (step.expect) return &#x60;Expect: ${step.expect.locator || step.expect}&#x60;;
    if (step.expect_api) return &#x60;API: ${step.expect_api.method} ${step.expect_api.path}&#x60;;
    return &#x60;Step ${index + 1}&#x60;;
  }

  private computeSpecHash(resolved: Record&amp;lt;string, unknown&amp;gt;): string {
    // Simple hash computation - in production you&amp;#39;d want a proper hash like SHA-256
    return &#x60;sha256-${JSON.stringify(resolved).length.toString(16)}&#x60;;
  }

  /**
   * Generate capabilities IR for dependency graph visualization
   */
  private generateCapabilitiesIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    const capabilities &#x3D;
      resolved.capabilities &amp;amp;&amp;amp;
      typeof resolved.capabilities &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp;
      !Array.isArray(resolved.capabilities)
        ? (resolved.capabilities as Record&amp;lt;string, any&amp;gt;)
        : {};
    const nodes: any[] &#x3D; [];
    const edges: any[] &#x3D; [];
    const groups: any[] &#x3D; [];
    const domains &#x3D; new Set&amp;lt;string&amp;gt;();

    // Process capabilities into nodes
    Object.entries(capabilities).forEach(([capId, capability]) &#x3D;&amp;gt; {
      const domain &#x3D; capId.split(&amp;#39;.&amp;#39;)[0];
      domains.add(domain);

      nodes.push({
        id: capId,
        label: capability.name || capId,
        type: &amp;#39;capability&amp;#39;,
        domain: domain,
        properties: {
          complexity: capability.complexity || &amp;#39;medium&amp;#39;,
          priority: capability.priority || &amp;#39;medium&amp;#39;,
          owner: capability.owner || &amp;#39;unknown&amp;#39;,
        },
      });

      // Create dependency edges
      if (capability.depends_on &amp;amp;&amp;amp; Array.isArray(capability.depends_on)) {
        capability.depends_on.forEach((depId: string) &#x3D;&amp;gt; {
          edges.push({
            source: depId,
            target: capId,
            type: &amp;#39;dependency&amp;#39;,
          });
        });
      }
    });

    // Create domain groups
    domains.forEach(domain &#x3D;&amp;gt; {
      const domainNodes &#x3D; nodes.filter(n &#x3D;&amp;gt; n.domain &#x3D;&#x3D;&#x3D; domain);
      groups.push({
        id: domain,
        label: domain.charAt(0).toUpperCase() + domain.slice(1),
        nodeIds: domainNodes.map(n &#x3D;&amp;gt; n.id),
      });
    });

    return {
      type: &amp;#39;directed_graph&amp;#39;,
      nodes,
      edges,
      groups,
      layout: {
        algorithm: &amp;#39;hierarchical&amp;#39;,
      },
      metadata: {
        totalCapabilities: nodes.length,
        dependencies: edges.length,
        domains: domains.size,
      },
    };
  }

  /**
   * Generate flows IR for flowchart visualization (alias for flow)
   */
  private generateFlowsIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    const flows &#x3D;
      resolved.flows &amp;amp;&amp;amp; typeof resolved.flows &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp; !Array.isArray(resolved.flows)
        ? (resolved.flows as Record&amp;lt;string, any&amp;gt;)
        : {};
    const flowList: any[] &#x3D; [];
    const nodes: any[] &#x3D; [];
    const edges: any[] &#x3D; [];
    let totalSteps &#x3D; 0;
    let totalDecisions &#x3D; 0;

    Object.entries(flows).forEach(([flowId, flow]) &#x3D;&amp;gt; {
      const flowSteps &#x3D; flow.steps || [];
      totalSteps +&#x3D; flowSteps.length;

      // Add flow to list
      flowList.push({
        id: flowId,
        name: flow.name || flowId,
        trigger: flow.trigger,
        outcome: flow.outcome,
        steps: flowSteps,
      });

      // Generate nodes for each step
      flowSteps.forEach((step: any, index: number) &#x3D;&amp;gt; {
        const nodeId &#x3D; &#x60;${flowId}.${index}&#x60;;

        nodes.push({
          id: nodeId,
          label: step.name || &#x60;Step ${index + 1}&#x60;,
          type: &amp;#39;process&amp;#39;,
          properties: {
            action: step.action,
            actor: step.actor,
            duration: step.estimated_duration,
            complexity: step.complexity,
          },
        });

        // Create sequence edges
        if (index &amp;gt; 0) {
          edges.push({
            source: &#x60;${flowId}.${index - 1}&#x60;,
            target: nodeId,
            type: &amp;#39;sequence&amp;#39;,
          });
        }

        // Handle branches (decision nodes)
        if (step.branches &amp;amp;&amp;amp; Array.isArray(step.branches)) {
          step.branches.forEach((branch: any, branchIndex: number) &#x3D;&amp;gt; {
            const decisionNodeId &#x3D; &#x60;${nodeId}.${branch.condition}&#x60;;
            totalDecisions++;

            nodes.push({
              id: decisionNodeId,
              label: branch.name || branch.condition,
              type: &amp;#39;decision&amp;#39;,
              properties: {
                condition: branch.condition,
                description: branch.description,
              },
            });

            edges.push({
              source: nodeId,
              target: decisionNodeId,
              type: &amp;#39;branch&amp;#39;,
              label: branch.condition,
            });
          });
        }
      });
    });

    return {
      type: &amp;#39;flowchart&amp;#39;,
      nodes,
      edges,
      flows: flowList,
      layout: {
        algorithm: &amp;#39;dagre&amp;#39;,
      },
      metadata: {
        totalFlows: flowList.length,
        totalSteps,
        totalDecisions,
      },
    };
  }

  /**
   * Generate dependencies IR for layered graph visualization
   */
  private generateDependenciesIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    const capabilities &#x3D;
      resolved.capabilities &amp;amp;&amp;amp;
      typeof resolved.capabilities &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp;
      !Array.isArray(resolved.capabilities)
        ? (resolved.capabilities as Record&amp;lt;string, any&amp;gt;)
        : {};
    const services &#x3D;
      resolved.services &amp;amp;&amp;amp;
      typeof resolved.services &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp;
      !Array.isArray(resolved.services)
        ? (resolved.services as Record&amp;lt;string, any&amp;gt;)
        : {};
    const layers: any[] &#x3D; [];
    const nodes: any[] &#x3D; [];
    const edges: any[] &#x3D; [];
    const processed &#x3D; new Set&amp;lt;string&amp;gt;();
    let layerIndex &#x3D; 0;

    // Add capability nodes
    Object.entries(capabilities).forEach(([capId, capability]) &#x3D;&amp;gt; {
      nodes.push({
        id: capId,
        label: capability.name || capId,
        type: &amp;#39;capability&amp;#39;,
        properties: {
          dependencies: capability.depends_on || [],
        },
      });

      // Add dependency edges
      if (capability.depends_on &amp;amp;&amp;amp; Array.isArray(capability.depends_on)) {
        capability.depends_on.forEach((depId: string) &#x3D;&amp;gt; {
          edges.push({
            source: depId,
            target: capId,
            type: &amp;#39;depends&amp;#39;,
          });
        });
      }
    });

    // Add service nodes
    Object.entries(services).forEach(([serviceId, service]) &#x3D;&amp;gt; {
      nodes.push({
        id: serviceId,
        label: service.name || serviceId,
        type: &amp;#39;service&amp;#39;,
        properties: {
          technology: service.technology,
          environment: service.environment,
          implements: service.implements || [],
        },
      });

      // Add implementation edges
      if (service.implements &amp;amp;&amp;amp; Array.isArray(service.implements)) {
        service.implements.forEach((capId: string) &#x3D;&amp;gt; {
          edges.push({
            source: serviceId,
            target: capId,
            type: &amp;#39;implements&amp;#39;,
          });
        });
      }
    });

    // Create logical layers (capabilities and services)
    const capabilityNodes &#x3D; nodes.filter(n &#x3D;&amp;gt; n.type &#x3D;&#x3D;&#x3D; &amp;#39;capability&amp;#39;);
    const serviceNodes &#x3D; nodes.filter(n &#x3D;&amp;gt; n.type &#x3D;&#x3D;&#x3D; &amp;#39;service&amp;#39;);

    if (capabilityNodes.length &amp;gt; 0) {
      layers.push({
        id: &amp;#39;business&amp;#39;,
        label: &amp;#39;Business Layer&amp;#39;,
        nodeIds: capabilityNodes.map(n &#x3D;&amp;gt; n.id),
      });
    }

    if (serviceNodes.length &amp;gt; 0) {
      layers.push({
        id: &amp;#39;application&amp;#39;,
        label: &amp;#39;Application Layer&amp;#39;,
        nodeIds: serviceNodes.map(n &#x3D;&amp;gt; n.id),
      });
    }

    return {
      type: &amp;#39;layered_graph&amp;#39;,
      nodes,
      edges,
      layers,
      layout: {
        algorithm: &amp;#39;layered&amp;#39;,
      },
    };
  }

  /**
   * Generate coverage IR for test coverage visualization
   */
  private generateCoverageIR(resolved: Record&amp;lt;string, unknown&amp;gt;): Record&amp;lt;string, unknown&amp;gt; {
    const capabilities &#x3D;
      resolved.capabilities &amp;amp;&amp;amp;
      typeof resolved.capabilities &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp;
      !Array.isArray(resolved.capabilities)
        ? (resolved.capabilities as Record&amp;lt;string, any&amp;gt;)
        : {};
    const tests &#x3D;
      resolved.tests &amp;amp;&amp;amp; typeof resolved.tests &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp; !Array.isArray(resolved.tests)
        ? (resolved.tests as Record&amp;lt;string, any&amp;gt;)
        : {};
    const requirements &#x3D;
      resolved.requirements &amp;amp;&amp;amp;
      typeof resolved.requirements &#x3D;&#x3D;&#x3D; &amp;#39;object&amp;#39; &amp;amp;&amp;amp;
      !Array.isArray(resolved.requirements)
        ? (resolved.requirements as Record&amp;lt;string, any&amp;gt;)
        : {};

    const nodes: any[] &#x3D; [];
    const edges: any[] &#x3D; [];
    const coverage: Record&amp;lt;string, any&amp;gt; &#x3D; {};
    let fullyTested &#x3D; 0;
    let partiallyTested &#x3D; 0;
    let untested &#x3D; 0;

    // Add capability nodes and calculate coverage
    Object.entries(capabilities).forEach(([capId, capability]) &#x3D;&amp;gt; {
      const coveringTests &#x3D; Object.entries(tests).filter(([_, test]) &#x3D;&amp;gt; {
        const covers &#x3D; test.covers || [];
        return covers.includes(capId);
      });

      const relatedRequirements &#x3D; Object.entries(requirements).filter(([_, req]) &#x3D;&amp;gt; {
        return req.capability &#x3D;&#x3D;&#x3D; capId;
      });

      const testCount &#x3D; coveringTests.length;
      const requirementCount &#x3D; relatedRequirements.length;

      // Coverage calculation: tests + requirements (simplified)
      let coveragePercentage &#x3D; 0;
      if (testCount &amp;gt;&#x3D; 8 &amp;amp;&amp;amp; requirementCount &amp;gt;&#x3D; 2) {
        coveragePercentage &#x3D; 100;
        fullyTested++;
      } else if (testCount &amp;gt;&#x3D; 1 || requirementCount &amp;gt;&#x3D; 1) {
        coveragePercentage &#x3D; Math.min(80, testCount * 10 + requirementCount * 20);
        partiallyTested++;
      } else {
        coveragePercentage &#x3D; 0;
        untested++;
      }

      nodes.push({
        id: capId,
        label: capability.name || capId,
        type: &amp;#39;capability&amp;#39;,
        properties: {
          testCount,
          requirementCount,
          coverage: coveragePercentage,
        },
      });

      coverage[capId] &#x3D; {
        covered: testCount &amp;gt; 0,
        testCount,
        requirementCount,
        coveragePercentage,
        tests: coveringTests.map(([testId, _]) &#x3D;&amp;gt; testId),
        requirements: relatedRequirements.map(([reqId, _]) &#x3D;&amp;gt; reqId),
      };
    });

    // Add test nodes
    Object.entries(tests).forEach(([testId, test]) &#x3D;&amp;gt; {
      nodes.push({
        id: testId,
        label: test.name || testId,
        type: &amp;#39;test&amp;#39;,
        properties: {
          covers: test.covers || [],
        },
      });

      // Add coverage edges from tests to capabilities
      if (test.covers &amp;amp;&amp;amp; Array.isArray(test.covers)) {
        test.covers.forEach((capId: string) &#x3D;&amp;gt; {
          edges.push({
            source: testId,
            target: capId,
            type: &amp;#39;covers&amp;#39;,
          });
        });
      }
    });

    // Add requirement nodes
    Object.entries(requirements).forEach(([reqId, req]) &#x3D;&amp;gt; {
      nodes.push({
        id: reqId,
        label: req.name || reqId,
        type: &amp;#39;requirement&amp;#39;,
        properties: {
          capability: req.capability,
        },
      });

      // Add specifies edges from requirements to capabilities
      if (req.capability) {
        edges.push({
          source: reqId,
          target: req.capability,
          type: &amp;#39;specifies&amp;#39;,
        });
      }
    });

    const totalCapabilities &#x3D; Object.keys(capabilities).length;
    const overallCoverage &#x3D;
      totalCapabilities &amp;gt; 0
        ? Math.round(((fullyTested + partiallyTested) / totalCapabilities) * 100)
        : 0;

    return {
      type: &amp;#39;coverage_graph&amp;#39;,
      nodes,
      edges,
      coverage: {
        overall: overallCoverage,
        fullyTested,
        partiallyTested,
        untested,
        details: coverage,
      },
      layout: {
        algorithm: &amp;#39;force&amp;#39;,
      },
      metadata: {
        totalCapabilities,
        totalTests: Object.keys(tests).length,
        totalRequirements: Object.keys(requirements).length,
      },
    };
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-15">
                <div class="file-header">📄 src/handlers/sandbox.ts</div>
                <div class="file-content">
                    <pre>import { pathToFileURL } from &amp;quot;node:url&amp;quot;;
import vm from &amp;quot;node:vm&amp;quot;;
import type { Logger } from &amp;quot;./types.js&amp;quot;;

export interface SandboxResult&amp;lt;T &#x3D; unknown&amp;gt; {
  success: boolean;
  value?: T;
  error?: Error;
  logs: Array&amp;lt;{ level: &amp;quot;info&amp;quot; | &amp;quot;warn&amp;quot; | &amp;quot;error&amp;quot;; message: string; data?: any }&amp;gt;;
}

export interface SandboxOptions {
  code: string;
  context?: Record&amp;lt;string, unknown&amp;gt;;
  timeoutMs?: number;
  filename?: string;
}

const DEFAULT_TIMEOUT &#x3D; 2000;

export class HandlerSandbox {
  constructor(private logger: Logger) {}

  async run&amp;lt;T &#x3D; unknown&amp;gt;(options: SandboxOptions): Promise&amp;lt;SandboxResult&amp;lt;T&amp;gt;&amp;gt; {
    const logs: SandboxResult[&amp;quot;logs&amp;quot;] &#x3D; [];
    const sandboxLogger: Logger &#x3D; {
      info: (message, data) &#x3D;&amp;gt; logs.push({ level: &amp;quot;info&amp;quot;, message, data }),
      warn: (message, data) &#x3D;&amp;gt; logs.push({ level: &amp;quot;warn&amp;quot;, message, data }),
      error: (message, data) &#x3D;&amp;gt; logs.push({ level: &amp;quot;error&amp;quot;, message, data }),
      debug: () &#x3D;&amp;gt; {},
    };

    const context &#x3D; {
      console: {
        log: (...args: unknown[]) &#x3D;&amp;gt; logs.push({ level: &amp;quot;info&amp;quot;, message: args.join(&amp;quot; &amp;quot;) }),
        warn: (...args: unknown[]) &#x3D;&amp;gt; logs.push({ level: &amp;quot;warn&amp;quot;, message: args.join(&amp;quot; &amp;quot;) }),
        error: (...args: unknown[]) &#x3D;&amp;gt; logs.push({ level: &amp;quot;error&amp;quot;, message: args.join(&amp;quot; &amp;quot;) }),
      },
      logger: sandboxLogger,
      ...options.context,
    };

    const vmContext &#x3D; vm.createContext(context, {
      name: &amp;quot;handler-sandbox&amp;quot;,
      codeGeneration: { strings: false, wasm: false },
    });

    try {
      const script &#x3D; new vm.Script(options.code, {
        filename: options.filename ?? &amp;quot;handler.js&amp;quot;,
        displayErrors: true,
      });

      script.runInContext(vmContext, {
        timeout: options.timeoutMs ?? DEFAULT_TIMEOUT,
      });

      const exported &#x3D; (vmContext.module?.exports ?? vmContext.exports) as T;

      return { success: true, value: exported, logs };
    } catch (error) {
      this.logger.error(&amp;quot;Sandbox execution failed&amp;quot;, error as Error);
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
        logs,
      };
    }
  }

  validate(code: string): { safe: boolean; violations: string[] } {
    const violations: string[] &#x3D; [];
    if (/process\./.test(code)) {
      violations.push(&amp;quot;Usage of process.* is not allowed&amp;quot;);
    }
    if (/require\s*\(/.test(code) || /import\s*\(/.test(code)) {
      violations.push(&amp;quot;Dynamic module loading is not allowed&amp;quot;);
    }
    return { safe: violations.length &#x3D;&#x3D;&#x3D; 0, violations };
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-16">
                <div class="file-header">📄 src/handlers/loader.ts</div>
                <div class="file-content">
                    <pre>import { readFile } from &amp;quot;node:fs/promises&amp;quot;;
import { HandlerSandbox } from &amp;quot;./sandbox.js&amp;quot;;
import type { HandlerModule, Logger, RegisteredHandler } from &amp;quot;./types.js&amp;quot;;

export class HandlerLoader {
  private sandbox: HandlerSandbox;

  constructor(private logger: Logger) {
    this.sandbox &#x3D; new HandlerSandbox(logger);
  }

  async load(handler: RegisteredHandler): Promise&amp;lt;HandlerModule&amp;gt; {
    const code &#x3D; await readFile(handler.handlerPath, &amp;quot;utf-8&amp;quot;);
    const validation &#x3D; this.sandbox.validate(code);
    if (!validation.safe) {
      throw new Error(&#x60;Handler code contains unsafe patterns: ${validation.violations.join(&amp;quot;, &amp;quot;)}&#x60;);
    }

    const sandboxResult &#x3D; await this.sandbox.run&amp;lt;HandlerModule&amp;gt;({
      code,
      filename: handler.handlerPath,
      context: {
        exports: {},
        module: { exports: {} },
        require: undefined,
        process: undefined,
      },
      timeoutMs: handler.config.timeout,
    });

    if (!sandboxResult.success || !sandboxResult.value) {
      throw sandboxResult.error || new Error(&amp;quot;Handler execution failed to initialize&amp;quot;);
    }

    if (sandboxResult.logs.length &amp;gt; 0) {
      sandboxResult.logs.forEach((log) &#x3D;&amp;gt; {
        this.logger.info(&#x60;[sandbox:${log.level}] ${log.message}&#x60;, log.data);
      });
    }

    const moduleExports &#x3D; sandboxResult.value;
    if (!moduleExports || typeof moduleExports.handler !&#x3D;&#x3D; &amp;quot;function&amp;quot;) {
      throw new Error(&amp;quot;Handler module must export a handler function&amp;quot;);
    }

    return moduleExports as HandlerModule;
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-17">
                <div class="file-header">📄 src/server.ts</div>
                <div class="file-content">
                    <pre>/**
 * Refactored Bun HTTP server with modular architecture
 *
 * This version replaces the massive 111KB monolithic server with a clean,
 * modular architecture that separates concerns into dedicated modules:
 *
 * - routes/: API endpoints using Hono framework
 * - websocket/: WebSocket connection and message handling
 * - mcp/: Model Context Protocol tool handlers
 * - static/: Static file serving for frontend
 */
import type { ServerWebSocket } from &amp;#39;bun&amp;#39;;
import { Hono } from &amp;#39;hono&amp;#39;;
import { AuthService } from &amp;#39;./auth.ts&amp;#39;;
import { loadConfig } from &amp;#39;./config.ts&amp;#39;;
import { SpecWorkbenchDB } from &amp;#39;./db.ts&amp;#39;;
import { EventService } from &amp;#39;./events.ts&amp;#39;;
import { HandlerAPIController } from &amp;#39;./handlers/api.js&amp;#39;;
import { IRGenerator } from &amp;#39;./ir.ts&amp;#39;;
import { SpecEngine } from &amp;#39;./specEngine.ts&amp;#39;;
import type { ServerConfig } from &amp;#39;./types.ts&amp;#39;;
import { createProblemDetails, logger } from &amp;#39;./utils.ts&amp;#39;;
import { WebhookService } from &amp;#39;./webhooks.ts&amp;#39;;

import { createMcpApp } from &amp;#39;./mcp.ts&amp;#39;;
// Import modular components
import { type Dependencies, createApiRouter } from &amp;#39;./routes/index.ts&amp;#39;;
import { StaticFileHandler } from &amp;#39;./static/index.ts&amp;#39;;
import { WebSocketHandler } from &amp;#39;./websocket/index.ts&amp;#39;;

export class SpecWorkbenchServer {
  private db: SpecWorkbenchDB;
  private auth: AuthService;
  private specEngine: SpecEngine;
  private irGenerator: IRGenerator;
  private events: EventService;
  private webhooks: WebhookService;
  private handlersApi: HandlerAPIController;

  // Modular components
  private apiRouter: ReturnType&amp;lt;typeof createApiRouter&amp;gt;;
  private httpApp: Hono;
  private wsHandler: WebSocketHandler;
  private mcpApp: ReturnType&amp;lt;typeof createMcpApp&amp;gt;;
  private staticHandler: StaticFileHandler;

  constructor(private config: ServerConfig) {
    // Initialize core services
    this.db &#x3D; new SpecWorkbenchDB(config);
    this.auth &#x3D; new AuthService(config);
    this.specEngine &#x3D; new SpecEngine(config);
    this.irGenerator &#x3D; new IRGenerator();
    this.events &#x3D; new EventService(config);
    this.webhooks &#x3D; new WebhookService(config, this.events, this.db);
    this.handlersApi &#x3D; new HandlerAPIController(this.webhooks.getHandlerManager());

    // Initialize modular components
    const dependencies: Dependencies &#x3D; {
      db: this.db,
      specEngine: this.specEngine,
      events: this.events,
      auth: this.auth,
      webhooks: this.webhooks,
      handlersApi: this.handlersApi,
      config: this.config,
    };

    this.apiRouter &#x3D; createApiRouter(dependencies);
    this.httpApp &#x3D; new Hono();
    this.wsHandler &#x3D; new WebSocketHandler(this.auth, this.events, config.websocket);
    this.mcpApp &#x3D; createMcpApp();
    this.staticHandler &#x3D; new StaticFileHandler();

    this.httpApp.use(&amp;#39;*&amp;#39;, async (c, next) &#x3D;&amp;gt; {
      await next();

      if (c.res) {
        const corsHeaders &#x3D; this.getCorsHeaders();
        for (const [key, value] of Object.entries(corsHeaders)) {
          if (!c.res.headers.has(key)) {
            c.res.headers.set(key, value);
          }
        }
      }
    });

    this.httpApp.route(&amp;#39;/&amp;#39;, this.apiRouter);

    this.httpApp.route(&amp;#39;/&amp;#39;, this.mcpApp);

    this.httpApp.all(&amp;#39;/webhooks/*&amp;#39;, async c &#x3D;&amp;gt; {
      const corsHeaders &#x3D; this.getCorsHeaders();
      return await this.webhooks.handleRequest(c.req.raw, corsHeaders);
    });

    this.httpApp.notFound(async c &#x3D;&amp;gt; {
      const corsHeaders &#x3D; this.getCorsHeaders();
      const pathname &#x3D; new URL(c.req.url).pathname;

      if (this.staticHandler.shouldServeStaticFile(pathname)) {
        return await this.staticHandler.serveFile(pathname, corsHeaders);
      }

      return this.createNotFoundResponse(pathname, corsHeaders);
    });

    this.httpApp.onError((err, c) &#x3D;&amp;gt; {
      return this.handleRequestError(err, c.req.method, new URL(c.req.url).pathname);
    });
  }

  /**
   * Start the server
   */
  async start(): Promise&amp;lt;void&amp;gt; {
    const self &#x3D; this;

    // Start OAuth service if enabled
    await this.auth.startOAuthService();

    const _server &#x3D; Bun.serve({
      port: this.config.port,
      hostname: this.config.host,

      async fetch(request, server) {
        console.log(&amp;#39;[FETCH] Request received:&amp;#39;, request.method, request.url);

        // Check for WebSocket upgrade requests explicitly
        const url &#x3D; new URL(request.url);
        if (
          url.pathname &#x3D;&#x3D;&#x3D; &amp;#39;/events&amp;#39; &amp;amp;&amp;amp;
          request.headers.get(&amp;#39;upgrade&amp;#39;)?.toLowerCase() &#x3D;&#x3D;&#x3D; &amp;#39;websocket&amp;#39;
        ) {
          logger.info(&amp;#39;[SERVER] WebSocket upgrade request detected&amp;#39;, {
            pathname: url.pathname,
            headers: {
              upgrade: request.headers.get(&amp;#39;upgrade&amp;#39;),
              connection: request.headers.get(&amp;#39;connection&amp;#39;),
              origin: request.headers.get(&amp;#39;origin&amp;#39;),
            },
          });

          // Handle authentication here before upgrade
          const authContext &#x3D; await self.auth.authenticateRequest(request.headers);

          logger.info(&amp;#39;[SERVER] WebSocket auth result&amp;#39;, {
            hasAuth: !!authContext,
            authContext: authContext || &amp;#39;NO_AUTH&amp;#39;,
          });

          if (!authContext) {
            logger.warn(&amp;#39;[SERVER] WebSocket auth failed - rejecting upgrade&amp;#39;);
            return new Response(&amp;#39;Unauthorized&amp;#39;, { status: 401 });
          }

          // Perform the upgrade with auth context
          const upgraded &#x3D; server.upgrade(request, {
            data: {
              connectionId: &amp;#39;&amp;#39;,
              authContext,
            },
          });

          logger.info(&amp;#39;[SERVER] WebSocket upgrade result&amp;#39;, {
            upgraded: upgraded ? &amp;#39;SUCCESS&amp;#39; : &amp;#39;FAILED&amp;#39;,
          });

          if (!upgraded) {
            return new Response(&amp;#39;WebSocket upgrade failed&amp;#39;, { status: 400 });
          }

          return undefined; // Successful upgrade, no response needed
        }

        return await self.handleRequest(request, server);
      },

      websocket: {
        message: async (ws, message) &#x3D;&amp;gt; {
          await self.wsHandler.handleMessage(
            ws as any,
            typeof message &#x3D;&#x3D;&#x3D; &amp;#39;string&amp;#39; ? message : message.toString()
          );
        },

        open: ws &#x3D;&amp;gt; {
          self.wsHandler.handleOpen(ws as any);
        },

        close: ws &#x3D;&amp;gt; {
          self.wsHandler.handleClose(ws as any);
        },
      },
    });

    logger.info(&amp;#39;🚀 Arbiter API server started&amp;#39;, {
      port: this.config.port,
      host: this.config.host,
      environment: process.env.NODE_ENV || &amp;#39;development&amp;#39;,
    });
  }

  /**
   * Get CORS headers
   */
  private getCorsHeaders(): Record&amp;lt;string, string&amp;gt; {
    return {
      &amp;#39;Access-Control-Allow-Origin&amp;#39;: &amp;#39;*&amp;#39;,
      &amp;#39;Access-Control-Allow-Methods&amp;#39;: &amp;#39;GET, POST, PUT, DELETE, PATCH, OPTIONS&amp;#39;,
      &amp;#39;Access-Control-Allow-Headers&amp;#39;:
        &amp;#39;Content-Type, Authorization, X-Requested-With, Accept, Origin, X-API-Key, &amp;#39; +
        &amp;#39;X-GitHub-Event, X-Hub-Signature-256, X-GitLab-Event, X-GitLab-Token&amp;#39;,
      &amp;#39;Access-Control-Expose-Headers&amp;#39;: &amp;#39;Content-Length, X-Request-ID&amp;#39;,
      &amp;#39;Access-Control-Allow-Credentials&amp;#39;: &amp;#39;true&amp;#39;,
      &amp;#39;Access-Control-Max-Age&amp;#39;: &amp;#39;86400&amp;#39;,
    };
  }

  /**
   * Handle preflight requests
   */
  private handlePreflightRequest(corsHeaders: Record&amp;lt;string, string&amp;gt;): Response {
    return new Response(null, {
      status: 204,
      headers: corsHeaders,
    });
  }

  /**
   * Main request handler - routes to appropriate modules
   */
  private async handleRequest(request: Request, server: any): Promise&amp;lt;Response&amp;gt; {
    const url &#x3D; new URL(request.url);
    const method &#x3D; request.method;
    const pathname &#x3D; url.pathname;

    try {
      logger.info(&amp;#39;[SERVER] Request received&amp;#39;, {
        method,
        pathname,
        url: url.toString(),
        requestHeaders: {
          upgrade: request.headers.get(&amp;#39;upgrade&amp;#39;),
          connection: request.headers.get(&amp;#39;connection&amp;#39;),
          origin: request.headers.get(&amp;#39;origin&amp;#39;),
          userAgent: request.headers.get(&amp;#39;user-agent&amp;#39;),
        },
      });

      const corsHeaders &#x3D; this.getCorsHeaders();

      if (method &#x3D;&#x3D;&#x3D; &amp;#39;OPTIONS&amp;#39;) {
        logger.info(&amp;#39;[SERVER] Handling OPTIONS preflight&amp;#39;);
        return this.handlePreflightRequest(corsHeaders);
      }

      logger.info(&amp;#39;[SERVER] Checking if WebSocket upgrade...&amp;#39;);
      if (this.wsHandler.isWebSocketUpgrade(pathname, request)) {
        logger.info(&amp;#39;[SERVER] WebSocket upgrade detected - calling handleUpgrade&amp;#39;);
        const upgradeResult &#x3D; await this.wsHandler.handleUpgrade(request, server);
        logger.info(&amp;#39;[SERVER] Upgrade result&amp;#39;, {
          hasResponse: !!upgradeResult.response,
          result: upgradeResult.response ? &amp;#39;Response returned&amp;#39; : &amp;#39;Success&amp;#39;,
        });
        return upgradeResult.response || new Response(&amp;#39;WebSocket upgrade successful&amp;#39;);
      }

      logger.info(&amp;#39;[SERVER] Not a WebSocket upgrade - proceeding to app routing&amp;#39;);

      logger.info(&amp;#39;[SERVER] Passing to httpApp.fetch&amp;#39;);
      return await this.httpApp.fetch(request);
    } catch (error) {
      console.log(&amp;#39;[SERVER] Error in handleRequest:&amp;#39;, error);
      return this.handleRequestError(error, method, pathname);
    }
  }

  /**
   * Create 404 Not Found response
   */
  private createNotFoundResponse(pathname: string, corsHeaders: Record&amp;lt;string, string&amp;gt;): Response {
    return new Response(
      JSON.stringify(
        createProblemDetails(
          404,
          &amp;#39;Not Found&amp;#39;,
          &#x60;Route ${pathname} not found&#x60;,
          undefined, // type
          undefined, // instance
          {
            available_endpoints: [&amp;#39;/health&amp;#39;, &amp;#39;/status&amp;#39;, &amp;#39;/mcp&amp;#39;, &amp;#39;/api/*&amp;#39;, &amp;#39;/ws&amp;#39;],
          }
        )
      ),
      {
        status: 404,
        headers: {
          &amp;#39;Content-Type&amp;#39;: &amp;#39;application/problem+json&amp;#39;,
          ...corsHeaders,
        },
      }
    );
  }

  /**
   * Handle request errors
   */
  private handleRequestError(error: unknown, method: string, pathname: string): Response {
    logger.error(&amp;#39;Request handling error&amp;#39;, error instanceof Error ? error : undefined, {
      method,
      pathname,
    });

    return new Response(
      JSON.stringify(
        createProblemDetails(500, &amp;#39;Internal Server Error&amp;#39;, &amp;#39;An unexpected error occurred&amp;#39;)
      ),
      {
        status: 500,
        headers: {
          &amp;#39;Content-Type&amp;#39;: &amp;#39;application/problem+json&amp;#39;,
          &amp;#39;Access-Control-Allow-Origin&amp;#39;: &amp;#39;*&amp;#39;,
        },
      }
    );
  }

  /**
   * Get client ID for rate limiting
   */
  private getClientId(request: Request): string {
    const forwarded &#x3D; request.headers.get(&amp;#39;x-forwarded-for&amp;#39;);
    const realIp &#x3D; request.headers.get(&amp;#39;x-real-ip&amp;#39;);
    const cfConnectingIp &#x3D; request.headers.get(&amp;#39;cf-connecting-ip&amp;#39;);

    // Use the first available IP, preferring Cloudflare&amp;#39;s
    const ip &#x3D; cfConnectingIp || realIp || forwarded?.split(&amp;#39;,&amp;#39;)[0] || &amp;#39;unknown&amp;#39;;

    // Include user agent for better rate limiting granularity
    const userAgent &#x3D; request.headers.get(&amp;#39;user-agent&amp;#39;) || &amp;#39;unknown&amp;#39;;
    const authHeader &#x3D; request.headers.get(&amp;#39;authorization&amp;#39;);

    // If there&amp;#39;s an auth header, use that for rate limiting (per user)
    if (authHeader) {
      return &#x60;auth:${authHeader.substring(0, 32)}&#x60;;
    }

    // Otherwise use IP + User Agent
    return &#x60;ip:${ip}:${userAgent.substring(0, 32)}&#x60;;
  }

  /**
   * Graceful shutdown
   */
  async shutdown(): Promise&amp;lt;void&amp;gt; {
    logger.info(&amp;#39;Shutting down server...&amp;#39;);

    try {
      // Close database connections
      await this.db.close();

      // Stop OAuth service
      await this.auth.stopOAuthService();

      // Clean up any other resources

      logger.info(&amp;#39;Server shutdown complete&amp;#39;);
    } catch (error) {
      logger.error(&amp;#39;Error during shutdown&amp;#39;, error instanceof Error ? error : undefined);
    }
  }
}

// Export for external usage
export { createApiRouter, WebSocketHandler, McpService, StaticFileHandler };

// Enhanced process monitoring and error handling
class ProcessMonitor {
  private memoryWarningThreshold &#x3D; 500 * 1024 * 1024; // 500MB
  private errorCount &#x3D; 0;
  private lastMemoryCheck &#x3D; Date.now();
  private isShuttingDown &#x3D; false;

  constructor(private server: SpecWorkbenchServer) {
    this.setupProcessMonitoring();
    this.setupMemoryMonitoring();
    this.setupUncaughtExceptionHandling();
  }

  private setupProcessMonitoring() {
    // Log process health every 30 seconds
    setInterval(() &#x3D;&amp;gt; {
      if (!this.isShuttingDown) {
        this.logProcessHealth();
      }
    }, 30000);
  }

  private setupMemoryMonitoring() {
    // Check memory usage every 10 seconds
    setInterval(() &#x3D;&amp;gt; {
      if (!this.isShuttingDown) {
        this.checkMemoryUsage();
      }
    }, 10000);
  }

  private setupUncaughtExceptionHandling() {
    // Handle uncaught exceptions
    process.on(&amp;#39;uncaughtException&amp;#39;, error &#x3D;&amp;gt; {
      this.errorCount++;
      logger.error(&amp;#39;❌ UNCAUGHT EXCEPTION&amp;#39;, error, {
        errorCount: this.errorCount,
        processUptime: process.uptime(),
        memoryUsage: process.memoryUsage(),
        pid: process.pid,
      });

      // If we get too many errors, shutdown gracefully
      if (this.errorCount &amp;gt; 5) {
        logger.error(&amp;#39;🚨 Too many uncaught exceptions, initiating shutdown&amp;#39;);
        this.gracefulShutdown(&amp;#39;uncaught-exceptions&amp;#39;);
      }
    });

    // Handle unhandled promise rejections
    process.on(&amp;#39;unhandledRejection&amp;#39;, (reason, promise) &#x3D;&amp;gt; {
      this.errorCount++;
      logger.error(&amp;#39;❌ UNHANDLED PROMISE REJECTION&amp;#39;, reason instanceof Error ? reason : undefined, {
        reason: reason,
        promise: promise,
        errorCount: this.errorCount,
        processUptime: process.uptime(),
        memoryUsage: process.memoryUsage(),
        pid: process.pid,
      });

      // If we get too many errors, shutdown gracefully
      if (this.errorCount &amp;gt; 10) {
        logger.error(&amp;#39;🚨 Too many unhandled rejections, initiating shutdown&amp;#39;);
        this.gracefulShutdown(&amp;#39;unhandled-rejections&amp;#39;);
      }
    });

    // Handle warnings
    process.on(&amp;#39;warning&amp;#39;, warning &#x3D;&amp;gt; {
      logger.warn(&amp;#39;⚠️ Node.js Warning&amp;#39;, undefined, {
        name: warning.name,
        message: warning.message,
        stack: warning.stack,
      });
    });

    // Handle exit events
    process.on(&amp;#39;beforeExit&amp;#39;, code &#x3D;&amp;gt; {
      if (!this.isShuttingDown) {
        logger.info(&amp;#39;🔄 Process beforeExit event&amp;#39;, { code });
      }
    });

    process.on(&amp;#39;exit&amp;#39;, code &#x3D;&amp;gt; {
      console.log(&#x60;🔚 Process exit with code: ${code}&#x60;);
    });
  }

  private logProcessHealth() {
    const memUsage &#x3D; process.memoryUsage();
    const cpuUsage &#x3D; process.cpuUsage();

    logger.info(&amp;#39;📊 Process Health Check&amp;#39;, {
      uptime: Math.floor(process.uptime()),
      pid: process.pid,
      nodeVersion: process.version,
      platform: process.platform,
      errorCount: this.errorCount,
      memory: {
        rss: Math.round(memUsage.rss / 1024 / 1024) + &amp;#39;MB&amp;#39;,
        heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024) + &amp;#39;MB&amp;#39;,
        heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024) + &amp;#39;MB&amp;#39;,
        external: Math.round(memUsage.external / 1024 / 1024) + &amp;#39;MB&amp;#39;,
      },
      cpu: {
        user: cpuUsage.user,
        system: cpuUsage.system,
      },
    });
  }

  private checkMemoryUsage() {
    const memUsage &#x3D; process.memoryUsage();

    if (memUsage.heapUsed &amp;gt; this.memoryWarningThreshold) {
      logger.warn(&amp;#39;⚠️ High memory usage detected&amp;#39;, {
        heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024) + &amp;#39;MB&amp;#39;,
        threshold: Math.round(this.memoryWarningThreshold / 1024 / 1024) + &amp;#39;MB&amp;#39;,
        recommendation: &amp;#39;Consider garbage collection or restart&amp;#39;,
      });

      // Force garbage collection if available
      if (global.gc) {
        logger.info(&amp;#39;🗑️ Running garbage collection&amp;#39;);
        global.gc();
      }
    }
  }

  async gracefulShutdown(reason: string) {
    if (this.isShuttingDown) {
      logger.warn(&amp;#39;⚠️ Shutdown already in progress, ignoring duplicate request&amp;#39;);
      return;
    }

    this.isShuttingDown &#x3D; true;
    logger.info(&#x60;🔸 Graceful shutdown initiated: ${reason}&#x60;);

    try {
      // Set a timeout for shutdown
      const shutdownTimeout &#x3D; setTimeout(() &#x3D;&amp;gt; {
        logger.error(&amp;#39;🚨 Shutdown timeout exceeded, forcing exit&amp;#39;);
        process.exit(1);
      }, 10000); // 10 second timeout

      await this.server.shutdown();
      clearTimeout(shutdownTimeout);

      logger.info(&amp;#39;✅ Graceful shutdown completed&amp;#39;);
      process.exit(0);
    } catch (error) {
      logger.error(&amp;#39;❌ Error during graceful shutdown&amp;#39;, error instanceof Error ? error : undefined);
      process.exit(1);
    }
  }
}

let config: ServerConfig;

try {
  config &#x3D; loadConfig();
} catch (error) {
  logger.error(&amp;#39;Failed to load server configuration&amp;#39;, error instanceof Error ? error : undefined);
  process.exit(1);
}

// Start the server
const server &#x3D; new SpecWorkbenchServer(config);
const monitor &#x3D; new ProcessMonitor(server);

// Handle graceful shutdown signals
process.on(&amp;#39;SIGINT&amp;#39;, async () &#x3D;&amp;gt; {
  console.log(&amp;#39;\n🔸 Received SIGINT signal&amp;#39;);
  await monitor.gracefulShutdown(&amp;#39;SIGINT&amp;#39;);
});

process.on(&amp;#39;SIGTERM&amp;#39;, async () &#x3D;&amp;gt; {
  console.log(&amp;#39;\n🔸 Received SIGTERM signal&amp;#39;);
  await monitor.gracefulShutdown(&amp;#39;SIGTERM&amp;#39;);
});

// Enhanced startup with retry logic
async function startServerWithRetry(maxRetries &#x3D; 3) {
  for (let attempt &#x3D; 1; attempt &amp;lt;&#x3D; maxRetries; attempt++) {
    try {
      logger.info(&#x60;🚀 Starting server (attempt ${attempt}/${maxRetries})&#x60;);
      await server.start();
      logger.info(&amp;#39;✅ Server started successfully&amp;#39;);
      return;
    } catch (error) {
      logger.error(
        &#x60;❌ Server startup failed (attempt ${attempt}/${maxRetries})&#x60;,
        error instanceof Error ? error : undefined
      );

      if (attempt &#x3D;&#x3D;&#x3D; maxRetries) {
        logger.error(&amp;#39;🚨 All startup attempts failed, exiting&amp;#39;);
        process.exit(1);
      }

      // Wait before retry
      const delay &#x3D; attempt * 2000; // 2s, 4s, 6s
      logger.info(&#x60;⏳ Waiting ${delay}ms before retry...&#x60;);
      await new Promise(resolve &#x3D;&amp;gt; setTimeout(resolve, delay));
    }
  }
}

// Start the server with retry logic
await startServerWithRetry();
</pre>
                </div>
            </div>
            <div class="file-section" id="file-18">
                <div class="file-header">📄 src/handlers/types.ts</div>
                <div class="file-content">
                    <pre>/**
 * Custom webhook handler types and interfaces
 */

// Handler execution context
export interface HandlerContext {
  projectId: string;
  config: HandlerConfig;
  logger: Logger;
  services: HandlerServices;
  metadata: HandlerMetadata;
}

// Handler configuration
export interface HandlerConfig {
  enabled: boolean;
  timeout: number; // milliseconds
  retries: number;
  environment: Record&amp;lt;string, string&amp;gt;;
  secrets: Record&amp;lt;string, string&amp;gt;; // Encrypted secrets
}

// Available services for handlers
export interface HandlerServices {
  events: EventService;
  db: SpecWorkbenchDB;
  http: HttpClient;
  notifications: NotificationService;
  git: GitService;
}

// Handler metadata
export interface HandlerMetadata {
  handlerPath: string;
  version: string;
  executionId: string;
  timestamp: string;
}

// Handler result
export interface HandlerResult {
  success: boolean;
  message: string;
  data?: Record&amp;lt;string, unknown&amp;gt;;
  actions?: string[];
  errors?: HandlerError[];
  duration?: number;
}

// Handler error
export interface HandlerError {
  code: string;
  message: string;
  details?: Record&amp;lt;string, unknown&amp;gt;;
  stack?: string;
}

// Enhanced webhook payload with parsed data
export interface EnhancedWebhookPayload extends WebhookPayload {
  parsed: {
    eventType: string;
    action?: string;
    author: {
      name: string;
      email?: string;
      username?: string;
    };
    repository: {
      name: string;
      fullName: string;
      owner: string;
      url: string;
      defaultBranch: string;
      isPrivate: boolean;
    };
    commits?: Array&amp;lt;{
      sha: string;
      message: string;
      author: string;
      url: string;
      timestamp: string;
      added: string[];
      modified: string[];
      removed: string[];
    }&amp;gt;;
    pullRequest?: {
      id: number;
      title: string;
      body: string;
      state: string;
      baseBranch: string;
      headBranch: string;
      url: string;
      merged: boolean;
      mergeable: boolean;
    };
    issue?: {
      id: number;
      title: string;
      body: string;
      state: string;
      labels: string[];
      assignees: string[];
      url: string;
    };
  };
}

// Handler function signature
export type WebhookHandler &#x3D; (
  payload: EnhancedWebhookPayload,
  context: HandlerContext,
) &#x3D;&amp;gt; Promise&amp;lt;HandlerResult&amp;gt;;

// Handler module interface
export interface HandlerModule {
  handler: WebhookHandler;
  config?: Partial&amp;lt;HandlerConfig&amp;gt;;
  metadata?: {
    name: string;
    description: string;
    version: string;
    author?: string;
    supportedEvents: string[];
    requiredPermissions: string[];
  };
}

// Logger interface for handlers
export interface Logger {
  info(message: string, meta?: Record&amp;lt;string, unknown&amp;gt;): void;
  warn(message: string, meta?: Record&amp;lt;string, unknown&amp;gt;): void;
  error(message: string, error?: Error, meta?: Record&amp;lt;string, unknown&amp;gt;): void;
  debug(message: string, meta?: Record&amp;lt;string, unknown&amp;gt;): void;
}

// HTTP client interface
export interface HttpClient {
  get(url: string, options?: RequestOptions): Promise&amp;lt;HttpResponse&amp;gt;;
  post(url: string, data?: unknown, options?: RequestOptions): Promise&amp;lt;HttpResponse&amp;gt;;
  put(url: string, data?: unknown, options?: RequestOptions): Promise&amp;lt;HttpResponse&amp;gt;;
  delete(url: string, options?: RequestOptions): Promise&amp;lt;HttpResponse&amp;gt;;
}

export interface RequestOptions {
  headers?: Record&amp;lt;string, string&amp;gt;;
  timeout?: number;
  retries?: number;
}

export interface HttpResponse {
  status: number;
  statusText: string;
  data: unknown;
  headers: Record&amp;lt;string, string&amp;gt;;
}

// Notification service interface
export interface NotificationService {
  sendSlack(webhook: string, message: SlackMessage): Promise&amp;lt;void&amp;gt;;
  sendEmail(to: string, subject: string, body: string): Promise&amp;lt;void&amp;gt;;
  sendWebhook(url: string, payload: unknown): Promise&amp;lt;void&amp;gt;;
}

export interface SlackMessage {
  text?: string;
  blocks?: unknown[];
  channel?: string;
  username?: string;
  iconEmoji?: string;
}

// Git service interface
export interface GitService {
  cloneRepository(url: string, path: string): Promise&amp;lt;void&amp;gt;;
  getCommitDiff(sha: string): Promise&amp;lt;FileDiff[]&amp;gt;;
  getFileContent(path: string, ref?: string): Promise&amp;lt;string&amp;gt;;
  createBranch(name: string, from?: string): Promise&amp;lt;void&amp;gt;;
  createPullRequest(title: string, body: string, base: string, head: string): Promise&amp;lt;unknown&amp;gt;;
}

export interface FileDiff {
  path: string;
  status: &amp;quot;added&amp;quot; | &amp;quot;modified&amp;quot; | &amp;quot;deleted&amp;quot; | &amp;quot;renamed&amp;quot;;
  additions: number;
  deletions: number;
  patch?: string;
}

// Handler registry types
export interface RegisteredHandler {
  id: string;
  provider: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;;
  event: string;
  handlerPath: string;
  enabled: boolean;
  config: HandlerConfig;
  lastExecuted?: string;
  executionCount: number;
  errorCount: number;
  metadata: HandlerModule[&amp;quot;metadata&amp;quot;];
}

export interface HandlerCreationOptions {
  provider: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;;
  event: string;
  code: string;
  config?: Partial&amp;lt;HandlerConfig&amp;gt;;
  metadata?: {
    name: string;
    description: string;
    version?: string;
    author?: string;
  };
}

export interface HandlerExecution {
  id: string;
  handlerId: string;
  projectId: string;
  provider: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;;
  event: string;
  payload: EnhancedWebhookPayload;
  result: HandlerResult;
  startedAt: string;
  completedAt: string;
  duration: number;
}

// Configuration for handler discovery
export interface HandlerDiscoveryConfig {
  handlersDirectory: string;
  enableAutoReload: boolean;
  maxConcurrentExecutions: number;
  defaultTimeout: number;
  defaultRetries: number;
  sandboxEnabled: boolean;
  allowedModules: string[];
  enableMetrics: boolean;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-19">
                <div class="file-header">📄 src/routes/index.ts</div>
                <div class="file-content">
                    <pre>import path from &amp;#39;path&amp;#39;;
import fs from &amp;#39;fs-extra&amp;#39;;
import { glob } from &amp;#39;glob&amp;#39;;
import { Hono } from &amp;#39;hono&amp;#39;;

export type Dependencies &#x3D; Record&amp;lt;string, unknown&amp;gt;;

interface SearchResult {
  title: string;
  type: string;
  path: string;
  content: string;
  relevance: number;
}

async function searchFiles(
  query: string,
  searchType: string,
  limit: number
): Promise&amp;lt;SearchResult[]&amp;gt; {
  const results: SearchResult[] &#x3D; [];
  const queryLower &#x3D; query.toLowerCase();

  // Define search patterns based on type
  const searchPatterns: Record&amp;lt;string, string[]&amp;gt; &#x3D; {
    all: [&amp;#39;**/*.md&amp;#39;, &amp;#39;**/*.ts&amp;#39;, &amp;#39;**/*.js&amp;#39;, &amp;#39;**/*.cue&amp;#39;, &amp;#39;**/*.json&amp;#39;, &amp;#39;**/*.yaml&amp;#39;, &amp;#39;**/*.yml&amp;#39;],
    specs: [&amp;#39;**/*.cue&amp;#39;, &amp;#39;**/spec/**/*&amp;#39;, &amp;#39;**/specs/**/*&amp;#39;],
    handlers: [&amp;#39;**/handlers/**/*&amp;#39;, &amp;#39;**/webhooks/**/*&amp;#39;],
    docs: [&amp;#39;**/*.md&amp;#39;, &amp;#39;**/docs/**/*&amp;#39;, &amp;#39;**/README*&amp;#39;],
    webhooks: [&amp;#39;**/webhooks/**/*&amp;#39;, &amp;#39;**/webhook/**/*&amp;#39;, &amp;#39;**/handlers/**/*&amp;#39;],
  };

  const patterns &#x3D; searchPatterns[searchType] || searchPatterns.all;

  try {
    for (const pattern of patterns) {
      const files &#x3D; await glob(pattern, {
        cwd: &amp;#39;/home/nathan/Projects/arbiter&amp;#39;,
        ignore: [&amp;#39;**/node_modules/**&amp;#39;, &amp;#39;**/dist/**&amp;#39;, &amp;#39;**/.git/**&amp;#39;, &amp;#39;**/build/**&amp;#39;],
        absolute: true,
      });

      for (const filePath of files) {
        try {
          if (!(await fs.pathExists(filePath))) continue;

          const stat &#x3D; await fs.stat(filePath);
          if (!stat.isFile() || stat.size &amp;gt; 100000) continue; // Skip large files

          const content &#x3D; await fs.readFile(filePath, &amp;#39;utf-8&amp;#39;);
          const contentLower &#x3D; content.toLowerCase();

          // Calculate relevance score
          let relevance &#x3D; 0;
          const lines &#x3D; content.split(&amp;#39;\n&amp;#39;);
          const matchingLines: string[] &#x3D; [];

          for (let i &#x3D; 0; i &amp;lt; lines.length; i++) {
            const line &#x3D; lines[i];
            const lineLower &#x3D; line.toLowerCase();

            if (lineLower.includes(queryLower)) {
              relevance++;
              matchingLines.push(&#x60;${i + 1}: ${line.trim()}&#x60;);

              // Boost relevance for title/heading matches
              if (
                line.trim().startsWith(&amp;#39;#&amp;#39;) ||
                line.includes(&amp;#39;title:&amp;#39;) ||
                line.includes(&amp;#39;name:&amp;#39;)
              ) {
                relevance +&#x3D; 3;
              }
            }
          }

          if (relevance &amp;gt; 0) {
            const relativePath &#x3D; path.relative(&amp;#39;/home/nathan/Projects/arbiter&amp;#39;, filePath);
            const fileType &#x3D; path.extname(filePath).slice(1) || &amp;#39;file&amp;#39;;

            results.push({
              title: path.basename(filePath),
              type: fileType,
              path: relativePath,
              content: matchingLines.slice(0, 5).join(&amp;#39;\n&amp;#39;), // First 5 matching lines
              relevance,
            });
          }
        } catch (error) {
          // Skip files that can&amp;#39;t be read
          continue;
        }
      }
    }

    // Sort by relevance and limit results
    return results.sort((a, b) &#x3D;&amp;gt; b.relevance - a.relevance).slice(0, limit);
  } catch (error) {
    console.error(&amp;#39;Search error:&amp;#39;, error);
    return [];
  }
}

export function createApiRouter(deps: Dependencies) {
  const app &#x3D; new Hono();

  app.get(&amp;#39;/health&amp;#39;, c &#x3D;&amp;gt;
    c.json({ status: &amp;#39;healthy&amp;#39;, timestamp: new Date().toISOString(), database: true })
  );

  app.post(&amp;#39;/api/validate&amp;#39;, async c &#x3D;&amp;gt; {
    return c.json({ success: true, spec_hash: &amp;#39;stubbed&amp;#39;, resolved: {} });
  });

  // Search endpoint for MCP
  app.post(&amp;#39;/api/search&amp;#39;, async c &#x3D;&amp;gt; {
    try {
      const body &#x3D; await c.req.json();
      const { query, type &#x3D; &amp;#39;all&amp;#39;, limit &#x3D; 10 } &#x3D; body;

      if (!query || typeof query !&#x3D;&#x3D; &amp;#39;string&amp;#39;) {
        return c.json({ error: &amp;#39;Query parameter is required&amp;#39; }, 400);
      }

      const results &#x3D; await searchFiles(query, type, limit);

      return c.json({
        success: true,
        query,
        type,
        total: results.length,
        results,
      });
    } catch (error) {
      console.error(&amp;#39;Search API error:&amp;#39;, error);
      return c.json(
        {
          success: false,
          error: &amp;#39;Search failed&amp;#39;,
          message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
        },
        500
      );
    }
  });

  // Fetch endpoint for MCP
  app.post(&amp;#39;/api/fetch&amp;#39;, async c &#x3D;&amp;gt; {
    try {
      const body &#x3D; await c.req.json();
      const { path: filePath, encoding &#x3D; &amp;#39;utf-8&amp;#39; } &#x3D; body;

      if (!filePath || typeof filePath !&#x3D;&#x3D; &amp;#39;string&amp;#39;) {
        return c.json(
          {
            success: false,
            error: &amp;#39;Path parameter is required&amp;#39;,
          },
          400
        );
      }

      // Normalize the path - remove leading slash if present
      const normalizedPath &#x3D; filePath.startsWith(&amp;#39;/&amp;#39;) ? filePath.slice(1) : filePath;
      const fullPath &#x3D; path.resolve(&amp;#39;/home/nathan/Projects/arbiter&amp;#39;, normalizedPath);

      // Security check - ensure the path is within the project directory
      if (!fullPath.startsWith(&amp;#39;/home/nathan/Projects/arbiter/&amp;#39;)) {
        return c.json(
          {
            success: false,
            error: &amp;#39;Access denied: Path outside project directory&amp;#39;,
          },
          403
        );
      }

      // Check if file exists
      if (!(await fs.pathExists(fullPath))) {
        return c.json(
          {
            success: false,
            error: &amp;#39;File not found&amp;#39;,
          },
          404
        );
      }

      const stat &#x3D; await fs.stat(fullPath);

      // Check if it&amp;#39;s a file
      if (!stat.isFile()) {
        return c.json(
          {
            success: false,
            error: &amp;#39;Path is not a file&amp;#39;,
          },
          400
        );
      }

      // Check file size (limit to 1MB for safety)
      if (stat.size &amp;gt; 1024 * 1024) {
        return c.json(
          {
            success: false,
            error: &amp;#39;File too large (limit: 1MB)&amp;#39;,
          },
          400
        );
      }

      let content: string;
      const fileType &#x3D; path.extname(fullPath).slice(1) || &amp;#39;file&amp;#39;;

      if (encoding &#x3D;&#x3D;&#x3D; &amp;#39;base64&amp;#39;) {
        const buffer &#x3D; await fs.readFile(fullPath);
        content &#x3D; buffer.toString(&amp;#39;base64&amp;#39;);
      } else {
        content &#x3D; await fs.readFile(fullPath, &amp;#39;utf-8&amp;#39;);
      }

      return c.json({
        success: true,
        path: filePath,
        encoding,
        content,
        size: stat.size,
        type: fileType,
        lastModified: stat.mtime.toISOString(),
      });
    } catch (error) {
      console.error(&amp;#39;Fetch API error:&amp;#39;, error);
      return c.json(
        {
          success: false,
          error: &amp;#39;Fetch failed&amp;#39;,
          message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
        },
        500
      );
    }
  });

  // Add endpoint for MCP add commands
  app.post(&amp;#39;/api/add&amp;#39;, async c &#x3D;&amp;gt; {
    try {
      const body &#x3D; await c.req.json();
      const { subcommand, name, options &#x3D; {} } &#x3D; body;

      if (!subcommand || !name) {
        return c.json(
          {
            success: false,
            error: &amp;#39;subcommand and name parameters are required&amp;#39;,
          },
          400
        );
      }

      // Import the addCommand function
      const { addCommand } &#x3D; await import(
        &amp;#39;/home/nathan/Projects/arbiter/packages/cli/src/commands/add.js&amp;#39;
      );

      // Create a basic CLI config (you may want to make this configurable)
      const config &#x3D; {
        apiUrl: &amp;#39;http://localhost:5050&amp;#39;,
        timeout: 30000,
        format: &amp;#39;json&amp;#39; as const,
        color: false,
        projectDir: process.cwd(),
      };

      // Call the add command
      const exitCode &#x3D; await addCommand(subcommand, name, options, config);

      if (exitCode &#x3D;&#x3D;&#x3D; 0) {
        return c.json({
          success: true,
          message: &#x60;Successfully added ${subcommand}: ${name}&#x60;,
          subcommand,
          name,
          options,
        });
      } else {
        return c.json(
          {
            success: false,
            error: &#x60;Add command failed with exit code ${exitCode}&#x60;,
            subcommand,
            name,
          },
          500
        );
      }
    } catch (error) {
      console.error(&amp;#39;Add API error:&amp;#39;, error);
      return c.json(
        {
          success: false,
          error: &amp;#39;Add command failed&amp;#39;,
          message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
        },
        500
      );
    }
  });

  // Create endpoint for MCP create project command
  app.post(&amp;#39;/api/create&amp;#39;, async c &#x3D;&amp;gt; {
    try {
      const body &#x3D; await c.req.json();
      const { name, options &#x3D; {} } &#x3D; body;

      if (!name) {
        return c.json(
          {
            success: false,
            error: &amp;#39;name parameter is required&amp;#39;,
          },
          400
        );
      }

      // Import the initCommand function
      const { initCommand } &#x3D; await import(
        &amp;#39;/home/nathan/Projects/arbiter/packages/cli/src/commands/init.js&amp;#39;
      );

      // Determine target directory
      const targetDir &#x3D; options.directory
        ? path.resolve(options.directory, name)
        : path.resolve(process.cwd(), name);

      // Prepare init options
      const initOptions &#x3D; {
        template: options.template || &amp;#39;basic&amp;#39;,
        force: options.force || false,
        ...options,
      };

      // Change to target directory for project creation
      const originalCwd &#x3D; process.cwd();

      try {
        // Ensure parent directory exists
        await fs.ensureDir(path.dirname(targetDir));

        // Create and change to target directory
        await fs.ensureDir(targetDir);
        process.chdir(targetDir);

        // Call the init command
        const exitCode &#x3D; await initCommand(name, initOptions);

        if (exitCode &#x3D;&#x3D;&#x3D; 0) {
          return c.json({
            success: true,
            message: &#x60;Successfully created project: ${name}&#x60;,
            name,
            directory: targetDir,
            template: initOptions.template,
            options: initOptions,
          });
        } else {
          return c.json(
            {
              success: false,
              error: &#x60;Init command failed with exit code ${exitCode}&#x60;,
              name,
              directory: targetDir,
            },
            500
          );
        }
      } finally {
        // Always restore original working directory
        process.chdir(originalCwd);
      }
    } catch (error) {
      console.error(&amp;#39;Create API error:&amp;#39;, error);
      return c.json(
        {
          success: false,
          error: &amp;#39;Create project failed&amp;#39;,
          message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
        },
        500
      );
    }
  });

  // Projects endpoint - using real database
  app.get(&amp;#39;/api/projects&amp;#39;, async c &#x3D;&amp;gt; {
    console.log(&amp;#39;🔄 GET /api/projects - Request received from:&amp;#39;, c.req.header(&amp;#39;origin&amp;#39;) || &amp;#39;unknown&amp;#39;);
    try {
      const db &#x3D; deps.db as any;
      const projects &#x3D; await db.listProjects();
      console.log(&amp;#39;📊 GET /api/projects - Raw projects from DB:&amp;#39;, projects.length, &amp;#39;projects&amp;#39;);

      // Transform database projects to match frontend format
      const formattedProjects &#x3D; projects.map((project: any) &#x3D;&amp;gt; ({
        id: project.id,
        name: project.name,
        status: &amp;#39;active&amp;#39;,
        services: project.service_count || 0,
        databases: project.database_count || 0,
        lastActivity: project.updated_at,
      }));

      return c.json({ projects: formattedProjects });
    } catch (error) {
      console.error(&amp;#39;Error fetching projects:&amp;#39;, error);
      return c.json({ projects: [] });
    }
  });

  // Create project endpoint
  app.post(&amp;#39;/api/projects&amp;#39;, async c &#x3D;&amp;gt; {
    try {
      const db &#x3D; deps.db as any;
      const body &#x3D; await c.req.json();
      const { name, path: projectPath } &#x3D; body;

      if (!name) {
        return c.json({ error: &amp;#39;Project name is required&amp;#39; }, 400);
      }

      // Generate project ID
      const projectId &#x3D; &#x60;project-${Date.now()}&#x60;;
      
      // Extract project name from directory if path is provided
      let actualProjectName &#x3D; name;
      if (projectPath) {
        actualProjectName &#x3D; path.basename(projectPath);
      }

      // If path is provided, run enhanced brownfield detection
      let services &#x3D; 0;
      let databases &#x3D; 0;
      let artifacts: any[] &#x3D; [];
      
      if (projectPath) {
        try {
          // Get all files in the git repository
          const gitFiles &#x3D; await glob(&amp;#39;**/*&amp;#39;, { 
            cwd: projectPath,
            ignore: [&amp;#39;**/target/**&amp;#39;, &amp;#39;**/node_modules/**&amp;#39;, &amp;#39;**/.git/**&amp;#39;, &amp;#39;**/dist/**&amp;#39;, &amp;#39;**/build/**&amp;#39;],
            onlyFiles: true
          });

          // Parse Cargo.toml for Rust projects
          const cargoTomlPath &#x3D; path.join(projectPath, &amp;#39;Cargo.toml&amp;#39;);
          if (await fs.pathExists(cargoTomlPath)) {
            const cargoContent &#x3D; await fs.readFile(cargoTomlPath, &amp;#39;utf-8&amp;#39;);
            
            // Extract workspace members from Cargo.toml
            const workspaceMatch &#x3D; cargoContent.match(/\[workspace\][\s\S]*?members\s*&#x3D;\s*\[([\s\S]*?)\]/);
            if (workspaceMatch) {
              const membersSection &#x3D; workspaceMatch[1];
              const memberLines &#x3D; membersSection.split(&amp;#39;,&amp;#39;).map(line &#x3D;&amp;gt; {
                const match &#x3D; line.trim().match(/&amp;quot;([^&amp;quot;]+)&amp;quot;/);
                return match ? match[1] : null;
              }).filter(Boolean);

              // Process each member to prepare artifacts
              for (const member of memberLines) {
                if (!member || member.startsWith(&amp;#39;#&amp;#39;)) continue;
                
                const memberPath &#x3D; path.join(projectPath, member);
                const isService &#x3D; member.startsWith(&amp;#39;service/&amp;#39;) || member.includes(&amp;#39;service&amp;#39;);
                const isShared &#x3D; member.startsWith(&amp;#39;shared/&amp;#39;);
                const isClient &#x3D; member.startsWith(&amp;#39;clients/&amp;#39;);
                const isTool &#x3D; member.startsWith(&amp;#39;tools/&amp;#39;);
                
                let artifactType &#x3D; &amp;#39;library&amp;#39;;
                if (isService) artifactType &#x3D; &amp;#39;service&amp;#39;;
                else if (isClient) artifactType &#x3D; &amp;#39;client&amp;#39;;
                else if (isTool) artifactType &#x3D; &amp;#39;tool&amp;#39;;
                
                const artifactName &#x3D; member.split(&amp;#39;/&amp;#39;).pop() || member;
                
                artifacts.push({
                  id: &#x60;${projectId}-${artifactName.replace(/[^a-zA-Z0-9]/g, &amp;#39;-&amp;#39;)}&#x60;,
                  name: artifactName,
                  type: artifactType,
                  member,
                  language: &amp;#39;rust&amp;#39;,
                  framework: &amp;#39;cargo&amp;#39;,
                  metadata: {
                    workspaceMember: member,
                    isService,
                    isShared,
                    path: memberPath
                  },
                  filePath: member
                });
                
                if (artifactType &#x3D;&#x3D;&#x3D; &amp;#39;service&amp;#39;) services++;
              }
            }
          }

          // Parse package.json files for Node.js/JavaScript projects
          const packageJsonFiles &#x3D; gitFiles.filter(file &#x3D;&amp;gt; file.endsWith(&amp;#39;package.json&amp;#39;));
          for (const packageFile of packageJsonFiles) {
            try {
              const packageContent &#x3D; await fs.readFile(path.join(projectPath, packageFile), &amp;#39;utf-8&amp;#39;);
              const packageData &#x3D; JSON.parse(packageContent);
              
              if (packageData.name) {
                const isRootPackage &#x3D; packageFile &#x3D;&#x3D;&#x3D; &amp;#39;package.json&amp;#39;;
                const packageName &#x3D; packageData.name.replace(&amp;#39;@&amp;#39;, &amp;#39;&amp;#39;).replace(&amp;#39;/&amp;#39;, &amp;#39;-&amp;#39;);
                const packageDir &#x3D; path.dirname(packageFile);
                
                // Determine artifact type based on package.json contents
                let artifactType &#x3D; &amp;#39;library&amp;#39;;
                if (packageData.scripts?.start || packageData.scripts?.dev) {
                  if (packageData.dependencies?.react || packageData.dependencies?.vue || packageData.dependencies?.angular) {
                    artifactType &#x3D; &amp;#39;frontend&amp;#39;;
                  } else if (packageData.dependencies?.express || packageData.dependencies?.fastify || packageData.dependencies?.koa) {
                    artifactType &#x3D; &amp;#39;service&amp;#39;;
                    services++;
                  } else {
                    artifactType &#x3D; &amp;#39;application&amp;#39;;
                  }
                } else if (packageData.bin) {
                  artifactType &#x3D; &amp;#39;tool&amp;#39;;
                }

                artifacts.push({
                  id: &#x60;${projectId}-${packageName.replace(/[^a-zA-Z0-9]/g, &amp;#39;-&amp;#39;)}&#x60;,
                  name: packageName,
                  type: artifactType,
                  language: &amp;#39;javascript&amp;#39;,
                  framework: packageData.dependencies?.typescript ? &amp;#39;typescript&amp;#39; : &amp;#39;node.js&amp;#39;,
                  metadata: {
                    packagePath: packageFile,
                    version: packageData.version,
                    scripts: packageData.scripts,
                    dependencies: Object.keys(packageData.dependencies || {}),
                    isRootPackage
                  },
                  filePath: packageFile
                });
              }
            } catch (error) {
              console.warn(&#x60;Failed to parse package.json file ${packageFile}:&#x60;, error);
            }
          }

          // Look for database configurations in all files
          const configFiles &#x3D; gitFiles.filter(file &#x3D;&amp;gt; 
            file.includes(&amp;#39;config&amp;#39;) &amp;amp;&amp;amp; 
            (file.endsWith(&amp;#39;.toml&amp;#39;) || file.endsWith(&amp;#39;.json&amp;#39;) || file.endsWith(&amp;#39;.yaml&amp;#39;) || file.endsWith(&amp;#39;.yml&amp;#39;) || file.endsWith(&amp;#39;.env&amp;#39;))
          );
          
          for (const configFile of configFiles) {
            try {
              const configContent &#x3D; await fs.readFile(path.join(projectPath, configFile), &amp;#39;utf-8&amp;#39;);
              
              // Detect PostgreSQL
              if ((configContent.includes(&amp;#39;postgres&amp;#39;) || configContent.includes(&amp;#39;database_url&amp;#39;) || configContent.includes(&amp;#39;DATABASE_URL&amp;#39;)) &amp;amp;&amp;amp; 
                  !artifacts.find(a &#x3D;&amp;gt; a.name &#x3D;&#x3D;&#x3D; &amp;#39;postgres&amp;#39;)) {
                databases++;
                artifacts.push({
                  id: &#x60;${projectId}-postgres-db&#x60;,
                  name: &amp;#39;postgres&amp;#39;,
                  type: &amp;#39;database&amp;#39;,
                  language: null,
                  framework: &amp;#39;postgresql&amp;#39;,
                  metadata: { configFile, detected: true },
                  filePath: configFile
                });
              }
              
              // Detect Redis
              if ((configContent.includes(&amp;#39;redis&amp;#39;) || configContent.includes(&amp;#39;cache&amp;#39;) || configContent.includes(&amp;#39;REDIS_URL&amp;#39;)) &amp;amp;&amp;amp; 
                  !artifacts.find(a &#x3D;&amp;gt; a.name &#x3D;&#x3D;&#x3D; &amp;#39;redis&amp;#39;)) {
                databases++;
                artifacts.push({
                  id: &#x60;${projectId}-redis-cache&#x60;,
                  name: &amp;#39;redis&amp;#39;,
                  type: &amp;#39;database&amp;#39;,
                  language: null,
                  framework: &amp;#39;redis&amp;#39;,
                  metadata: { configFile, detected: true },
                  filePath: configFile
                });
              }

              // Detect MongoDB
              if ((configContent.includes(&amp;#39;mongodb&amp;#39;) || configContent.includes(&amp;#39;mongo&amp;#39;) || configContent.includes(&amp;#39;MONGODB_URL&amp;#39;)) &amp;amp;&amp;amp; 
                  !artifacts.find(a &#x3D;&amp;gt; a.name &#x3D;&#x3D;&#x3D; &amp;#39;mongodb&amp;#39;)) {
                databases++;
                artifacts.push({
                  id: &#x60;${projectId}-mongodb&#x60;,
                  name: &amp;#39;mongodb&amp;#39;,
                  type: &amp;#39;database&amp;#39;,
                  language: null,
                  framework: &amp;#39;mongodb&amp;#39;,
                  metadata: { configFile, detected: true },
                  filePath: configFile
                });
              }
            } catch (error) {
              console.warn(&#x60;Failed to parse config file ${configFile}:&#x60;, error);
            }
          }

          // Look for Docker files to detect containerized services
          const dockerFiles &#x3D; gitFiles.filter(file &#x3D;&amp;gt; 
            file.toLowerCase().includes(&amp;#39;dockerfile&amp;#39;) || file.toLowerCase().includes(&amp;#39;docker-compose&amp;#39;)
          );
          
          for (const dockerFile of dockerFiles) {
            try {
              const dockerContent &#x3D; await fs.readFile(path.join(projectPath, dockerFile), &amp;#39;utf-8&amp;#39;);
              
              // Extract service names from docker-compose files
              if (dockerFile.includes(&amp;#39;docker-compose&amp;#39;)) {
                // Look for services section specifically
                const servicesMatch &#x3D; dockerContent.match(/services:\s*\n([\s\S]*?)(?&#x3D;\n\S|\n$|$)/);
                if (servicesMatch) {
                  const servicesSection &#x3D; servicesMatch[1];
                  const serviceMatches &#x3D; servicesSection.match(/^\s{2,}([a-zA-Z0-9_-]+):/gm);
                  if (serviceMatches) {
                    serviceMatches.forEach(match &#x3D;&amp;gt; {
                      const serviceName &#x3D; match.trim().replace(&amp;#39;:&amp;#39;, &amp;#39;&amp;#39;);
                      if (!artifacts.find(a &#x3D;&amp;gt; a.name &#x3D;&#x3D;&#x3D; serviceName)) {
                        artifacts.push({
                          id: &#x60;${projectId}-docker-${serviceName}&#x60;,
                          name: serviceName,
                          type: &amp;#39;service&amp;#39;,
                          language: &amp;#39;docker&amp;#39;,
                          framework: &amp;#39;container&amp;#39;,
                          metadata: { 
                            dockerFile, 
                            detected: true,
                            containerized: true 
                          },
                          filePath: dockerFile
                        });
                        services++;
                      }
                    });
                  }
                }
              }
            } catch (error) {
              console.warn(&#x60;Failed to parse Docker file ${dockerFile}:&#x60;, error);
            }
          }
          
        } catch (error) {
          console.warn(&amp;#39;Enhanced brownfield detection failed, creating empty project:&amp;#39;, error);
          // Continue with empty project if brownfield detection fails
        }
      }

      // Create project with detected counts
      const project &#x3D; await db.createProject(projectId, actualProjectName, services, databases);

      // Now create all the artifacts for the project
      for (const artifact of artifacts) {
        try {
          await db.createArtifact(
            artifact.id,
            projectId,
            artifact.name,
            artifact.type,
            artifact.language,
            artifact.framework,
            artifact.metadata,
            artifact.filePath
          );
        } catch (error) {
          console.warn(&#x60;Failed to create artifact ${artifact.name}:&#x60;, error);
        }
      }

      return c.json({
        id: project.id,
        name: project.name,
        status: &amp;#39;active&amp;#39;,
        services,
        databases,
        artifacts: artifacts.length,
        lastActivity: project.created_at,
      });
    } catch (error) {
      console.error(&amp;#39;Error creating project:&amp;#39;, error);
      return c.json({ error: &amp;#39;Failed to create project&amp;#39; }, 500);
    }
  });

  // Action log endpoint for service activities
  app.get(&amp;#39;/api/activities&amp;#39;, c &#x3D;&amp;gt; {
    return c.json({
      activities: [
        {
          id: &amp;#39;act-1&amp;#39;,
          type: &amp;#39;service&amp;#39;,
          message: &amp;#39;Service added: user-auth-service&amp;#39;,
          timestamp: &amp;#39;2025-09-20T10:30:00Z&amp;#39;,
          projectId: &amp;#39;project-1&amp;#39;,
        },
        {
          id: &amp;#39;act-2&amp;#39;,
          type: &amp;#39;database&amp;#39;,
          message: &amp;#39;Database configured: postgres-main&amp;#39;,
          timestamp: &amp;#39;2025-09-20T10:15:00Z&amp;#39;,
          projectId: &amp;#39;project-1&amp;#39;,
        },
        {
          id: &amp;#39;act-3&amp;#39;,
          type: &amp;#39;deployment&amp;#39;,
          message: &amp;#39;Deployed to staging environment&amp;#39;,
          timestamp: &amp;#39;2025-09-20T09:45:00Z&amp;#39;,
          projectId: &amp;#39;project-2&amp;#39;,
        },
      ],
    });
  });

  // Specifications endpoint for CLI
  app.get(&amp;#39;/api/specifications&amp;#39;, async c &#x3D;&amp;gt; {
    const startTime &#x3D; Date.now();
    const requestId &#x3D; Math.random().toString(36).substr(2, 9);

    try {
      console.log(&#x60;[SPECS-GET] ${requestId} - Request started at ${new Date().toISOString()}&#x60;);

      const query &#x3D; c.req.query();
      const { type, path: specPath } &#x3D; query;
      console.log(&#x60;[SPECS-GET] ${requestId} - Query params:&#x60;, { type, path: specPath });

      if (specPath &amp;amp;&amp;amp; (await fs.pathExists(specPath))) {
        console.log(&#x60;[SPECS-GET] ${requestId} - File exists, reading content...&#x60;);
        const content &#x3D; await fs.readFile(specPath, &amp;#39;utf-8&amp;#39;);
        const stat &#x3D; await fs.stat(specPath);
        const duration &#x3D; Date.now() - startTime;

        console.log(&#x60;[SPECS-GET] ${requestId} - Success after ${duration}ms&#x60;);

        return c.json({
          success: true,
          type,
          path: specPath,
          content,
          lastModified: stat.mtime.toISOString(),
        });
      }

      const duration &#x3D; Date.now() - startTime;
      console.log(&#x60;[SPECS-GET] ${requestId} - File not found after ${duration}ms&#x60;);

      return c.json(
        {
          success: false,
          error: &amp;#39;Specification not found&amp;#39;,
          type,
          path: specPath,
        },
        404
      );
    } catch (error) {
      const duration &#x3D; Date.now() - startTime;
      console.error(&#x60;[SPECS-GET] ${requestId} - Error after ${duration}ms:&#x60;, error);

      return c.json(
        {
          success: false,
          error: &amp;#39;Failed to retrieve specification&amp;#39;,
          message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
        },
        500
      );
    }
  });

  app.post(&amp;#39;/api/specifications&amp;#39;, async c &#x3D;&amp;gt; {
    const startTime &#x3D; Date.now();
    const requestId &#x3D; Math.random().toString(36).substr(2, 9);

    try {
      console.log(&#x60;[SPECS-POST] ${requestId} - Request started at ${new Date().toISOString()}&#x60;);

      const body &#x3D; await c.req.json();
      const { type, path: specPath, content } &#x3D; body;
      console.log(&#x60;[SPECS-POST] ${requestId} - Body params:&#x60;, {
        type,
        path: specPath,
        contentLength: content?.length || 0,
      });

      if (!specPath || !content) {
        const duration &#x3D; Date.now() - startTime;
        console.log(
          &#x60;[SPECS-POST] ${requestId} - Bad request after ${duration}ms - missing path or content&#x60;
        );

        return c.json(
          {
            success: false,
            error: &amp;#39;path and content are required&amp;#39;,
          },
          400
        );
      }

      console.log(&#x60;[SPECS-POST] ${requestId} - Ensuring directory exists...&#x60;);
      // Ensure directory exists
      await fs.ensureDir(path.dirname(specPath));

      console.log(&#x60;[SPECS-POST] ${requestId} - Writing file...&#x60;);
      // Write the specification file
      await fs.writeFile(specPath, content, &amp;#39;utf-8&amp;#39;);

      const duration &#x3D; Date.now() - startTime;
      console.log(&#x60;[SPECS-POST] ${requestId} - Success after ${duration}ms&#x60;);

      return c.json({
        success: true,
        type,
        path: specPath,
        message: &amp;#39;Specification created successfully&amp;#39;,
        lastModified: new Date().toISOString(),
      });
    } catch (error) {
      const duration &#x3D; Date.now() - startTime;
      console.error(&#x60;[SPECS-POST] ${requestId} - Error after ${duration}ms:&#x60;, error);

      return c.json(
        {
          success: false,
          error: &amp;#39;Failed to create specification&amp;#39;,
          message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
        },
        500
      );
    }
  });

  // Handler endpoints that integrate with the existing HandlerAPIController
  // Order matters! More specific routes must come before parameterized routes

  // Handler management endpoints (non-parameterized routes first)
  app.get(&amp;#39;/api/handlers/executions&amp;#39;, async c &#x3D;&amp;gt; {
    const query &#x3D; c.req.query();
    const request &#x3D; {
      handlerId: query.handlerId,
      projectId: query.projectId,
      provider: query.provider as &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39; | undefined,
      event: query.event,
      limit: query.limit ? parseInt(query.limit) : undefined,
      offset: query.offset ? parseInt(query.offset) : undefined,
    };
    const response &#x3D; await _.handlersApi.getExecutionHistory(request);
    return c.json(response);
  });

  app.get(&amp;#39;/api/handlers/stats&amp;#39;, async c &#x3D;&amp;gt; {
    const response &#x3D; await _.handlersApi.getHandlerStats();
    return c.json(response);
  });

  app.post(&amp;#39;/api/handlers/validate&amp;#39;, async c &#x3D;&amp;gt; {
    const { filePath } &#x3D; await c.req.json();
    const response &#x3D; await _.handlersApi.validateHandler({ filePath });
    return c.json(response);
  });

  app.post(&amp;#39;/api/handlers/init&amp;#39;, async c &#x3D;&amp;gt; {
    const response &#x3D; await _.handlersApi.initializeHandlerStructure();
    return c.json(response);
  });

  // Generic handlers list and CRUD operations
  app.get(&amp;#39;/api/handlers&amp;#39;, async c &#x3D;&amp;gt; {
    const query &#x3D; c.req.query();
    const request &#x3D; {
      provider: query.provider as &amp;#39;github&amp;#39; | &amp;#39;gitlab&amp;#39; | undefined,
      event: query.event,
      enabled: query.enabled ? query.enabled &#x3D;&#x3D;&#x3D; &amp;#39;true&amp;#39; : undefined,
    };
    const response &#x3D; await _.handlersApi.listHandlers(request);
    return c.json(response);
  });

  app.post(&amp;#39;/api/handlers&amp;#39;, async c &#x3D;&amp;gt; {
    const request &#x3D; await c.req.json();
    const response &#x3D; await _.handlersApi.createHandler(request);
    return c.json(response);
  });

  // Parameterized routes (must come after non-parameterized routes)
  app.get(&amp;#39;/api/handlers/:id&amp;#39;, async c &#x3D;&amp;gt; {
    const id &#x3D; c.req.param(&amp;#39;id&amp;#39;);
    const response &#x3D; await _.handlersApi.getHandler({ id });
    return c.json(response);
  });

  app.put(&amp;#39;/api/handlers/:id&amp;#39;, async c &#x3D;&amp;gt; {
    const id &#x3D; c.req.param(&amp;#39;id&amp;#39;);
    const updates &#x3D; await c.req.json();
    const response &#x3D; await _.handlersApi.updateHandler({ id, updates });
    return c.json(response);
  });

  app.delete(&amp;#39;/api/handlers/:id&amp;#39;, async c &#x3D;&amp;gt; {
    const id &#x3D; c.req.param(&amp;#39;id&amp;#39;);
    const response &#x3D; await _.handlersApi.removeHandler({ id });
    return c.json(response);
  });

  app.post(&amp;#39;/api/handlers/:id/toggle&amp;#39;, async c &#x3D;&amp;gt; {
    const id &#x3D; c.req.param(&amp;#39;id&amp;#39;);
    const { enabled } &#x3D; await c.req.json();
    const response &#x3D; await _.handlersApi.toggleHandler({ id, enabled });
    return c.json(response);
  });

  app.post(&amp;#39;/api/handlers/:id/reload&amp;#39;, async c &#x3D;&amp;gt; {
    const id &#x3D; c.req.param(&amp;#39;id&amp;#39;);
    const response &#x3D; await _.handlersApi.reloadHandler({ id });
    return c.json(response);
  });

  // Missing endpoints that the frontend expects
  app.get(&amp;#39;/api/resolved&amp;#39;, async c &#x3D;&amp;gt; {
    const projectId &#x3D; c.req.query(&amp;#39;projectId&amp;#39;);

    if (!projectId) {
      return c.json({ error: &amp;#39;projectId parameter is required&amp;#39; }, 400);
    }

    try {
      // Get project from database to fetch real brownfield detection data
      const db &#x3D; deps.db as any;
      const projects &#x3D; await db.listProjects();
      const project &#x3D; projects.find((p: any) &#x3D;&amp;gt; p.id &#x3D;&#x3D;&#x3D; projectId);

      if (!project) {
        return c.json({ error: &amp;#39;Project not found&amp;#39; }, 404);
      }

      // Get real artifacts from database
      const artifacts &#x3D; await db.getArtifacts(projectId);
      
      // Build services from real artifacts
      const services: Record&amp;lt;string, any&amp;gt; &#x3D; {};
      const serviceArtifacts &#x3D; artifacts.filter((a: any) &#x3D;&amp;gt; a.type &#x3D;&#x3D;&#x3D; &amp;#39;service&amp;#39;);
      
      for (const artifact of serviceArtifacts) {
        const serviceName &#x3D; artifact.name.replace(/_/g, &amp;#39;-&amp;#39;);
        services[serviceName] &#x3D; {
          name: artifact.name.split(/[-_]/).map((word: string) &#x3D;&amp;gt; 
            word.charAt(0).toUpperCase() + word.slice(1)
          ).join(&amp;#39; &amp;#39;),
          type: &amp;#39;deployment&amp;#39;,
          image: &amp;#39;rust:latest&amp;#39;,
          ports: [{ port: 8080, targetPort: 8080 }],
          metadata: {
            language: artifact.language || &amp;#39;rust&amp;#39;,
            framework: artifact.framework || &amp;#39;cargo&amp;#39;,
            workspaceMember: artifact.metadata?.workspaceMember,
            filePath: artifact.file_path,
            detected: true
          }
        };
      }

      // Build databases from real artifacts
      const databases: Record&amp;lt;string, any&amp;gt; &#x3D; {};
      const databaseArtifacts &#x3D; artifacts.filter((a: any) &#x3D;&amp;gt; a.type &#x3D;&#x3D;&#x3D; &amp;#39;database&amp;#39;);
      
      for (const artifact of databaseArtifacts) {
        const dbName &#x3D; artifact.name.replace(/_/g, &amp;#39;-&amp;#39;);
        databases[dbName] &#x3D; {
          name: artifact.name.split(/[-_]/).map((word: string) &#x3D;&amp;gt; 
            word.charAt(0).toUpperCase() + word.slice(1)
          ).join(&amp;#39; &amp;#39;),
          type: artifact.framework || &amp;#39;postgresql&amp;#39;,
          version: artifact.name &#x3D;&#x3D;&#x3D; &amp;#39;postgres&amp;#39; ? &amp;#39;14&amp;#39; : &amp;#39;7&amp;#39;,
          metadata: {
            configFile: artifact.metadata?.configFile,
            detected: true
          }
        };
      }

      // Build other artifacts (clients, tools, libraries)
      const components: Record&amp;lt;string, any&amp;gt; &#x3D; {};
      const otherArtifacts &#x3D; artifacts.filter((a: any) &#x3D;&amp;gt; ![&amp;#39;service&amp;#39;, &amp;#39;database&amp;#39;].includes(a.type));
      
      for (const artifact of otherArtifacts) {
        const componentName &#x3D; artifact.name.replace(/_/g, &amp;#39;-&amp;#39;);
        components[componentName] &#x3D; {
          name: artifact.name.split(/[-_]/).map((word: string) &#x3D;&amp;gt; 
            word.charAt(0).toUpperCase() + word.slice(1)
          ).join(&amp;#39; &amp;#39;),
          type: artifact.type,
          language: artifact.language || &amp;#39;rust&amp;#39;,
          framework: artifact.framework || &amp;#39;cargo&amp;#39;,
          metadata: {
            workspaceMember: artifact.metadata?.workspaceMember,
            filePath: artifact.file_path,
            detected: true
          }
        };
      }

      // Generate UI routes based on detected services
      const routes &#x3D; Object.keys(services).slice(0, 3).map((serviceName, index) &#x3D;&amp;gt; ({
        id: serviceName.replace(&amp;#39;-service&amp;#39;, &amp;#39;&amp;#39;).replace(&amp;#39;service-&amp;#39;, &amp;#39;&amp;#39;),
        path: &#x60;/${serviceName.replace(&amp;#39;-service&amp;#39;, &amp;#39;&amp;#39;).replace(&amp;#39;service-&amp;#39;, &amp;#39;&amp;#39;)}&#x60;,
        name: services[serviceName].name,
        component: &#x60;${serviceName.replace(&amp;#39;-service&amp;#39;, &amp;#39;&amp;#39;).replace(&amp;#39;service-&amp;#39;, &amp;#39;&amp;#39;).charAt(0).toUpperCase() + serviceName.replace(&amp;#39;-service&amp;#39;, &amp;#39;&amp;#39;).replace(&amp;#39;service-&amp;#39;, &amp;#39;&amp;#39;).slice(1)}Page&#x60;,
        capabilities: [&amp;#39;read-data&amp;#39;]
      }));

      return c.json({
        success: true,
        projectId,
        resolved: {
          apiVersion: &amp;#39;v2&amp;#39;,
          kind: &amp;#39;Application&amp;#39;,
          metadata: {
            name: project.name,
            version: &amp;#39;1.0.0&amp;#39;,
            brownfield: true,
            detectedServices: serviceArtifacts.length,
            detectedDatabases: databaseArtifacts.length,
            totalArtifacts: artifacts.length
          },
          spec: {
            services,
            databases,
            components,
            ui: {
              routes
            },
            flows: [
              {
                id: &amp;#39;service-flow&amp;#39;,
                name: &amp;#39;Service Integration Flow&amp;#39;,
                steps: [
                  { visit: &amp;#39;/&amp;#39; },
                  { expect_api: { method: &amp;#39;GET&amp;#39;, path: &amp;#39;/health&amp;#39; } },
                ],
              },
            ],
            capabilities: {
              &amp;#39;read-data&amp;#39;: {
                name: &amp;#39;Read Data&amp;#39;,
                description: &amp;#39;Capability to read application data&amp;#39;,
              }
            },
          },
        },
      });
    } catch (error) {
      console.error(&amp;#39;Error fetching resolved spec:&amp;#39;, error);
      return c.json({ error: &amp;#39;Failed to fetch project specification&amp;#39; }, 500);
    }
  });

  app.get(&amp;#39;/api/ir/flow&amp;#39;, async c &#x3D;&amp;gt; {
    const projectId &#x3D; c.req.query(&amp;#39;projectId&amp;#39;);

    if (!projectId) {
      return c.json({ error: &amp;#39;projectId parameter is required&amp;#39; }, 400);
    }

    // Mock intermediate representation flow data
    return c.json({
      success: true,
      projectId,
      flows: [
        {
          id: &amp;#39;user-registration&amp;#39;,
          name: &amp;#39;User Registration&amp;#39;,
          description: &amp;#39;New user sign-up process&amp;#39;,
          nodes: [
            {
              id: &amp;#39;start&amp;#39;,
              type: &amp;#39;start&amp;#39;,
              position: { x: 0, y: 0 },
              data: { label: &amp;#39;Start Registration&amp;#39; },
            },
            {
              id: &amp;#39;form&amp;#39;,
              type: &amp;#39;form&amp;#39;,
              position: { x: 200, y: 0 },
              data: { label: &amp;#39;Registration Form&amp;#39;, fields: [&amp;#39;email&amp;#39;, &amp;#39;password&amp;#39;, &amp;#39;name&amp;#39;] },
            },
            {
              id: &amp;#39;validate&amp;#39;,
              type: &amp;#39;decision&amp;#39;,
              position: { x: 400, y: 0 },
              data: { label: &amp;#39;Validate Input&amp;#39; },
            },
            {
              id: &amp;#39;create-user&amp;#39;,
              type: &amp;#39;action&amp;#39;,
              position: { x: 600, y: 0 },
              data: { label: &amp;#39;Create User Account&amp;#39; },
            },
            {
              id: &amp;#39;send-email&amp;#39;,
              type: &amp;#39;action&amp;#39;,
              position: { x: 800, y: 0 },
              data: { label: &amp;#39;Send Welcome Email&amp;#39; },
            },
            {
              id: &amp;#39;success&amp;#39;,
              type: &amp;#39;end&amp;#39;,
              position: { x: 1000, y: 0 },
              data: { label: &amp;#39;Registration Complete&amp;#39; },
            },
          ],
          edges: [
            { id: &amp;#39;e1&amp;#39;, source: &amp;#39;start&amp;#39;, target: &amp;#39;form&amp;#39; },
            { id: &amp;#39;e2&amp;#39;, source: &amp;#39;form&amp;#39;, target: &amp;#39;validate&amp;#39; },
            { id: &amp;#39;e3&amp;#39;, source: &amp;#39;validate&amp;#39;, target: &amp;#39;create-user&amp;#39;, data: { label: &amp;#39;Valid&amp;#39; } },
            { id: &amp;#39;e4&amp;#39;, source: &amp;#39;create-user&amp;#39;, target: &amp;#39;send-email&amp;#39; },
            { id: &amp;#39;e5&amp;#39;, source: &amp;#39;send-email&amp;#39;, target: &amp;#39;success&amp;#39; },
            { id: &amp;#39;e6&amp;#39;, source: &amp;#39;validate&amp;#39;, target: &amp;#39;form&amp;#39;, data: { label: &amp;#39;Invalid&amp;#39; } },
          ],
        },
        {
          id: &amp;#39;user-login&amp;#39;,
          name: &amp;#39;User Login&amp;#39;,
          description: &amp;#39;User authentication process&amp;#39;,
          nodes: [
            {
              id: &amp;#39;start&amp;#39;,
              type: &amp;#39;start&amp;#39;,
              position: { x: 0, y: 100 },
              data: { label: &amp;#39;Start Login&amp;#39; },
            },
            {
              id: &amp;#39;credentials&amp;#39;,
              type: &amp;#39;form&amp;#39;,
              position: { x: 200, y: 100 },
              data: { label: &amp;#39;Enter Credentials&amp;#39;, fields: [&amp;#39;email&amp;#39;, &amp;#39;password&amp;#39;] },
            },
            {
              id: &amp;#39;authenticate&amp;#39;,
              type: &amp;#39;action&amp;#39;,
              position: { x: 400, y: 100 },
              data: { label: &amp;#39;Authenticate User&amp;#39; },
            },
            {
              id: &amp;#39;success&amp;#39;,
              type: &amp;#39;end&amp;#39;,
              position: { x: 600, y: 100 },
              data: { label: &amp;#39;Login Successful&amp;#39; },
            },
          ],
          edges: [
            { id: &amp;#39;e1&amp;#39;, source: &amp;#39;start&amp;#39;, target: &amp;#39;credentials&amp;#39; },
            { id: &amp;#39;e2&amp;#39;, source: &amp;#39;credentials&amp;#39;, target: &amp;#39;authenticate&amp;#39; },
            { id: &amp;#39;e3&amp;#39;, source: &amp;#39;authenticate&amp;#39;, target: &amp;#39;success&amp;#39; },
          ],
        },
      ],
    });
  });

  // Surface analysis endpoint with brownfield detection
  app.post(&amp;#39;/api/surface&amp;#39;, async c &#x3D;&amp;gt; {
    try {
      const body &#x3D; await c.req.json();
      const { targets &#x3D; [], options &#x3D; {} } &#x3D; body;

      if (!targets.length) {
        return c.json(
          {
            success: false,
            error: &amp;#39;targets parameter is required&amp;#39;,
          },
          400
        );
      }

      // Import the brownfield scanner
      const { ScannerRunner } &#x3D; await import(&amp;#39;@arbiter/shared/brownfield/scanner&amp;#39;);
      const { RustPlugin } &#x3D; await import(&amp;#39;@arbiter/shared/brownfield/plugins/rust&amp;#39;);

      // Initialize scanner with plugins
      const scanner &#x3D; new ScannerRunner({
        projectRoot: targets[0],
        plugins: [new RustPlugin()],
        parseOptions: {
          deepAnalysis: options.deepAnalysis ?? true,
          maxFileSize: options.maxFileSize ?? 1024 * 1024, // 1MB
          targetLanguages: options.targetLanguages ?? [&amp;#39;rust&amp;#39;],
          patterns: {
            include: [&amp;#39;**/*&amp;#39;],
            exclude: []
          }
        },
        inferenceOptions: {
          minConfidence: options.minConfidence ?? 0.3,
          inferRelationships: options.inferRelationships ?? true,
        },
        debug: options.debug ?? false,
      });

      // Run the brownfield analysis
      const manifest &#x3D; await scanner.scan();

      return c.json({
        success: true,
        targets,
        manifest,
        artifacts: manifest.artifacts,
        statistics: manifest.statistics,
        message: &#x60;Found ${manifest.artifacts.length} artifacts across ${manifest.statistics?.languagesDetected?.length || 0} languages&#x60;,
      });
    } catch (error) {
      console.error(&amp;#39;Surface analysis error:&amp;#39;, error);
      return c.json(
        {
          success: false,
          error: &amp;#39;Surface analysis failed&amp;#39;,
          message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
        },
        500
      );
    }
  });

  return app;
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-20">
                <div class="file-header">📄 src/handlers/examples/slack-notification.ts</div>
                <div class="file-content">
                    <pre>/**
 * Example: Slack notification handler
 * Sends formatted notifications to Slack channels on webhook events
 */

import type { HandlerModule, WebhookHandler } from &amp;#39;../types.js&amp;#39;;

const handleSlackNotification: WebhookHandler &#x3D; async (payload, context) &#x3D;&amp;gt; {
  const { logger, services, config } &#x3D; context;
  const { parsed } &#x3D; payload;

  logger.info(&amp;#39;Processing Slack notification handler&amp;#39;, {
    event: parsed.eventType,
    repository: parsed.repository.fullName,
  });

  const slackWebhook &#x3D; config.secrets.SLACK_WEBHOOK;
  if (!slackWebhook) {
    return {
      success: false,
      message: &amp;#39;SLACK_WEBHOOK secret not configured&amp;#39;,
      errors: [
        {
          code: &amp;#39;MISSING_CONFIGURATION&amp;#39;,
          message: &amp;#39;Slack webhook URL is required in handler configuration&amp;#39;,
        },
      ],
    };
  }

  try {
    let message &#x3D; &amp;#39;&amp;#39;;
    let blocks: unknown[] &#x3D; [];

    // Format message based on event type
    switch (parsed.eventType) {
      case &amp;#39;push&amp;#39;:
        if (parsed.commits &amp;amp;&amp;amp; parsed.commits.length &amp;gt; 0) {
          message &#x3D; &#x60;📝 ${parsed.commits.length} new commit(s) pushed to ${parsed.repository.fullName}&#x60;;

          blocks &#x3D; [
            {
              type: &amp;#39;header&amp;#39;,
              text: {
                type: &amp;#39;plain_text&amp;#39;,
                text: &amp;#39;📝 New commits pushed&amp;#39;,
              },
            },
            {
              type: &amp;#39;section&amp;#39;,
              fields: [
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Repository:* &amp;lt;${parsed.repository.url}|${parsed.repository.fullName}&amp;gt;&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Commits:* ${parsed.commits.length}&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Author:* ${parsed.author.name}&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Branch:* ${payload.ref?.replace(&amp;#39;refs/heads/&amp;#39;, &amp;#39;&amp;#39;) || &amp;#39;unknown&amp;#39;}&#x60;,
                },
              ],
            },
            {
              type: &amp;#39;section&amp;#39;,
              text: {
                type: &amp;#39;mrkdwn&amp;#39;,
                text: &amp;#39;*Recent commits:*&amp;#39;,
              },
            },
          ];

          // Add up to 5 recent commits
          const recentCommits &#x3D; parsed.commits.slice(0, 5);
          for (const commit of recentCommits) {
            blocks.push({
              type: &amp;#39;section&amp;#39;,
              text: {
                type: &amp;#39;mrkdwn&amp;#39;,
                text: &#x60;• &amp;lt;${commit.url}|${commit.sha.substring(0, 7)}&amp;gt; ${commit.message}\n  _by ${commit.author}_&#x60;,
              },
            });
          }

          if (parsed.commits.length &amp;gt; 5) {
            blocks.push({
              type: &amp;#39;context&amp;#39;,
              elements: [
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;_and ${parsed.commits.length - 5} more commits..._&#x60;,
                },
              ],
            });
          }
        }
        break;

      case &amp;#39;pull_request&amp;#39;:
        if (parsed.pullRequest &amp;amp;&amp;amp; parsed.action) {
          const pr &#x3D; parsed.pullRequest;
          const emoji &#x3D;
            parsed.action &#x3D;&#x3D;&#x3D; &amp;#39;opened&amp;#39;
              ? &amp;#39;🔀&amp;#39;
              : parsed.action &#x3D;&#x3D;&#x3D; &amp;#39;closed&amp;#39; &amp;amp;&amp;amp; pr.merged
                ? &amp;#39;✅&amp;#39;
                : parsed.action &#x3D;&#x3D;&#x3D; &amp;#39;closed&amp;#39;
                  ? &amp;#39;❌&amp;#39;
                  : &amp;#39;📝&amp;#39;;

          message &#x3D; &#x60;${emoji} Pull request ${parsed.action}: ${pr.title}&#x60;;

          blocks &#x3D; [
            {
              type: &amp;#39;header&amp;#39;,
              text: {
                type: &amp;#39;plain_text&amp;#39;,
                text: &#x60;${emoji} Pull request ${parsed.action}&#x60;,
              },
            },
            {
              type: &amp;#39;section&amp;#39;,
              fields: [
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Repository:* &amp;lt;${parsed.repository.url}|${parsed.repository.fullName}&amp;gt;&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*PR:* &amp;lt;${pr.url}|#${pr.id}&amp;gt;&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Author:* ${parsed.author.name}&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Branches:* ${pr.headBranch} → ${pr.baseBranch}&#x60;,
                },
              ],
            },
            {
              type: &amp;#39;section&amp;#39;,
              text: {
                type: &amp;#39;mrkdwn&amp;#39;,
                text: &#x60;*${pr.title}*\n${pr.body ? pr.body.substring(0, 300) + (pr.body.length &amp;gt; 300 ? &amp;#39;...&amp;#39; : &amp;#39;&amp;#39;) : &amp;#39;_No description provided_&amp;#39;}&#x60;,
              },
            },
          ];

          if (parsed.action &#x3D;&#x3D;&#x3D; &amp;#39;closed&amp;#39; &amp;amp;&amp;amp; pr.merged) {
            blocks.push({
              type: &amp;#39;context&amp;#39;,
              elements: [
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &amp;#39;✅ This pull request was merged successfully&amp;#39;,
                },
              ],
            });
          }
        }
        break;

      case &amp;#39;issues&amp;#39;:
        if (parsed.issue &amp;amp;&amp;amp; parsed.action) {
          const issue &#x3D; parsed.issue;
          const emoji &#x3D;
            parsed.action &#x3D;&#x3D;&#x3D; &amp;#39;opened&amp;#39; ? &amp;#39;🐛&amp;#39; : parsed.action &#x3D;&#x3D;&#x3D; &amp;#39;closed&amp;#39; ? &amp;#39;✅&amp;#39; : &amp;#39;📝&amp;#39;;

          message &#x3D; &#x60;${emoji} Issue ${parsed.action}: ${issue.title}&#x60;;

          blocks &#x3D; [
            {
              type: &amp;#39;header&amp;#39;,
              text: {
                type: &amp;#39;plain_text&amp;#39;,
                text: &#x60;${emoji} Issue ${parsed.action}&#x60;,
              },
            },
            {
              type: &amp;#39;section&amp;#39;,
              fields: [
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Repository:* &amp;lt;${parsed.repository.url}|${parsed.repository.fullName}&amp;gt;&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Issue:* &amp;lt;${issue.url}|#${issue.id}&amp;gt;&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Author:* ${parsed.author.name}&#x60;,
                },
                {
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;*Labels:* ${issue.labels.length &amp;gt; 0 ? issue.labels.join(&amp;#39;, &amp;#39;) : &amp;#39;None&amp;#39;}&#x60;,
                },
              ],
            },
            {
              type: &amp;#39;section&amp;#39;,
              text: {
                type: &amp;#39;mrkdwn&amp;#39;,
                text: &#x60;*${issue.title}*\n${issue.body ? issue.body.substring(0, 300) + (issue.body.length &amp;gt; 300 ? &amp;#39;...&amp;#39; : &amp;#39;&amp;#39;) : &amp;#39;_No description provided_&amp;#39;}&#x60;,
              },
            },
          ];
        }
        break;

      default:
        message &#x3D; &#x60;🔔 ${parsed.eventType} event in ${parsed.repository.fullName}&#x60;;
        blocks &#x3D; [
          {
            type: &amp;#39;section&amp;#39;,
            text: {
              type: &amp;#39;mrkdwn&amp;#39;,
              text: &#x60;🔔 Received *${parsed.eventType}* event from &amp;lt;${parsed.repository.url}|${parsed.repository.fullName}&amp;gt;&#x60;,
            },
          },
        ];
    }

    // Send Slack notification
    await services.notifications.sendSlack(slackWebhook, {
      text: message,
      blocks,
      username: &amp;#39;Arbiter Webhook&amp;#39;,
      iconEmoji: &amp;#39;:robot_face:&amp;#39;,
    });

    logger.info(&amp;#39;Slack notification sent successfully&amp;#39;, {
      event: parsed.eventType,
      repository: parsed.repository.fullName,
    });

    return {
      success: true,
      message: &amp;#39;Slack notification sent successfully&amp;#39;,
      actions: [&amp;#39;Sent Slack notification&amp;#39;],
      data: {
        slackMessage: message,
        blocksCount: blocks.length,
      },
    };
  } catch (error) {
    logger.error(&amp;#39;Slack notification failed&amp;#39;, error as Error);

    return {
      success: false,
      message: &amp;#39;Failed to send Slack notification&amp;#39;,
      errors: [
        {
          code: &amp;#39;NOTIFICATION_FAILED&amp;#39;,
          message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
          stack: error instanceof Error ? error.stack : undefined,
        },
      ],
    };
  }
};

const handlerModule: HandlerModule &#x3D; {
  handler: handleSlackNotification,
  config: {
    enabled: true,
    timeout: 15000,
    retries: 1,
    environment: {},
    secrets: {},
  },
  metadata: {
    name: &amp;#39;Slack Notification Handler&amp;#39;,
    description: &amp;#39;Sends formatted notifications to Slack channels for webhook events&amp;#39;,
    version: &amp;#39;1.0.0&amp;#39;,
    author: &amp;#39;Arbiter Team&amp;#39;,
    supportedEvents: [
      &amp;#39;push&amp;#39;,
      &amp;#39;pull_request&amp;#39;,
      &amp;#39;merge_request&amp;#39;,
      &amp;#39;issues&amp;#39;,
      &amp;#39;Push Hook&amp;#39;,
      &amp;#39;Merge Request Hook&amp;#39;,
    ],
    requiredPermissions: [&amp;#39;notifications:send&amp;#39;],
  },
};

export default handlerModule;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-21">
                <div class="file-header">📄 src/migrations/run.ts</div>
                <div class="file-content">
                    <pre>#!/usr/bin/env bun
/**
 * Database migration runner
 */
import { Database } from &amp;#39;bun:sqlite&amp;#39;;
import { existsSync } from &amp;#39;node:fs&amp;#39;;
import { drizzle } from &amp;#39;drizzle-orm/bun-sqlite&amp;#39;;
import { migrate } from &amp;#39;drizzle-orm/bun-sqlite/migrator&amp;#39;;
import { logger } from &amp;#39;../utils.ts&amp;#39;;

interface Migration {
  id: string;
  name: string;
  up: string;
  down?: string;
}

const migrations: Migration[] &#x3D; [
  {
    id: &amp;#39;001&amp;#39;,
    name: &amp;#39;initial_schema&amp;#39;,
    up: &#x60;
      -- Enable WAL mode for better concurrent access
      PRAGMA journal_mode &#x3D; WAL;
      PRAGMA synchronous &#x3D; NORMAL;
      PRAGMA cache_size &#x3D; 1000;
      PRAGMA temp_store &#x3D; memory;

      -- Create tables
      CREATE TABLE IF NOT EXISTS projects (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        updated_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;))
      );

      CREATE TABLE IF NOT EXISTS fragments (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        path TEXT NOT NULL,
        content TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        updated_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        FOREIGN KEY (project_id) REFERENCES projects (id) ON DELETE CASCADE,
        UNIQUE (project_id, path)
      );

      CREATE TABLE IF NOT EXISTS versions (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        spec_hash TEXT NOT NULL,
        resolved_json TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        FOREIGN KEY (project_id) REFERENCES projects (id) ON DELETE CASCADE,
        UNIQUE (project_id, spec_hash)
      );

      CREATE TABLE IF NOT EXISTS events (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        event_type TEXT NOT NULL,
        data TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;)),
        FOREIGN KEY (project_id) REFERENCES projects (id) ON DELETE CASCADE
      );

      -- Create indices for performance
      CREATE INDEX IF NOT EXISTS idx_fragments_project_id ON fragments (project_id);
      CREATE INDEX IF NOT EXISTS idx_fragments_path ON fragments (project_id, path);
      CREATE INDEX IF NOT EXISTS idx_versions_project_id ON versions (project_id);
      CREATE INDEX IF NOT EXISTS idx_versions_hash ON versions (spec_hash);
      CREATE INDEX IF NOT EXISTS idx_events_project_id ON events (project_id);
      CREATE INDEX IF NOT EXISTS idx_events_created_at ON events (created_at DESC);

      -- Trigger to update updated_at on projects
      CREATE TRIGGER IF NOT EXISTS update_projects_updated_at
      AFTER UPDATE ON projects
      FOR EACH ROW
      BEGIN
        UPDATE projects SET updated_at &#x3D; datetime(&amp;#39;now&amp;#39;) WHERE id &#x3D; NEW.id;
      END;

      -- Trigger to update updated_at on fragments
      CREATE TRIGGER IF NOT EXISTS update_fragments_updated_at
      AFTER UPDATE ON fragments
      FOR EACH ROW
      BEGIN
        UPDATE fragments SET updated_at &#x3D; datetime(&amp;#39;now&amp;#39;) WHERE id &#x3D; NEW.id;
      END;
    &#x60;,
    down: &#x60;
      DROP TRIGGER IF EXISTS update_fragments_updated_at;
      DROP TRIGGER IF EXISTS update_projects_updated_at;
      DROP INDEX IF EXISTS idx_events_created_at;
      DROP INDEX IF EXISTS idx_events_project_id;
      DROP INDEX IF EXISTS idx_versions_hash;
      DROP INDEX IF EXISTS idx_versions_project_id;
      DROP INDEX IF EXISTS idx_fragments_path;
      DROP INDEX IF EXISTS idx_fragments_project_id;
      DROP TABLE IF EXISTS events;
      DROP TABLE IF EXISTS versions;
      DROP TABLE IF EXISTS fragments;
      DROP TABLE IF EXISTS projects;
    &#x60;,
  },
];

class MigrationRunner {
  private db: Database;

  constructor(dbPath: string) {
    this.db &#x3D; new Database(dbPath, { create: true });
    this.initializeMigrationTable();
  }

  private initializeMigrationTable(): void {
    this.db.exec(&#x60;
      CREATE TABLE IF NOT EXISTS migrations (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        applied_at TEXT NOT NULL DEFAULT (datetime(&amp;#39;now&amp;#39;))
      )
    &#x60;);
  }

  private getAppliedMigrations(): Set&amp;lt;string&amp;gt; {
    const stmt &#x3D; this.db.prepare(&amp;#39;SELECT id FROM migrations&amp;#39;);
    const results &#x3D; stmt.all() as { id: string }[];
    return new Set(results.map(r &#x3D;&amp;gt; r.id));
  }

  private recordMigration(id: string, name: string): void {
    const stmt &#x3D; this.db.prepare(&amp;#39;INSERT INTO migrations (id, name) VALUES (?, ?)&amp;#39;);
    stmt.run(id, name);
  }

  private removeMigration(id: string): void {
    const stmt &#x3D; this.db.prepare(&amp;#39;DELETE FROM migrations WHERE id &#x3D; ?&amp;#39;);
    stmt.run(id);
  }

  async runMigrations(): Promise&amp;lt;void&amp;gt; {
    await this.runDrizzleMigrations();

    const applied &#x3D; this.getAppliedMigrations();
    const pending &#x3D; migrations.filter(m &#x3D;&amp;gt; !applied.has(m.id));

    if (pending.length &#x3D;&#x3D;&#x3D; 0) {
      logger.info(&amp;#39;No pending migrations&amp;#39;);
      return;
    }

    logger.info(&#x60;Running ${pending.length} pending migrations&#x60;);

    for (const migration of pending) {
      try {
        logger.info(&#x60;Applying migration: ${migration.id} - ${migration.name}&#x60;);

        // Execute migration (some commands can&amp;#39;t be in transactions)
        this.db.exec(migration.up);
        this.recordMigration(migration.id, migration.name);

        logger.info(&#x60;✅ Migration ${migration.id} applied successfully&#x60;);
      } catch (error) {
        logger.error(
          &#x60;❌ Migration ${migration.id} failed&#x60;,
          error instanceof Error ? error : undefined
        );
        throw error;
      }
    }

    logger.info(&amp;#39;All migrations completed successfully&amp;#39;);
  }

  private async runDrizzleMigrations(): Promise&amp;lt;void&amp;gt; {
    const migrationsDir &#x3D; new URL(&amp;#39;../../drizzle&amp;#39;, import.meta.url).pathname;

    if (!existsSync(migrationsDir)) {
      return;
    }

    logger.info(&amp;#39;Running Drizzle migrations&amp;#39;, { migrationsDir });

    try {
      await migrate(drizzle(this.db), { migrationsFolder: migrationsDir });
      logger.info(&amp;#39;Drizzle migrations completed successfully&amp;#39;);
    } catch (error) {
      logger.error(&amp;#39;Drizzle migrations failed&amp;#39;, error instanceof Error ? error : undefined);
      throw error;
    }
  }

  async rollbackMigration(id: string): Promise&amp;lt;void&amp;gt; {
    const migration &#x3D; migrations.find(m &#x3D;&amp;gt; m.id &#x3D;&#x3D;&#x3D; id);

    if (!migration) {
      throw new Error(&#x60;Migration ${id} not found&#x60;);
    }

    if (!migration.down) {
      throw new Error(&#x60;Migration ${id} has no rollback script&#x60;);
    }

    const applied &#x3D; this.getAppliedMigrations();

    if (!applied.has(id)) {
      throw new Error(&#x60;Migration ${id} has not been applied&#x60;);
    }

    try {
      logger.info(&#x60;Rolling back migration: ${migration.id} - ${migration.name}&#x60;);

      // Execute rollback
      this.db.exec(migration.down!);
      this.removeMigration(migration.id);

      logger.info(&#x60;✅ Migration ${migration.id} rolled back successfully&#x60;);
    } catch (error) {
      logger.error(
        &#x60;❌ Rollback of migration ${migration.id} failed&#x60;,
        error instanceof Error ? error : undefined
      );
      throw error;
    }
  }

  listMigrations(): void {
    const applied &#x3D; this.getAppliedMigrations();

    logger.info(&amp;#39;Migration Status:&amp;#39;);
    console.log(&amp;#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&amp;#39;);

    for (const migration of migrations) {
      const status &#x3D; applied.has(migration.id) ? &amp;#39;✅ Applied&amp;#39; : &amp;#39;⏳ Pending&amp;#39;;
      console.log(&#x60;${status} ${migration.id} - ${migration.name}&#x60;);
    }
  }

  close(): void {
    this.db.close();
  }
}

// CLI interface
async function main() {
  const dbPath &#x3D; process.env.DATABASE_PATH || &amp;#39;./spec_workbench.db&amp;#39;;
  const runner &#x3D; new MigrationRunner(dbPath);

  try {
    const command &#x3D; process.argv[2];

    switch (command) {
      case &amp;#39;up&amp;#39;:
        await runner.runMigrations();
        break;

      case &amp;#39;down&amp;#39;: {
        const migrationId &#x3D; process.argv[3];
        if (!migrationId) {
          console.error(&amp;#39;Usage: bun run migrate down &amp;lt;migration_id&amp;gt;&amp;#39;);
          process.exit(1);
        }
        await runner.rollbackMigration(migrationId);
        break;
      }

      case &amp;#39;status&amp;#39;:
        runner.listMigrations();
        break;

      default:
        // Default to running migrations
        await runner.runMigrations();
        break;
    }
  } catch (error) {
    logger.error(&amp;#39;Migration failed&amp;#39;, error instanceof Error ? error : undefined);
    process.exit(1);
  } finally {
    runner.close();
  }
}

if (import.meta.main) {
  main();
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-22">
                <div class="file-header">📄 src/websocket/index.ts</div>
                <div class="file-content">
                    <pre>import type { ServerWebSocket } from &amp;#39;bun&amp;#39;;
import type { AuthService } from &amp;#39;../auth.ts&amp;#39;;
import type { EventService } from &amp;#39;../events.ts&amp;#39;;
import type { ServerConfig, WebSocketMessage } from &amp;#39;../types.ts&amp;#39;;
import { logger } from &amp;#39;../utils.ts&amp;#39;;

export class WebSocketHandler {
  constructor(
    private auth: AuthService,
    private events: EventService,
    private config: ServerConfig[&amp;#39;websocket&amp;#39;]
  ) {}

  /**
   * Check if request is a WebSocket upgrade for /events endpoint
   */
  isWebSocketUpgrade(pathname: string, request: Request): boolean {
    const upgradeHeader &#x3D; request.headers.get(&amp;#39;upgrade&amp;#39;);
    const connectionHeader &#x3D; request.headers.get(&amp;#39;connection&amp;#39;);

    const isUpgrade &#x3D;
      pathname &#x3D;&#x3D;&#x3D; &amp;#39;/events&amp;#39; &amp;amp;&amp;amp;
      upgradeHeader?.toLowerCase() &#x3D;&#x3D;&#x3D; &amp;#39;websocket&amp;#39; &amp;amp;&amp;amp;
      connectionHeader?.toLowerCase().includes(&amp;#39;upgrade&amp;#39;);

    logger.info(&amp;#39;[WS] isWebSocketUpgrade called&amp;#39;, {
      pathname,
      upgradeHeader,
      connectionHeader,
      userAgent: request.headers.get(&amp;#39;user-agent&amp;#39;),
      origin: request.headers.get(&amp;#39;origin&amp;#39;),
      result: isUpgrade,
    });

    return isUpgrade;
  }

  /**
   * Handle WebSocket upgrade request
   */
  async handleUpgrade(request: Request, server: any): Promise&amp;lt;{ response?: Response }&amp;gt; {
    const startTime &#x3D; Date.now();
    let connectionId: string | undefined;

    try {
      logger.info(&amp;#39;[WS] handleUpgrade called&amp;#39;, {
        url: request.url,
        method: request.method,
        timestamp: new Date().toISOString(),
        upgradeHeaders: {
          upgrade: request.headers.get(&amp;#39;upgrade&amp;#39;),
          connection: request.headers.get(&amp;#39;connection&amp;#39;),
          &amp;#39;sec-websocket-key&amp;#39;: request.headers.get(&amp;#39;sec-websocket-key&amp;#39;),
          &amp;#39;sec-websocket-version&amp;#39;: request.headers.get(&amp;#39;sec-websocket-version&amp;#39;),
          &amp;#39;sec-websocket-protocol&amp;#39;: request.headers.get(&amp;#39;sec-websocket-protocol&amp;#39;),
          origin: request.headers.get(&amp;#39;origin&amp;#39;),
          userAgent: request.headers.get(&amp;#39;user-agent&amp;#39;),
        },
      });

      // Validate WebSocket headers
      const secWebSocketKey &#x3D; request.headers.get(&amp;#39;sec-websocket-key&amp;#39;);
      const secWebSocketVersion &#x3D; request.headers.get(&amp;#39;sec-websocket-version&amp;#39;);

      if (!secWebSocketKey) {
        logger.warn(&amp;#39;[WS] Missing Sec-WebSocket-Key header&amp;#39;);
        return {
          response: new Response(&amp;#39;Bad Request: Missing Sec-WebSocket-Key&amp;#39;, { status: 400 }),
        };
      }

      if (secWebSocketVersion !&#x3D;&#x3D; &amp;#39;13&amp;#39;) {
        logger.warn(&amp;#39;[WS] Unsupported WebSocket version&amp;#39;, { version: secWebSocketVersion });
        return {
          response: new Response(&amp;#39;Bad Request: Unsupported WebSocket version&amp;#39;, { status: 400 }),
        };
      }

      // Get auth context with timeout
      logger.info(&amp;#39;[WS] Authenticating request...&amp;#39;);
      const authPromise &#x3D; this.auth.authenticateRequest(request.headers);
      const timeoutPromise &#x3D; new Promise((_, reject) &#x3D;&amp;gt;
        setTimeout(() &#x3D;&amp;gt; reject(new Error(&amp;#39;Authentication timeout&amp;#39;)), 5000)
      );

      const authContext &#x3D; (await Promise.race([authPromise, timeoutPromise])) as any;

      logger.info(&amp;#39;[WS] Auth context result&amp;#39;, {
        authResult: authContext ? &amp;#39;OK&amp;#39; : &amp;#39;FAILED&amp;#39;,
        hasContext: !!authContext,
        authDuration: Date.now() - startTime,
      });

      if (!authContext) {
        logger.warn(&amp;#39;[WS] Auth failed - returning 401&amp;#39;);
        return {
          response: new Response(&amp;#39;Unauthorized&amp;#39;, { status: 401 }),
        };
      }

      logger.info(&amp;#39;[WS] Attempting server.upgrade...&amp;#39;);

      // Generate connection ID before upgrade
      connectionId &#x3D; &#x60;ws_${Date.now()}_${Math.random().toString(36).substring(2, 15)}&#x60;;

      // Upgrade the connection with enhanced error handling
      let upgraded: boolean;
      try {
        upgraded &#x3D; server.upgrade(request, {
          data: {
            connectionId,
            authContext,
            upgradeTime: new Date().toISOString(),
          },
        });
      } catch (upgradeError) {
        logger.error(
          &amp;#39;[WS] Server upgrade threw exception&amp;#39;,
          upgradeError instanceof Error ? upgradeError : undefined,
          {
            connectionId,
            duration: Date.now() - startTime,
          }
        );
        return {
          response: new Response(&amp;#39;WebSocket upgrade internal error&amp;#39;, { status: 500 }),
        };
      }

      logger.info(&amp;#39;[WS] Upgrade result&amp;#39;, {
        upgraded: upgraded ? &amp;#39;SUCCESS&amp;#39; : &amp;#39;FAILED&amp;#39;,
        connectionId,
        duration: Date.now() - startTime,
      });

      if (!upgraded) {
        logger.warn(&amp;#39;[WS] Upgrade failed - returning 400&amp;#39;, {
          connectionId,
          possibleCauses: [
            &amp;#39;Connection already established&amp;#39;,
            &amp;#39;Invalid headers&amp;#39;,
            &amp;#39;Server resource constraints&amp;#39;,
            &amp;#39;Network conditions&amp;#39;,
          ],
        });
        return {
          response: new Response(&amp;#39;WebSocket upgrade failed&amp;#39;, { status: 400 }),
        };
      }

      logger.info(&amp;#39;[WS] Upgrade successful - no response needed&amp;#39;, {
        connectionId,
        totalDuration: Date.now() - startTime,
      });
      return {}; // Success, no response needed
    } catch (error) {
      const duration &#x3D; Date.now() - startTime;
      logger.error(&amp;#39;[WS] WebSocket upgrade error&amp;#39;, error instanceof Error ? error : undefined, {
        connectionId,
        duration,
        errorType: error instanceof Error ? error.constructor.name : typeof error,
        isTimeout: error instanceof Error &amp;amp;&amp;amp; error.message.includes(&amp;#39;timeout&amp;#39;),
        isAuthError: error instanceof Error &amp;amp;&amp;amp; error.message.includes(&amp;#39;auth&amp;#39;),
        requestHeaders: Object.fromEntries(request.headers.entries()),
      });

      // Return appropriate error response based on error type
      if (error instanceof Error) {
        if (error.message.includes(&amp;#39;timeout&amp;#39;)) {
          return {
            response: new Response(&amp;#39;WebSocket upgrade timeout&amp;#39;, { status: 408 }),
          };
        }
        if (error.message.includes(&amp;#39;auth&amp;#39;)) {
          return {
            response: new Response(&amp;#39;WebSocket authentication error&amp;#39;, { status: 401 }),
          };
        }
      }

      return {
        response: new Response(&amp;#39;WebSocket upgrade error&amp;#39;, { status: 500 }),
      };
    }
  }

  /**
   * Handle WebSocket connection opened
   */
  handleOpen(
    ws: ServerWebSocket&amp;lt;{ connectionId: string; authContext: any; upgradeTime?: string }&amp;gt;
  ): void {
    const startTime &#x3D; Date.now();
    let connectionId: string | undefined;

    try {
      logger.info(&amp;#39;[WS] Connection opened - handleOpen called&amp;#39;, {
        hasData: !!ws.data,
        hasAuthContext: !!ws.data?.authContext,
        upgradeTime: ws.data?.upgradeTime,
      });

      // Validate WebSocket data
      if (!ws.data) {
        logger.error(&amp;#39;[WS] WebSocket opened without data object&amp;#39;);
        ws.close(1002, &amp;#39;Invalid connection data&amp;#39;);
        return;
      }

      if (!ws.data.authContext) {
        logger.error(&amp;#39;[WS] WebSocket opened without auth context&amp;#39;);
        ws.close(1002, &amp;#39;Missing authentication&amp;#39;);
        return;
      }

      // Generate connection ID if not present
      if (!ws.data.connectionId) {
        connectionId &#x3D; &#x60;ws_${Date.now()}_${Math.random().toString(36).substring(2, 15)}&#x60;;
        ws.data.connectionId &#x3D; connectionId;
        logger.info(&amp;#39;[WS] Generated connection ID&amp;#39;, { connectionId });
      } else {
        connectionId &#x3D; ws.data.connectionId;
      }

      // Register with events service with timeout
      const connectionPromise &#x3D; this.events.handleConnection(ws, ws.data.authContext);
      const timeoutPromise &#x3D; new Promise((_, reject) &#x3D;&amp;gt;
        setTimeout(() &#x3D;&amp;gt; reject(new Error(&amp;#39;Connection registration timeout&amp;#39;)), 3000)
      );

      Promise.race([connectionPromise, timeoutPromise])
        .then(registeredId &#x3D;&amp;gt; {
          if (registeredId !&#x3D;&#x3D; connectionId) {
            logger.info(&amp;#39;[WS] Connection ID updated by events service&amp;#39;, {
              original: connectionId,
              updated: registeredId,
            });
            ws.data.connectionId &#x3D; registeredId;
            connectionId &#x3D; registeredId;
          }

          logger.info(&amp;#39;[WS] Connection established successfully&amp;#39;, {
            connectionId,
            duration: Date.now() - startTime,
            authUser: ws.data.authContext?.user_id || &amp;#39;anonymous&amp;#39;,
          });

          logger.debug(&amp;#39;WebSocket connection opened&amp;#39;, { connectionId });
        })
        .catch(error &#x3D;&amp;gt; {
          logger.error(
            &amp;#39;[WS] Failed to register connection with events service&amp;#39;,
            error instanceof Error ? error : undefined,
            {
              connectionId,
              duration: Date.now() - startTime,
            }
          );
          ws.close(1011, &amp;#39;Connection registration failed&amp;#39;);
        });
    } catch (error) {
      logger.error(&amp;#39;[WS] Error in handleOpen&amp;#39;, error instanceof Error ? error : undefined, {
        connectionId,
        duration: Date.now() - startTime,
        hasWebSocketData: !!ws.data,
      });

      try {
        ws.close(1011, &amp;#39;Connection setup failed&amp;#39;);
      } catch (closeError) {
        logger.error(
          &amp;#39;[WS] Failed to close WebSocket after error&amp;#39;,
          closeError instanceof Error ? closeError : undefined
        );
      }
    }
  }

  /**
   * Handle WebSocket message received
   */
  async handleMessage(
    ws: ServerWebSocket&amp;lt;{ connectionId: string; authContext: any }&amp;gt;,
    message: string
  ): Promise&amp;lt;void&amp;gt; {
    const startTime &#x3D; Date.now();
    let connectionId: string | undefined;

    try {
      connectionId &#x3D; ws.data?.connectionId;

      logger.debug(&amp;#39;[WS] Message received&amp;#39;, {
        connectionId,
        messageLength: message.length,
        messagePreview: message.length &amp;gt; 100 ? message.substring(0, 100) + &amp;#39;...&amp;#39; : message,
      });

      if (!connectionId) {
        logger.warn(&amp;#39;[WS] Received message from connection without ID&amp;#39;, {
          hasData: !!ws.data,
          messageLength: message.length,
        });
        ws.send(
          JSON.stringify({
            type: &amp;#39;error&amp;#39;,
            error: &amp;#39;Connection not properly initialized&amp;#39;,
            timestamp: new Date().toISOString(),
          })
        );
        return;
      }

      // Validate message size
      if (message.length &amp;gt; 64 * 1024) {
        // 64KB limit
        logger.warn(&amp;#39;[WS] Message too large&amp;#39;, {
          connectionId,
          messageLength: message.length,
          limit: 64 * 1024,
        });
        ws.send(
          JSON.stringify({
            type: &amp;#39;error&amp;#39;,
            error: &amp;#39;Message too large&amp;#39;,
            maxSize: 64 * 1024,
            timestamp: new Date().toISOString(),
          })
        );
        return;
      }

      let parsedMessage: WebSocketMessage;
      try {
        parsedMessage &#x3D; JSON.parse(message);
      } catch (parseError) {
        logger.warn(&amp;#39;[WS] Invalid JSON message received&amp;#39;, {
          connectionId,
          messageLength: message.length,
          error: parseError instanceof Error ? parseError.message : &amp;#39;Unknown parse error&amp;#39;,
        });
        ws.send(
          JSON.stringify({
            type: &amp;#39;error&amp;#39;,
            error: &amp;#39;Invalid JSON format&amp;#39;,
            timestamp: new Date().toISOString(),
          })
        );
        return;
      }

      // Validate message structure
      if (!parsedMessage || typeof parsedMessage !&#x3D;&#x3D; &amp;#39;object&amp;#39;) {
        logger.warn(&amp;#39;[WS] Invalid message structure&amp;#39;, { connectionId });
        ws.send(
          JSON.stringify({
            type: &amp;#39;error&amp;#39;,
            error: &amp;#39;Invalid message structure&amp;#39;,
            timestamp: new Date().toISOString(),
          })
        );
        return;
      }

      // Handle message with timeout
      const messagePromise &#x3D; this.events.handleMessage(connectionId, parsedMessage);
      const timeoutPromise &#x3D; new Promise((_, reject) &#x3D;&amp;gt;
        setTimeout(() &#x3D;&amp;gt; reject(new Error(&amp;#39;Message handling timeout&amp;#39;)), 10000)
      );

      await Promise.race([messagePromise, timeoutPromise]);

      logger.debug(&amp;#39;[WS] Message handled successfully&amp;#39;, {
        connectionId,
        messageType: parsedMessage.type || &amp;#39;unknown&amp;#39;,
        duration: Date.now() - startTime,
      });
    } catch (error) {
      logger.error(&amp;#39;[WS] WebSocket message error&amp;#39;, error instanceof Error ? error : undefined, {
        connectionId,
        duration: Date.now() - startTime,
        messageLength: message.length,
        errorType: error instanceof Error ? error.constructor.name : typeof error,
        isTimeout: error instanceof Error &amp;amp;&amp;amp; error.message.includes(&amp;#39;timeout&amp;#39;),
      });

      // Send error response to client
      try {
        ws.send(
          JSON.stringify({
            type: &amp;#39;error&amp;#39;,
            error: &amp;#39;Message processing failed&amp;#39;,
            details: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
            timestamp: new Date().toISOString(),
          })
        );
      } catch (sendError) {
        logger.error(
          &amp;#39;[WS] Failed to send error response&amp;#39;,
          sendError instanceof Error ? sendError : undefined
        );
      }
    }
  }

  /**
   * Handle WebSocket connection closed
   */
  handleClose(
    ws: ServerWebSocket&amp;lt;{ connectionId: string; authContext: any }&amp;gt;,
    code?: number,
    reason?: string
  ): void {
    const startTime &#x3D; Date.now();
    let connectionId: string | undefined;

    try {
      connectionId &#x3D; ws.data?.connectionId;

      logger.info(&amp;#39;[WS] Connection closing&amp;#39;, {
        connectionId,
        code,
        reason,
        hasData: !!ws.data,
      });

      if (connectionId) {
        // Fire-and-forget disconnection handling - don&amp;#39;t wait for completion
        setImmediate(() &#x3D;&amp;gt; {
          try {
            this.events.handleDisconnection(connectionId);
            logger.debug(&amp;#39;[WS] WebSocket connection cleanup initiated&amp;#39;, {
              connectionId,
              code,
              reason,
              duration: Date.now() - startTime,
            });
          } catch (error) {
            // Ignore disconnection errors - they&amp;#39;re common during rapid reconnects
            logger.debug(&amp;#39;[WS] Disconnection cleanup completed&amp;#39;, {
              connectionId,
              duration: Date.now() - startTime,
              note: &amp;#39;Cleanup completed, any errors are expected during rapid cycles&amp;#39;,
            });
          }
        });
      } else {
        logger.warn(&amp;#39;[WS] Connection closed without ID&amp;#39;, {
          code,
          reason,
          hasData: !!ws.data,
        });
      }
    } catch (error) {
      logger.error(&amp;#39;[WS] WebSocket close error&amp;#39;, error instanceof Error ? error : undefined, {
        connectionId,
        code,
        reason,
        duration: Date.now() - startTime,
      });
    }
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-23">
                <div class="file-header">📄 src/handlers/api.ts</div>
                <div class="file-content">
                    <pre>/**
 * API endpoints for custom webhook handlers management
 */

import type { CustomHandlerManager } from &amp;quot;./manager.js&amp;quot;;
import type {
  HandlerCreationOptions,
  HandlerExecution,
  HandlerResult,
  RegisteredHandler,
} from &amp;quot;./types.js&amp;quot;;

// Request/Response types for API endpoints
export interface ListHandlersRequest {
  provider?: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;;
  event?: string;
  enabled?: boolean;
}

export interface ListHandlersResponse {
  success: boolean;
  handlers: RegisteredHandler[];
  total: number;
}

export interface GetHandlerRequest {
  id: string;
}

export interface GetHandlerResponse {
  success: boolean;
  handler?: RegisteredHandler;
  message?: string;
}

export interface UpdateHandlerRequest {
  id: string;
  updates: Partial&amp;lt;RegisteredHandler&amp;gt;;
}

export interface UpdateHandlerResponse {
  success: boolean;
  handler?: RegisteredHandler;
  message: string;
}

export interface ToggleHandlerRequest {
  id: string;
  enabled: boolean;
}

export interface ToggleHandlerResponse {
  success: boolean;
  message: string;
}

export interface ValidateHandlerRequest {
  filePath: string;
}

export interface ValidateHandlerResponse {
  success: boolean;
  valid: boolean;
  errors: string[];
  warnings: string[];
}

export type CreateHandlerRequest &#x3D; HandlerCreationOptions;

export interface CreateHandlerResponse {
  success: boolean;
  handler?: RegisteredHandler;
  message: string;
}

export interface ExecutionHistoryRequest {
  handlerId?: string;
  projectId?: string;
  provider?: &amp;quot;github&amp;quot; | &amp;quot;gitlab&amp;quot;;
  event?: string;
  limit?: number;
  offset?: number;
}

export interface ExecutionHistoryResponse {
  success: boolean;
  executions: HandlerExecution[];
  total: number;
  hasMore: boolean;
}

export interface HandlerStatsResponse {
  success: boolean;
  stats: {
    totalHandlers: number;
    enabledHandlers: number;
    activeExecutions: number;
    totalExecutions: number;
    failedExecutions: number;
    executionsLast24h: number;
    avgExecutionTime: number;
    errorRate: number;
  };
}

/**
 * Handler API Controller
 */
export class HandlerAPIController {
  constructor(private handlerManager: CustomHandlerManager) {}

  /**
   * GET /api/handlers
   * List all registered handlers with optional filtering
   */
  async listHandlers(request: ListHandlersRequest): Promise&amp;lt;ListHandlersResponse&amp;gt; {
    try {
      let handlers &#x3D; this.handlerManager.getHandlers();

      // Apply filters
      if (request.provider) {
        handlers &#x3D; handlers.filter((h) &#x3D;&amp;gt; h.provider &#x3D;&#x3D;&#x3D; request.provider);
      }

      if (request.event) {
        handlers &#x3D; handlers.filter((h) &#x3D;&amp;gt; h.event &#x3D;&#x3D;&#x3D; request.event);
      }

      if (request.enabled !&#x3D;&#x3D; undefined) {
        handlers &#x3D; handlers.filter((h) &#x3D;&amp;gt; h.enabled &#x3D;&#x3D;&#x3D; request.enabled);
      }

      return {
        success: true,
        handlers,
        total: handlers.length,
      };
    } catch (error) {
      return {
        success: false,
        handlers: [],
        total: 0,
      };
    }
  }

  /**
   * GET /api/handlers/:id
   * Get a specific handler by ID
   */
  async getHandler(request: GetHandlerRequest): Promise&amp;lt;GetHandlerResponse&amp;gt; {
    try {
      const handler &#x3D; this.handlerManager.getHandler(request.id);

      if (!handler) {
        return {
          success: false,
          message: &amp;quot;Handler not found&amp;quot;,
        };
      }

      return {
        success: true,
        handler,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;,
      };
    }
  }

  /**
   * PUT /api/handlers/:id
   * Update handler configuration
   */
  async updateHandler(request: UpdateHandlerRequest): Promise&amp;lt;UpdateHandlerResponse&amp;gt; {
    try {
      const success &#x3D; this.handlerManager.updateHandlerConfig(request.id, request.updates);

      if (!success) {
        return {
          success: false,
          message: &amp;quot;Handler not found or update failed&amp;quot;,
        };
      }

      const handler &#x3D; this.handlerManager.getHandler(request.id);
      return {
        success: true,
        handler,
        message: &amp;quot;Handler updated successfully&amp;quot;,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;,
      };
    }
  }

  /**
   * POST /api/handlers/:id/toggle
   * Enable or disable a handler
   */
  async toggleHandler(request: ToggleHandlerRequest): Promise&amp;lt;ToggleHandlerResponse&amp;gt; {
    try {
      const success &#x3D; this.handlerManager.setHandlerEnabled(request.id, request.enabled);

      if (!success) {
        return {
          success: false,
          message: &amp;quot;Handler not found&amp;quot;,
        };
      }

      return {
        success: true,
        message: &#x60;Handler ${request.enabled ? &amp;quot;enabled&amp;quot; : &amp;quot;disabled&amp;quot;} successfully&#x60;,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;,
      };
    }
  }

  /**
   * DELETE /api/handlers/:id
   * Remove a handler
   */
  async removeHandler(request: GetHandlerRequest): Promise&amp;lt;UpdateHandlerResponse&amp;gt; {
    try {
      const success &#x3D; this.handlerManager.removeHandler(request.id);

      return {
        success,
        message: success ? &amp;quot;Handler removed successfully&amp;quot; : &amp;quot;Handler not found&amp;quot;,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;,
      };
    }
  }

  /**
   * POST /api/handlers/:id/reload
   * Reload a handler from file
   */
  async reloadHandler(request: GetHandlerRequest): Promise&amp;lt;UpdateHandlerResponse&amp;gt; {
    try {
      const success &#x3D; await this.handlerManager.reloadHandler(request.id);

      return {
        success,
        message: success ? &amp;quot;Handler reloaded successfully&amp;quot; : &amp;quot;Handler not found or reload failed&amp;quot;,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;,
      };
    }
  }

  /**
   * POST /api/handlers/validate
   * Validate handler code
   */
  async validateHandler(request: ValidateHandlerRequest): Promise&amp;lt;ValidateHandlerResponse&amp;gt; {
    try {
      const validation &#x3D; await this.handlerManager.validateHandler(request.filePath);

      return {
        success: true,
        valid: validation.valid,
        errors: validation.errors,
        warnings: validation.warnings,
      };
    } catch (error) {
      return {
        success: false,
        valid: false,
        errors: [error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;],
        warnings: [],
      };
    }
  }

  /**
   * POST /api/handlers
   * Create a new handler
   */
  async createHandler(request: CreateHandlerRequest): Promise&amp;lt;CreateHandlerResponse&amp;gt; {
    try {
      const handler &#x3D; await this.handlerManager.createHandler(request);

      return {
        success: true,
        handler,
        message: &amp;quot;Handler created successfully&amp;quot;,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;,
      };
    }
  }

  /**
   * GET /api/handlers/executions
   * Get handler execution history
   */
  async getExecutionHistory(request: ExecutionHistoryRequest): Promise&amp;lt;ExecutionHistoryResponse&amp;gt; {
    try {
      let executions &#x3D; this.handlerManager.getExecutionHistory(request.limit || 100);

      // Apply filters
      if (request.handlerId) {
        executions &#x3D; executions.filter((e) &#x3D;&amp;gt; e.handlerId &#x3D;&#x3D;&#x3D; request.handlerId);
      }

      if (request.projectId) {
        executions &#x3D; executions.filter((e) &#x3D;&amp;gt; e.projectId &#x3D;&#x3D;&#x3D; request.projectId);
      }

      if (request.provider) {
        executions &#x3D; executions.filter((e) &#x3D;&amp;gt; e.provider &#x3D;&#x3D;&#x3D; request.provider);
      }

      if (request.event) {
        executions &#x3D; executions.filter((e) &#x3D;&amp;gt; e.event &#x3D;&#x3D;&#x3D; request.event);
      }

      // Apply pagination
      const offset &#x3D; request.offset || 0;
      const limit &#x3D; request.limit || 100;
      const paginatedExecutions &#x3D; executions.slice(offset, offset + limit);

      return {
        success: true,
        executions: paginatedExecutions,
        total: executions.length,
        hasMore: offset + limit &amp;lt; executions.length,
      };
    } catch (error) {
      return {
        success: false,
        executions: [],
        total: 0,
        hasMore: false,
      };
    }
  }

  /**
   * GET /api/handlers/stats
   * Get handler system statistics
   */
  async getHandlerStats(): Promise&amp;lt;HandlerStatsResponse&amp;gt; {
    try {
      const stats &#x3D; this.handlerManager.getHandlerStats();
      const executions &#x3D; this.handlerManager.getExecutionHistory();

      // Calculate additional statistics
      const now &#x3D; Date.now();
      const oneDayAgo &#x3D; now - 24 * 60 * 60 * 1000;

      const executionsLast24h &#x3D; executions.filter(
        (e) &#x3D;&amp;gt; new Date(e.startedAt).getTime() &amp;gt; oneDayAgo,
      ).length;

      const completedExecutions &#x3D; executions.filter((e) &#x3D;&amp;gt; e.result.duration);
      const avgExecutionTime &#x3D;
        completedExecutions.length &amp;gt; 0
          ? completedExecutions.reduce((sum, e) &#x3D;&amp;gt; sum + (e.result.duration || 0), 0) /
            completedExecutions.length
          : 0;

      const errorRate &#x3D;
        stats.totalExecutions &amp;gt; 0 ? (stats.failedExecutions / stats.totalExecutions) * 100 : 0;

      return {
        success: true,
        stats: {
          ...stats,
          executionsLast24h,
          avgExecutionTime: Math.round(avgExecutionTime),
          errorRate: Math.round(errorRate * 100) / 100,
        },
      };
    } catch (error) {
      return {
        success: false,
        stats: {
          totalHandlers: 0,
          enabledHandlers: 0,
          activeExecutions: 0,
          totalExecutions: 0,
          failedExecutions: 0,
          executionsLast24h: 0,
          avgExecutionTime: 0,
          errorRate: 0,
        },
      };
    }
  }

  /**
   * POST /api/handlers/init
   * Initialize handler directory structure
   */
  async initializeHandlerStructure(): Promise&amp;lt;{ success: boolean; message: string }&amp;gt; {
    try {
      await this.handlerManager.createHandlerStructure();
      return {
        success: true,
        message: &amp;quot;Handler directory structure created successfully&amp;quot;,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;,
      };
    }
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-24">
                <div class="file-header">📄 src/handlers/examples/push-handler.ts</div>
                <div class="file-content">
                    <pre>/**
 * Example: Push event handler
 * Demonstrates the handler API and common patterns
 */

import type { HandlerModule, HandlerResult, WebhookHandler } from &amp;#39;../types.js&amp;#39;;

// Handler function implementation
const handlePush: WebhookHandler &#x3D; async (payload, context) &#x3D;&amp;gt; {
  const { logger, services, projectId } &#x3D; context;
  const { parsed } &#x3D; payload;

  logger.info(&amp;#39;Processing push event&amp;#39;, {
    repository: parsed.repository.fullName,
    ref: payload.ref,
    commits: parsed.commits?.length || 0,
  });

  const actions: string[] &#x3D; [];

  try {
    // Example: Check for spec file changes
    const specChanges &#x3D; parsed.commits?.some(
      commit &#x3D;&amp;gt;
        commit.modified.some(file &#x3D;&amp;gt; file.endsWith(&amp;#39;.cue&amp;#39;)) ||
        commit.added.some(file &#x3D;&amp;gt; file.endsWith(&amp;#39;.cue&amp;#39;))
    );

    if (specChanges) {
      logger.info(&amp;#39;Spec files changed, triggering validation&amp;#39;);

      // Trigger spec validation through events
      await services.events.broadcastToProject(projectId, {
        project_id: projectId,
        event_type: &amp;#39;validation_started&amp;#39;,
        data: {
          trigger: &amp;#39;push_handler&amp;#39;,
          repository: parsed.repository.fullName,
          ref: payload.ref,
          commits: parsed.commits?.length || 0,
        },
      });

      actions.push(&amp;#39;Triggered spec validation&amp;#39;);
    }

    // Example: Send notification for main branch pushes
    if (payload.ref &#x3D;&#x3D;&#x3D; &#x60;refs/heads/${parsed.repository.defaultBranch}&#x60;) {
      const slackWebhook &#x3D; context.config.secrets.SLACK_WEBHOOK;
      if (slackWebhook) {
        await services.notifications.sendSlack(slackWebhook, {
          text: &#x60;📝 New commits pushed to ${parsed.repository.fullName}&#x60;,
          blocks: [
            {
              type: &amp;#39;section&amp;#39;,
              text: {
                type: &amp;#39;mrkdwn&amp;#39;,
                text: &#x60;*${parsed.commits?.length || 0} new commits* in &amp;lt;${parsed.repository.url}|${parsed.repository.fullName}&amp;gt;&#x60;,
              },
            },
            {
              type: &amp;#39;section&amp;#39;,
              fields:
                parsed.commits?.slice(0, 3).map(commit &#x3D;&amp;gt; ({
                  type: &amp;#39;mrkdwn&amp;#39;,
                  text: &#x60;• ${commit.message}\n  _by ${commit.author}_&#x60;,
                })) || [],
            },
          ],
        });
        actions.push(&amp;#39;Sent Slack notification&amp;#39;);
      }
    }

    // Example: Auto-create issues for breaking changes
    if (parsed.commits?.some(commit &#x3D;&amp;gt; commit.message.toLowerCase().includes(&amp;#39;breaking&amp;#39;))) {
      // This would integrate with the repository&amp;#39;s issue tracker
      logger.info(&amp;#39;Breaking changes detected, consider creating tracking issue&amp;#39;);
      actions.push(&amp;#39;Detected breaking changes&amp;#39;);
    }

    return {
      success: true,
      message: &#x60;Processed ${parsed.commits?.length || 0} commits&#x60;,
      actions,
      data: {
        repository: parsed.repository.fullName,
        ref: payload.ref,
        commitsProcessed: parsed.commits?.length || 0,
        specFilesChanged: specChanges,
      },
    };
  } catch (error) {
    logger.error(&amp;#39;Push handler failed&amp;#39;, error as Error);

    return {
      success: false,
      message: &amp;#39;Push handler execution failed&amp;#39;,
      errors: [
        {
          code: &amp;#39;HANDLER_EXECUTION_ERROR&amp;#39;,
          message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
          stack: error instanceof Error ? error.stack : undefined,
        },
      ],
    };
  }
};

// Handler module export
const handlerModule: HandlerModule &#x3D; {
  handler: handlePush,
  config: {
    enabled: true,
    timeout: 30000, // 30 seconds
    retries: 2,
    environment: {},
    secrets: {},
  },
  metadata: {
    name: &amp;#39;Push Event Handler&amp;#39;,
    description: &amp;#39;Handles Git push events with spec validation and notifications&amp;#39;,
    version: &amp;#39;1.0.0&amp;#39;,
    author: &amp;#39;Arbiter Team&amp;#39;,
    supportedEvents: [&amp;#39;push&amp;#39;, &amp;#39;Push Hook&amp;#39;],
    requiredPermissions: [&amp;#39;events:publish&amp;#39;, &amp;#39;notifications:send&amp;#39;],
  },
};

export default handlerModule;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-25">
                <div class="file-header">📄 src/mcp-cli-integration.ts</div>
                <div class="file-content">
                    <pre>import { spawn } from &amp;#39;node:child_process&amp;#39;;
import { promisify } from &amp;#39;node:util&amp;#39;;
import type { HandlerResult } from &amp;#39;./handlers/types.js&amp;#39;;
import { logger } from &amp;#39;./utils.ts&amp;#39;;

export class McpCliIntegration {
  async triggerTool(_: string, __: Record&amp;lt;string, unknown&amp;gt;): Promise&amp;lt;HandlerResult&amp;gt; {
    return {
      success: true,
      message: &amp;#39;MCP tool execution stubbed for tests&amp;#39;,
    };
  }

  async validateCue(
    content: string
  ): Promise&amp;lt;{ success: boolean; errors?: string[]; warnings?: string[] }&amp;gt; {
    try {
      // Write content to temp file and validate with CUE
      const tempFile &#x3D; &#x60;/tmp/validate_${Date.now()}.cue&#x60;;
      await Bun.write(tempFile, content);

      const result &#x3D; await this.runCommand(&amp;#39;cue&amp;#39;, [&amp;#39;vet&amp;#39;, tempFile]);

      // Clean up temp file
      await Bun.write(tempFile, &amp;#39;&amp;#39;); // Clear and let GC handle it

      if (result.success) {
        return { success: true };
      } else {
        return {
          success: false,
          errors: result.stderr ? [result.stderr] : [&amp;#39;Validation failed&amp;#39;],
        };
      }
    } catch (error) {
      logger.error(&amp;#39;CUE validation error&amp;#39;, error instanceof Error ? error : undefined);
      return {
        success: false,
        errors: [error instanceof Error ? error.message : &amp;#39;Unknown validation error&amp;#39;],
      };
    }
  }

  async generateCode(
    specName: string,
    outputType: string &#x3D; &amp;#39;typescript&amp;#39;
  ): Promise&amp;lt;{ success: boolean; output?: string; error?: string }&amp;gt; {
    try {
      // Use the Arbiter CLI to generate code
      const result &#x3D; await this.runCommand(&amp;#39;./arbiter-cli&amp;#39;, [
        &amp;#39;generate&amp;#39;,
        specName,
        &amp;#39;--format&amp;#39;,
        &amp;#39;json&amp;#39;,
      ]);

      if (result.success) {
        return {
          success: true,
          output: result.stdout || &amp;#39;Code generation completed successfully&amp;#39;,
        };
      } else {
        return {
          success: false,
          error: result.stderr || &amp;#39;Code generation failed&amp;#39;,
        };
      }
    } catch (error) {
      logger.error(&amp;#39;Code generation error&amp;#39;, error instanceof Error ? error : undefined);
      return {
        success: false,
        error: error instanceof Error ? error.message : &amp;#39;Unknown generation error&amp;#39;,
      };
    }
  }

  private async runCommand(
    command: string,
    args: string[]
  ): Promise&amp;lt;{ success: boolean; stdout?: string; stderr?: string }&amp;gt; {
    return new Promise(resolve &#x3D;&amp;gt; {
      const process &#x3D; spawn(command, args, { stdio: [&amp;#39;pipe&amp;#39;, &amp;#39;pipe&amp;#39;, &amp;#39;pipe&amp;#39;] });

      let stdout &#x3D; &amp;#39;&amp;#39;;
      let stderr &#x3D; &amp;#39;&amp;#39;;

      process.stdout?.on(&amp;#39;data&amp;#39;, data &#x3D;&amp;gt; {
        stdout +&#x3D; data.toString();
      });

      process.stderr?.on(&amp;#39;data&amp;#39;, data &#x3D;&amp;gt; {
        stderr +&#x3D; data.toString();
      });

      process.on(&amp;#39;close&amp;#39;, code &#x3D;&amp;gt; {
        resolve({
          success: code &#x3D;&#x3D;&#x3D; 0,
          stdout: stdout.trim(),
          stderr: stderr.trim(),
        });
      });

      process.on(&amp;#39;error&amp;#39;, error &#x3D;&amp;gt; {
        resolve({
          success: false,
          stderr: error.message,
        });
      });
    });
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-26">
                <div class="file-header">📄 src/config.ts</div>
                <div class="file-content">
                    <pre>import { readFileSync } from &amp;#39;node:fs&amp;#39;;
import path from &amp;#39;node:path&amp;#39;;
import type { ServerConfig } from &amp;#39;./types.ts&amp;#39;;

export function loadConfig(): ServerConfig {
  const configPath &#x3D; process.env.ARBITER_CONFIG_PATH || path.join(process.cwd(), &amp;#39;config.json&amp;#39;);
  try {
    const raw &#x3D; readFileSync(configPath, &amp;#39;utf-8&amp;#39;);
    return JSON.parse(raw) as ServerConfig;
  } catch {
    return {
      port: parseInt(process.env.PORT || &amp;#39;5050&amp;#39;, 10),
      host: &amp;#39;localhost&amp;#39;,
      database_path: &amp;#39;arbiter.db&amp;#39;,
      spec_workdir: path.join(process.cwd(), &amp;#39;.spec-workdir&amp;#39;),
      cue_binary_path: &amp;#39;cue&amp;#39;,
      jq_binary_path: &amp;#39;jq&amp;#39;,
      auth_required: false,
      rate_limit: { max_tokens: 10, refill_rate: 1, window_ms: 10000 },
      external_tool_timeout_ms: 5000,
      websocket: { max_connections: 100, ping_interval_ms: 30000 },
    };
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-27">
                <div class="file-header">📄 src/static/index.ts</div>
                <div class="file-content">
                    <pre>import type { Request } from &amp;quot;bun&amp;quot;;

export class StaticFileHandler {
  shouldServeStaticFile(_path: string): boolean {
    return false;
  }

  async serveFile(_path: string, headers: Record&amp;lt;string, string&amp;gt;): Promise&amp;lt;Response&amp;gt; {
    return new Response(&amp;quot;Not Found&amp;quot;, { status: 404, headers });
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-28">
                <div class="file-header">📄 src/specEngine.ts</div>
                <div class="file-content">
                    <pre>/**
 * Spec validation engine with CUE and jq integration
 */
import { join } from &amp;quot;node:path&amp;quot;;
import { type CueDiagnostic, CueRunner } from &amp;quot;@arbiter/cue-runner&amp;quot;;
import type {
  CoverageGap,
  Duplicate,
  ExternalToolResult,
  Fragment,
  GapSet,
  ServerConfig,
  TokenReference,
  ValidationError,
  ValidationWarning,
} from &amp;quot;./types.ts&amp;quot;;
import {
  computeSpecHash,
  ensureDir,
  executeCommand,
  formatCUE,
  generateId,
  logger,
} from &amp;quot;./utils.ts&amp;quot;;

/**
 * Interface for assertion configurations
 */
interface AssertionConfig {
  query: string;
  description: string;
  threshold?: number;
  type?: string;
}

/**
 * Interface for assertion commands
 */
interface AssertionCommand {
  execute(tempFilePath: string, jqBinaryPath: string): Promise&amp;lt;ValidationError | null&amp;gt;;
  getConfig(): AssertionConfig;
}

/**
 * Result of assertion processing
 */
interface AssertionResult {
  success: boolean;
  value?: number;
  error?: string;
}

/**
 * Manages temporary file creation and cleanup
 */
class TempFileManager {
  private tempFile: string;

  constructor(_data: Record&amp;lt;string, unknown&amp;gt;) {
    this.tempFile &#x3D; &#x60;/tmp/resolved_${generateId()}.json&#x60;;
  }

  async create(data: Record&amp;lt;string, unknown&amp;gt;): Promise&amp;lt;void&amp;gt; {
    const resolvedJson &#x3D; JSON.stringify(data, null, 2);
    await Bun.write(this.tempFile, resolvedJson);
  }

  getPath(): string {
    return this.tempFile;
  }

  async cleanup(): Promise&amp;lt;void&amp;gt; {
    try {
      const exists &#x3D; await Bun.file(this.tempFile).exists();
      if (exists) {
        await Bun.write(this.tempFile, &amp;quot;&amp;quot;);
      }
    } catch {
      // Ignore cleanup errors
    }
  }
}

/**
 * Processes and parses assertion results
 */
class AssertionResultProcessor {
  static processCommandResult(result: any): AssertionResult {
    if (result.success) {
      const value &#x3D; Number.parseInt(result.stdout.trim(), 10) || 0;
      return { success: true, value };
    }
    return { success: false, error: result.stderr };
  }

  static createValidationError(
    config: AssertionConfig,
    result: AssertionResult,
    errorType:
      | &amp;quot;execution&amp;quot;
      | &amp;quot;command_failed&amp;quot;
      | &amp;quot;threshold_exceeded&amp;quot;
      | &amp;quot;minimum_not_met&amp;quot; &#x3D; &amp;quot;threshold_exceeded&amp;quot;,
    error?: Error,
  ): ValidationError {
    if (error) {
      return {
        type: &amp;quot;assertion&amp;quot;,
        message: &#x60;jq execution error for ${config.description}&#x60;,
        details: {
          query: config.query,
          error: error.message,
        },
      };
    }

    if (!result.success) {
      return {
        type: &amp;quot;assertion&amp;quot;,
        message: &#x60;jq assertion failed: ${config.description}&#x60;,
        details: {
          query: config.query,
          error: result.error,
        },
      };
    }

    // Create appropriate error message based on error type
    let message: string;
    switch (errorType) {
      case &amp;quot;threshold_exceeded&amp;quot;:
        message &#x3D; &#x60;${config.description}: expected &amp;lt;&#x3D; ${config.threshold}, got ${result.value}&#x60;;
        break;
      case &amp;quot;minimum_not_met&amp;quot;:
        message &#x3D; &#x60;${config.description}: expected &amp;gt;&#x3D; ${config.threshold}, got ${result.value}&#x60;;
        break;
      default:
        message &#x3D; &#x60;${config.description}: assertion failed&#x60;;
    }

    return {
      type: &amp;quot;assertion&amp;quot;,
      message,
      details: {
        query: config.query,
        value: result.value,
        threshold: config.threshold,
      },
    };
  }
}

/**
 * Base template for assertion execution
 */
abstract class AbstractAssertionCommand implements AssertionCommand {
  protected config: AssertionConfig;

  constructor(config: AssertionConfig) {
    this.config &#x3D; config;
  }

  async execute(tempFilePath: string, jqBinaryPath: string): Promise&amp;lt;ValidationError | null&amp;gt; {
    try {
      const commandResult &#x3D; await this.executeJqCommand(tempFilePath, jqBinaryPath);
      const result &#x3D; AssertionResultProcessor.processCommandResult(commandResult);

      if (!result.success) {
        return AssertionResultProcessor.createValidationError(
          this.config,
          result,
          &amp;quot;command_failed&amp;quot;,
        );
      }

      if (this.shouldCreateError(result)) {
        return AssertionResultProcessor.createValidationError(
          this.config,
          result,
          this.getErrorType(),
        );
      }

      return null;
    } catch (error) {
      return AssertionResultProcessor.createValidationError(
        this.config,
        { success: false },
        &amp;quot;execution&amp;quot;,
        error instanceof Error ? error : new Error(&amp;quot;Unknown error&amp;quot;),
      );
    }
  }

  protected abstract shouldCreateError(result: AssertionResult): boolean;
  protected abstract getErrorType(): &amp;quot;threshold_exceeded&amp;quot; | &amp;quot;minimum_not_met&amp;quot;;

  protected async executeJqCommand(tempFilePath: string, jqBinaryPath: string): Promise&amp;lt;any&amp;gt; {
    return executeCommand(jqBinaryPath, [this.config.query, tempFilePath], { timeout: 5000 });
  }

  getConfig(): AssertionConfig {
    return this.config;
  }
}

/**
 * Command for threshold-based assertions
 */
class ThresholdAssertionCommand extends AbstractAssertionCommand {
  protected shouldCreateError(result: AssertionResult): boolean {
    // For threshold assertions, we fail when the value exceeds the threshold
    // For &amp;quot;unresolved tokens&amp;quot;, threshold&#x3D;0 means we fail if there are ANY (&amp;gt;0)
    return (
      this.config.threshold !&#x3D;&#x3D; undefined &amp;amp;&amp;amp;
      result.value !&#x3D;&#x3D; undefined &amp;amp;&amp;amp;
      result.value &amp;gt; this.config.threshold
    );
  }

  protected getErrorType(): &amp;quot;threshold_exceeded&amp;quot; | &amp;quot;minimum_not_met&amp;quot; {
    return &amp;quot;threshold_exceeded&amp;quot;;
  }
}

/**
 * Command for minimum threshold assertions (must be &amp;gt;&#x3D; threshold)
 */
class MinimumThresholdCommand extends AbstractAssertionCommand {
  protected shouldCreateError(result: AssertionResult): boolean {
    return (
      this.config.threshold !&#x3D;&#x3D; undefined &amp;amp;&amp;amp;
      result.value !&#x3D;&#x3D; undefined &amp;amp;&amp;amp;
      result.value &amp;lt; this.config.threshold
    );
  }

  protected getErrorType(): &amp;quot;threshold_exceeded&amp;quot; | &amp;quot;minimum_not_met&amp;quot; {
    return &amp;quot;minimum_not_met&amp;quot;;
  }
}

/**
 * Command for existence-based assertions
 */
class ExistenceAssertionCommand extends AbstractAssertionCommand {
  protected shouldCreateError(result: AssertionResult): boolean {
    return result.value &#x3D;&#x3D;&#x3D; 0; // Fail if nothing exists
  }

  protected getErrorType(): &amp;quot;threshold_exceeded&amp;quot; | &amp;quot;minimum_not_met&amp;quot; {
    return &amp;quot;minimum_not_met&amp;quot;; // Existence is essentially minimum threshold of 1
  }
}

/**
 * Builder for creating assertion commands
 */
class AssertionCommandBuilder {
  private config: Partial&amp;lt;AssertionConfig&amp;gt; &#x3D; {};

  static create(): AssertionCommandBuilder {
    return new AssertionCommandBuilder();
  }

  query(query: string): AssertionCommandBuilder {
    this.config.query &#x3D; query;
    return this;
  }

  description(description: string): AssertionCommandBuilder {
    this.config.description &#x3D; description;
    return this;
  }

  threshold(threshold: number): AssertionCommandBuilder {
    this.config.threshold &#x3D; threshold;
    return this;
  }

  type(type: string): AssertionCommandBuilder {
    this.config.type &#x3D; type;
    return this;
  }

  buildThreshold(): ThresholdAssertionCommand {
    if (!this.config.query || !this.config.description) {
      throw new Error(&amp;quot;Query and description are required&amp;quot;);
    }
    return new ThresholdAssertionCommand(this.config as AssertionConfig);
  }

  buildMinimum(): MinimumThresholdCommand {
    if (!this.config.query || !this.config.description) {
      throw new Error(&amp;quot;Query and description are required&amp;quot;);
    }
    return new MinimumThresholdCommand(this.config as AssertionConfig);
  }

  buildExistence(): ExistenceAssertionCommand {
    if (!this.config.query || !this.config.description) {
      throw new Error(&amp;quot;Query and description are required&amp;quot;);
    }
    return new ExistenceAssertionCommand(this.config as AssertionConfig);
  }
}

/**
 * Strategy for different assertion execution approaches
 */
interface AssertionExecutionStrategy {
  execute(
    commands: AssertionCommand[],
    tempFilePath: string,
    jqBinaryPath: string,
  ): Promise&amp;lt;ValidationError[]&amp;gt;;
}

/**
 * Sequential execution strategy
 */
class SequentialExecutionStrategy implements AssertionExecutionStrategy {
  async execute(
    commands: AssertionCommand[],
    tempFilePath: string,
    jqBinaryPath: string,
  ): Promise&amp;lt;ValidationError[]&amp;gt; {
    const errors: ValidationError[] &#x3D; [];

    for (const command of commands) {
      const error &#x3D; await command.execute(tempFilePath, jqBinaryPath);
      if (error) {
        errors.push(error);
      }
    }

    return errors;
  }
}

/**
 * Parallel execution strategy
 */
class ParallelExecutionStrategy implements AssertionExecutionStrategy {
  async execute(
    commands: AssertionCommand[],
    tempFilePath: string,
    jqBinaryPath: string,
  ): Promise&amp;lt;ValidationError[]&amp;gt; {
    const promises &#x3D; commands.map((command) &#x3D;&amp;gt; command.execute(tempFilePath, jqBinaryPath));

    const results &#x3D; await Promise.all(promises);
    return results.filter((error): error is ValidationError &#x3D;&amp;gt; error !&#x3D;&#x3D; null);
  }
}

/**
 * Main assertion executor class
 */
class AssertionExecutor {
  private strategy: AssertionExecutionStrategy;
  private commands: AssertionCommand[];

  constructor(private config: ServerConfig) {
    this.strategy &#x3D; new SequentialExecutionStrategy(); // Default to sequential
    this.commands &#x3D; this.buildDefaultAssertions();
  }

  setStrategy(strategy: AssertionExecutionStrategy): void {
    this.strategy &#x3D; strategy;
  }

  addCommand(command: AssertionCommand): void {
    this.commands.push(command);
  }

  async execute(resolved: Record&amp;lt;string, unknown&amp;gt;): Promise&amp;lt;ValidationError[]&amp;gt; {
    const tempFileManager &#x3D; new TempFileManager(resolved);

    try {
      await tempFileManager.create(resolved);

      return await this.strategy.execute(
        this.commands,
        tempFileManager.getPath(),
        this.config.jq_binary_path,
      );
    } catch (error) {
      return [
        {
          type: &amp;quot;assertion&amp;quot;,
          message: &amp;quot;Failed to create temporary file for jq processing&amp;quot;,
          details: {
            error: error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;,
          },
        },
      ];
    } finally {
      await tempFileManager.cleanup();
    }
  }

  private buildDefaultAssertions(): AssertionCommand[] {
    return [
      AssertionCommandBuilder.create()
        .query(
          &amp;#39;[paths(scalars) as $p | select(getpath($p) | type &#x3D;&#x3D; &amp;quot;string&amp;quot; and test(&amp;quot;[$][{][^}]+[}]&amp;quot;)) | $p] | length&amp;#39;,
        )
        .description(&amp;quot;Check for unresolved template tokens&amp;quot;)
        .threshold(0)
        .buildThreshold(), // Fail if &amp;gt; 0 tokens found

      // Note: Capabilities validation is handled by custom validators, not jq assertions
      // This keeps the jq assertions focused on structural checks
    ];
  }
}

export class SpecEngine {
  constructor(private config: ServerConfig) {}

  /**
   * Get the project directory path
   */
  private getProjectDir(projectId: string): string {
    return join(this.config.spec_workdir, projectId);
  }

  /**
   * Get the fragments directory path
   */
  private getFragmentsDir(projectId: string): string {
    return join(this.getProjectDir(projectId), &amp;quot;fragments&amp;quot;);
  }

  private createCueRunner(projectId: string): CueRunner {
    return new CueRunner({
      cueBinaryPath: this.config.cue_binary_path,
      cwd: this.getFragmentsDir(projectId),
      timeoutMs: this.config.external_tool_timeout_ms,
    });
  }

  private cueDiagnosticsToValidationErrors(diagnostics: CueDiagnostic[]): ValidationError[] {
    return diagnostics.map((diag) &#x3D;&amp;gt; {
      const detailEntries: Record&amp;lt;string, unknown&amp;gt; &#x3D; {
        raw: diag.raw,
      };

      if (diag.file) {
        detailEntries.file &#x3D; diag.file;
      }
      if (typeof diag.line &#x3D;&#x3D;&#x3D; &amp;quot;number&amp;quot;) {
        detailEntries.line &#x3D; diag.line;
      }
      if (typeof diag.column &#x3D;&#x3D;&#x3D; &amp;quot;number&amp;quot;) {
        detailEntries.column &#x3D; diag.column;
      }
      if (diag.summary) {
        detailEntries.summary &#x3D; diag.summary;
      }

      const location &#x3D; diag.file ? &#x60;${diag.file}:${diag.line ?? 0}:${diag.column ?? 0}&#x60; : undefined;

      return {
        type: &amp;quot;schema&amp;quot; as const,
        message: diag.message,
        ...(location ? { location } : {}),
        details: detailEntries,
      };
    });
  }

  /**
   * Write fragments to filesystem for CUE processing
   */
  private async writeFragmentsToFS(projectId: string, fragments: Fragment[]): Promise&amp;lt;void&amp;gt; {
    const fragmentsDir &#x3D; this.getFragmentsDir(projectId);
    await ensureDir(fragmentsDir);

    // Write each fragment to its path
    for (const fragment of fragments) {
      // Ensure fragment path has .cue extension
      const fragmentFileName &#x3D; fragment.path.endsWith(&amp;quot;.cue&amp;quot;)
        ? fragment.path
        : &#x60;${fragment.path}.cue&#x60;;
      const fragmentPath &#x3D; join(fragmentsDir, fragmentFileName);
      const fragmentDir &#x3D; join(fragmentPath, &amp;quot;..&amp;quot;);

      await ensureDir(fragmentDir);
      await Bun.write(fragmentPath, fragment.content);
    }

    logger.debug(&amp;quot;Wrote fragments to filesystem&amp;quot;, {
      projectId,
      fragmentCount: fragments.length,
    });
  }

  /**
   * Format CUE fragment content
   */
  async formatFragment(
    content: string,
  ): Promise&amp;lt;{ formatted: string; success: boolean; error?: string }&amp;gt; {
    return formatCUE(content, this.config.cue_binary_path);
  }

  /**
   * Run CUE validation (cue vet)
   */
  private async runCueValidation(projectId: string): Promise&amp;lt;ValidationError[]&amp;gt; {
    try {
      const runner &#x3D; this.createCueRunner(projectId);
      const vetResult &#x3D; await runner.vet();

      this.logCueValidationResult(projectId, vetResult.raw, vetResult.diagnostics);

      if (vetResult.success) {
        return [];
      }

      const diagnostics &#x3D; this.cueDiagnosticsToValidationErrors(vetResult.diagnostics);
      if (diagnostics.length &amp;gt; 0) {
        return diagnostics;
      }

      return [
        {
          type: &amp;quot;schema&amp;quot;,
          message: vetResult.raw.stderr || &amp;quot;CUE validation failed&amp;quot;,
        },
      ];
    } catch (error) {
      return this.handleCueValidationError(projectId, error);
    }
  }

  /**
   * Log CUE validation completion
   */
  private logCueValidationResult(
    projectId: string,
    result: ExternalToolResult,
    diagnostics: CueDiagnostic[],
  ): void {
    logger.debug(&amp;quot;CUE validation completed&amp;quot;, {
      projectId,
      success: result.success,
      errorCount: diagnostics.length,
      duration: result.duration_ms,
    });
  }

  /**
   * Handle CUE validation errors
   */
  private handleCueValidationError(projectId: string, error: unknown): ValidationError[] {
    const validationError: ValidationError &#x3D; {
      type: &amp;quot;schema&amp;quot;,
      message: &#x60;CUE validation failed: ${error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;}&#x60;,
    };

    logger.error(&amp;quot;CUE validation error&amp;quot;, error instanceof Error ? error : undefined, {
      projectId,
    });

    return [validationError];
  }

  /**
   * Export resolved specification (cue export)
   */
  private async exportResolvedSpec(projectId: string): Promise&amp;lt;{
    success: boolean;
    resolved?: Record&amp;lt;string, unknown&amp;gt;;
    error?: string;
    diagnostics?: CueDiagnostic[];
  }&amp;gt; {
    try {
      const runner &#x3D; this.createCueRunner(projectId);
      const exportResult &#x3D; await runner.exportJson();

      if (exportResult.success &amp;amp;&amp;amp; exportResult.value) {
        logger.debug(&amp;quot;CUE export completed&amp;quot;, {
          projectId,
          duration: exportResult.raw.duration_ms,
        });

        return { success: true, resolved: exportResult.value };
      }

      return {
        success: false,
        error: exportResult.error,
        diagnostics: exportResult.diagnostics,
      };
    } catch (error) {
      logger.error(&amp;quot;CUE export error&amp;quot;, error instanceof Error ? error : undefined, { projectId });

      return {
        success: false,
        error: error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;,
      };
    }
  }

  /**
   * Run jq assertions on resolved specification
   */
  private async runJqAssertions(resolved: Record&amp;lt;string, unknown&amp;gt;): Promise&amp;lt;ValidationError[]&amp;gt; {
    const executor &#x3D; new AssertionExecutor(this.config);
    return executor.execute(resolved);
  }

  /**
   * Run custom TypeScript validators
   */
  private async runCustomValidators(
    resolved: Record&amp;lt;string, unknown&amp;gt;,
  ): Promise&amp;lt;{ errors: ValidationError[]; warnings: ValidationWarning[] }&amp;gt; {
    const errors: ValidationError[] &#x3D; [];
    const warnings: ValidationWarning[] &#x3D; [];

    try {
      // Validate duplicates
      const duplicateCheck &#x3D; this.findDuplicates(resolved);
      duplicateCheck.forEach((duplicate) &#x3D;&amp;gt; {
        warnings.push({
          type: &amp;quot;duplicate&amp;quot;,
          message: &#x60;Duplicate ${duplicate.type}: ${duplicate.name}&#x60;,
          location: duplicate.locations.join(&amp;quot;, &amp;quot;),
        });
      });

      // Check for undefined capabilities
      if (typeof resolved &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot; &amp;amp;&amp;amp; resolved !&#x3D;&#x3D; null) {
        const capabilities &#x3D; (resolved as any).capabilities;

        if (!capabilities || Object.keys(capabilities).length &#x3D;&#x3D;&#x3D; 0) {
          errors.push({
            type: &amp;quot;custom&amp;quot;,
            message: &amp;quot;No capabilities defined in specification&amp;quot;,
          });
        }
      }

      // Add more custom validations as needed
    } catch (error) {
      errors.push({
        type: &amp;quot;custom&amp;quot;,
        message: &#x60;Custom validator error: ${error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;}&#x60;,
      });
    }

    return { errors, warnings };
  }

  /**
   * Find duplicates in the resolved specification
   */
  private findDuplicates(resolved: Record&amp;lt;string, unknown&amp;gt;): Duplicate[] {
    const duplicates: Duplicate[] &#x3D; [];

    try {
      // This is a simplified implementation
      // In a real system, you&amp;#39;d want more sophisticated duplicate detection

      if (typeof resolved &#x3D;&#x3D;&#x3D; &amp;quot;object&amp;quot; &amp;amp;&amp;amp; resolved !&#x3D;&#x3D; null) {
        const capabilities &#x3D; (resolved as any).capabilities || {};
        const capabilityNames &#x3D; Object.keys(capabilities);
        const nameCount: Record&amp;lt;string, string[]&amp;gt; &#x3D; {};

        // Count occurrences of capability names
        capabilityNames.forEach((name) &#x3D;&amp;gt; {
          const parts &#x3D; name.split(&amp;quot;.&amp;quot;);
          parts.forEach((part) &#x3D;&amp;gt; {
            if (!nameCount[part]) nameCount[part] &#x3D; [];
            nameCount[part].push(name);
          });
        });

        // Find duplicates
        Object.entries(nameCount).forEach(([name, locations]) &#x3D;&amp;gt; {
          if (locations.length &amp;gt; 1) {
            duplicates.push({
              type: &amp;quot;capability&amp;quot;,
              name,
              locations,
            });
          }
        });
      }
    } catch (error) {
      logger.error(&amp;quot;Error finding duplicates&amp;quot;, error instanceof Error ? error : undefined);
    }

    return duplicates;
  }

  /**
   * Complete validation pipeline
   */
  async validateProject(
    projectId: string,
    fragments: Fragment[],
  ): Promise&amp;lt;{
    success: boolean;
    specHash: string;
    resolved?: Record&amp;lt;string, unknown&amp;gt;;
    errors: ValidationError[];
    warnings: ValidationWarning[];
  }&amp;gt; {
    const startTime &#x3D; Date.now();

    try {
      // Execute the main validation workflow
      const result &#x3D; await this.executeValidationWorkflow(projectId, fragments);

      // Log completion metrics
      this.logValidationCompletion(projectId, result, Date.now() - startTime);

      return result;
    } catch (error) {
      return this.handleValidationError(projectId, error, Date.now() - startTime);
    }
  }

  /**
   * Execute the core validation workflow steps
   */
  private async executeValidationWorkflow(
    projectId: string,
    fragments: Fragment[],
  ): Promise&amp;lt;{
    success: boolean;
    specHash: string;
    resolved?: Record&amp;lt;string, unknown&amp;gt;;
    errors: ValidationError[];
    warnings: ValidationWarning[];
  }&amp;gt; {
    // Step 1: Write fragments to filesystem
    await this.writeFragmentsToFS(projectId, fragments);

    // Step 2: Run CUE validation
    let schemaErrors &#x3D; await this.runCueValidation(projectId);

    // Step 3: Export resolved specification
    const exportResult &#x3D; await this.exportResolvedSpec(projectId);

    // Handle export failure early
    if (!exportResult.success || !exportResult.resolved) {
      if (exportResult.diagnostics &amp;amp;&amp;amp; exportResult.diagnostics.length &amp;gt; 0) {
        schemaErrors &#x3D; schemaErrors.concat(
          this.cueDiagnosticsToValidationErrors(exportResult.diagnostics),
        );
      }

      return this.createFailureResult(schemaErrors, exportResult.error);
    }

    // Step 4-6: Process successful export
    return await this.processSuccessfulExport(exportResult.resolved, schemaErrors);
  }

  /**
   * Create validation result for export failures
   */
  private createFailureResult(
    errors: ValidationError[],
    exportError?: string,
  ): {
    success: boolean;
    specHash: string;
    resolved?: Record&amp;lt;string, unknown&amp;gt;;
    errors: ValidationError[];
    warnings: ValidationWarning[];
  } {
    const aggregated &#x3D; [...errors];

    if (exportError) {
      aggregated.push({
        type: &amp;quot;schema&amp;quot;,
        message: exportError,
      });
    }

    return {
      success: false,
      specHash: &amp;quot;&amp;quot;,
      errors: aggregated,
      warnings: [],
    };
  }

  /**
   * Process successful spec export through remaining validation steps
   */
  private async processSuccessfulExport(
    resolved: Record&amp;lt;string, unknown&amp;gt;,
    schemaErrors: ValidationError[],
  ): Promise&amp;lt;{
    success: boolean;
    specHash: string;
    resolved?: Record&amp;lt;string, unknown&amp;gt;;
    errors: ValidationError[];
    warnings: ValidationWarning[];
  }&amp;gt; {
    // Compute spec hash
    const specHash &#x3D; computeSpecHash(JSON.stringify(resolved));

    // Run remaining validation steps
    const assertionErrors &#x3D; await this.runJqAssertions(resolved);
    const customValidation &#x3D; await this.runCustomValidators(resolved);

    // Aggregate all results
    const allErrors &#x3D; [...schemaErrors, ...assertionErrors, ...customValidation.errors];
    const success &#x3D; allErrors.length &#x3D;&#x3D;&#x3D; 0;

    return {
      success,
      specHash,
      resolved,
      errors: allErrors,
      warnings: customValidation.warnings,
    };
  }

  /**
   * Log validation completion metrics
   */
  private logValidationCompletion(
    projectId: string,
    result: {
      success: boolean;
      specHash: string;
      errors: ValidationError[];
      warnings: ValidationWarning[];
    },
    duration: number,
  ): void {
    // Reduced logging - only log validation failures or significant events
    const errorCount &#x3D; result.errors.length;
    const warningCount &#x3D; result.warnings.length;
    if (!result.success || errorCount &amp;gt; 0) {
      logger.info(&amp;quot;Validation completed&amp;quot;, {
        projectId,
        success: result.success,
        specHash: result.specHash,
        errorCount,
        warningCount,
        duration,
      });
    }
  }

  /**
   * Handle validation pipeline errors
   */
  private handleValidationError(
    projectId: string,
    error: unknown,
    duration: number,
  ): {
    success: boolean;
    specHash: string;
    resolved?: Record&amp;lt;string, unknown&amp;gt;;
    errors: ValidationError[];
    warnings: ValidationWarning[];
  } {
    logger.error(&amp;quot;Validation pipeline error&amp;quot;, error instanceof Error ? error : undefined, {
      projectId,
      duration,
    });

    return {
      success: false,
      specHash: &amp;quot;&amp;quot;,
      errors: [
        {
          type: &amp;quot;custom&amp;quot;,
          message: &#x60;Validation pipeline failed: ${error instanceof Error ? error.message : &amp;quot;Unknown error&amp;quot;}&#x60;,
        },
      ],
      warnings: [],
    };
  }

  /**
   * Generate gap analysis
   */
  async generateGapSet(resolved: Record&amp;lt;string, unknown&amp;gt;): Promise&amp;lt;GapSet&amp;gt; {
    try {
      const gapData &#x3D; this.initializeGapData(resolved);
      const orphanedTokens &#x3D; this.findOrphanedTokens(resolved);
      const coverageGaps &#x3D; this.analyzeCoverageGaps(resolved);

      return this.buildGapSet(gapData.duplicates, orphanedTokens, coverageGaps);
    } catch (error) {
      logger.error(&amp;quot;Gap analysis error&amp;quot;, error instanceof Error ? error : undefined);
      return this.createEmptyGapSet();
    }
  }

  /**
   * Initialize gap data with duplicates
   */
  private initializeGapData(resolved: Record&amp;lt;string, unknown&amp;gt;): {
    duplicates: Duplicate[];
  } {
    return {
      duplicates: this.findDuplicates(resolved),
    };
  }

  /**
   * Find orphaned tokens in resolved specification
   */
  private findOrphanedTokens(resolved: Record&amp;lt;string, unknown&amp;gt;): TokenReference[] {
    const jsonStr &#x3D; JSON.stringify(resolved);
    const tokenMatches &#x3D; jsonStr.match(/\$\{[^}]+\}/g) || [];

    return tokenMatches.map((token) &#x3D;&amp;gt; ({
      token,
      defined_in: [],
      referenced_in: [&amp;quot;resolved.json&amp;quot;],
    }));
  }

  /**
   * Analyze coverage gaps between capabilities and tests
   */
  private analyzeCoverageGaps(resolved: Record&amp;lt;string, unknown&amp;gt;): CoverageGap[] {
    if (typeof resolved !&#x3D;&#x3D; &amp;quot;object&amp;quot; || resolved &#x3D;&#x3D;&#x3D; null) {
      return [];
    }

    const capabilities &#x3D; (resolved as any).capabilities || {};
    const tests &#x3D; (resolved as any).tests || {};
    const coverageGaps: CoverageGap[] &#x3D; [];

    Object.keys(capabilities).forEach((capability) &#x3D;&amp;gt; {
      if (!this.hasTestCoverage(capability, tests)) {
        coverageGaps.push({
          capability,
          expected_coverage: 100,
          actual_coverage: 0,
          missing_scenarios: [&amp;quot;basic&amp;quot;, &amp;quot;error_handling&amp;quot;, &amp;quot;edge_cases&amp;quot;],
        });
      }
    });

    return coverageGaps;
  }

  /**
   * Check if a capability has test coverage
   */
  private hasTestCoverage(capability: string, tests: Record&amp;lt;string, any&amp;gt;): boolean {
    return Object.keys(tests).some(
      (test) &#x3D;&amp;gt; test.includes(capability) || tests[test]?.covers?.includes(capability),
    );
  }

  /**
   * Build the final gap set result
   */
  private buildGapSet(
    duplicates: Duplicate[],
    orphanedTokens: TokenReference[],
    coverageGaps: CoverageGap[],
  ): GapSet {
    return {
      missing_capabilities: [], // Simplified implementation
      orphaned_tokens: orphanedTokens,
      coverage_gaps: coverageGaps,
      duplicates,
    };
  }

  /**
   * Create empty gap set for error cases
   */
  private createEmptyGapSet(): GapSet {
    return {
      missing_capabilities: [],
      orphaned_tokens: [],
      coverage_gaps: [],
      duplicates: [],
    };
  }

  /**
   * Clean up project workspace
   */
  async cleanupProject(projectId: string): Promise&amp;lt;void&amp;gt; {
    try {
      const projectDir &#x3D; this.getProjectDir(projectId);
      await executeCommand(&amp;quot;rm&amp;quot;, [&amp;quot;-rf&amp;quot;, projectDir]);

      logger.debug(&amp;quot;Cleaned up project workspace&amp;quot;, { projectId });
    } catch (error) {
      logger.error(
        &amp;quot;Failed to cleanup project workspace&amp;quot;,
        error instanceof Error ? error : undefined,
        {
          projectId,
        },
      );
    }
  }
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-29">
                <div class="file-header">📄 src/handlers/examples/spec-validator.ts</div>
                <div class="file-content">
                    <pre>/**
 * Example: Spec validation handler
 * Automatically validates CUE specifications when changes are detected
 */

import type { HandlerModule, WebhookHandler } from &amp;#39;../types.js&amp;#39;;

const handleSpecValidation: WebhookHandler &#x3D; async (payload, context) &#x3D;&amp;gt; {
  const { logger, services, projectId } &#x3D; context;
  const { parsed } &#x3D; payload;

  logger.info(&amp;#39;Processing spec validation handler&amp;#39;, {
    event: parsed.eventType,
    repository: parsed.repository.fullName,
    commitCount: parsed.commits?.length || 0,
  });

  try {
    // Check if any CUE files were modified
    const specFiles &#x3D;
      parsed.commits?.flatMap(commit &#x3D;&amp;gt; [
        ...commit.added.filter(file &#x3D;&amp;gt; file.endsWith(&amp;#39;.cue&amp;#39;)),
        ...commit.modified.filter(file &#x3D;&amp;gt; file.endsWith(&amp;#39;.cue&amp;#39;)),
      ]) || [];

    if (specFiles.length &#x3D;&#x3D;&#x3D; 0) {
      logger.debug(&amp;#39;No CUE files changed, skipping validation&amp;#39;);
      return {
        success: true,
        message: &amp;#39;No CUE files changed&amp;#39;,
        actions: [],
      };
    }

    logger.info(&amp;#39;CUE files detected for validation&amp;#39;, {
      files: specFiles,
      count: specFiles.length,
    });

    const actions: string[] &#x3D; [];

    // Trigger spec validation event
    await services.events.broadcastToProject(projectId, {
      project_id: projectId,
      event_type: &amp;#39;validation_started&amp;#39;,
      data: {
        trigger: &amp;#39;spec_validation_handler&amp;#39;,
        repository: parsed.repository.fullName,
        ref: payload.ref,
        specFiles,
        commits:
          parsed.commits?.map(c &#x3D;&amp;gt; ({
            sha: c.sha,
            message: c.message,
            author: c.author,
          })) || [],
      },
    });

    actions.push(&#x60;Triggered validation for ${specFiles.length} CUE files&#x60;);

    // For each spec file, log what changed
    for (const file of specFiles) {
      const commit &#x3D; parsed.commits?.find(c &#x3D;&amp;gt; c.added.includes(file) || c.modified.includes(file));

      if (commit) {
        const action &#x3D; commit.added.includes(file) ? &amp;#39;added&amp;#39; : &amp;#39;modified&amp;#39;;
        logger.info(&#x60;Spec file ${action}&#x60;, {
          file,
          commit: commit.sha,
          message: commit.message,
        });

        actions.push(&#x60;Detected ${action} spec file: ${file}&#x60;);
      }
    }

    // Check for breaking changes based on commit messages
    const breakingChanges &#x3D;
      parsed.commits?.filter(
        commit &#x3D;&amp;gt;
          commit.message.toLowerCase().includes(&amp;#39;breaking&amp;#39;) ||
          commit.message.toLowerCase().includes(&amp;#39;breaking change&amp;#39;) ||
          commit.message.includes(&amp;#39;BREAKING CHANGE:&amp;#39;)
      ) || [];

    if (breakingChanges.length &amp;gt; 0) {
      logger.warn(&amp;#39;Breaking changes detected in spec files&amp;#39;, {
        commits: breakingChanges.map(c &#x3D;&amp;gt; ({ sha: c.sha, message: c.message })),
      });

      // Broadcast breaking change warning
      await services.events.broadcastToProject(projectId, {
        project_id: projectId,
        event_type: &amp;#39;validation_started&amp;#39;,
        data: {
          trigger: &amp;#39;breaking_change_detection&amp;#39;,
          repository: parsed.repository.fullName,
          breakingChanges: breakingChanges.map(c &#x3D;&amp;gt; ({
            sha: c.sha,
            message: c.message,
            author: c.author,
          })),
          warning: &amp;#39;Breaking changes detected in specification files&amp;#39;,
        },
      });

      actions.push(&#x60;⚠️ Detected ${breakingChanges.length} commits with breaking changes&#x60;);
    }

    // Check for assembly files specifically
    const assemblyFiles &#x3D; specFiles.filter(
      file &#x3D;&amp;gt; file.includes(&amp;#39;assembly&amp;#39;) || file.includes(&amp;#39;.assembly.cue&amp;#39;)
    );

    if (assemblyFiles.length &amp;gt; 0) {
      logger.info(&amp;#39;Assembly files detected, triggering comprehensive validation&amp;#39;, {
        assemblyFiles,
      });

      await services.events.broadcastToProject(projectId, {
        project_id: projectId,
        event_type: &amp;#39;validation_started&amp;#39;,
        data: {
          trigger: &amp;#39;assembly_validation&amp;#39;,
          repository: parsed.repository.fullName,
          assemblyFiles,
          validationType: &amp;#39;comprehensive&amp;#39;,
        },
      });

      actions.push(
        &#x60;🏗️ Triggered comprehensive validation for ${assemblyFiles.length} assembly files&#x60;
      );
    }

    // Estimate validation complexity
    const totalLines &#x3D;
      parsed.commits?.reduce((sum, commit) &#x3D;&amp;gt; {
        return sum + (commit.added.length + commit.modified.length);
      }, 0) || 0;

    let complexity &#x3D; &amp;#39;low&amp;#39;;
    if (totalLines &amp;gt; 50 || breakingChanges.length &amp;gt; 0) {
      complexity &#x3D; &amp;#39;high&amp;#39;;
    } else if (totalLines &amp;gt; 20 || assemblyFiles.length &amp;gt; 0) {
      complexity &#x3D; &amp;#39;medium&amp;#39;;
    }

    logger.info(&amp;#39;Validation complexity estimated&amp;#39;, {
      complexity,
      totalLines,
      specFiles: specFiles.length,
      assemblyFiles: assemblyFiles.length,
      breakingChanges: breakingChanges.length,
    });

    return {
      success: true,
      message: &#x60;Validation triggered for ${specFiles.length} CUE files&#x60;,
      actions,
      data: {
        specFilesChanged: specFiles.length,
        assemblyFilesChanged: assemblyFiles.length,
        breakingChangesDetected: breakingChanges.length,
        validationComplexity: complexity,
        repository: parsed.repository.fullName,
        ref: payload.ref,
      },
    };
  } catch (error) {
    logger.error(&amp;#39;Spec validation handler failed&amp;#39;, error as Error);

    return {
      success: false,
      message: &amp;#39;Spec validation handler execution failed&amp;#39;,
      errors: [
        {
          code: &amp;#39;VALIDATION_HANDLER_ERROR&amp;#39;,
          message: error instanceof Error ? error.message : &amp;#39;Unknown error&amp;#39;,
          stack: error instanceof Error ? error.stack : undefined,
        },
      ],
    };
  }
};

const handlerModule: HandlerModule &#x3D; {
  handler: handleSpecValidation,
  config: {
    enabled: true,
    timeout: 20000,
    retries: 1,
    environment: {
      VALIDATION_MODE: &amp;#39;strict&amp;#39;,
    },
    secrets: {},
  },
  metadata: {
    name: &amp;#39;Spec Validation Handler&amp;#39;,
    description: &amp;#39;Automatically validates CUE specifications when changes are detected in commits&amp;#39;,
    version: &amp;#39;1.0.0&amp;#39;,
    author: &amp;#39;Arbiter Team&amp;#39;,
    supportedEvents: [&amp;#39;push&amp;#39;, &amp;#39;Push Hook&amp;#39;],
    requiredPermissions: [&amp;#39;events:publish&amp;#39;, &amp;#39;validation:trigger&amp;#39;],
  },
};

export default handlerModule;
</pre>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Load self-contained bundle (includes React, ReactDOM, React Arborist, and Lucide React) -->
    <script src="assets/scribe-tree-bundle.js"></script>
    
    <script>
        // File data from Handlebars template
        const fileData = [
            {
                path: "DIRECTORY_MAP.txt",
                icon: "file-text",
                index: 0,
                size: "4.76 KB",
                tokens: "1,609",
                score: "1.00"
            },
            {
                path: "src/types.ts",
                icon: "file-code",
                index: 1,
                size: "6.93 KB",
                tokens: "1,602",
                score: "0.85"
            },
            {
                path: "src/db.ts",
                icon: "file-code",
                index: 2,
                size: "20.43 KB",
                tokens: "4,463",
                score: "0.85"
            },
            {
                path: "src/utils.ts",
                icon: "file-code",
                index: 3,
                size: "8.85 KB",
                tokens: "1,987",
                score: "0.85"
            },
            {
                path: "src/events.ts",
                icon: "file-code",
                index: 4,
                size: "14.14 KB",
                tokens: "2,849",
                score: "0.85"
            },
            {
                path: "src/auth.ts",
                icon: "file-code",
                index: 5,
                size: "17.18 KB",
                tokens: "3,485",
                score: "0.85"
            },
            {
                path: "src/handlers/discovery.ts",
                icon: "file-code",
                index: 6,
                size: "11.30 KB",
                tokens: "2,275",
                score: "0.85"
            },
            {
                path: "src/handlers/services.ts",
                icon: "file-code",
                index: 7,
                size: "17.18 KB",
                tokens: "3,751",
                score: "0.85"
            },
            {
                path: "src/nats.ts",
                icon: "file-code",
                index: 8,
                size: "6.97 KB",
                tokens: "1,453",
                score: "0.85"
            },
            {
                path: "src/handlers/manager.ts",
                icon: "file-code",
                index: 9,
                size: "16.36 KB",
                tokens: "3,377",
                score: "0.85"
            },
            {
                path: "src/mcp.ts",
                icon: "file-code",
                index: 10,
                size: "13.81 KB",
                tokens: "2,685",
                score: "0.85"
            },
            {
                path: "src/handlers/executor.ts",
                icon: "file-code",
                index: 11,
                size: "17.51 KB",
                tokens: "3,482",
                score: "0.85"
            },
            {
                path: "src/webhooks.ts",
                icon: "file-code",
                index: 12,
                size: "13.22 KB",
                tokens: "2,629",
                score: "0.85"
            },
            {
                path: "src/ir.ts",
                icon: "file-code",
                index: 13,
                size: "21.12 KB",
                tokens: "4,356",
                score: "0.85"
            },
            {
                path: "src/handlers/sandbox.ts",
                icon: "file-code",
                index: 14,
                size: "2.52 KB",
                tokens: "579",
                score: "0.73"
            },
            {
                path: "src/handlers/loader.ts",
                icon: "file-code",
                index: 15,
                size: "1.52 KB",
                tokens: "311",
                score: "0.68"
            },
            {
                path: "src/server.ts",
                icon: "file-code",
                index: 16,
                size: "18.02 KB",
                tokens: "3,799",
                score: "0.85"
            },
            {
                path: "src/handlers/types.ts",
                icon: "file-code",
                index: 17,
                size: "5.69 KB",
                tokens: "1,227",
                score: "0.85"
            },
            {
                path: "src/routes/index.ts",
                icon: "file-code",
                index: 18,
                size: "40.45 KB",
                tokens: "8,206",
                score: "0.85"
            },
            {
                path: "src/handlers/examples/slack-notification.ts",
                icon: "file-code",
                index: 19,
                size: "8.53 KB",
                tokens: "1,701",
                score: "0.85"
            },
            {
                path: "src/migrations/run.ts",
                icon: "file-code",
                index: 20,
                size: "8.41 KB",
                tokens: "1,751",
                score: "0.85"
            },
            {
                path: "src/websocket/index.ts",
                icon: "file-code",
                index: 21,
                size: "14.71 KB",
                tokens: "2,829",
                score: "0.85"
            },
            {
                path: "src/handlers/api.ts",
                icon: "file-code",
                index: 22,
                size: "10.49 KB",
                tokens: "2,185",
                score: "0.85"
            },
            {
                path: "src/handlers/examples/push-handler.ts",
                icon: "file-code",
                index: 23,
                size: "3.94 KB",
                tokens: "808",
                score: "0.80"
            },
            {
                path: "src/mcp-cli-integration.ts",
                icon: "file-code",
                index: 24,
                size: "3.03 KB",
                tokens: "642",
                score: "0.75"
            },
            {
                path: "src/config.ts",
                icon: "file-code",
                index: 25,
                size: "843.00 B",
                tokens: "207",
                score: "0.64"
            },
            {
                path: "src/static/index.ts",
                icon: "file-code",
                index: 26,
                size: "300.00 B",
                tokens: "70",
                score: "0.61"
            },
            {
                path: "src/specEngine.ts",
                icon: "file-code",
                index: 27,
                size: "26.92 KB",
                tokens: "5,404",
                score: "0.17"
            },
            {
                path: "src/handlers/examples/spec-validator.ts",
                icon: "file-code",
                index: 28,
                size: "6.23 KB",
                tokens: "1,245",
                score: "0.17"
            }
        ];

        // Initialize the file tree
        document.addEventListener('DOMContentLoaded', function() {
            if (window.ScribeFileTree) {
                const fileTree = new window.ScribeFileTree();
                const success = fileTree.renderTree('file-tree-container', fileData);
                
                if (success) {
                    console.log('File tree rendered successfully');
                } else {
                    console.error('Failed to render file tree');
                    // Fallback to simple list
                    const container = document.getElementById('file-tree-container');
                    if (container) {
                        container.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-muted);">Tree view failed to load. Use the file list below.</div>';
                    }
                }
            } else {
                console.error('ScribeFileTree not available');
            }
            
            // Initialize control buttons and ping mechanism
            initializeControls();
        });
        
        // Control functionality
        function initializeControls() {
            // Ping server every 30 seconds to keep alive
            setInterval(pingServer, 30000);
            
            // Initial ping
            pingServer();
            
            // Setup button event listeners
            const saveBtn = document.getElementById('save-btn');
            const shutdownBtn = document.getElementById('shutdown-btn');
            
            if (saveBtn) {
                saveBtn.addEventListener('click', handleSave);
            }
            
            if (shutdownBtn) {
                shutdownBtn.addEventListener('click', handleShutdown);
            }
        }
        
        async function pingServer() {
            try {
                const response = await fetch('/api/ping', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    updateConnectionStatus(true);
                } else {
                    updateConnectionStatus(false);
                }
            } catch (error) {
                console.warn('Ping failed:', error);
                updateConnectionStatus(false);
            }
        }
        
        function updateConnectionStatus(isOnline) {
            const statusDot = document.getElementById('connection-status');
            const statusText = document.getElementById('status-text');
            
            if (statusDot && statusText) {
                if (isOnline) {
                    statusDot.className = 'status-dot online';
                    statusText.textContent = 'Connected';
                } else {
                    statusDot.className = 'status-dot offline';
                    statusText.textContent = 'Disconnected';
                }
            }
        }
        
        async function handleSave() {
            const saveBtn = document.getElementById('save-btn');
            if (!saveBtn) return;
            
            // Disable button and show loading
            saveBtn.disabled = true;
            saveBtn.innerHTML = '⏳ Saving...';
            
            try {
                // Get current selected files from the tree
                const selectedFiles = getSelectedFiles();
                
                const response = await fetch('/api/bundle/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        files: selectedFiles
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    saveBtn.innerHTML = '✅ Saved!';
                    setTimeout(() => {
                        saveBtn.innerHTML = '💾 Save Bundle';
                        saveBtn.disabled = false;
                    }, 2000);
                } else {
                    throw new Error('Save failed');
                }
            } catch (error) {
                console.error('Save error:', error);
                saveBtn.innerHTML = '❌ Save Failed';
                setTimeout(() => {
                    saveBtn.innerHTML = '💾 Save Bundle';
                    saveBtn.disabled = false;
                }, 2000);
            }
        }
        
        async function handleShutdown() {
            if (!confirm('Are you sure you want to shutdown the server?')) {
                return;
            }
            
            const shutdownBtn = document.getElementById('shutdown-btn');
            if (!shutdownBtn) return;
            
            // Disable button and show loading
            shutdownBtn.disabled = true;
            shutdownBtn.innerHTML = '⏳ Shutting down...';
            
            try {
                const response = await fetch('/api/shutdown', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    shutdownBtn.innerHTML = '✅ Server stopped';
                    updateConnectionStatus(false);
                    // Show goodbye message
                    setTimeout(() => {
                        document.body.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 100vh; font-size: 24px; color: var(--text-primary);">🛑 Server has been shut down</div>';
                    }, 1000);
                } else {
                    throw new Error('Shutdown failed');
                }
            } catch (error) {
                console.error('Shutdown error:', error);
                shutdownBtn.innerHTML = '❌ Shutdown Failed';
                setTimeout(() => {
                    shutdownBtn.innerHTML = '🛑 Shutdown Server';
                    shutdownBtn.disabled = false;
                }, 2000);
            }
        }
        
        function getSelectedFiles() {
            // This would integrate with the React tree component
            // For now, return all files as selected
            return fileData.map(file => file.path);
        }
    </script>
</body>
</html>